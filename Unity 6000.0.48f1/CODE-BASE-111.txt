 
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\MonoBleedingEdge\lib\mono\4.5\Microsoft.Common.tasks---------------


<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" >
	<UsingTask TaskName="Microsoft.Build.Tasks.AL"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignLinkMetadata"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignCulture"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignProjectConfiguration"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Copy"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateProperty"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Csc"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Delete"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Error"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Exec"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.LC"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Message"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.SignFile"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Touch"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Vbc"			AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Warning"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"	AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"		AssemblyName="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
</Project>


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\MonoBleedingEdge\lib\mono\4.5\Microsoft.Common.tasks---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\MonoBleedingEdge\lib\mono\xbuild\12.0\bin\Microsoft.Common.tasks---------------
.
.
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" >
	<UsingTask TaskName="Microsoft.Build.Tasks.AL"			AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignLinkMetadata"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignCulture"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignProjectConfiguration"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Copy"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateProperty"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Csc"			AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Delete"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Error"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Exec"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.LC"			AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Message"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.SignFile"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Touch"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Vbc"			AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Warning"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"	AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"		AssemblyName="Microsoft.Build.Tasks.v12.0, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
</Project>
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\MonoBleedingEdge\lib\mono\xbuild\12.0\bin\Microsoft.Common.tasks---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\MonoBleedingEdge\lib\mono\xbuild\14.0\bin\Microsoft.Common.tasks---------------
.
.
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" >
	<UsingTask TaskName="Microsoft.Build.Tasks.AL"			AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignLinkMetadata"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignCulture"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.AssignProjectConfiguration"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Copy"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.CreateProperty"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Csc"			AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Delete"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Error"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Exec"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.LC"			AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Message"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.SignFile"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Touch"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Vbc"			AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Warning"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"	AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	<UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"		AssemblyName="Microsoft.Build.Tasks.Core, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
</Project>
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\MonoBleedingEdge\lib\mono\xbuild\14.0\bin\Microsoft.Common.tasks---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.core\Editor\CustomRenderTexture\CustomRenderTextureShader.template---------------


Shader "CustomRenderTexture/#NAME#"
{
    Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex("InputTex", 2D) = "white" {}
     }

     SubShader
     {
        Blend One Zero

        Pass
        {
            Name "#NAME#"

            CGPROGRAM
            #include "UnityCustomRenderTexture.cginc"
            #pragma vertex CustomRenderTextureVertexShader
            #pragma fragment frag
            #pragma target 3.0

            float4      _Color;
            sampler2D   _MainTex;

            float4 frag(v2f_customrendertexture IN) : SV_Target
            {
                float2 uv = IN.localTexcoord.xy;
                float4 color = tex2D(_MainTex, uv) * _Color;

                // TODO: Replace this by actual code!
                uint2 p = uv.xy * 256;
                return countbits(~(p.x & p.y) + 1) % 2 * float4(uv, 1, 1) * color;
            }
            ENDCG
        }
    }
}


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.core\Editor\CustomRenderTexture\CustomRenderTextureShader.template---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\Decal\ShaderGraph\DecalPass.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

    // Render State
    $splice(RenderState)

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    $splice(PassPragmas)

    // Keywords
    $splice(PassKeywords)
    $splice(GraphKeywords)

    #define FORCE_VIRTUAL_TEXTURING_OFF 1

    // For custom interpolators to inject a substruct definition before FragInputs definition,
    // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
    $splice(CustomInterpolatorPreInclude)

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Decals do not support VT but we need to include it to avoid compilation error

    // Defines
    $AttributesMesh.normalOS:               #define ATTRIBUTES_NEED_NORMAL
    $AttributesMesh.tangentOS:              #define ATTRIBUTES_NEED_TANGENT
    $AttributesMesh.uv0:                    #define ATTRIBUTES_NEED_TEXCOORD0
    $AttributesMesh.uv1:                    #define ATTRIBUTES_NEED_TEXCOORD1
    $AttributesMesh.uv2:                    #define ATTRIBUTES_NEED_TEXCOORD2
    $AttributesMesh.uv3:                    #define ATTRIBUTES_NEED_TEXCOORD3
    $AttributesMesh.color:                  #define ATTRIBUTES_NEED_COLOR
    $AttributesMesh.instanceID:             #define ATTRIBUTES_NEED_INSTANCEID
    $VaryingsMeshToPS.positionRWS:          #define VARYINGS_NEED_POSITION_WS
    $VaryingsMeshToPS.normalWS:             #define VARYINGS_NEED_TANGENT_TO_WORLD
    $VaryingsMeshToPS.texCoord0:            #define VARYINGS_NEED_TEXCOORD0
    $VaryingsMeshToPS.texCoord1:            #define VARYINGS_NEED_TEXCOORD1
    $VaryingsMeshToPS.texCoord2:            #define VARYINGS_NEED_TEXCOORD2
    $VaryingsMeshToPS.texCoord3:            #define VARYINGS_NEED_TEXCOORD3
    $VaryingsMeshToPS.color:                #define VARYINGS_NEED_COLOR
    $VaryingsMeshToPS.instanceID:           #define VARYINGS_NEED_INSTANCEID
    $FragInputs.instanceID:                 #define FRAG_INPUTS_USE_INSTANCEID

    $features.graphVertex:                  #define HAVE_MESH_MODIFICATION

    $SurfaceDescriptionInputs.FaceSign:     // Define when IsFontFaceNode is included in ShaderGraph
    $SurfaceDescriptionInputs.FaceSign:     #define VARYINGS_NEED_CULLFACE

    $splice(GraphDefines)

    // -- Properties used by ScenePickingPass
    #ifdef SCENEPICKINGPASS
    float4 _SelectionID;
    #endif

    // Includes
    $splice(PreGraphIncludes)

    // --------------------------------------------------
    // Structs and Packing

    $splice(PassStructs)

    $splice(InterpolatorPack)

    // --------------------------------------------------
    // Graph

    // Graph Properties
    $splice(GraphProperties)

    // Graph Includes
    $splice(GraphIncludes)

    // Graph Functions
    $splice(GraphFunctions)

    // Graph Vertex
    $splice(GraphVertex)

    // Graph Pixel
    $splice(GraphPixel)

    // --------------------------------------------------
    // Build Graph Inputs

    $features.graphVertex:  $include("Vertex.template.hlsl")
    $features.graphPixel:   $include("Pixel.template.hlsl")

    // --------------------------------------------------
    // Build Surface Data

    void GetSurfaceData(FragInputs fragInputs, float3 V, PositionInputs posInput, float angleFadeFactor, out DecalSurfaceData surfaceData)
    {
        #if (SHADERPASS == SHADERPASS_DBUFFER_PROJECTOR) || (SHADERPASS == SHADERPASS_FORWARD_EMISSIVE_PROJECTOR)
            float4x4 normalToWorld = UNITY_ACCESS_INSTANCED_PROP(Decal, _NormalToWorld);
            float fadeFactor = clamp(normalToWorld[0][3], 0.0f, 1.0f) * angleFadeFactor;
            float2 scale = float2(normalToWorld[3][0], normalToWorld[3][1]);
            float2 offset = float2(normalToWorld[3][2], normalToWorld[3][3]);
            fragInputs.texCoord0.xy = fragInputs.texCoord0.xy * scale + offset;
            fragInputs.texCoord1.xy = fragInputs.texCoord1.xy * scale + offset;
            fragInputs.texCoord2.xy = fragInputs.texCoord2.xy * scale + offset;
            fragInputs.texCoord3.xy = fragInputs.texCoord3.xy * scale + offset;
            fragInputs.positionRWS = posInput.positionWS;
            fragInputs.tangentToWorld[2].xyz = TransformObjectToWorldDir(float3(0, 1, 0));
            fragInputs.tangentToWorld[1].xyz = TransformObjectToWorldDir(float3(0, 0, 1));
        #else
            #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
            LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
            #endif

            float fadeFactor = 1.0;
        #endif

        SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);

        // setup defaults -- these are used if the graph doesn't output a value
        ZERO_INITIALIZE(DecalSurfaceData, surfaceData);

        #ifdef _MATERIAL_AFFECTS_EMISSION
            $SurfaceDescription.Emission:       surfaceData.emissive.rgb = surfaceDescription.Emission.rgb * fadeFactor;
        #endif

        // copy across graph values, if defined
        #ifdef _MATERIAL_AFFECTS_ALBEDO
            $SurfaceDescription.BaseColor:      surfaceData.baseColor.xyz = surfaceDescription.BaseColor;
            $SurfaceDescription.Alpha:          surfaceData.baseColor.w = surfaceDescription.Alpha * fadeFactor;
        #endif

        #ifdef _MATERIAL_AFFECTS_NORMAL
            #ifdef DECAL_SURFACE_GRADIENT
                #if (SHADERPASS == SHADERPASS_DBUFFER_PROJECTOR) || (SHADERPASS == SHADERPASS_FORWARD_EMISSIVE_PROJECTOR)
                    $SurfaceDescription.NormalTS:   float3x3 tangentToWorld = transpose((float3x3)normalToWorld);
                #else
                    $SurfaceDescription.NormalTS:   float3x3 tangentToWorld = fragInputs.tangentToWorld;
                #endif

                $SurfaceDescription.NormalTS:   surfaceData.normalWS.xyz = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS.xyz, tangentToWorld[0], tangentToWorld[1]);
            #else
                #if (SHADERPASS == SHADERPASS_DBUFFER_PROJECTOR)
                    $SurfaceDescription.NormalTS:   surfaceData.normalWS.xyz = mul((float3x3)normalToWorld, surfaceDescription.NormalTS);
                #elif (SHADERPASS == SHADERPASS_DBUFFER_MESH) || (SHADERPASS == SHADERPASS_FORWARD_PREVIEW)
                    // We need to normalize as we use mikkt tangent space and this is expected (tangent space is not normalize)
                    $SurfaceDescription.NormalTS:   surfaceData.normalWS.xyz = normalize(TransformTangentToWorld(surfaceDescription.NormalTS, fragInputs.tangentToWorld));
                #endif
            #endif

            $SurfaceDescription.NormalAlpha:    surfaceData.normalWS.w = surfaceDescription.NormalAlpha * fadeFactor;
        #else
            #if (SHADERPASS == SHADERPASS_FORWARD_PREVIEW) // Default to vertex normal
                #ifdef DECAL_SURFACE_GRADIENT
                    $SurfaceDescription.NormalTS:   surfaceData.normalWS.xyz = float3(0.0, 0.0, 0.0);
                #else
                    $SurfaceDescription.NormalTS: surfaceData.normalWS.xyz = normalize(TransformTangentToWorld(float3(0.0, 0.0, 0.1), fragInputs.tangentToWorld));
                #endif
            #endif
        #endif

            // In case of Smoothness / AO / Metal, all the three are always computed but color mask can change
        #ifdef _MATERIAL_AFFECTS_MASKMAP
            $SurfaceDescription.Smoothness:     surfaceData.mask.z = surfaceDescription.Smoothness;
            $SurfaceDescription.MAOSAlpha:      surfaceData.mask.w = surfaceDescription.MAOSAlpha * fadeFactor;

            #ifdef DECALS_4RT
                $SurfaceDescription.Metallic:   surfaceData.mask.x = surfaceDescription.Metallic;
                $SurfaceDescription.Occlusion:  surfaceData.mask.y = surfaceDescription.Occlusion;
                $SurfaceDescription.MAOSAlpha:  surfaceData.MAOSBlend.x = surfaceDescription.MAOSAlpha * fadeFactor;
                $SurfaceDescription.MAOSAlpha:  surfaceData.MAOSBlend.y = surfaceDescription.MAOSAlpha * fadeFactor;
            #endif
        #endif
    }

    // --------------------------------------------------
    // Main

    $splice(PostGraphIncludes)

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\Decal\ShaderGraph\DecalPass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\FogVolume\ShaderGraph\Templates\FogVolume.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

    // Render State
    $splice(RenderState)

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    $splice(PassPragmas)
    // #pragma enable_d3d11_debug_symbols

    // Keywords
    $splice(PassKeywords)
    $splice(GraphKeywords)

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

    $splice(GraphDefines)

    // Includes
    $splice(PreGraphIncludes)

    // --------------------------------------------------
    // Structs and Packing

    $splice(PassStructs)

    // --------------------------------------------------
    // Graph

    // Graph Properties
    $splice(GraphProperties)

    // Graph Includes
    $splice(GraphIncludes)

    // Graph Functions
    $splice(GraphFunctions)

    // Graph Pixel
    $splice(GraphPixel)

    // --------------------------------------------------
    // Build Graph Inputs

    // Graph Pixel
    $features.graphPixel:   $include("Pixel.template.hlsl")

    // --------------------------------------------------
    // Build Surface Data

    void GetVolumeData(FragInputs fragInputs, float3 V, out float3 scatteringColor, out float density)
    {
        SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);

        scatteringColor = surfaceDescription.BaseColor;
        density = surfaceDescription.Alpha;
    }

    // --------------------------------------------------
    // Main

    $splice(PostGraphIncludes)

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\FogVolume\ShaderGraph\Templates\FogVolume.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\PBRSky\ShaderGraph\ShaderPass.template---------------
.
.
Pass
{

$splice(PassName)

// Render State
$splice(RenderState)

// Debug
$splice(Debug)

// --------------------------------------------------
// Pass

HLSLPROGRAM

// Pragmas
$splice(PassPragmas)

// Keywords
$splice(PassKeywords)
$splice(GraphKeywords)

// Defines
$Attributes.vertexID: #define ATTRIBUTES_NEED_VERTEXID

$splice(PassInstancing)
$splice(GraphDefines)

// Includes
$splice(PreGraphIncludes)

// --------------------------------------------------
// Structs and Packing

$splice(PassStructs)

$splice(InterpolatorPack)

// --------------------------------------------------
// Graph

// Graph Properties
$splice(GraphProperties)

// Graph Includes
$splice(GraphIncludes)

// Graph Functions
$splice(GraphFunctions)

// Graph Pixel
$splice(GraphPixel)

// --------------------------------------------------
// Build Graph Inputs

$features.graphPixel: $include("SharedCode.template.hlsl")

// --------------------------------------------------
// Main

float3 GetNormalWS(float3 normal, float3 normalTS)
{
    float3 tangent = normalize(cross(normal, float3(0.0, 1.0, 0.0)));
    float3 bitangent = cross(tangent, normal);

    float3x3 tangentToWorld = float3x3(tangent, bitangent, normal);
    return SafeNormalize(TransformTangentToWorld(normalTS, tangentToWorld));
}

void BuildGroundNormal(inout SurfaceDescriptionInputs input, SurfaceDescription surfaceDescription)
{
    float3 N = input.WorldSpaceNormal;

    $SurfaceDescription.GroundNormalOS: N = surfaceDescription.GroundNormalOS;
    $SurfaceDescription.GroundNormalTS: N = GetNormalWS(N, surfaceDescription.GroundNormalTS);
    $SurfaceDescription.GroundNormalWS: N = surfaceDescription.GroundNormalWS;

    input.WorldSpaceNormal = N;
}

void RenderGround(inout SurfaceDescriptionInputs input, SurfaceDescription surfaceDescription)
{
    if (input.tGround < input.tFrag)
    {
        // Closest so far.
        // Make it negative to communicate to EvaluatePbrAtmosphere that we intersected the ground.
        input.tFrag = -input.tGround;
        input.radiance = 0.0f;

        float smoothness = 1.0f;
        float3 albedo = _GroundAlbedo.xyz;

        $SurfaceDescription.GroundSmoothness: smoothness = surfaceDescription.GroundSmoothness;
        $SurfaceDescription.GroundEmission:   input.radiance = surfaceDescription.GroundEmission;
        $SurfaceDescription.GroundColor:      albedo *= surfaceDescription.GroundColor;
        BuildGroundNormal(input, surfaceDescription);

        const float roughness = PerceptualSmoothnessToRoughness(smoothness);
        const float F0 = IorToFresnel0(1.4f);
        const float3 diffuse = Lambert() * albedo;

        float3 N = input.WorldSpaceNormal;
        float3 V = -input.WorldSpaceViewDirection;

        float NdotV        = dot(N, V);
        float clampedNdotV = ClampNdotV(NdotV);
        float partLambdaV = GetSmithJointGGXPartLambdaV(clampedNdotV, roughness);

        // Shade the ground.
        for (uint i = 0; i < _CelestialLightCount; i++)
        {
            CelestialBodyData light = _CelestialBodyDatas[i];

            float3 L    = -light.forward.xyz;
            float NdotL = dot(N, L);
            float LdotV, NdotH, LdotH, invLenLV;
            GetBSDFAngle(V, L, NdotL, NdotV, LdotV, NdotH, LdotH, invLenLV);

            float3 intensity  = light.color.rgb;
            #ifdef LOCAL_SKY
                intensity *= SampleGroundIrradianceTexture(NdotL);
            #else
                float3 opticalDepth = ComputeAtmosphericOpticalDepth(_PlanetaryRadius, NdotL, true);
                intensity *= TransmittanceFromOpticalDepth(opticalDepth) * saturate(NdotL);
            #endif

            float DV       = DV_SmithJointGGX(NdotH, abs(NdotL), clampedNdotV, roughness, partLambdaV);
            float specular = F0 * DV;

            input.radiance += (diffuse + specular) * intensity;
        }
    }
}

float3 RenderSky(Varyings varyings)
{
    SurfaceDescriptionInputs input = BuildSurfaceDescriptionInputs(varyings);
    const SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(input);

    if (input.hitGround) // See the ground?
        RenderGround(input, surfaceDescription);
    else if (input.tFrag == FLT_INF) // See the stars?
        input.radiance += surfaceDescription.SpaceColor;

    float3 skyColor = 0, skyOpacity = 0;

    float3 V = -input.WorldSpaceViewDirection;
    float distAlongRay = input.tFrag;
    bool renderSunDisk = input.renderSunDisk != 0;

    #ifdef LOCAL_SKY
    if (input.intersectAtmosphere != 0)
        EvaluatePbrAtmosphere(_PBRSkyCameraPosPS, V, distAlongRay, renderSunDisk, skyColor, skyOpacity);
    #else
    if (!input.hitGround)
        EvaluateDistantAtmosphere(-V, skyColor, skyOpacity);
    #endif

    skyColor += input.radiance * (1 - skyOpacity);
    return skyColor * _IntensityMultiplier;
}

PackedVaryings Vert(Attributes input)
{
    Varyings output = (Varyings)0;
    UNITY_SETUP_INSTANCE_ID(input);
    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
    output.positionCS = GetFullScreenTriangleVertexPosition(input.vertexID, UNITY_RAW_FAR_CLIP_VALUE);
    PackedVaryings packedOutput = PackVaryings(output);
    return packedOutput;
}

float4 FragBaking(PackedVaryings packedInput) : SV_Target
{
    return float4(RenderSky(UnpackVaryings(packedInput)), 1.0f);
}

float4 Frag(PackedVaryings packedInput) : SV_Target
{
    Varyings input = UnpackVaryings(packedInput);
    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);
    return float4(RenderSky(input) * GetCurrentExposureMultiplier(), 1.0f);
}

$splice(PostGraphIncludes)

ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\PBRSky\ShaderGraph\ShaderPass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\ShaderGraph\Templates\RaytraceDebug.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    $splice(PassPragmas)

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

    // Includes
    $splice(PreGraphIncludes)
	$splice(GraphIncludes)
    $splice(PostGraphIncludes)

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\ShaderGraph\Templates\RaytraceDebug.template---------------

.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Samples~\Common\Textures\terrain\ground_grass_fells_mossy\ground_grass_fells_mossy.terrainlayer---------------

.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

    // Render State
    $splice(RenderState)

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    $splice(PassPragmas)

    // Keywords
    $splice(PassKeywords)
    $splice(GraphKeywords)

    // Defines
    $splice(GraphDefines)

    // For custom interpolators to inject a substruct definition before FragInputs definition,
    // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
    $splice(CustomInterpolatorPreInclude)

	$features.graphVFX: #define HAVE_VFX_MODIFICATION

    // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
	#ifdef HAVE_VFX_MODIFICATION
	struct FragInputsVFX
    {
        $splice(FragInputsVFX)
    };
    #endif

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
    // Always include Shader Graph version
    // Always include last to avoid double macros
    #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition

    // --------------------------------------------------
    // Defines

    // Attribute
    $AttributesMesh.normalOS:                           #define ATTRIBUTES_NEED_NORMAL
    $AttributesMesh.tangentOS:                          #define ATTRIBUTES_NEED_TANGENT
    $AttributesMesh.uv0:                                #define ATTRIBUTES_NEED_TEXCOORD0
    $AttributesMesh.uv1:                                #define ATTRIBUTES_NEED_TEXCOORD1
    $AttributesMesh.uv2:                                #define ATTRIBUTES_NEED_TEXCOORD2
    $AttributesMesh.uv3:                                #define ATTRIBUTES_NEED_TEXCOORD3
    $AttributesMesh.color:                              #define ATTRIBUTES_NEED_COLOR
    $AttributesMesh.vertexID:                           #define ATTRIBUTES_NEED_VERTEXID
    $AttributesMesh.instanceID:                         #define ATTRIBUTES_NEED_INSTANCEID
    $VaryingsMeshToPS.positionRWS:                      #define VARYINGS_NEED_POSITION_WS
    $VaryingsMeshToPS.positionPredisplacementRWS:       #define VARYINGS_NEED_POSITIONPREDISPLACEMENT_WS
    $VaryingsMeshToPS.normalWS:                         #define VARYINGS_NEED_TANGENT_TO_WORLD
    $VaryingsMeshToPS.texCoord0:                        #define VARYINGS_NEED_TEXCOORD0
    $VaryingsMeshToPS.texCoord1:                        #define VARYINGS_NEED_TEXCOORD1
    $VaryingsMeshToPS.texCoord2:                        #define VARYINGS_NEED_TEXCOORD2
    $VaryingsMeshToPS.texCoord3:                        #define VARYINGS_NEED_TEXCOORD3
    $VaryingsMeshToPS.color:                            #define VARYINGS_NEED_COLOR
    $VaryingsMeshToPS.elementToWorld0:                  #define VARYINGS_NEED_ELEMENT_TO_WORLD
    $VaryingsMeshToPS.worldToElement0:                  #define VARYINGS_NEED_WORLD_TO_ELEMENT
    $VaryingsMeshToPS.instanceID:                       #define VARYINGS_NEED_INSTANCEID
    $Varyings.diffuseGIData0:                           #define VARYINGS_NEED_SIX_WAY_DIFFUSE_GI_DATA

    $features.graphVertex:                              #define HAVE_MESH_MODIFICATION

    //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
    //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
    //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
    #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
    #define FRAG_INPUTS_ENABLE_STRIPPING
    #endif
    $FragInputs.texCoord0: #define FRAG_INPUTS_USE_TEXCOORD0
    $FragInputs.texCoord1: #define FRAG_INPUTS_USE_TEXCOORD1
    $FragInputs.texCoord2: #define FRAG_INPUTS_USE_TEXCOORD2
    $FragInputs.texCoord3: #define FRAG_INPUTS_USE_TEXCOORD3
    $FragInputs.instanceID: #define FRAG_INPUTS_USE_INSTANCEID

    $FragInputs.diffuseGIData0: #define FRAG_INPUTS_USE_SIX_WAY_DIFFUSE_GI_DATA

    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"

    $SurfaceDescriptionInputs.FaceSign:                 // Define when IsFontFaceNode is included in ShaderGraph
    $SurfaceDescriptionInputs.FaceSign:                 #define VARYINGS_NEED_CULLFACE

    $VertexDescription.CustomVelocity: #define _ADD_CUSTOM_VELOCITY

    $features.graphTessellation: #ifdef TESSELLATION_ON
    $features.graphTessellation: // World and normal are always available
    $features.graphTessellation: $VaryingsMeshToDS.positionPredisplacementRWS:          #define VARYINGS_DS_NEED_POSITIONPREDISPLACEMENT
    $features.graphTessellation: $VaryingsMeshToDS.tangentWS:                           #define VARYINGS_DS_NEED_TANGENT
    $features.graphTessellation: $VaryingsMeshToDS.texCoord0:                           #define VARYINGS_DS_NEED_TEXCOORD0
    $features.graphTessellation: $VaryingsMeshToDS.texCoord1:                           #define VARYINGS_DS_NEED_TEXCOORD1
    $features.graphTessellation: $VaryingsMeshToDS.texCoord2:                           #define VARYINGS_DS_NEED_TEXCOORD2
    $features.graphTessellation: $VaryingsMeshToDS.texCoord3:                           #define VARYINGS_DS_NEED_TEXCOORD3
    $features.graphTessellation: $VaryingsMeshToDS.color:                               #define VARYINGS_DS_NEED_COLOR
    $features.graphTessellation: $VaryingsMeshToDS.instanceID:                          #define VARYINGS_DS_NEED_INSTANCEID
	$features.graphTessellation: #endif

    // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
    // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
    // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
    // to still allow us to rename the field and keyword of this node without breaking existing code.
    #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
    #define RAYTRACING_SHADER_GRAPH_HIGH
    #endif

    #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
    #define RAYTRACING_SHADER_GRAPH_LOW
    #endif
    // end

    #ifndef SHADER_UNLIT
    // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
    // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
    #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
        #define VARYINGS_NEED_CULLFACE
    #endif
    #endif

    // Specific Material Define
    $include("ShaderPassDefine.template.hlsl")
    // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it

    // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
    // we should have a code like this:
    // if !defined(_DISABLE_SSR_TRANSPARENT)
    // pragma multi_compile _ WRITE_NORMAL_BUFFER
    // endif
    // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
    // it based on if SSR transparent in frame settings and not (and stripper can strip it).
    // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
    // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
    // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
    #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
        #define WRITE_NORMAL_BUFFER
    #endif
    #endif

    // See Lit.shader
    #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
        #define WRITE_DECAL_BUFFER
    #endif

    #ifndef DEBUG_DISPLAY
        // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
        // Don't do it with debug display mode as it is possible there is no depth prepass in this case
        #if !defined(_SURFACE_TYPE_TRANSPARENT)
            #if SHADERPASS == SHADERPASS_FORWARD
            #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
            #elif SHADERPASS == SHADERPASS_GBUFFER
            #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
            #endif
        #endif
    #endif

    // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
    #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
        #define _DEFERRED_CAPABLE_MATERIAL
    #endif

    // Translate transparent motion vector define
    #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
        #define _WRITE_TRANSPARENT_MOTION_VECTOR
    #endif

    // -- Graph Properties
    $splice(GraphProperties)

    // -- Property used by ScenePickingPass
    #ifdef SCENEPICKINGPASS
    float4 _SelectionID;
    #endif

    // -- Properties used by SceneSelectionPass
    #ifdef SCENESELECTIONPASS
    int _ObjectId;
    int _PassValue;
    #endif

    // Includes
    $splice(PreGraphIncludes)
    $splice(GraphIncludes)

    // --------------------------------------------------
    // Structs and Packing

    $splice(PassStructs)

    $splice(InterpolatorPack)

    // --------------------------------------------------
    // Graph


    // Graph Functions
    $splice(GraphFunctions)

    // Graph Vertex
    $splice(GraphVertex)

    // Graph Pixel
    $splice(GraphPixel)

    // --------------------------------------------------
    // Build Graph Inputs
    #ifdef HAVE_VFX_MODIFICATION
    #define VFX_SRP_ATTRIBUTES AttributesMesh
    #define VaryingsMeshType VaryingsMeshToPS
    #define VFX_SRP_VARYINGS VaryingsMeshType
    #define VFX_SRP_SURFACE_INPUTS FragInputs
    #endif
    $features.graphVFX:     $include("VFXConfig.template.hlsl")
    $features.graphVertex:  $include("Vertex.template.hlsl")
    $features.graphTessellation:  $include("Tessellation.template.hlsl")
    $features.graphPixel:   $include("Pixel.template.hlsl")

    // --------------------------------------------------
    // Build Surface Data (Specific Material)

    $include("DecalCommon.template.hlsl")
    $include("ShaderPass.template.hlsl")

    // --------------------------------------------------
    // Get Surface And BuiltinData

    void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
    {
        // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
        #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
        #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
        LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
        #endif
        #endif

        #ifndef SHADER_UNLIT
        #ifdef _DOUBLESIDED_ON
            float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
        #else
            float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
        #endif

        ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
        #endif // SHADER_UNLIT

        SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);

        #if defined(HAVE_VFX_MODIFICATION)
        GraphProperties properties;
        ZERO_INITIALIZE(GraphProperties, properties);

        GetElementPixelProperties(fragInputs, properties);

        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
        #else
        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
        #endif

        #ifdef DEBUG_DISPLAY
        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
        {
            $SurfaceDescription.Alpha: surfaceDescription.Alpha = 1.0f;
        }
        #endif

        // Perform alpha test very early to save performance (a killed pixel will not sample textures)
        // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
        #ifdef _ALPHATEST_ON
            float alphaCutoff = surfaceDescription.AlphaClipThreshold;
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            // The TransparentDepthPrepass is also used with SSR transparent.
            // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
            // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
            $DoAlphaTestPrepass: alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPrepass;
            #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
            // DepthPostpass always use its own alpha threshold
            alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
            #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
            // If use shadow threshold isn't enable we don't allow any test
            $DoAlphaTestShadow: alphaCutoff = _UseShadowThreshold ? surfaceDescription.AlphaClipThresholdShadow : alphaCutoff;
            #endif

            GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
        #endif

        #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
        ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
        #endif

        #ifndef SHADER_UNLIT
        float3 bentNormalWS;
        BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);

        #ifdef FRAG_INPUTS_USE_TEXCOORD1
            float4 lightmapTexCoord1 = fragInputs.texCoord1;
        #else
            float4 lightmapTexCoord1 = float4(0,0,0,0);
        #endif

        #ifdef FRAG_INPUTS_USE_TEXCOORD2
            float4 lightmapTexCoord2 = fragInputs.texCoord2;
        #else
            float4 lightmapTexCoord2 = float4(0,0,0,0);
        #endif

        float alpha = 1.0;
        $SurfaceDescription.Alpha: alpha = surfaceDescription.Alpha;

        // Builtin Data
        // For back lighting we use the oposite vertex normal
        InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);

        #else
        BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);

        ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
        builtinData.opacity = surfaceDescription.Alpha;

        #if defined(DEBUG_DISPLAY)
            // Light Layers are currently not used for the Unlit shader (because it is not lit)
            // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
            // display in the light layers visualization mode, therefore we need the renderingLayers
            builtinData.renderingLayers = GetMeshRenderingLayerMask();
        #endif

        #endif // SHADER_UNLIT

        #ifdef _ALPHATEST_ON
            // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
            builtinData.alphaClipTreshold = alphaCutoff;
        #endif

        // override sampleBakedGI - not used by Unlit
		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        $LightingGI: builtinData.bakeDiffuseLighting = surfaceDescription.BakedGI; builtinData.isLightmap = 1;
        $BackLightingGI: builtinData.backBakeDiffuseLighting = surfaceDescription.BakedBackGI; builtinData.isLightmap = 1;

        $SurfaceDescription.Emission: builtinData.emissiveColor = surfaceDescription.Emission;

        // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
        // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
        // This is a limitation of the current MRT approach.
        #ifdef UNITY_VIRTUAL_TEXTURING
        $SurfaceDescription.VTPackedFeedback: builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;
        #endif

        #if _DEPTHOFFSET_ON
        builtinData.depthOffset = surfaceDescription.DepthOffset;
        #endif

        // TODO: We should generate distortion / distortionBlur for non distortion pass
        #if (SHADERPASS == SHADERPASS_DISTORTION)
        builtinData.distortion = surfaceDescription.Distortion;
        builtinData.distortionBlur = surfaceDescription.DistortionBlur;
        #endif

        #ifndef SHADER_UNLIT
        // PostInitBuiltinData call ApplyDebugToBuiltinData
        PostInitBuiltinData(V, posInput, surfaceData, builtinData);
        #else
        ApplyDebugToBuiltinData(builtinData);
        #endif

        RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
    }

    // --------------------------------------------------
    // Main

    $splice(PostGraphIncludes)

    // --------------------------------------------------
    // Visual Effect Vertex Invocations

	#ifdef HAVE_VFX_MODIFICATION
        #if !defined(SHADER_STAGE_RAY_TRACING)
	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
        #else
        $features.graphVFX:     $include("IntersectionShader.template.hlsl")
        #endif
	#endif

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\ShaderGraph\Templates\ShaderPass.template---------------
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Samples~\Common\Textures\terrain\ground_rockgrass_fellsdirty\ground_rockgrass_fellsdirty.terrainlayer---------------
.

.


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Samples~\Common\Textures\terrain\ground_rockgrass_fellsdirty\ground_rockgrass_fellsdirty.terrainlayer---------------
.

.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\Water\ShaderGraph\WaterDecalShaderPass.template---------------
.
.
Pass
{

$splice(PassName)

// Render State
$splice(RenderState)

// Debug
$splice(Debug)

// --------------------------------------------------
// Pass

HLSLPROGRAM

// Pragmas
$splice(PassPragmas)

// Keywords
$splice(PassKeywords)
$splice(GraphKeywords)

// Defines
$Attributes.vertexID: #define ATTRIBUTES_NEED_VERTEXID
$Attributes.uv0: #define ATTRIBUTES_NEED_TEXCOORD0
$Attributes.uv1: #define ATTRIBUTES_NEED_TEXCOORD1
$Attributes.uv2: #define ATTRIBUTES_NEED_TEXCOORD2
$Attributes.uv3: #define ATTRIBUTES_NEED_TEXCOORD3

$Varyings.texCoord0: #define VARYINGS_NEED_TEXCOORD0
$Varyings.texCoord1: #define VARYINGS_NEED_TEXCOORD1
$Varyings.texCoord2: #define VARYINGS_NEED_TEXCOORD2
$Varyings.texCoord3: #define VARYINGS_NEED_TEXCOORD3


$splice(PassInstancing)
$splice(GraphDefines)

// Includes
$splice(PreGraphIncludes)

// --------------------------------------------------
// Structs and Packing

$splice(PassStructs)

$splice(InterpolatorPack)

// --------------------------------------------------
// Graph

// Graph Properties
$splice(GraphProperties)

// Graph Includes
$splice(GraphIncludes)

// Graph Functions
$splice(GraphFunctions)

// Graph Pixel
$splice(GraphPixel)

// --------------------------------------------------
// Build Graph Inputs

void BuildVaryings(Attributes input, inout Varyings output)
{
    UNITY_SETUP_INSTANCE_ID(input);
    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

    output.texCoord0 = output.positionCS * 0.5 + 0.5;

#if UNITY_UV_STARTS_AT_TOP
    if (_FlipY < 0.5)
        output.texCoord0.y = 1 - output.texCoord0.y;
#endif

    float3 p = ComputeWorldSpacePosition(output.positionCS, UNITY_MATRIX_I_VP);

    // Encode view direction in texCoord1
    output.texCoord1.xyz = GetWorldSpaceViewDir(p);
}

float3 _WaterDecalTimeParameters;

SurfaceDescriptionInputs BuildSurfaceDescriptionInputs(Varyings input)
{
    SurfaceDescriptionInputs output;
    ZERO_INITIALIZE(SurfaceDescriptionInputs, output);

    $SurfaceDescriptionInputs.ScreenPosition:                           output.ScreenPosition = float4(input.texCoord0.xy, 0, 1);
    $SurfaceDescriptionInputs.NDCPosition:                              output.NDCPosition = input.texCoord0.xy;

    $SurfaceDescriptionInputs.uv0:                                      output.uv0 = input.texCoord0;
    $SurfaceDescriptionInputs.uv1:                                      output.uv1 = input.texCoord1;
    $SurfaceDescriptionInputs.uv2:                                      output.uv2 = input.texCoord2;
    $SurfaceDescriptionInputs.uv3:                                      output.uv3 = input.texCoord3;

    $SurfaceDescriptionInputs.TimeParameters:                           output.TimeParameters = _WaterDecalTimeParameters.xyz;

    return output;
}

// --------------------------------------------------
// Main

PackedVaryings Vert(Attributes input)
{
    Varyings output = (Varyings)0;
    output.positionCS = GetFullScreenTriangleVertexPosition(input.vertexID, UNITY_RAW_FAR_CLIP_VALUE);
    BuildVaryings(input, output);
    PackedVaryings packedOutput = PackVaryings(output);
    return packedOutput;
}

#ifdef PASS_DEFORMATION_AND_FOAM
	#define TARGET_TYPE float3
#elif defined(PASS_MASK)
	#define TARGET_TYPE float4
#elif defined(PASS_LARGE_CURRENT)
	#define TARGET_TYPE float3
#elif defined(PASS_RIPPLES_CURRENT)
	#define TARGET_TYPE float3
#endif


TARGET_TYPE Frag(PackedVaryings packedInput) : SV_Target
{
    Varyings varyings = UnpackVaryings(packedInput);
	SurfaceDescriptionInputs inputs = BuildSurfaceDescriptionInputs(varyings);
	SurfaceDescription surface = SurfaceDescriptionFunction(inputs);

    float deformation = 0.0f;
    float2 foam = 0.0f;
    float4 mask = 1.0f;
    float3 largeCurrent = 0.0f;
    float3 ripplesCurrent = 0.0f;

#if _AFFECTS_DEFORMATION == 1
    $Material.Deformation:  deformation = surface.Deformation;
#endif

#if _AFFECTS_FOAM == 1
    $Material.SurfaceFoam:  foam.x = saturate(surface.SurfaceFoam);
    $Material.DeepFoam:     foam.y = saturate(surface.DeepFoam);
#endif

#if _AFFECTS_MASK == 1
    $Material.SimulationMask:       mask.xyz = saturate(surface.SimulationMask);
    $Material.SimulationFoamMask:   mask.w = saturate(surface.SimulationFoamMask);
#endif

#if _AFFECTS_LARGE_CURRENT == 1
    $Material.LargeCurrent:          largeCurrent.xy = surface.LargeCurrent;
    $Material.LargeCurrentInfluence: largeCurrent.z = saturate(surface.LargeCurrentInfluence);
#endif

#if _AFFECTS_RIPPLES_CURRENT == 1
    $Material.RipplesCurrent:          ripplesCurrent.xy = surface.RipplesCurrent;
    $Material.RipplesCurrentInfluence: ripplesCurrent.z = saturate(surface.RipplesCurrentInfluence);
#endif

#ifdef PASS_DEFORMATION_AND_FOAM
    return float3(deformation, foam);
#elif defined(PASS_MASK)
    return mask;
#elif defined(PASS_LARGE_CURRENT)
    return largeCurrent;
#elif defined(PASS_RIPPLES_CURRENT)
    return ripplesCurrent;
#endif
}

$splice(PostGraphIncludes)

ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\Material\Water\ShaderGraph\WaterDecalShaderPass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\PostProcessing\Templates\CustomPostProcessingShader.template---------------
.
.
Shader "Hidden/Shader/#SCRIPTNAME#"
{
    Properties
    {
        // This property is necessary to make the CommandBuffer.Blit bind the source texture to _MainTex
        _MainTex("Main Texture", 2DArray) = "grey" {}
    }

    HLSLINCLUDE

    #pragma target 4.5
    #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FXAA.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/RTUpscale.hlsl"

    struct Attributes
    {
        uint vertexID : SV_VertexID;
        UNITY_VERTEX_INPUT_INSTANCE_ID
    };

    struct Varyings
    {
        float4 positionCS : SV_POSITION;
        float2 texcoord   : TEXCOORD0;
        UNITY_VERTEX_OUTPUT_STEREO
    };

    Varyings Vert(Attributes input)
    {
        Varyings output;
        UNITY_SETUP_INSTANCE_ID(input);
        UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
        output.positionCS = GetFullScreenTriangleVertexPosition(input.vertexID);
        output.texcoord = GetFullScreenTriangleTexCoord(input.vertexID);
        return output;
    }

    // List of properties to control your post process effect
    float _Intensity;
    TEXTURE2D_X(_MainTex);

    float4 CustomPostProcess(Varyings input) : SV_Target
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);

        // Note that if HDUtils.DrawFullScreen is not used to render the post process, you don't need to call ClampAndScaleUVForBilinearPostProcessTexture.

        float3 sourceColor = SAMPLE_TEXTURE2D_X(_MainTex, s_linear_clamp_sampler, ClampAndScaleUVForBilinearPostProcessTexture(input.texcoord.xy)).xyz;

        // Apply greyscale effect
        float3 color = lerp(sourceColor, Luminance(sourceColor), _Intensity);

        return float4(color, 1);
    }

    ENDHLSL

    SubShader
    {
        Tags{ "RenderPipeline" = "HDRenderPipeline" }
        Pass
        {
            Name "#NAME#"

            ZWrite Off
            ZTest Always
            Blend Off
            Cull Off

            HLSLPROGRAM
                #pragma fragment CustomPostProcess
                #pragma vertex Vert
            ENDHLSL
        }
    }
    Fallback Off
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\PostProcessing\Templates\CustomPostProcessingShader.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\PostProcessing\Templates\CustomPostProcessingVolume.template---------------
.
.
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.HighDefinition;
using System;

[Serializable, VolumeComponentMenu("Post-processing/Custom/#NAME#")]
public sealed class #SCRIPTNAME# : CustomPostProcessVolumeComponent, IPostProcessComponent
{
    [Tooltip("Controls the intensity of the effect.")]
    public ClampedFloatParameter intensity = new ClampedFloatParameter(0f, 0f, 1f);

    Material m_Material;

    public bool IsActive() => m_Material != null && intensity.value > 0f;

    // Do not forget to add this post process in the Custom Post Process Orders list (Project Settings > Graphics > HDRP Global Settings).
    public override CustomPostProcessInjectionPoint injectionPoint => CustomPostProcessInjectionPoint.AfterPostProcess;

    const string kShaderName = "Hidden/Shader/#SCRIPTNAME#";

    public override void Setup()
    {
        if (Shader.Find(kShaderName) != null)
            m_Material = new Material(Shader.Find(kShaderName));
        else
            Debug.LogError($"Unable to find shader '{kShaderName}'. Post Process Volume #NAME# is unable to load. To fix this, please edit the 'kShaderName' constant in #NAME#.cs or change the name of your custom post process shader.");
    }

    public override void Render(CommandBuffer cmd, HDCamera camera, RTHandle source, RTHandle destination)
    {
        if (m_Material == null)
            return;

        m_Material.SetFloat("_Intensity", intensity.value);
        m_Material.SetTexture("_MainTex", source);
        HDUtils.DrawFullScreen(cmd, m_Material, destination, shaderPassId: 0);
    }

    public override void Cleanup()
    {
        CoreUtils.Destroy(m_Material);
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\PostProcessing\Templates\CustomPostProcessingVolume.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\RenderPipeline\CustomPass\CustomPassCSharpScript.template---------------
.
.
using UnityEngine;
using UnityEngine.Rendering.HighDefinition;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;

class #SCRIPTNAME# : CustomPass
{
    // It can be used to configure render targets and their clear state. Also to create temporary render target textures.
    // When empty this render pass will render to the active camera render target.
    // You should never call CommandBuffer.SetRenderTarget. Instead call <c>ConfigureTarget</c> and <c>ConfigureClear</c>.
    // The render pipeline will ensure target setup and clearing happens in an performance manner.
    protected override void Setup(ScriptableRenderContext renderContext, CommandBuffer cmd)
    {
        // Setup code here
    }

    protected override void Execute(CustomPassContext ctx)
    {
        // Executed every frame for all the camera inside the pass volume.
        // The context contains the command buffer to use to enqueue graphics commands.
    }

    protected override void Cleanup()
    {
        // Cleanup code
    }
}.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\RenderPipeline\CustomPass\CustomPassCSharpScript.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\RenderPipeline\CustomPass\CustomPassFullScreenShader.template---------------
.
.
Shader "FullScreen/#SCRIPTNAME#"
{
    HLSLINCLUDE

    #pragma vertex Vert

    #pragma target 4.5
    #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/RenderPass/CustomPass/CustomPassCommon.hlsl"

    // The PositionInputs struct allow you to retrieve a lot of useful information for your fullScreenShader:
    // struct PositionInputs
    // {
    //     float3 positionWS;  // World space position (could be camera-relative)
    //     float2 positionNDC; // Normalized screen coordinates within the viewport    : [0, 1) (with the half-pixel offset)
    //     uint2  positionSS;  // Screen space pixel coordinates                       : [0, NumPixels)
    //     uint2  tileCoord;   // Screen tile coordinates                              : [0, NumTiles)
    //     float  deviceDepth; // Depth from the depth buffer                          : [0, 1] (typically reversed)
    //     float  linearDepth; // View space Z coordinate                              : [Near, Far]
    // };

    // To sample custom buffers, you have access to these functions:
    // But be careful, on most platforms you can't sample to the bound color buffer. It means that you
    // can't use the SampleCustomColor when the pass color buffer is set to custom (and same for camera the buffer).
    // float4 CustomPassSampleCustomColor(float2 uv);
    // float4 CustomPassLoadCustomColor(uint2 pixelCoords);
    // float LoadCustomDepth(uint2 pixelCoords);
    // float SampleCustomDepth(float2 uv);

    // There are also a lot of utility function you can use inside Common.hlsl and Color.hlsl,
    // you can check them out in the source code of the core SRP package.

    float4 FullScreenPass(Varyings varyings) : SV_Target
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(varyings);
        float depth = LoadCameraDepth(varyings.positionCS.xy);
        PositionInputs posInput = GetPositionInput(varyings.positionCS.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
        float3 viewDirection = GetWorldSpaceNormalizeViewDir(posInput.positionWS);
        float4 color = float4(0.0, 0.0, 0.0, 0.0);

        // Load the camera color buffer at the mip 0 if we're not at the before rendering injection point
        if (_CustomPassInjectionPoint != CUSTOMPASSINJECTIONPOINT_BEFORE_RENDERING)
            color = float4(CustomPassLoadCameraColor(varyings.positionCS.xy, 0), 1);

        // Add your custom pass code here

        // Fade value allow you to increase the strength of the effect while the camera gets closer to the custom pass volume
        float f = 1 - abs(_FadeValue * 2 - 1);
        return float4(color.rgb + f, color.a);
    }

    ENDHLSL

    SubShader
    {
        Tags{ "RenderPipeline" = "HDRenderPipeline" }
        Pass
        {
            Name "Custom Pass 0"

            ZWrite Off
            ZTest Always
            Blend SrcAlpha OneMinusSrcAlpha
            Cull Off

            HLSLPROGRAM
                #pragma fragment FullScreenPass
            ENDHLSL
        }
    }
    Fallback Off
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\RenderPipeline\CustomPass\CustomPassFullScreenShader.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\RenderPipeline\CustomPass\CustomPassRenderersShader.template---------------
.
.
Shader "Renderers/#SCRIPTNAME#"
{
    Properties
    {
        _Color("Color", Color) = (1,1,1,1)
        _ColorMap("ColorMap", 2D) = "white" {}

        // Transparency
        _AlphaCutoff("Alpha Cutoff", Range(0.0, 1.0)) = 0.5
        [HideInInspector]_BlendMode("_BlendMode", Range(0.0, 1.0)) = 0.5
    }

    HLSLINCLUDE

    #pragma target 4.5
    #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

    // #pragma enable_d3d11_debug_symbols

    //enable GPU instancing support
    #pragma multi_compile_instancing
    #pragma multi_compile _ DOTS_INSTANCING_ON

    ENDHLSL

    SubShader
    {
        Tags{ "RenderPipeline" = "HDRenderPipeline" }
        Pass
        {
            Name "FirstPass"
            Tags { "LightMode" = "FirstPass" }

            Blend Off
            ZWrite Off
            ZTest LEqual

            Cull Back

            HLSLPROGRAM

            // Toggle the alpha test
            #define _ALPHATEST_ON

            // Toggle transparency
            // #define _SURFACE_TYPE_TRANSPARENT

            // Toggle fog on transparent
            #define _ENABLE_FOG_ON_TRANSPARENT
            
            // List all the attributes needed in your shader (will be passed to the vertex shader)
            // you can see the complete list of these attributes in VaryingMesh.hlsl
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT

            // List all the varyings needed in your fragment shader
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TANGENT_TO_WORLD

            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            
            TEXTURE2D(_ColorMap);

            // Declare properties in the UnityPerMaterial cbuffer to make the shader compatible with SRP Batcher.
CBUFFER_START(UnityPerMaterial)
            float4 _ColorMap_ST;
            float4 _Color;

            float _AlphaCutoff;
            float _BlendMode;
CBUFFER_END

            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/RenderPass/CustomPass/CustomPassRenderersV2.hlsl"

            // If you need to modify the vertex datas, you can uncomment this code
            // Note: all the transformations here are done in object space
            // #define HAVE_MESH_MODIFICATION
            // AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters)
            // {
            //     input.positionOS += input.normalOS * 0.0001; // inflate a bit the mesh to avoid z-fight
            //     return input;
            // }

            // Put the code to render the objects in your custom pass in this function
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 viewDirection, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData)
            {
                float2 colorMapUv = TRANSFORM_TEX(fragInputs.texCoord0.xy, _ColorMap);
                float4 result = SAMPLE_TEXTURE2D(_ColorMap, s_trilinear_clamp_sampler, colorMapUv) * _Color;
                float opacity = result.a;
                float3 color = result.rgb;

#ifdef _ALPHATEST_ON
                DoAlphaTest(opacity, _AlphaCutoff);
#endif

                // Write back the data to the output structures
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                ZERO_INITIALIZE(SurfaceData, surfaceData);
                builtinData.opacity = opacity;
                builtinData.emissiveColor = float3(0, 0, 0);
                surfaceData.color = color;
            }

            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForwardUnlit.hlsl"

            #pragma vertex Vert
            #pragma fragment Frag

            ENDHLSL
        }
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\RenderPipeline\CustomPass\CustomPassRenderersShader.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXDecal.template---------------
.
.
#define VFXComputePixelOutputToDBuffer(i,outDBuffer) \
{ \
	DecalSurfaceData surfaceData; \
    ZERO_INITIALIZE(DecalSurfaceData, surfaceData); \
    VFXGetSurfaceDecalData(surfaceData,i); \
 \
    ENCODE_INTO_DBUFFER(surfaceData, outDBuffer); \
}

void VFXGetSurfaceDecalData(out DecalSurfaceData surfaceData, VFX_VARYING_PS_INPUTS i)
{
	ZERO_INITIALIZE(DecalSurfaceData, surfaceData);
	VFXTransformPSInputs(i);

${VFXLoadParameter:{enableDecalLayers}}
${VFXLoadParameter:{decalLayerMask}}

DecalPrepassData material;
ZERO_INITIALIZE(DecalPrepassData, material);
//Check light layer
if(_EnableDecalLayers)
{
	// Clip the decal if it does not pass the decal layer mask of the receiving material.
	// Decal layer of the decal
	DecodeFromDecalPrepass(i.pos.xy, material);

	if ((decalLayerMask & material.renderingLayerMask) == 0)
	{
		clip(-1);
	}
}

	float3 clipPos;
	clipPos.xy = (i.pos.xy / _ScreenParams.xy) * 2.0f - 1.0f;
	clipPos.z = VFXSampleDepth(i.pos);
	clipPos.y *= _ProjectionParams.x;

    float4 hpositionWS = mul(UNITY_MATRIX_I_VP, float4(clipPos,1.0f));
    float4 worldPos = float4(hpositionWS.xyz / hpositionWS.w, 1.0f);

	float4x4 worldToElement;
	worldToElement[0] = i.worldToDecal0;
	worldToElement[1] = i.worldToDecal1;
	worldToElement[2] = -i.worldToDecal2; //Z points TOWARDS the surface, so we need to revert it
	worldToElement[3] = float4(0,0,0,1);

    float3 positionDS = mul(worldToElement, worldPos).xyz * 2.0f;
	clip(1.0f - abs(positionDS));

    float3x3 normalToWorld = transpose(float3x3(
                                    VFXSafeNormalize(worldToElement[0].xyz),
                                    VFXSafeNormalize(worldToElement[1].xyz),
                                    VFXSafeNormalize(worldToElement[2].xyz)));

	float2 uv = positionDS.xy * 0.5f + 0.5f;
	VFXUVData uvData = GetUVData(i,uv);
    float angleFadeFactor = 1.0f;

if(_EnableDecalLayers)
{
	if (i.VFX_VARYING_ANGLEFADE.x > 0.0f) // if angle fade is enabled
	{
        float3 decalNormal = float3(normalToWorld[0].z, normalToWorld[1].z, normalToWorld[2].z);

		float dotAngle = dot(material.geomNormalWS, decalNormal);
        angleFadeFactor = DecodeAngleFade(dot(material.geomNormalWS, decalNormal), i.VFX_VARYING_ANGLEFADE);
	}
}
	float fadeFactor = i.VFX_VARYING_FADEFACTOR;
	fadeFactor *= angleFadeFactor;

//Compute color even for emissive, to have the correct opacity
    float4 color = float4(1,1,1,1);
    #if HDRP_USE_BASE_COLOR
    color *= VFXGetParticleColor(i);
    #elif HDRP_USE_ADDITIONAL_BASE_COLOR
    #if defined(VFX_VARYING_COLOR)
    color.xyz *= i.VFX_VARYING_COLOR;
    #endif
    #if defined(VFX_VARYING_ALPHA)
    color.a *= i.VFX_VARYING_ALPHA;
    #endif
    #endif
    #if HDRP_USE_BASE_COLOR_MAP
    float4 colorMap = SampleTexture(VFX_SAMPLER(baseColorMap),uvData);
    #if HDRP_USE_BASE_COLOR_MAP_COLOR
    color.xyz *= colorMap.xyz;
    #endif
    #if HDRP_USE_BASE_COLOR_MAP_ALPHA
    color.a *= colorMap.a;
    #endif
    #endif
	color.a *= fadeFactor;
    VFXClipFragmentColor(color.a,i);

#if SHADERPASS == SHADERPASS_VFX_DBUFFER_PROJECTOR
    surfaceData.baseColor.rgb = saturate(color.rgb);
	surfaceData.baseColor.a = color.a;

	float albedoMapBlend = surfaceData.baseColor.a;
	float maskMapBlend = fadeFactor;
    #ifdef DECALS_4RT
        float metallic = 0.0f;
        float ao = 0.0f;
        #ifdef VFX_VARYING_METALLIC
            metallic = i.VFX_VARYING_METALLIC;
        #endif
        #ifdef VFX_VARYING_AMBIENT_OCCLUSION
            ao = i.VFX_VARYING_AMBIENT_OCCLUSION;
        #endif
    #endif

        float smoothness = 0.5f;
    #ifdef VFX_VARYING_SMOOTHNESS
        smoothness = i.VFX_VARYING_SMOOTHNESS;
    #endif


    #if HDRP_USE_MASK_MAP
        surfaceData.mask = SampleTexture(VFX_SAMPLER(maskMap), uvData);
	    maskMapBlend = surfaceData.mask.z * fadeFactor;
    #ifdef DECALS_4RT
	    surfaceData.mask.x = lerp(0, metallic, surfaceData.mask.x);
	    surfaceData.mask.y = lerp(0, ao, surfaceData.mask.y);
    #endif
	    surfaceData.mask.z = lerp(0, smoothness, surfaceData.mask.w);
    #else //HDRP_USE_MASK_MAP
    #ifdef DECALS_4RT
        surfaceData.mask.xy = float2(metallic, ao);
    #endif
        surfaceData.mask.z = smoothness;
    #endif

    #if VFX_MASK_BLEND_BASE_COLOR_ALPHA
	    surfaceData.mask.w = albedoMapBlend;
    #elif VFX_MASK_BLEND_MASK_BLUE
	    surfaceData.mask.w = maskMapBlend;
    #endif

        float normalAlpha = 1.0f;

    #ifdef DECAL_SURFACE_GRADIENT
        float3x3 tangentToWorld = transpose(normalToWorld);
        #if USE_NORMAL_MAP
	    float2 deriv = UnpackDerivativeNormalRGorAG(SampleTexture(VFX_SAMPLER(normalMap),uvData));
        #else // USE_NORMAL_MAP
        float2 deriv = float2(0.0f,0.0f);
        #endif  // USE_NORMAL_MAP
        float3 normalWS = SurfaceGradientFromTBN(deriv, tangentToWorld[0], tangentToWorld[1]);

    #else //DECAL_SURFACE_GRADIENT
        #if USE_NORMAL_MAP
        float3 normalTS = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
        #else //USE_NORMAL_MAP
	    float3 normalTS = float3(0.0f,0.0f,1.0f);
	    #endif //USE_NORMAL_MAP
        float3 normalWS = mul(normalToWorld, normalTS);
	    normalWS = normalize(normalWS);
    #endif //DECAL_SURFACE_GRADIENT

    #ifdef VFX_VARYING_NORMALALPHA
        surfaceData.normalWS.w = i.VFX_VARYING_NORMALALPHA;
    #else
        surfaceData.normalWS.w = 0.0f;
    #endif

	    surfaceData.normalWS.xyz = normalWS;
	    #if VFX_NORMAL_BLEND_BASE_COLOR_ALPHA
	    surfaceData.normalWS.w *= albedoMapBlend;
	    #elif VFX_NORMAL_BLEND_MASK_BLUE
	    surfaceData.normalWS.w *= maskMapBlend;
	    #endif

	    surfaceData.MAOSBlend.xy = float2(surfaceData.mask.w, surfaceData.mask.w);
	#endif
	#if SHADERPASS == SHADERPASS_VFX_DECAL_FORWARD_EMISSIVE
        surfaceData.emissive = float3(1,1,1) * fadeFactor;
        #if defined(VFX_VARYING_EMISSIVE) && (HDRP_USE_EMISSIVE_COLOR || HDRP_USE_ADDITIONAL_EMISSIVE_COLOR)
		surfaceData.emissive *= i.VFX_VARYING_EMISSIVE;
		#endif
		#ifdef HDRP_USE_EMISSIVE_MAP
		float emissiveScale = 1.0f;
		#ifdef VFX_VARYING_EMISSIVESCALE
		emissiveScale = i.VFX_VARYING_EMISSIVESCALE;
		#endif
		surfaceData.emissive *= SampleTexture(VFX_SAMPLER(emissiveMap), uvData).rgb * emissiveScale;
		#endif
		// Inverse pre-expose using exposureWeight weight
		float3 emissiveRcpExposure = surfaceData.emissive * GetInverseCurrentExposureMultiplier();
		#ifdef VFX_VARYING_EXPOSUREWEIGHT
		surfaceData.emissive = lerp(emissiveRcpExposure, surfaceData.emissive, i.VFX_VARYING_EXPOSUREWEIGHT);
		#elif VFX_BYPASS_EXPOSURE
		surfaceData.emissive = lerp(emissiveRcpExposure, surfaceData.emissive, 0.0f);
		#else
		surfaceData.emissive = lerp(emissiveRcpExposure, surfaceData.emissive, 1.0f);
		#endif
        surfaceData.emissive *= saturate(color.a);
	#endif
}

.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXDecal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXDecalVaryings.template---------------
.
.
#define HDRP_NEEDS_UVS (HDRP_USE_BASE_COLOR_MAP || HDRP_USE_MASK_MAP || USE_NORMAL_MAP || HDRP_USE_EMISSIVE_MAP)
#define HDRP_USE_EMISSIVE (HDRP_USE_EMISSIVE_MAP || HDRP_USE_EMISSIVE_COLOR || HDRP_USE_ADDITIONAL_EMISSIVE_COLOR)

${VFXBegin:VFXHDRPDecalVaryingsMacros}
#if (VFX_NEEDS_COLOR_INTERPOLATOR && HDRP_USE_BASE_COLOR) || HDRP_USE_ADDITIONAL_BASE_COLOR
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#endif

#if AFFECT_METALLIC
#define VFX_VARYING_METALLIC materialProperties.x
#endif

#if AFFECT_AMBIENT_OCCLUSION
#define VFX_VARYING_AMBIENT_OCCLUSION materialProperties.y
#endif

#if AFFECT_SMOOTHNESS
#define VFX_VARYING_SMOOTHNESS materialProperties.z
#endif

#if HDRP_USE_EMISSIVE_MAP
#define VFX_VARYING_EMISSIVESCALE materialProperties.w
#endif

#if HDRP_USE_EMISSIVE_COLOR || HDRP_USE_ADDITIONAL_EMISSIVE_COLOR
#define VFX_VARYING_EMISSIVE emissiveColor.rgb
#endif

#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT emissiveColor.a
#endif


#if USE_FLIPBOOK
#if USE_FLIPBOOK_ARRAY_LAYOUT
	#define VFX_VARYING_FLIPBOOKSIZE flipBookSize
#else
	#define VFX_VARYING_FLIPBOOKSIZE flipBookSize.xy
	#define VFX_VARYING_INVFLIPBOOKSIZE flipBookSize.zw
#endif
#if USE_FLIPBOOK_MOTIONVECTORS
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants.xy
#define VFX_VARYING_TEXINDEX builtInInterpolants.z
#define VFX_VARYING_TEXINDEXBLEND builtInInterpolants.w
#else
#define VFX_VARYING_TEXINDEX texIndices.x
#if USE_FLIPBOOK_INTERPOLATION
#define VFX_VARYING_TEXINDEXBLEND texIndices.y
#endif
#endif
#endif

#if USE_UV_SCALE_BIAS
#define VFX_VARYING_UV_SCALE scaleBias.xy
#define VFX_VARYING_UV_BIAS scaleBias.zw
#endif

#if USE_NORMAL_MAP
#define VFX_VARYING_NORMALALPHA normalAlpha
#endif


#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_POSWS posWS
#define VFX_VARYING_FADEFACTOR fadeParameters.x
#define VFX_VARYING_ANGLEFADE fadeParameters.yz
#if USE_ALPHA_TEST
#define VFX_VARYING_ALPHATHRESHOLD fadeParameters.w
#endif
${VFXEnd}

${VFXBegin:VFXHDRPDecalDeclareVaryings}

#if (VFX_NEEDS_COLOR_INTERPOLATOR && HDRP_USE_BASE_COLOR) || HDRP_USE_ADDITIONAL_BASE_COLOR
VFX_OPTIONAL_INTERPOLATION float4 color : COLOR0;
#endif
#if HDRP_USE_EMISSIVE
VFX_OPTIONAL_INTERPOLATION float4 emissiveColor : COLOR1;
#endif

// x: metallic
// y: AO
// z: smoothness
// w: emissive scale
VFX_OPTIONAL_INTERPOLATION float4 materialProperties : TEXCOORD0;
#if USE_FLIPBOOK
#if USE_FLIPBOOK_ARRAY_LAYOUT
	nointerpolation float flipBookSize : TEXCOORD1;
#else
	nointerpolation float4 flipBookSize : TEXCOORD1;
#endif
#if USE_FLIPBOOK_MOTIONVECTORS
// x: motion vectors scale X
// y: motion vectors scale Y
// z: texIndex
// w: texIndexBlend
nointerpolation float4 builtInInterpolants : TEXCOORD2;
#else
// x: texIndex
// y: texIndexBlend
nointerpolation float2 texIndices : TEXCOORD2;
#endif
#endif

#if USE_UV_SCALE_BIAS
nointerpolation float4 scaleBias : TEXCOORD1;
#endif

float3 posWS : TEXCOORD3;
#if USE_ALPHA_TEST
// x: fade factor
// y: angle fade start
// z: angle fade end
// w: alpha threshold
nointerpolation float4 fadeParameters : TEXCOORD4;
#else
// x: fade factor
// y: angle fade start
// z: angle fade end
nointerpolation float3 fadeParameters : TEXCOORD4;
#endif

nointerpolation float4 worldToDecal0 : TEXCOORD5;
nointerpolation float4 worldToDecal1 : TEXCOORD6;
nointerpolation float4 worldToDecal2 : TEXCOORD7;

#if USE_NORMAL_MAP
VFX_OPTIONAL_INTERPOLATION float normalAlpha : TEXCOORD8;
#endif

VFX_VERTEX_OUTPUT_INSTANCE_INDEX

${VFXEnd}

${VFXBegin:VFXHDRPDecalFillVaryings}
#ifndef VFX_SHADERGRAPH

#ifdef VFX_VARYING_SMOOTHNESS
${VFXLoadParameter:{smoothness}}
o.VFX_VARYING_SMOOTHNESS = smoothness;
#endif

#ifdef VFX_VARYING_METALLIC
${VFXLoadParameter:{metallic}}
o.VFX_VARYING_METALLIC = metallic;
#endif

#ifdef VFX_VARYING_AMBIENT_OCCLUSION
${VFXLoadParameter:{ambientOcclusion}}
o.VFX_VARYING_AMBIENT_OCCLUSION = ambientOcclusion;
#endif

#if HDRP_USE_EMISSIVE_MAP
#ifdef VFX_VARYING_EMISSIVESCALE
${VFXLoadParameter:{emissiveScale}}
o.VFX_VARYING_EMISSIVESCALE = emissiveScale;
#endif
#endif

#ifdef VFX_VARYING_EMISSIVE
#if HDRP_USE_EMISSIVE_COLOR
o.VFX_VARYING_EMISSIVE = attributes.color;
#elif HDRP_USE_ADDITIONAL_EMISSIVE_COLOR
${VFXLoadParameter:{emissiveColor}}
o.VFX_VARYING_EMISSIVE = emissiveColor.rgb;
#endif
#endif

#if HDRP_USE_ADDITIONAL_BASE_COLOR
#ifdef VFX_VARYING_COLOR
${VFXLoadParameter:{baseColor}}
o.VFX_VARYING_COLOR = baseColor;
#endif
#endif
#endif

float4x4 worldToDecal = GetVFXToElementMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

#if VFX_LOCAL_SPACE
worldToDecal = mul(worldToDecal, VFXGetWorldToObjectMatrix());
#else
worldToDecal = ApplyCameraTranslationToInverseMatrix(worldToDecal);
#endif
o.worldToDecal0 = worldToDecal[0];
o.worldToDecal1 = worldToDecal[1];
o.worldToDecal2 = worldToDecal[2];

#ifdef VFX_VARYING_NORMALALPHA
${VFXLoadParameter:{normalAlpha}}
o.VFX_VARYING_NORMALALPHA = normalAlpha;
#endif
${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXDecalVaryings.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXDistortion.template---------------
.
.
${VFXBegin:VFXVertexDistortionProcess}

#if DISTORTION_SCREENSPACE
		${VFXLoadParameter:{distortionScale}}
		o.distortionInterpolants.xy = distortionScale;
#endif

#if DISTORTION_NORMALBASED
		${VFXLoadParameter:{distortionScale}}
		o.distortionInterpolants.x = distortionScale;
		o.distortionInterpolants.y = 0.0;
#endif

		${VFXLoadParameter:{blurScale}}
		o.distortionInterpolants.z = blurScale;

#if DISTORTION_SCALE_BY_DISTANCE
		// Scale Distortion by Distance
		float clipPosW = o.VFX_VARYING_POSCS.w;
		o.distortionInterpolants.xy /= clipPosW;
#endif

${VFXEnd}



${VFXBegin:VFXFragmentDistortionProcess}

		float2 distortion;
		float blur;

#if DISTORTION_SCREENSPACE
		float3 smpDistort = VFXGetTextureColor(VFX_SAMPLER(distortionBlurMap),i).xyz;
		distortion = (smpDistort.xy * 2.0 - 1.0) * i.distortionInterpolants.xy;
		blur = smpDistort.z * i.distortionInterpolants.z;
#endif

#if DISTORTION_NORMALBASED
		${VFXComputeNormalWS}
		float3 viewNormal = mul(VFXGetWorldToViewRotMatrix(),normalWS);
		float smpSmoothness = VFXGetTextureColor(VFX_SAMPLER(smoothnessMap),i).a;
		float smpMask = VFXGetTextureColor(VFX_SAMPLER(alphaMask),i).a;
		distortion = viewNormal.xy * i.distortionInterpolants.x * smpMask;
		blur = (1.0-smpSmoothness) * i.distortionInterpolants.z * smpMask; 
#endif
		float fade = VFXGetSoftParticleFade(i);
		o.distortion.xyw = fade * i.VFX_VARYING_ALPHA * float3(distortion.xy, blur);
		o.distortion.z = 1.0;
		return o;

${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXDistortion.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXLit.template---------------
.
.
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXLit.hlsl"

#ifndef VFX_SHADERGRAPH


void VFXGetHDRPLitData(out SurfaceData surfaceData, out BuiltinData builtinData, out BSDFData bsdfData, out PreLightData preLightData, VFX_VARYING_PS_INPUTS i, float3 normalWS, PositionInputs posInput,  const VFXUVData uvData, bool frontFace, uint2 tileIndex)
{
    #if HDRP_MATERIAL_TYPE_TRANSLUCENT
	    ${VFXLoadParameter:{diffusionProfileHash}} // Loads diffusion profile
	#else
	    const uint diffusionProfileHash = 0;
	#endif
	    float alpha;
	    surfaceData = VFXGetSurfaceData(i,normalWS,uvData,diffusionProfileHash,frontFace,alpha);
	    bsdfData = ConvertSurfaceDataToBSDFData(posInput.positionSS.xy, surfaceData);
#if defined(SHADER_STAGE_RAY_TRACING)
        preLightData = GetPreLightData(-WorldRayDirection(),posInput,bsdfData);
#else
        preLightData = GetPreLightData(GetWorldSpaceNormalizeViewDir(posInput.positionWS),posInput,bsdfData);
#endif
#ifndef VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
	    preLightData.diffuseFGD = 1.0f;
        //TODO: investigate why this is needed
        preLightData.coatPartLambdaV = 0;
        preLightData.coatIblR = 0;
        preLightData.coatIblF = 0;
    #endif

	    builtinData = VFXGetBuiltinData(i,posInput,surfaceData,uvData,alpha);
}

void VFXGetHDRPLitData(out SurfaceData surfaceData, out BuiltinData builtinData, out BSDFData bsdfData, out PreLightData preLightData, VFX_VARYING_PS_INPUTS i, float3 normalWS, const VFXUVData uvData, bool frontFace, uint2 tileIndex)
{
	float3 posRWS = VFXGetPositionRWS(i);
	float4 posSS = i.VFX_VARYING_POSCS;
	PositionInputs posInput = GetPositionInput(posSS.xy, _ScreenSize.zw, posSS.z, posSS.w, posRWS, tileIndex);

	VFXGetHDRPLitData(surfaceData, builtinData, bsdfData, preLightData, i, normalWS, posInput, uvData, frontFace, 0);
}

void VFXGetHDRPLitData(out SurfaceData surfaceData, out BuiltinData builtinData, VFX_VARYING_PS_INPUTS i, float3 normalWS, const VFXUVData uvData)
{
	BSDFData bsdfData = (BSDFData)0;
	PreLightData preLightData = (PreLightData)0;
	VFXGetHDRPLitData(surfaceData,builtinData,bsdfData,preLightData,i,normalWS,uvData, true, uint2(0,0));
}


#endif


#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXLitPixelOutput.hlsl"

.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXLit.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXLitVaryings.template---------------
.
.
#define HDRP_NEEDS_UVS (HDRP_USE_BASE_COLOR_MAP || HDRP_USE_MASK_MAP || USE_NORMAL_MAP || HDRP_USE_EMISSIVE_MAP)
#define HDRP_USE_EMISSIVE (HDRP_USE_EMISSIVE_MAP || HDRP_USE_EMISSIVE_COLOR || HDRP_USE_ADDITIONAL_EMISSIVE_COLOR)

${VFXInclude("Shaders/SixWay/SixWayVaryings.template"), VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}

${VFXBegin:VFXHDRPLitVaryingsMacros}
#if (VFX_NEEDS_COLOR_INTERPOLATOR && HDRP_USE_BASE_COLOR) || HDRP_USE_ADDITIONAL_BASE_COLOR
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#endif

#ifndef VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
#define VFX_VARYING_SMOOTHNESS materialProperties.x
#endif

#if HDRP_MATERIAL_TYPE_STANDARD
#define VFX_VARYING_METALLIC materialProperties.y
#elif HDRP_MATERIAL_TYPE_SPECULAR
#define VFX_VARYING_SPECULAR specularColor
#elif HDRP_MATERIAL_TYPE_TRANSLUCENT
#define VFX_VARYING_THICKNESS materialProperties.y
#endif

#if USE_NORMAL_MAP
#define VFX_VARYING_NORMALSCALE materialProperties.z
#endif

#if HDRP_USE_EMISSIVE_MAP && !defined(VFX_MATERIAL_TYPE_SIX_WAY_SMOKE)
#define VFX_VARYING_EMISSIVESCALE materialProperties.w
#endif

#if HDRP_USE_EMISSIVE_COLOR || HDRP_USE_ADDITIONAL_EMISSIVE_COLOR
#define VFX_VARYING_EMISSIVE emissiveColor.rgb
#endif

#if USE_EXPOSURE_WEIGHT
#if HDRP_USE_EMISSIVE
#define VFX_VARYING_EXPOSUREWEIGHT emissiveColor.a
#elif VFX_MATERIAL_TYPE_SIX_WAY_SMOKE && VFX_SIX_WAY_USE_ONE_EMISSIVE_CHANNEL
#define VFX_VARYING_EXPOSUREWEIGHT exposureWeight
#endif
#endif

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
    ${SixWayVaryingsMacros}
#endif
${VFXEnd}

${VFXBegin:VFXHDRPLitDeclareVaryings}

#if (VFX_NEEDS_COLOR_INTERPOLATOR && HDRP_USE_BASE_COLOR) || HDRP_USE_ADDITIONAL_BASE_COLOR
VFX_OPTIONAL_INTERPOLATION float4 color : COLOR0;
#endif
#if HDRP_MATERIAL_TYPE_SPECULAR
VFX_OPTIONAL_INTERPOLATION float3 specularColor : COLOR1;
#endif
#if HDRP_USE_EMISSIVE
VFX_OPTIONAL_INTERPOLATION float4 emissiveColor : COLOR2;
#elif VFX_MATERIAL_TYPE_SIX_WAY_SMOKE && VFX_SIX_WAY_USE_ONE_EMISSIVE_CHANNEL && USE_EXPOSURE_WEIGHT
VFX_OPTIONAL_INTERPOLATION float exposureWeight : COLOR2;
#endif

#ifndef VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
// x: smoothness
// y: metallic/thickness
// z: normal scale
// w: emissive scale
VFX_OPTIONAL_INTERPOLATION float4 materialProperties : TEXCOORD0;
#endif

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
${SixWayDeclareVaryings}
#endif

VFX_VERTEX_OUTPUT_INSTANCE_INDEX

${VFXEnd}

${VFXBegin:VFXHDRPLitFillVaryings}
#ifndef VFX_SHADERGRAPH
#ifdef VFX_VARYING_SMOOTHNESS
${VFXLoadParameter:{smoothness}}
o.VFX_VARYING_SMOOTHNESS = smoothness;
#endif
#if HDRP_MATERIAL_TYPE_STANDARD
#ifdef VFX_VARYING_METALLIC
${VFXLoadParameter:{metallic}}
o.VFX_VARYING_METALLIC = metallic;
#endif
#elif HDRP_MATERIAL_TYPE_SPECULAR
#ifdef VFX_VARYING_SPECULAR
${VFXLoadParameter:{specularColor}}
o.VFX_VARYING_SPECULAR = specularColor.rgb;
#endif
#elif HDRP_MATERIAL_TYPE_TRANSLUCENT
#ifdef VFX_VARYING_THICKNESS
${VFXLoadParameter:{thickness}}
o.VFX_VARYING_THICKNESS = thickness;
#endif
#endif
#if USE_NORMAL_MAP
#ifdef VFX_VARYING_NORMALSCALE
${VFXLoadParameter:{normalScale}}
o.VFX_VARYING_NORMALSCALE = normalScale;
#endif
#endif
#if HDRP_USE_EMISSIVE_MAP
#ifdef VFX_VARYING_EMISSIVESCALE
${VFXLoadParameter:{emissiveScale}}
o.VFX_VARYING_EMISSIVESCALE = emissiveScale;
#endif
#endif
#ifdef VFX_VARYING_EMISSIVE
#if HDRP_USE_EMISSIVE_COLOR
o.VFX_VARYING_EMISSIVE = attributes.color;
#elif HDRP_USE_ADDITIONAL_EMISSIVE_COLOR
${VFXLoadParameter:{emissiveColor}}
o.VFX_VARYING_EMISSIVE = emissiveColor.rgb;
#endif
#endif
#if HDRP_USE_ADDITIONAL_BASE_COLOR
#ifdef VFX_VARYING_COLOR
${VFXLoadParameter:{baseColor}}
o.VFX_VARYING_COLOR = baseColor;
#endif
#endif

${SixWayFillVaryings}

#endif

${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXLitVaryings.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXPasses.template---------------
.
.
${VFXBegin:VFXPassDepth}"DepthForwardOnly"${VFXEnd}
${VFXBegin:VFXPassForward}"ForwardOnly"${VFXEnd}
${VFXBegin:VFXPassShadow}"ShadowCaster"${VFXEnd}
${VFXBegin:VFXPassVelocity}"MotionVectors"${VFXEnd}

${VFXBegin:VFXPassDepthDefine}
#define SHADERPASS SHADERPASS_DEPTH_ONLY

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
#define SCENESELECTIONPASS
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
#define SCENEPICKINGPASS
#endif

${VFXEnd}

${VFXBegin:VFXPassForwardDefine}#define SHADERPASS SHADERPASS_FORWARD_UNLIT${VFXEnd}
${VFXBegin:VFXPassShadowDefine}#define SHADERPASS SHADERPASS_SHADOWS${VFXEnd}
${VFXBegin:VFXPassVelocityDefine}#define SHADERPASS SHADERPASS_MOTION_VECTORS${VFXEnd}

${VFXBegin:VFXPassDepthAdditionalPragma}#pragma multi_compile _ WRITE_MSAA_DEPTH${VFXEnd}
${VFXBegin:VFXPassForwardAdditionalPragma}#pragma multi_compile _ DEBUG_DISPLAY${VFXEnd}
${VFXBegin:VFXPassVelocityAdditionalPragma}#pragma multi_compile _ WRITE_MSAA_DEPTH${VFXEnd}

${VFXBegin:VFXShaderGraphFunctionsInclude}
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinGIUtilities.hlsl"
#ifndef SHADERPASS
#error Shaderpass should be defined at this stage.
#endif
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
${VFXEnd}

${VFXBegin:VFXPassDepthCommonFragmentLit}
#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
${VFXPassShadowDefine}
#else
${VFXPassDepthDefine}
#endif
${VFXIncludeRP("VFXLit.template")}

${SHADERGRAPH_PIXEL_CODE_DEPTHONLY}

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
int _ObjectId;
int _PassValue;
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
float4 _SelectionID;
#endif

#pragma fragment frag
void frag(ps_input i
#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
#endif
#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	#ifdef WRITE_MSAA_DEPTH
	// We need the depth color as SV_Target0 for alpha to coverage
	, out float4 outDepthColor : SV_Target0
	, out float4 outMotionVector : SV_Target1
		#ifdef WRITE_NORMAL_BUFFER
		, out float4 outNormalBuffer : SV_Target2
		#endif
	#else
	// When no MSAA, the motion vector is always the first buffer
	, out float4 outMotionVector : SV_Target0
		#ifdef WRITE_NORMAL_BUFFER
		, out float4 outNormalBuffer : SV_Target1
		#endif
	#endif
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
	#ifdef WRITE_MSAA_DEPTH
	// We need the depth color as SV_Target0 for alpha to coverage
	, out float4 outDepthColor : SV_Target0
		#ifdef WRITE_NORMAL_BUFFER
		, out float4 outNormalBuffer : SV_Target1
		#endif
	#elif defined(WRITE_NORMAL_BUFFER)
	, out float4 outNormalBuffer : SV_Target0
	#endif
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
    , out float4 outColor : SV_Target0
#endif
)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	VFXTransformPSInputs(i);
	${VFXComputeNormalWS}

	#ifdef VFX_SHADERGRAPH
        ${VFXAdditionalInterpolantsPreparation}
        ${SHADERGRAPH_PIXEL_CALL_DEPTHONLY}
        float alpha = OUTSG.${SHADERGRAPH_PARAM_ALPHA};
    #else

	float alpha = VFXGetFragmentColor(i).a;

	#if HDRP_USE_BASE_COLOR_MAP_ALPHA
		alpha *= VFXGetTextureColor(VFX_SAMPLER(baseColorMap),i).a;
	#endif
    #if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
        #ifndef VFX_VARYING_NORMAL
			const VFXUVData uvData = GetUVData(i);
		#endif
        alpha *= SampleTexture(VFX_SAMPLER(positiveAxesLightmap),uvData).a;
         #if VFX_SIX_WAY_USE_ALPHA_REMAP
            alpha = SampleCurve(i.VFX_VARYING_ALPHA_REMAP, alpha);
         #endif
    #endif
    #endif
	VFXClipFragmentColor(alpha,i);

	#ifdef WRITE_NORMAL_BUFFER
        #ifndef VFX_SHADERGRAPH
            VFXComputePixelOutputToNormalBuffer(i,normalWS,uvData,outNormalBuffer);
        #else
           #if HAS_SHADERGRAPH_PARAM_NORMAL
               float3 n =  OUTSG.Normal_8;
               normalWS = mul(n,tbn);
           #endif
           SurfaceData surface = (SurfaceData)0;
           surface.normalWS = normalWS;
           EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surface), outNormalBuffer);
        #endif
	#endif

	#ifdef WRITE_MSAA_DEPTH
		outDepthColor = i.VFX_VARYING_POSCS.z;
		#if VFX_USE_ALPHA_TO_MASK
			outDepthColor.a = alpha;
		#endif
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
		${VFXComputeOutputMotionVector}
		outMotionVector = encodedMotionVector;
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
		// We use depth prepass for scene selection in the editor, this code allow to output the outline correctly
		outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
		outColor = _SelectionID;
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
		//void
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
		//void
	#else
		#error VFX_PASSDEPTH undefined
	#endif
}
${VFXEnd}

${VFXBegin:VFXPassFullScreenDebugCommonVertex}
#if !defined(SHADER_API_METAL)
    if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VERTEX_DENSITY)
        IncrementVertexDensityCounter(o.VFX_VARYING_POSCS);
#endif
${VFXEnd}

${VFXBegin:VFXPassFullScreenDebugCommonFragment}
    #pragma fragment frag
    [earlydepthstencil]
    void frag(ps_input i
#if defined(PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER)
            , uint primitiveId : SV_PrimitiveID
#endif
    )
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
        VFXTransformPSInputs(i);
        VFX_FRAG_SETUP_INSTANCE_ID(i);
        
#ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER
        if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)
        {
           IncrementQuadOverdrawCounter((uint2)i.VFX_VARYING_POSCS.xy, primitiveId);
        }
#endif
    }
${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXPasses.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXSGSurfaceData.template---------------
.
.
SurfaceData surface;
float3 builtinEmissiveColor = (float3)0;
float builtinOpacity = (float)0;
surface = (SurfaceData)0;

surface.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;
surface.specularOcclusion = 1.0f;
surface.ambientOcclusion = 1.0f;
surface.subsurfaceMask = 1.0f;
surface.transmissionMask = 1.0f;

#if HAS_SHADERGRAPH_PARAM_ALPHA
    builtinOpacity = OUTSG.${SHADERGRAPH_PARAM_ALPHA};
    VFXClipFragmentColor(builtinOpacity, i);
#endif

#if HAS_SHADERGRAPH_PARAM_SMOOTHNESS
    surface.perceptualSmoothness = OUTSG.${SHADERGRAPH_PARAM_SMOOTHNESS};
#endif
#if HAS_SHADERGRAPH_PARAM_METALLIC
    surface.metallic = OUTSG.${SHADERGRAPH_PARAM_METALLIC};
#endif
#if HAS_SHADERGRAPH_PARAM_BASECOLOR
    surface.baseColor = OUTSG.${SHADERGRAPH_PARAM_BASECOLOR};
#endif

#if HAS_SHADERGRAPH_PARAM_NORMALTS
    float3 n =  OUTSG.${SHADERGRAPH_PARAM_NORMALTS};
    normalWS = mul(n,tbn);
#endif

surface.normalWS = normalWS;

#if HAS_SHADERGRAPH_PARAM_EMISSION
    builtinEmissiveColor = OUTSG.${SHADERGRAPH_PARAM_EMISSION};
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXSGSurfaceData.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXVertexProbeSampling.template---------------
.
.
${VFXBegin:VFXVertexProbeDeclareVaryings}
//Store a compacted version of the contributions in the six directions (3xfloat4)
#if defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)
#define INDIRECT_INTERPOLATION
#else
#define INDIRECT_INTERPOLATION nointerpolation
#endif

INDIRECT_INTERPOLATION float4 bakeDiffuseLighting[3] : BAKEDIFFUSE0;
${VFXEnd}

${VFXBegin:VFXVertexProbeVaryingsMacros}
#define VFX_VARYING_BAKE_DIFFUSE_LIGHTING bakeDiffuseLighting
${VFXEnd}

${VFXBegin:VFXVertexProbeFillVaryings}
#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
#if VFX_PRIMITIVE_QUAD || VFX_PRIMITIVE_TRIANGLE || VFX_PRIMITIVE_OCTAGON
float4 inTangent = float4(o.VFX_VARYING_TANGENT, 1.0f);
#else
float4 inTangent = o.VFX_VARYING_TANGENT;
#endif
    GatherDiffuseGIData(o.VFX_VARYING_NORMAL, inTangent, o.VFX_VARYING_POSWS,
                                                          o.VFX_VARYING_BAKE_DIFFUSE_LIGHTING[0],
                                                          o.VFX_VARYING_BAKE_DIFFUSE_LIGHTING[1],
                                                          o.VFX_VARYING_BAKE_DIFFUSE_LIGHTING[2]);
#endif
${VFXEnd}


#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
#define HAS_LIGHTLOOP
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/SixWayLit/SixWaySmokeLit.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"


.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\VFXVertexProbeSampling.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleBasicCube.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Back
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
        ${VFXInclude("Shaders/ParticleHexahedron/PassSelection.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleHexahedron/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticleHexahedron/PassBasicForward.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleBasicCube.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleCube.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Back
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleHexahedron/PassForward.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleCube.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleDecal.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Back
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleDecals/PassSelection.template")}
		${VFXInclude("Shaders/ParticleDecals/PassForward.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleDecal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleDistortionMesh.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Off
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXIncludeRP("Templates/Mesh/PassSelection.template")}
		${VFXIncludeRP("Templates/Mesh/PassDistortion.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleDistortionMesh.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleDistortionPlanarPrimitive.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Off
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassSelection.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassDistortion.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleDistortionPlanarPrimitive.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleHDRPDecal.template---------------
.
.
{
	SubShader
	{
		HLSLINCLUDE
		#define mainTexture baseColorMap
		ENDHLSL

		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassSelection.template")}
		${VFXIncludeRP("Templates/HDRPDecal/PassDBuffer.template")}
		${VFXIncludeRP("Templates/HDRPDecal/PassForwardEmissive.template"), NEEDS_FORWARD_EMISSIVE_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleHDRPDecal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesHW.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleLines/PassSelection.template")}
		${VFXInclude("Shaders/ParticleLines/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleLines/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticleLines/PassForward.template")}
		${VFXIncludeRP("Templates/ParticleLines/PassFullScreenDebug.template")}
		${VFXInclude("Shaders/ParticleLines/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesHW.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesSW.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleLinesSW/PassSelection.template")}
		${VFXInclude("Shaders/ParticleLinesSW/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleLinesSW/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticleLinesSW/PassForward.template")}
		${VFXIncludeRP("Templates/ParticleLinesSW/PassFullScreenDebug.template")}
		${VFXInclude("Shaders/ParticleLinesSW/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesSW.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLitCube.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Back

		HLSLINCLUDE
		#define mainTexture baseColorMap
		ENDHLSL

		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassSelection.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassDepth.template"),IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/Hexahedron/PassDepthForwardOnly.template"),HDRP_MATERIAL_TYPE_SIMPLELIT}
		${VFXInclude("Shaders/ParticleHexahedron/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXIncludeRP("Templates/Hexahedron/PassGBuffer.template"), IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/Hexahedron/PassForward.template")}
		${VFXIncludeRP("Templates/Hexahedron/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLitCube.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLitMesh.template---------------
.
.
{
	SubShader
	{
		Tags{ "RenderPipeline" = "HDRenderPipeline" }
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXIncludeRP("Templates/Mesh/PassSelection.template")}
		${VFXIncludeRP("Templates/Mesh/PassDepth.template"),IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/Mesh/PassDepthForwardOnly.template"),NEEDS_DEPTH_FORWARD_ONLY}
		${VFXIncludeRP("Templates/Mesh/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXIncludeRP("Templates/Mesh/PassGBuffer.template"),IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/Mesh/PassFullScreenDebug.template")}
		${VFXIncludeRP("Templates/Mesh/PassForward.template")}
		${VFXIncludeRP("Templates/Mesh/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLitMesh.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLitPlanarPrimitive.template---------------
.
.
{

	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Off

	    ${VFXInclude("Shaders/VFXParticleHeader.template")}

		${VFXIncludeRP("Templates/PlanarPrimitive/PassSelection.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassDepth.template"),IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassDepthForwardOnly.template"),NEEDS_DEPTH_FORWARD_ONLY}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassGBuffer.template"),IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassForward.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassFullScreenDebug.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}

	${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/DXRPasses.template"),VFX_IS_RAYTRACED}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleLitPlanarPrimitive.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleMeshes.template---------------
.
.
{
	SubShader
	{
		Tags{ "RenderPipeline" = "HDRenderPipeline" }
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleMeshes/PassSelection.template")}
		${VFXInclude("Shaders/ParticleMeshes/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleMeshes/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticleMeshes/PassForward.template")}
		${VFXIncludeRP("Templates/Mesh/PassFullScreenDebug.template")}
		${VFXInclude("Shaders/ParticleMeshes/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleMeshes.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticlePlanarPrimitive.template---------------
.
.
{

	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Off

		// Required passes
        ${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassSelection.template")}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassForward.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/PassFullScreenDebug.template")}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}

	${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/DXRPasses.template"),VFX_IS_RAYTRACED}

}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticlePlanarPrimitive.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticlePoints.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticlePoints/PassSelection.template")}
		${VFXInclude("Shaders/ParticlePoints/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticlePoints/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticlePoints/PassForward.template")}
		${VFXIncludeRP("Templates/ParticlePoints/PassFullScreenDebug.template")}
		${VFXInclude("Shaders/ParticlePoints/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticlePoints.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleSphere.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Off
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXIncludeRP("Templates/Sphere/PassSelection.template")}
		${VFXIncludeRP("Templates/Sphere/PassDepth.template"),IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/Sphere/PassDepthForwardOnly.template"),HDRP_MATERIAL_TYPE_SIMPLELIT}
		${VFXIncludeRP("Templates/Sphere/PassGBuffer.template"),IS_OPAQUE_NOT_SIMPLE_LIT_PARTICLE}
		${VFXIncludeRP("Templates/Sphere/PassForward.template")}
		${VFXInclude("Shaders/ParticleSpheres/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXParticleSphere.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXVolumetricFogOutput.template---------------
.
.
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Cull Off

		${VFXInclude("Shaders/VFXParticleHeader.template")}

        Pass
        {
            Name "SceneSelectionPass"
            Tags { "LightMode"="SceneSelectionPass" }

            ZWrite On
            Blend Off

            HLSLPROGRAM
            #pragma vertex Vert
            #pragma fragment FragmentSceneSelection

            #define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
            ${VFXIncludeRP("Templates/Volumetric/PassVolumetricFog.template")}
            ENDHLSL
        }

        Pass
        {
            Name "VolumetricFogVFX"
            Tags { "LightMode"="VolumetricFogVFX" }

            HLSLPROGRAM

            #pragma vertex Vert
            #pragma fragment Frag

            ${VFXIncludeRP("Templates/Volumetric/PassVolumetricFog.template")}
            ENDHLSL
        }

        Pass
        {
            Name "VolumetricFogVFXOverdrawDebug"
            Tags { "LightMode"="VolumetricFogVFXOverdrawDebug" }

            Blend One One

            HLSLPROGRAM

            #pragma vertex Vert
            #pragma fragment FragmentOverdrawDebug

            #define HDRP_OVERDRAW_DEBUG

            ${VFXIncludeRP("Templates/Volumetric/PassVolumetricFog.template")}
            ENDHLSL
        }
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\VFXVolumetricFogOutput.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\HDRPDecal\PassDBuffer.template---------------
.
.
Pass
{
	Name "DBufferMesh"
	Tags {"LightMode"="DBufferVFX"}


	Cull Front
    ZWrite Off
    ZTest Greater


    // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
    Blend 0 SrcAlpha OneMinusSrcAlpha, Zero OneMinusSrcAlpha
    Blend 1 SrcAlpha OneMinusSrcAlpha, Zero OneMinusSrcAlpha
    Blend 2 SrcAlpha OneMinusSrcAlpha, Zero OneMinusSrcAlpha
    Blend 3 Zero OneMinusSrcColor


    ColorMask ${VFXDecalColorMask0}
    ColorMask ${VFXDecalColorMask1} 1
    ColorMask ${VFXDecalColorMask2} 2
    ColorMask ${VFXDecalColorMask3} 3

	HLSLPROGRAM
	#pragma target 4.5
	#pragma multi_compile _ RENDERING_LAYERS
	#pragma multi_compile _ DEBUG_DISPLAY
    #pragma multi_compile_fragment DECALS_3RT DECALS_4RT
    #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT

	#define UNITY_MATERIAL_LIT

	${VFXIncludeRP("VFXDecalVaryings.template")}
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/Decal.hlsl"
	#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"



	struct ps_input
	{
		float4 pos : SV_POSITION;
		${VFXHDRPDecalDeclareVaryings}
		UNITY_VERTEX_OUTPUT_STEREO
	};

	${VFXHDRPDecalVaryingsMacros}

	${VFXBegin:VFXVertexAdditionalProcess}
	${VFXHDRPDecalFillVaryings}
	${VFXEnd}


${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}
#define SHADERPASS SHADERPASS_VFX_DBUFFER_PROJECTOR
${VFXIncludeRP("VFXDecal.template")}

	#pragma fragment frag
	void frag(ps_input i, OUTPUT_DBUFFER(outDBuffer))
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
#if VFX_USE_GRAPH_VALUES
        uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
        ${VFXLoadGraphValues}
#endif
        //TODO Ludovic: pass graphValues here
		VFXComputePixelOutputToDBuffer(i,outDBuffer);
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\HDRPDecal\PassDBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\HDRPDecal\PassForwardEmissive.template---------------
.
.
Pass
{
	Name "DecalMeshForwardEmissive"
	Tags {"LightMode"="DecalMeshForwardEmissive"}


    ZWrite Off
    ZTest LEqual

    Blend 0 SrcAlpha One

	HLSLPROGRAM
	#pragma target 4.5
	#pragma multi_compile _ RENDERING_LAYERS
	#pragma multi_compile _ DEBUG_DISPLAY

	#define UNITY_MATERIAL_LIT

	${VFXIncludeRP("VFXDecalVaryings.template")}
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/Decal.hlsl"
	#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl"



	struct ps_input
	{
		float4 pos : SV_POSITION;
		${VFXHDRPDecalDeclareVaryings}
		UNITY_VERTEX_OUTPUT_STEREO
	};

	${VFXHDRPDecalVaryingsMacros}

	${VFXBegin:VFXVertexAdditionalProcess}
	${VFXHDRPDecalFillVaryings}
	${VFXEnd}


${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}
#define SHADERPASS SHADERPASS_VFX_DECAL_FORWARD_EMISSIVE
${VFXIncludeRP("VFXDecal.template")}


	#pragma fragment frag
	void frag(ps_input i, out float4 outEmissive : SV_Target0)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);

#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif

		DecalSurfaceData surfaceData;
    	ZERO_INITIALIZE(DecalSurfaceData, surfaceData);
//TODO Ludovic : Pass graphValues here
		VFXGetSurfaceDecalData(surfaceData,i);
		outEmissive.rgb = surfaceData.emissive * GetCurrentExposureMultiplier();
		outEmissive.a = 1.0f;
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\HDRPDecal\PassForwardEmissive.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassDepthForwardOnly.template---------------
.
.
Pass
{
    Name "DepthForwardOnly"
	Tags { "LightMode"="DepthForwardOnly" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#pragma multi_compile _ WRITE_NORMAL_BUFFER
	#pragma multi_compile _ WRITE_DECAL_BUFFER
	#pragma multi_compile _ WRITE_MSAA_DEPTH
	${VFXInclude("Shaders/ParticleHexahedron/PassDepthOrMV.template")}


	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassDepthForwardOnly.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassForward.template---------------
.
.
Pass
{		
    Name "${VFXHDRPForwardPassName}"
	Tags { "LightMode"="${VFXHDRPForwardPassName}"}
	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5
	
	#define UNITY_MATERIAL_LIT
	#define LIGHTLOOP_TILE_PASS
	${VFXHDRPForwardDefines}
	#pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST
	#pragma multi_compile_fragment PUNCTUAL_SHADOW_LOW PUNCTUAL_SHADOW_MEDIUM PUNCTUAL_SHADOW_HIGH
	#pragma multi_compile_fragment DIRECTIONAL_SHADOW_LOW DIRECTIONAL_SHADOW_MEDIUM DIRECTIONAL_SHADOW_HIGH
	#pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH
	#pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
	#pragma multi_compile _ DEBUG_DISPLAY
	
	${VFXIncludeRP("VFXLitVaryings.template")}	
	
	struct ps_input
	{
		float4 pos : SV_POSITION;
		
		${VFXHDRPLitDeclareVaryings}
		
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD
		// x: inverse soft particles fade distance
		// y: alpha threshold
		nointerpolation float3 builtInInterpolants : TEXCOORD1;
		#endif

		#if HDRP_NEEDS_UVS
		nointerpolation uint faceID : TEXCOORD2;
		#endif
		
		float3 offsets : TEXCOORD3;
		nointerpolation float3 rotX : TEXCOORD4;
		nointerpolation float3 rotY : TEXCOORD5;
		
		float3 posWS : TEXCOORD8; // Needed for fog
        
        ${VFXAdditionalInterpolantsDeclaration}
		
		UNITY_VERTEX_OUTPUT_STEREO
	};
	
	struct ps_output
	{
		float4 color : SV_Target0;
	};

	${VFXHDRPLitVaryingsMacros}

	#define VFX_VARYING_PS_INPUTS ps_input
	#define VFX_VARYING_POSCS pos
	#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
	#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
	#define VFX_VARYING_OFFSETS offsets
	#define VFX_VARYING_ROTX rotX
	#define VFX_VARYING_ROTY rotY
	#if HDRP_NEEDS_UVS
	#define VFX_VARYING_FACEID faceID
	#endif
	#define VFX_VARYING_POSWS posWS

	${VFXBegin:VFXVertexAdditionalProcess}
	${VFXHDRPLitFillVaryings}
	${VFXEnd}

	${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}
	#define SHADERPASS SHADERPASS_FORWARD
	${VFXIncludeRP("VFXLit.template")}	
		
    ${SHADERGRAPH_PIXEL_CODE_FORWARD}

	#pragma fragment frag
	void frag(ps_input i
	, out float4 outColor : SV_Target0
#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
#endif
	)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);

		#if VFX_USE_GRAPH_VALUES
		   uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
		   ${VFXLoadGraphValues}
		#endif

#if !USE_DOUBLE_SIDED
		const bool frontFace = true;
#endif
		const float faceMul = frontFace ? 1.0f : -1.0f;

		float3 normalWS;
		const VFXUVData uvData = GetUVData(i,VFXCubeGetUV(i));

		#if USE_NORMAL_MAP
		float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
		normalWS = VFXCubeTransformNormalTS(i,n,frontFace);
		normalWS = lerp(VFXCubeGetLocalNormal(i) * faceMul,normalWS,i.materialProperties.z);
		#else
		normalWS = VFXCubeGetLocalNormal(i) * faceMul;
		#endif
		normalWS = VFXCubeTransformNormalWS(i,normalWS);
		normalWS = normalize(normalWS);

		outColor = VFXGetPixelOutputForward(i,normalWS,uvData, true);
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassGBuffer.template---------------
.
.
// Forward pass
Pass
{
    Name "GBuffer"
	Tags { "LightMode"="GBuffer" }

    ${VFXStencilGBuffer}

	HLSLPROGRAM
	#pragma target 4.5

	#pragma multi_compile _ RENDERING_LAYERS
	#pragma multi_compile _ DEBUG_DISPLAY
	#pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2

	#define UNITY_MATERIAL_LIT

	${VFXIncludeRP("VFXLitVaryings.template")}

	struct ps_input
	{
		float4 pos : SV_POSITION;

		${VFXHDRPLitDeclareVaryings}

		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST
		// x: inverse soft particles fade distance
		// y: alpha threshold
		nointerpolation float2 builtInInterpolants : TEXCOORD1;
		#endif

		float3 offsets : TEXCOORD3;
		nointerpolation float3 rotX : TEXCOORD4;
		nointerpolation float3 rotY : TEXCOORD5;

		#if HDRP_NEEDS_UVS
		nointerpolation uint faceID : TEXCOORD6;
		#endif

		UNITY_VERTEX_OUTPUT_STEREO
	};

	struct ps_output
	{
		float4 color : SV_Target0;
	};

${VFXHDRPLitVaryingsMacros}

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_OFFSETS offsets
#define VFX_VARYING_ROTX rotX
#define VFX_VARYING_ROTY rotY
#if HDRP_NEEDS_UVS
#define VFX_VARYING_FACEID faceID
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}

	${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}
	#define SHADERPASS SHADERPASS_GBUFFER
	${VFXIncludeRP("VFXLit.template")}

	#pragma fragment frag
	void frag(ps_input i, OUTPUT_GBUFFER(outGBuffer)
#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
#endif
	)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		VFX_FRAG_SETUP_INSTANCE_ID(i);

    #if VFX_USE_GRAPH_VALUES
       uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
       ${VFXLoadGraphValues}
    #endif

#if !USE_DOUBLE_SIDED
		const bool frontFace = true;
#endif
		const float faceMul = frontFace ? 1.0f : -1.0f;

		float3 normalWS;
		const VFXUVData uvData = GetUVData(i,VFXCubeGetUV(i));

		#if USE_NORMAL_MAP
		float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
		normalWS = VFXCubeTransformNormalTS(i,n,frontFace);
		normalWS = lerp(VFXCubeGetLocalNormal(i) * faceMul,normalWS,i.materialProperties.z);
		#else
		normalWS = VFXCubeGetLocalNormal(i) * faceMul;
		#endif
		normalWS = VFXCubeTransformNormalWS(i,normalWS);
		normalWS = normalize(normalWS);

		VFXComputePixelOutputToGBuffer(i,normalWS,uvData,outGBuffer);

	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassGBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif
	#pragma target 4.5

	struct ps_input
	{
		float4 pos : SV_POSITION;
		float3 offsets : TEXCOORD0;

		#if VFX_USE_ALPHA_CURRENT || USE_ALPHA_TEST
		// x: alpha
		// y: alpha threshold
		nointerpolation float2 builtInInterpolants : TEXCOORD1;
		#endif

		nointerpolation uint faceID : TEXCOORD2;

		UNITY_VERTEX_OUTPUT_STEREO

        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#if USE_ALPHA_TEST
#define VFX_VARYING_ALPHA builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#endif
#define VFX_VARYING_OFFSETS offsets
#define VFX_VARYING_FACEID faceID

${VFXBegin:VFXVertexAdditionalProcess}${VFXEnd}

    ${VFXPassShadowDefine}

	${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}

	#pragma fragment frag
	float frag(ps_input i) : SV_Target0
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		float alpha = VFXGetFragmentColor(i).a;
#if HDRP_USE_BASE_COLOR_MAP_ALPHA
		alpha *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(baseColorMap),i,VFXCubeGetUV(i)).a;
#endif
		VFXClipFragmentColor(alpha,i);
		return 0;
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Hexahedron\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDepth.template---------------
.
.
Pass
{
    Name "DepthOnly"
	Tags { "LightMode"="DepthOnly" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#pragma multi_compile _ WRITE_NORMAL_BUFFER
    #pragma multi_compile _ WRITE_DECAL_BUFFER
	#pragma multi_compile _ WRITE_MSAA_DEPTH
	${VFXIncludeRP("Templates/Mesh/PassDepthOrMV.template")}


	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDepthForwardOnly.template---------------
.
.
Pass
{
	Name "DepthForwardOnly"
	Tags { "LightMode"="DepthForwardOnly" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#pragma multi_compile _ WRITE_NORMAL_BUFFER
    #pragma multi_compile _ WRITE_DECAL_BUFFER
    #pragma multi_compile _ WRITE_MSAA_DEPTH
	${VFXIncludeRP("Templates/Mesh/PassDepthOrMV.template")}


	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDepthForwardOnly.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDepthOrMV.template---------------
.
.

#pragma target 4.5
#define UNITY_MATERIAL_LIT

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD0;
	#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD0;
		#else
		float2 uv : TEXCOORD0;
		#endif
	#endif
    #if VFX_SHADERGRAPH_HAS_UV1
    float4 uv1 : COLOR2;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV2
    float4 uv2 : COLOR3;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV3
    float4 uv3 : COLOR4;
    #endif
    #if VFX_SHADERGRAPH_HAS_COLOR
    float4 vertexColor : COLOR1;
    #endif
	#if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
	// x: alpha threshold
	// y: frame blending factor
	// z: alpha
	// w: smoothness
	nointerpolation float4 builtInInterpolants : TEXCOORD1;
	#endif
	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vector scale u
	// y: motion vector scale v
	nointerpolation float2 builtInInterpolants2 : TEXCOORD3;
	#endif
	#if defined(WRITE_NORMAL_BUFFER) || SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY
	float3 normal : TEXCOORD4;
	#if SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
	float4 tangent : TEXCOORD5;
	#endif
	#endif
	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD6;
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
	#endif

    #if VFX_SIX_WAY_USE_ALPHA_REMAP
    nointerpolation float4 alphaRemap : TEXCOORD9;
    #endif

    ${VFXAdditionalInterpolantsDeclaration}


	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.z
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if defined(WRITE_NORMAL_BUFFER) || SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY
#define VFX_VARYING_NORMAL normal
#endif
#ifdef WRITE_NORMAL_BUFFER
#define VFX_VARYING_SMOOTHNESS builtInInterpolants.w
#endif
#if SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
#define VFX_VARYING_TANGENT tangent
#endif
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif

#if VFX_SIX_WAY_USE_ALPHA_REMAP
     #define VFX_VARYING_ALPHA_REMAP alphaRemap
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}

${VFXInclude("Shaders/ParticleMeshes/Pass.template")}
${VFXPassDepthCommonFragmentLit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDistortion.template---------------
.
.
// Distortion pass
Pass
{
	Tags { "LightMode"="DistortionVectors" }

    ${VFXStencilDistortionVectors}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}

	#define USE_NORMAL_MAP DISTORTION_NORMALBASED

	struct ps_input
	{
		float4 pos : SV_POSITION;
		#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD0;
		#else
			#if USE_FLIPBOOK_ARRAY_LAYOUT
			float3 uv : TEXCOORD0;
			#else
			float2 uv : TEXCOORD0;
			#endif
		#endif

		#if USE_SOFT_PARTICLE || VFX_USE_ALPHA_CURRENT || USE_FLIPBOOK_INTERPOLATION
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: frame blending factor
		// w: alpha
		nointerpolation float4 builtInInterpolants : TEXCOORD1;
		#endif

		#if USE_FLIPBOOK_MOTIONVECTORS
		// x: motion vector scale u
		// y: motion vector scale v
		nointerpolation float2 builtInInterpolants2 : TEXCOORD2;
		#endif

		// x: horizontal value / normal scale
		// y: vertical value
		// z: blur scale
		nointerpolation float3 distortionInterpolants : TEXCOORD3;

		#if USE_SOFT_PARTICLE
		float4 projPos : TEXCOORD4;
		#endif

		#if DISTORTION_NORMALBASED
		float3 normal : TEXCOORD5;
		float4 tangent : TEXCOORD6;
		#endif

		UNITY_VERTEX_OUTPUT_STEREO

        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

	struct ps_output
	{
		float4 distortion : SV_Target0;
	};

	#define VFX_VARYING_PS_INPUTS ps_input
	#define VFX_VARYING_POSCS pos
	#define VFX_VARYING_POSSS projPos
	#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
	#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
	#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
	#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
	#define VFX_VARYING_ALPHA builtInInterpolants.w
#if DISTORTION_NORMALBASED
	#define VFX_VARYING_NORMAL normal
	#define VFX_VARYING_TANGENT tangent
#endif
	#define VFX_VARYING_UV uv

	${VFXIncludeRP("VFXDistortion.template")}

	${VFXBegin:VFXVertexAdditionalProcess}

	${VFXVertexDistortionProcess}

	${VFXEnd}

	${VFXInclude("Shaders/ParticleMeshes/Pass.template")}

	#pragma fragment frag
	ps_output frag(ps_input i)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		ps_output o = (ps_output)0;
		VFXTransformPSInputs(i);

		${VFXFragmentDistortionProcess}
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassDistortion.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassForward.template---------------
.
.
Pass
{
    Name "${VFXHDRPForwardPassName}"
	Tags { "LightMode"="${VFXHDRPForwardPassName}"}

    ${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5

	#define UNITY_MATERIAL_LIT
	${VFXHDRPForwardDefines}
	#pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST
	#pragma multi_compile_fragment PUNCTUAL_SHADOW_LOW PUNCTUAL_SHADOW_MEDIUM PUNCTUAL_SHADOW_HIGH
	#pragma multi_compile_fragment DIRECTIONAL_SHADOW_LOW DIRECTIONAL_SHADOW_MEDIUM DIRECTIONAL_SHADOW_HIGH
	#pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH
    #if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
    #pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
    #else
    #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
    #endif
	#pragma multi_compile _ DEBUG_DISPLAY
	//#pragma enable_d3d11_debug_symbols

	${VFXIncludeRP("VFXLitVaryings.template")}
    ${VFXIncludeRP("VFXVertexProbeSampling.template"),VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}
	struct ps_input
	{
		float4 pos : SV_POSITION;

		${VFXHDRPLitDeclareVaryings}

		#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD1;
		#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD1;
		#else
		float2 uv : TEXCOORD1;
		#endif
		#endif
        #if VFX_SHADERGRAPH_HAS_UV1
        float4 uv1 : COLOR2;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV2
        float4 uv2 : COLOR3;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV3
        float4 uv3 : COLOR4;
        #endif
        #if VFX_SHADERGRAPH_HAS_COLOR
        float4 vertexColor : COLOR1;
        #endif
		float3 normal : TEXCOORD2;
		#if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
		float4 tangent : TEXCOORD3;
		#endif
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_FEATURE_MOTION_VECTORS_FORWARD
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: frame blending factor
		nointerpolation float3 builtInInterpolants : TEXCOORD4;
		#endif

		#if USE_FLIPBOOK_MOTIONVECTORS
		// x: motion vector scale u
		// y: motion vector scale v
		nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
		#endif

		#if VFX_FEATURE_MOTION_VECTORS_FORWARD
		VFX_DECLARE_MOTION_VECTORS_STORAGE(6,7)
		#endif

		float3 posWS : TEXCOORD8; // Needed for fog

        ${VFXAdditionalInterpolantsDeclaration}

		UNITY_VERTEX_OUTPUT_STEREO
	};

	struct ps_output
	{
		float4 color : SV_Target0;
	};

${VFXHDRPLitVaryingsMacros}
#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
${VFXVertexProbeVaryingsMacros}
#endif

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_NORMAL normal
#if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
#define VFX_VARYING_TANGENT tangent
#endif
#define VFX_VARYING_POSWS posWS

#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXVertexProbeDeclareFunctions}

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXVertexProbeFillVaryings}
${VFXEnd}

	${VFXInclude("Shaders/ParticleMeshes/Pass.template")}
	#define SHADERPASS SHADERPASS_FORWARD
	${VFXIncludeRP("VFXLit.template")}

    ${SHADERGRAPH_PIXEL_CODE_FORWARD}

	#pragma fragment frag
	void frag(ps_input i
	, out float4 outColor : SV_Target0
#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
#endif
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	, out float4 outMotionVector : SV_Target1
#endif
	)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		VFX_FRAG_SETUP_INSTANCE_ID(i);

		${VFXComputeNormalWS}

        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_FORWARD}

            ${VFXIncludeRP("VFXSGSurfaceData.template")}
            outColor = VFXGetPixelOutputForwardShaderGraph(i, surface, builtinEmissiveColor, builtinOpacity);
        #else
            #if USE_DOUBLE_SIDED
            outColor = VFXGetPixelOutputForward(i,normalWS,uvData, frontFace);
            #else
            outColor = VFXGetPixelOutputForward(i,normalWS,uvData, true);
            #endif
        #endif

		#if VFX_FEATURE_MOTION_VECTORS_FORWARD
			${VFXComputeOutputMotionVector}
			outMotionVector = encodedMotionVector;
			outMotionVector.a = outColor.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
		#endif
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassFullScreenDebug.template---------------
.
.
Pass
{
    Name "FullScreenDebug"
    Tags{ "LightMode" = "FullScreenDebug" }
    
        
    HLSLPROGRAM
    #pragma target 4.5
    #define DEBUG_DISPLAY
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl"
    
    struct ps_input
    {
        float4 pos : SV_POSITION;

        #if VFX_SHADERGRAPH_HAS_UV1
        float4 uv1 : TEXCOORD1;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV2
        float4 uv2 : TEXCOORD2;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV3
        float4 uv3 : TEXCOORD3;
        #endif
        #if VFX_SHADERGRAPH_HAS_COLOR
        float4 vertexColor : COLOR;
        #endif

        ${VFXAdditionalInterpolantsDeclaration}

        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };
    
    #define VFX_VARYING_PS_INPUTS ps_input
    #define VFX_VARYING_POSCS pos

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXPassFullScreenDebugCommonVertex}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticleMeshes/Pass.template")}

    ${VFXPassFullScreenDebugCommonFragment}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassFullScreenDebug.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassGBuffer.template---------------
.
.
Pass
{
    Name "GBuffer"
	Tags { "LightMode"="GBuffer" }
	
    ${VFXStencilGBuffer}
		
	HLSLPROGRAM
	#pragma target 4.5
	
	#pragma multi_compile _ RENDERING_LAYERS
	#pragma multi_compile _ DEBUG_DISPLAY
    #pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2

	#define UNITY_MATERIAL_LIT
	
	${VFXIncludeRP("VFXLitVaryings.template")}	
	
	struct ps_input
	{
		float4 pos : SV_POSITION;
		
		${VFXHDRPLitDeclareVaryings}
		
		#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD1;
		#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD1;
		#else
		float2 uv : TEXCOORD1;	
		#endif	
		#endif
        #if VFX_SHADERGRAPH_HAS_UV1
        float4 uv1 : COLOR2;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV2
        float4 uv2 : COLOR3;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV3
        float4 uv3 : COLOR4;
        #endif
        #if VFX_SHADERGRAPH_HAS_COLOR
        float4 vertexColor : COLOR1;
        #endif
		float3 normal : TEXCOORD2;
		#if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
		float4 tangent : TEXCOORD3;
		#endif
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: frame blending factor
		nointerpolation float3 builtInInterpolants : TEXCOORD4;
		#endif
		#if USE_FLIPBOOK_MOTIONVECTORS
		// x: motion vector scale u
		// y: motion vector scale v
		nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
		#endif
        
#if VFX_NEEDS_POSWS_INTERPOLATOR
		float3 posWS : TEXCOORD6;
#endif

        ${VFXAdditionalInterpolantsDeclaration}
    
		UNITY_VERTEX_OUTPUT_STEREO
	};
	
	struct ps_output
	{
		float4 color : SV_Target0;
	};

${VFXHDRPLitVaryingsMacros}
	
#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_NORMAL normal

#if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
#define VFX_VARYING_TANGENT tangent
#endif
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}

	${VFXInclude("Shaders/ParticleMeshes/Pass.template")}	
	#define SHADERPASS SHADERPASS_GBUFFER	
	${VFXIncludeRP("VFXLit.template")}
		
	${SHADERGRAPH_PIXEL_CODE_GBUFFER}
    
	#pragma fragment frag
	void frag(ps_input i, OUTPUT_GBUFFER(outGBuffer)
#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
#endif
	)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		VFX_FRAG_SETUP_INSTANCE_ID(i);
		${VFXComputeNormalWS}
        
        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_GBUFFER}

            ${VFXIncludeRP("VFXSGSurfaceData.template")}

            BuiltinData builtin;
            VFXSetupBuiltinForGBuffer(i, surface, builtinEmissiveColor, builtinOpacity, builtin);
            ENCODE_INTO_GBUFFER(surface, builtin, i.VFX_VARYING_POSCS.xy, outGBuffer);
        #else
            VFXComputePixelOutputToGBuffer(i,normalWS,uvData,outGBuffer);
        #endif
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassGBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassSelection.template---------------
.
.
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXIncludeRP("Templates/Mesh/PassDepthOrMV.template")}

	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXIncludeRP("Templates/Mesh/PassDepthOrMV.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SHADOW
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif
	${VFXIncludeRP("Templates/Mesh/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassVelocity.template---------------
.
.
Pass
{
    Name "MotionVectors"
	Tags { "LightMode"="MotionVectors" }
	
	${VFXStencilMotionVector}

	ZWrite On
	Blend Off
	
	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	#pragma multi_compile _ WRITE_NORMAL_BUFFER
    #pragma multi_compile _ WRITE_DECAL_BUFFER
	#pragma multi_compile _ WRITE_MSAA_DEPTH
	${VFXIncludeRP("Templates/Mesh/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Mesh\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\ParticleLines\PassFullScreenDebug.template---------------
.
.
Pass
{
    Name "FullScreenDebug"
    Tags{ "LightMode" = "FullScreenDebug" }
    
    HLSLPROGRAM
    #pragma target 4.5
    #define DEBUG_DISPLAY
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl"
    
    struct ps_input
    {
        float4 pos : SV_POSITION;
        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };
    
    #define VFX_VARYING_PS_INPUTS ps_input
    #define VFX_VARYING_POSCS pos

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXPassFullScreenDebugCommonVertex}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticleLines/Pass.template")}

    ${VFXPassFullScreenDebugCommonFragment}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\ParticleLines\PassFullScreenDebug.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\ParticleLinesSW\PassFullScreenDebug.template---------------
.
.
Pass
{
    Name "FullScreenDebug"
    Tags{ "LightMode" = "FullScreenDebug" }
    
    HLSLPROGRAM
    #pragma target 4.5
    #define DEBUG_DISPLAY
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl"
    
    struct ps_input
    {
        float4 pos : SV_POSITION;
        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };
    
    #define VFX_VARYING_PS_INPUTS ps_input
    #define VFX_VARYING_POSCS pos

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXPassFullScreenDebugCommonVertex}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticleLinesSW/Pass.template")}

    ${VFXPassFullScreenDebugCommonFragment}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\ParticleLinesSW\PassFullScreenDebug.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\ParticlePoints\PassFullScreenDebug.template---------------
.
.
Pass
{
    Name "FullScreenDebug"
    Tags{ "LightMode" = "FullScreenDebug" }
    
    HLSLPROGRAM
    #pragma target 4.5
    #define DEBUG_DISPLAY
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl"
    
    struct ps_input
    {
        float4 pos : SV_POSITION;
        float pointSize : PSIZE;
        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };
    
    #define VFX_VARYING_PS_INPUTS ps_input
    #define VFX_VARYING_POSCS pos

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXPassFullScreenDebugCommonVertex}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticlePoints/Pass.template")}

    ${VFXPassFullScreenDebugCommonFragment}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\ParticlePoints\PassFullScreenDebug.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDepth.template---------------
.
.
Pass
{
    Name "DepthOnly"
	Tags { "LightMode"="DepthOnly" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#pragma multi_compile _ WRITE_NORMAL_BUFFER
	#pragma multi_compile _ WRITE_MSAA_DEPTH
	${VFXIncludeRP("Templates/PlanarPrimitive/PassDepthOrMV.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDepthForwardOnly.template---------------
.
.
Pass
{
    Name "DepthForwardOnly"
    Tags { "LightMode"="DepthForwardOnly" }

    ZWrite On
    Blend Off

    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
    #pragma multi_compile _ WRITE_NORMAL_BUFFER
    #pragma multi_compile _ WRITE_MSAA_DEPTH
    ${VFXIncludeRP("Templates/PlanarPrimitive/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDepthForwardOnly.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDepthOrMV.template---------------
.
.
#pragma target 4.5
#define UNITY_MATERIAL_LIT

#define NEEDS_NORMAL	defined(WRITE_NORMAL_BUFFER) || defined(WRITE_DECAL_BUFFER) || FORCE_NORMAL_VARYING || SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY
#define NEEDS_TANGENT	USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
#define NEEDS_WORLDPOS	VFX_NEEDS_POSWS_INTERPOLATOR

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_FLIPBOOK_INTERPOLATION
	float4 uv : TEXCOORD0;
	#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD0;
		#else
		float2 uv : TEXCOORD0;
		#endif
	#endif
	#if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
	// x: alpha threshold
	// y: frame blending factor
	// z: alpha
	// w: smoothness
	VFX_OPTIONAL_INTERPOLATION float4 builtInInterpolants : TEXCOORD1;
	#endif

	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vector scale u
	// y: motion vector scale v
	VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD2;
	#endif

	#if NEEDS_NORMAL
	float4 normal : TEXCOORD3; // normal scale is stored in w
	#endif
	#if NEEDS_TANGENT
	float3 tangent : TEXCOORD4;
	#endif
	#if USE_NORMAL_BENDING
	float2 bentFactors : TEXCOORD5;
	#endif
	#if NEEDS_WORLDPOS
	float3 posWS : TEXCOORD6;
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
	#endif

    #if VFX_SIX_WAY_USE_ALPHA_REMAP
    nointerpolation float4 alphaRemap : TEXCOORD9;
    #endif

    ${VFXAdditionalInterpolantsDeclaration}

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX

};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.z
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv

#if NEEDS_NORMAL
#define VFX_VARYING_NORMAL normal.xyz
#endif
#ifdef WRITE_NORMAL_BUFFER
#define VFX_VARYING_SMOOTHNESS builtInInterpolants.w
#endif
#if NEEDS_TANGENT
#define VFX_VARYING_TANGENT tangent
#endif
#if NEEDS_WORLDPOS
#define VFX_VARYING_POSWS posWS
#endif
#if USE_NORMAL_MAP
#define VFX_VARYING_NORMALSCALE normal.w
#endif
#if USE_NORMAL_BENDING
#define VFX_VARYING_BENTFACTORS bentFactors
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if VFX_SIX_WAY_USE_ALPHA_REMAP
    #define VFX_VARYING_ALPHA_REMAP alphaRemap
#endif


${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}

${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
${VFXPassDepthCommonFragmentLit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDistortion.template---------------
.
.
// Distortion pass
Pass
{
	Tags { "LightMode"="DistortionVectors" }

    ${VFXStencilDistortionVectors}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}

	#define USE_NORMAL_MAP DISTORTION_NORMALBASED

	struct ps_input
	{
		float4 pos : SV_POSITION;
		#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD0;
		#else
			#if USE_FLIPBOOK_ARRAY_LAYOUT
			float3 uv : TEXCOORD0;
			#else
			float2 uv : TEXCOORD0;
			#endif
		#endif

		#if USE_SOFT_PARTICLE || VFX_USE_ALPHA_CURRENT || USE_FLIPBOOK_INTERPOLATION
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: frame blending factor
		// w: alpha
		VFX_OPTIONAL_INTERPOLATION float4 builtInInterpolants : TEXCOORD1;
		#endif

		#if USE_FLIPBOOK_MOTIONVECTORS
		// x: motion vector scale u
		// y: motion vector scale v
		VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD2;
		#endif

		// x: horizontal value / normal scale
		// y: vertical value
		// z: blur scale
		VFX_OPTIONAL_INTERPOLATION float3 distortionInterpolants : TEXCOORD3;

		#if USE_SOFT_PARTICLE
		float4 projPos : TEXCOORD4;
		#endif

		#if DISTORTION_NORMALBASED
		float3 normal : TEXCOORD5;
		float3 tangent : TEXCOORD6;
		#endif

		UNITY_VERTEX_OUTPUT_STEREO

        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

	struct ps_output
	{
		float4 distortion : SV_Target0;
	};

	#define VFX_VARYING_PS_INPUTS ps_input
	#define VFX_VARYING_POSCS pos
	#define VFX_VARYING_POSSS projPos
	#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
	#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
	#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
    #define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
	#define VFX_VARYING_ALPHA builtInInterpolants.w
#if DISTORTION_NORMALBASED
	#define VFX_VARYING_NORMAL normal
	#define VFX_VARYING_TANGENT tangent
#endif
	#define VFX_VARYING_UV uv

	${VFXIncludeRP("VFXDistortion.template")}

	${VFXBegin:VFXVertexAdditionalProcess}

	${VFXVertexDistortionProcess}

	${VFXEnd}

	${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}

	#pragma fragment frag
	ps_output frag(ps_input i)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		ps_output o = (ps_output)0;

		${VFXFragmentDistortionProcess}
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassDistortion.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name "${VFXHDRPForwardPassName}"
	Tags { "LightMode"="${VFXHDRPForwardPassName}"}

    ${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5

	#define UNITY_MATERIAL_LIT
	${VFXHDRPForwardDefines}
	#pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST
	#pragma multi_compile_fragment PUNCTUAL_SHADOW_LOW PUNCTUAL_SHADOW_MEDIUM PUNCTUAL_SHADOW_HIGH
	#pragma multi_compile_fragment DIRECTIONAL_SHADOW_LOW DIRECTIONAL_SHADOW_MEDIUM DIRECTIONAL_SHADOW_HIGH
	#pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH
    #if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
    #pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
    #else
    #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
    #endif
	#pragma multi_compile _ DEBUG_DISPLAY
	//#pragma enable_d3d11_debug_symbols

	${VFXIncludeRP("VFXLitVaryings.template")}
	${VFXIncludeRP("VFXVertexProbeSampling.template"),VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}

	struct ps_input
	{
		float4 pos : SV_POSITION;

		${VFXHDRPLitDeclareVaryings}

		#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD1;
		#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD1;
		#else
		float2 uv : TEXCOORD1;
		#endif
		#endif
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_FEATURE_MOTION_VECTORS_FORWARD || (VFX_MATERIAL_TYPE_SIX_WAY_SMOKE && VFX_SIX_WAY_USE_ONE_EMISSIVE_CHANNEL)
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: frame blending factor
        // w: emissive multiplier
		VFX_OPTIONAL_INTERPOLATION float4 builtInInterpolants : TEXCOORD2;
		#endif

		#if USE_FLIPBOOK_MOTIONVECTORS
		// x: motion vector scale u
		// y: motion vector scale v
		VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD3;
		#endif

		VFX_OPTIONAL_INTERPOLATION float3 normal : TEXCOORD4;
		#if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
		VFX_OPTIONAL_INTERPOLATION float3 tangent : TEXCOORD5;
		#endif
		#if USE_NORMAL_BENDING
		float2 bentFactors : TEXCOORD6;
		#endif

		#if VFX_FEATURE_MOTION_VECTORS_FORWARD
		VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
		#endif

		float3 posWS : TEXCOORD9; // Needed for fog

        ${VFXAdditionalInterpolantsDeclaration}

		UNITY_VERTEX_OUTPUT_STEREO
	};

${VFXHDRPLitVaryingsMacros}

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
${VFXVertexProbeVaryingsMacros}
#endif

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv
#define VFX_VARYING_NORMAL normal
#if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
#define VFX_VARYING_TANGENT tangent
#endif
#if USE_NORMAL_BENDING
#define VFX_VARYING_BENTFACTORS bentFactors
#endif
#define VFX_VARYING_POSWS posWS

#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXVertexProbeDeclareFunctions}

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXVertexProbeFillVaryings}
${VFXEnd}


	${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
	#define SHADERPASS SHADERPASS_FORWARD
	${VFXIncludeRP("VFXLit.template")}

    ${SHADERGRAPH_PIXEL_CODE_FORWARD}

	#pragma fragment frag
	void frag(ps_input i
	, out float4 outColor : SV_Target0
	#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
	#endif
	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	, out float4 outMotionVector : SV_Target1
	#endif
	)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		VFX_FRAG_SETUP_INSTANCE_ID(i);

		${VFXComputeNormalWS}

        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_FORWARD}

            ${VFXIncludeRP("VFXSGSurfaceData.template")}
            outColor = VFXGetPixelOutputForwardShaderGraph(i, surface, builtinEmissiveColor, builtinOpacity);
        #else
            #if USE_DOUBLE_SIDED
            outColor = VFXGetPixelOutputForward(i,normalWS,uvData, frontFace);
            #else
            outColor = VFXGetPixelOutputForward(i,normalWS,uvData, true);
            #endif
        #endif

        #if VFX_FEATURE_MOTION_VECTORS_FORWARD
            ${VFXComputeOutputMotionVector}
            outMotionVector = encodedMotionVector;
            outMotionVector.a = outColor.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
        #endif
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassFullScreenDebug.template---------------
.
.
Pass
{
    Name "FullScreenDebug"
    Tags{ "LightMode" = "FullScreenDebug" }
    
    HLSLPROGRAM
    #pragma target 4.5
    #define DEBUG_DISPLAY
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl"
    
    struct ps_input
    {
        float4 pos : SV_POSITION;

        #if VFX_SHADERGRAPH_HAS_UV1
        float4 uv1 : TEXCOORD1;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV2
        float4 uv2 : TEXCOORD2;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV3
        float4 uv3 : TEXCOORD3;
        #endif
        #if VFX_SHADERGRAPH_HAS_COLOR
        float4 vertexColor : COLOR;
        #endif

        ${VFXAdditionalInterpolantsDeclaration}

        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };
    
    #define VFX_VARYING_PS_INPUTS ps_input
    #define VFX_VARYING_POSCS pos

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXPassFullScreenDebugCommonVertex}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}

    ${VFXPassFullScreenDebugCommonFragment}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassFullScreenDebug.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassGBuffer.template---------------
.
.
Pass
{
    Name "GBuffer"
	Tags { "LightMode"="GBuffer" }

    ${VFXStencilGBuffer}
		
	HLSLPROGRAM
	#pragma target 4.5
	
	#pragma multi_compile _ RENDERING_LAYERS
	#pragma multi_compile _ DEBUG_DISPLAY
    #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2

	#define UNITY_MATERIAL_LIT
		
	${VFXIncludeRP("VFXLitVaryings.template")}		
		
	struct ps_input
	{
		float4 pos : SV_POSITION;
		
		${VFXHDRPLitDeclareVaryings}
		
		#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD1;
		#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD1;
		#else
		float2 uv : TEXCOORD1;	
		#endif
		#endif
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: frame blending factor
		VFX_OPTIONAL_INTERPOLATION float3 builtInInterpolants : TEXCOORD2;
		#endif
		#if USE_FLIPBOOK_MOTIONVECTORS
		// x: motion vector scale u
		// y: motion vector scale v
		VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD3;
		#endif
		VFX_OPTIONAL_INTERPOLATION float3 normal : TEXCOORD4;
		#if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
		VFX_OPTIONAL_INTERPOLATION float3 tangent : TEXCOORD5;
		#endif
		#if USE_NORMAL_BENDING
		float2 bentFactors : TEXCOORD6;
		#endif
        #if VFX_NEEDS_POSWS_INTERPOLATOR
        float3 posWS : TEXCOORD7;
        #endif

        ${VFXAdditionalInterpolantsDeclaration}

		UNITY_VERTEX_OUTPUT_STEREO
	};
	
${VFXHDRPLitVaryingsMacros}		
	
#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv
#define VFX_VARYING_NORMAL normal
#if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
#define VFX_VARYING_TANGENT tangent
#endif
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_NORMAL_BENDING
#define VFX_VARYING_BENTFACTORS bentFactors
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}
	
	${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
	#define SHADERPASS SHADERPASS_GBUFFER
    ${VFXIncludeRP("VFXLit.template")}
			
    ${SHADERGRAPH_PIXEL_CODE_GBUFFER}
	#pragma fragment frag
	void frag(ps_input i, OUTPUT_GBUFFER(outGBuffer)
	#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
	#endif
	)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		VFX_FRAG_SETUP_INSTANCE_ID(i);

		${VFXComputeNormalWS}

        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_GBUFFER}
            ${VFXIncludeRP("VFXSGSurfaceData.template")}

            BuiltinData builtin;
            VFXSetupBuiltinForGBuffer(i, surface, builtinEmissiveColor, builtinOpacity, builtin);
            ENCODE_INTO_GBUFFER(surface, builtin, i.VFX_VARYING_POSCS.xy, outGBuffer);
        #else
            VFXComputePixelOutputToGBuffer(i,normalWS,uvData,outGBuffer);
        #endif
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassGBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassSelection.template---------------
.
.
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXIncludeRP("Templates/PlanarPrimitive/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXIncludeRP("Templates/PlanarPrimitive/PassDepthOrMV.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassShadowCaster.template---------------
.
.
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SHADOW
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif
	${VFXIncludeRP("Templates/PlanarPrimitive/PassDepthOrMV.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassVelocity.template---------------
.
.
Pass
{
    Name "MotionVectors"
	Tags { "LightMode"="MotionVectors" }

	${VFXStencilMotionVector}

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	#pragma multi_compile _ WRITE_NORMAL_BUFFER
	#pragma multi_compile _ WRITE_MSAA_DEPTH
	${VFXIncludeRP("Templates/PlanarPrimitive/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Common\IntersectionShader.template---------------
.
.
            [shader("intersection")]
            void IntersectionShader()
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                VFXAttributes attributes;
                ZERO_INITIALIZE(VFXAttributes, attributes);

                // Index needs to be available in the context for the attribute load to work
                ${VFXGetIndexFromRTPrimitiveIndex}
                ${VFXLoadGraphValues}

                // Load the VFX attributes that we need for this
                ${VFXLoadAttributes}
                ${VFXProcessBlocks}
                ${VFXLoadSizeRT}

                // Build the ray tracing procedural data
                RayTracingProceduralData rtProceduralData = BuildRayTracingProceduralData(attributes, size3);

                // Execute the matching intersection code
                IntersectPrimitive(rtProceduralData);
            }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Common\IntersectionShader.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Common\PassRayTracingDebug.template---------------
.
.

        Pass
        {
            Name "DebugDXR"
            Tags{ "LightMode" = "DebugDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma skip_variants INSTANCING_ON

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_DEBUG

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"

            // VFX includes
            ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/RayTracingInputStructure.template")}
            ${VFXPerPassInclude}
            ${VFXIncludeRP("VFXLit.template")}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/IntersectionFunctions.template")}

            // Material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

            ${VFXGeneratedBlockFunction}

            // Generic function that handles the reflection code
            [shader("closesthit")]
            void ClosestHitDebug(inout RayIntersectionDebug rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                rayIntersection.t = RayTCurrent();
                rayIntersection.barycentrics = attributeData.barycentrics;
                rayIntersection.primitiveIndex = PrimitiveIndex();
                rayIntersection.instanceIndex = InstanceIndex();
            }

            // Generic function that handles the reflection code
            [shader("anyhit")]
            void AnyHitDebug(inout RayIntersectionDebug rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Debug data
                rayIntersection.t = RayTCurrent();
                rayIntersection.barycentrics = attributeData.barycentrics;
                rayIntersection.primitiveIndex = PrimitiveIndex();
                rayIntersection.instanceIndex = InstanceIndex();
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Common\PassRayTracingDebug.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\DXRPasses.template---------------
.
.
SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }

		// Required passes by ray tracing
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/PassVisibilityDXRLit.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/PassIndirectDXRLit.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/PassGBufferDXRLit.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/PassForwardDXRLit.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/PassRayTracingDebug.template")}
	}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\DXRPasses.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\EvaluateMaterialData.template---------------
.
.
float4 GetScreenSpacePos(float3 posWS)
{
    float4 posSS = VFXTransformPositionWorldToClip(posWS);
    posSS.xyz /= posSS.w;
    posSS.xy = 0.5f * posSS.xy + 0.5;
    #if UNITY_UV_STARTS_AT_TOP
        posSS.y = 1.0 - posSS.y;
    #endif
    posSS.xy *= _ScreenSize.xy;
    return posSS;
}

void EvaluateLitMaterialData(in PositionInputs posInput, in AttributeData attributeData,
                            out SurfaceData surfaceData, out BuiltinData builtinData,
                            out BSDFData bsdfData, out PreLightData preLightData,
                            out float velocity)
{
    // Index needs to be available in the context for the attribute load to work
    ${VFXGetIndexFromRTPrimitiveIndex}
    ${VFXLoadGraphValues}

    // Attributes of the paticle
    VFXAttributes attributes;
    ZERO_INITIALIZE(VFXAttributes, attributes);

    // Load the VFX attributes that we need for this
    ${VFXLoadAttributes}
    ${VFXProcessBlocks}
    ${VFXLoadSize}

    // Build the "varying" input
    rt_input o;
    ZERO_INITIALIZE(rt_input, o);
    {
        // Fill the attributes
        ${VFXVertexCommonProcess}
        ${VFXHDRPLitFillVaryings}

        o.VFX_VARYING_UV.xy = attributeData.barycentrics;
        o.VFX_VARYING_POSCS = GetScreenSpacePos(posInput.positionWS);
        VFXTransformPSInputs(o);

        #ifdef VFX_VARYING_BENTFACTORS
            ${VFXLoadParameter:{normalBendingFactor}}
            #define BENT_FACTOR_MULTIPLIER 1.41421353816986083984375f
            o.VFX_VARYING_BENTFACTORS = (o.VFX_VARYING_UV.xy - 0.5f) * normalBendingFactor * BENT_FACTOR_MULTIPLIER;
        #endif

        ${VFXVertexSetFlipbooksInterpolants}
    }

    rt_input i = o;
    i.VFX_VARYING_NORMAL = normalize(-WorldToPrimitive(attributes, size3)[2].xyz);
    #ifdef VFX_VARYING_TANGENT
        i.VFX_VARYING_TANGENT = normalize(WorldToPrimitive(attributes, size3)[0].xyz);
    #endif

    bool frontFace = dot(WorldRayDirection(), i.VFX_VARYING_NORMAL) < 0;
    ${VFXComputeNormalWS}

    // Intialize the output values to zero
    surfaceData = (SurfaceData)0;
    builtinData = (BuiltinData)0;
    bsdfData = (BSDFData)0;
    preLightData = (PreLightData)0;

    // Evaluate the input data
    VFXGetHDRPLitData(surfaceData, builtinData, bsdfData, preLightData, i, normalWS, posInput, uvData, frontFace, 0);

    // Grab the current particle's AABB
    AABB particleAABB = FetchPrimitiveAABB(PrimitiveIndex(), VFX_AABB_COUNT, instanceIndex);
    float3 inputVertexPosition = 0.0;
    float3 currentOS = (particleAABB.maxPosOS + particleAABB.minPosOS) * 0.5;
    float3 currentWS = TransformObjectToWorld(currentOS);

    ${VFXVertexComputeDisplacement}
    velocity = displacement;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\EvaluateMaterialData.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\IntersectionFunctions.template---------------
.
.
            // Needs to be included after the VFX includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXRayTracingCommon.hlsl"
            // Visibility function required for the intersection shader
            bool AABBPrimitiveIsVisible(RayTracingProceduralData rtProceduralData, float2 uv)
            {
            #if VFX_USE_GRAPH_VALUES
                uint instanceActiveIndex = asuint(_InstanceActiveIndex);
                ${VFXLoadGraphValues}
            #endif
                VFXAttributes attributes = rtProceduralData.attributes;
            #if USE_FLIPBOOK
                ${VFXLoadParameter:{invFlipBookSize}}
                ${VFXLoadParameter:{flipBookSize}}
                #if USE_FLIPBOOK_INTERPOLATION
                    VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, uv, attributes.texIndex, attributes.texIndexBlend);
                #else
                    VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, uv, attributes.texIndex);
                #endif
                uv = uvData.uvs.xy;
            #endif
            #if HDRP_USE_BASE_COLOR_MAP && USE_ALPHA_TEST
                ${VFXLoadParameter:{alphaThreshold}}
                return attributes.alpha * SampleTexture(VFX_SAMPLER(baseColorMap), uv, 0).a > alphaThreshold;
            #else
                return true;
            #endif
            }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\IntersectionFunctions.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassForwardDXRLit.template---------------
.
.

        Pass
        {
            Name "ForwardDXR"
            Tags{ "LightMode" = "ForwardDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma skip_variants INSTANCING_ON

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_FORWARD

            // We are in a ray tracing pass, we can only support low shadows
            #define SHADOW_LOW

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"

            // VFX includes
            ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/RayTracingInputStructure.template")}
            ${VFXHDRPLitVaryingsMacros}
            ${VFXPerPassInclude}
            ${VFXIncludeRP("VFXLit.template")}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/IntersectionFunctions.template")}

            // Lighting and material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingLightLoop.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/AtmosphericScatteringRayTracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Forward/EvaluateRayTracingForward.hlsl"


            // Graph functions
            ${VFXGeneratedBlockFunction}

            // Include to evaluate the material data
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/EvaluateMaterialData.template")}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Evaluate the position
                float3 positionRWS = WorldRayOrigin() + rayIntersection.t * WorldRayDirection();

                // Evaluate the position input
                PositionInputs posInput = GetPositionInput(rayIntersection.pixelCoord, _ScreenSize.zw, positionRWS);

                // Output structures
                SurfaceData surfaceData = (SurfaceData)0;
                BuiltinData builtinData = (BuiltinData)0;
                BSDFData bsdfData = (BSDFData)0;
                PreLightData preLightData = (PreLightData)0;
                float velocity = 0.0f;

                // Evaluate all the required material data
                EvaluateLitMaterialData(posInput, attributeData, surfaceData, builtinData, bsdfData, preLightData, velocity);

                // Evaluate the view direction
                float3 viewWS = -WorldRayDirection();

                // Evaluate the forward lighting
                EvaluateForwardRayTracingLighting(preLightData, posInput, bsdfData, builtinData, surfaceData, viewWS, positionRWS, bsdfData.normalWS, true, rayIntersection);

                // Apply fog attenuation
                ApplyFogAttenuation(WorldRayOrigin(), WorldRayDirection(), rayIntersection.t, rayIntersection.color, true);
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassForwardDXRLit.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassGBufferDXRLit.template---------------
.
.

        Pass
        {
            Name "GBufferDXR"
            Tags{ "LightMode" = "GBufferDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma multi_compile _ MINIMAL_GBUFFER
            #pragma skip_variants INSTANCING_ON

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_GBUFFER

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Deferred/RaytracingIntersectonGBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/StandardLit/StandardLit.hlsl"

            // VFX includes
            ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/RayTracingInputStructure.template")}
            ${VFXHDRPLitVaryingsMacros}
            ${VFXPerPassInclude}
            ${VFXIncludeRP("VFXLit.template")}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/IntersectionFunctions.template")}

            // Lighting and material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"


            // Graph functions
            ${VFXGeneratedBlockFunction}

            // Include to evaluate the material data
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/EvaluateMaterialData.template")}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersectionGBuffer rayIntersectionGbuffer : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersectionGbuffer.t = RayTCurrent();

                // Evaluate the view direction
                float3 viewWS = -WorldRayDirection();

                // Evaluate the position
                float3 positionRWS = WorldRayOrigin() + rayIntersectionGbuffer.t * WorldRayDirection();

                // Evaluate the position input
                PositionInputs posInput = GetPositionInput(0, _ScreenSize.zw, positionRWS);

                // Output structures
                SurfaceData surfaceData = (SurfaceData)0;
                BuiltinData builtinData = (BuiltinData)0;
                BSDFData bsdfData = (BSDFData)0;
                PreLightData preLightData = (PreLightData)0;
                float velocity = 0.0f;

                // Evaluate all the required material data
                EvaluateLitMaterialData(posInput, attributeData, surfaceData, builtinData, bsdfData, preLightData, velocity);

                // First we pack the data into the standard bsdf data
                StandardBSDFData standardLitData;
                ZERO_INITIALIZE(StandardBSDFData, standardLitData);
                FitToStandardLit(bsdfData, builtinData, posInput.positionSS, standardLitData);

            #ifdef MINIMAL_GBUFFER
                // Override all the parameters that we do not require for our minimal lit version
                standardLitData.specularOcclusion = 1.0;
                standardLitData.normalWS = bsdfData.normalWS;
                standardLitData.coatMask = 0.0;
                standardLitData.emissiveAndBaked = builtinData.emissiveColor;
            #endif

                // Then export it to the gbuffer
                EncodeIntoStandardGBuffer(standardLitData, rayIntersectionGbuffer.gbuffer0, rayIntersectionGbuffer.gbuffer1, rayIntersectionGbuffer.gbuffer2, rayIntersectionGbuffer.gbuffer3);
                rayIntersectionGbuffer.t = standardLitData.isUnlit != 0 ? -RayTCurrent() : RayTCurrent();
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassGBufferDXRLit.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassIndirectDXRLit.template---------------
.
.

        Pass
        {
            Name "IndirectDXR"
            Tags{ "LightMode" = "IndirectDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma skip_variants INSTANCING_ON

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_INDIRECT

            // We are in a ray tracing pass, we can only support low shadows
            #define SHADOW_LOW

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"

            // VFX includes
            ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/RayTracingInputStructure.template")}
            ${VFXHDRPLitVaryingsMacros}
            ${VFXPerPassInclude}
            ${VFXIncludeRP("VFXLit.template")}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/IntersectionFunctions.template")}

            // Lighting and material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingLightLoop.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/AtmosphericScatteringRayTracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/EvaluateRayTracingIndirect.hlsl"

            // Graph functions
            ${VFXGeneratedBlockFunction}

            // Include to evaluate the material data
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/EvaluateMaterialData.template")}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Evaluate the view direction
                float3 viewWS = -WorldRayDirection();

                // Evaluate the position
                float3 positionRWS = WorldRayOrigin() + rayIntersection.t * WorldRayDirection();

                // Evaluate the position input
                PositionInputs posInput = GetPositionInput(rayIntersection.pixelCoord, _ScreenSize.zw, positionRWS);

                // Output structures
                SurfaceData surfaceData = (SurfaceData)0;
                BuiltinData builtinData = (BuiltinData)0;
                BSDFData bsdfData = (BSDFData)0;
                PreLightData preLightData = (PreLightData)0;
                float velocity = 0.0f;

                // Evaluate all the required material data
                EvaluateLitMaterialData(posInput, attributeData, surfaceData, builtinData, bsdfData, preLightData, velocity);

                // Evaluate the lighting
                EvaluateIndirectRayTracingLighting(preLightData, posInput, bsdfData, builtinData, viewWS, positionRWS, rayIntersection);

                // Apply fog attenuation
                ApplyFogAttenuation(WorldRayOrigin(), WorldRayDirection(), rayIntersection.t, rayIntersection.color, true);
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassIndirectDXRLit.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassVisibilityDXRLit.template---------------
.
.

        Pass
        {
            Name "VisibilityDXR"
            Tags{ "LightMode" = "VisibilityDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma multi_compile _ TRANSPARENT_COLOR_SHADOW
            #pragma skip_variants INSTANCING_ON

	        #if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	        #define USE_ALPHA_TEST 1
	        #endif

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_VISIBILITY

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"

            // VFX includes
	        ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/RayTracingInputStructure.template")}
            ${VFXPerPassInclude}
            ${VFXIncludeRP("VFXLit.template")}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/IntersectionFunctions.template")}

            // Material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

            ${VFXGeneratedBlockFunction}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersectionVisibility rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Index needs to be available in the context for the attribute load to work
                ${VFXGetIndexFromRTPrimitiveIndex}
                ${VFXLoadGraphValues}
                // Grab the current particle's AABB
                AABB particleAABB = FetchPrimitiveAABB(PrimitiveIndex(), VFX_AABB_COUNT, instanceIndex);
                float3 inputVertexPosition = 0.0;
                float3 currentOS = (particleAABB.maxPosOS + particleAABB.minPosOS) * 0.5;
                float3 currentWS = TransformObjectToWorld(currentOS);

                ${VFXVertexComputeDisplacement}
                rayIntersection.velocity = displacement;
            }

            // Include to evaluate the material data
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Lit/EvaluateMaterialData.template")}

            [shader("anyhit")]
            void AnyHitVisibility(inout RayIntersectionVisibility rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Evaluate the view direction
                float3 viewWS = -WorldRayDirection();

                // Evaluate the position
                float3 positionRWS = WorldRayOrigin() + rayIntersection.t * WorldRayDirection();

                // Evaluate the position input
                PositionInputs posInput = GetPositionInput(0, _ScreenSize.zw, positionRWS);

                // Output structures
                SurfaceData surfaceData = (SurfaceData)0;
                BuiltinData builtinData = (BuiltinData)0;
                BSDFData bsdfData = (BSDFData)0;
                PreLightData preLightData = (PreLightData)0;
                float velocity = 0.0f;

                // Evaluate all the required material data
                EvaluateLitMaterialData(posInput, attributeData, surfaceData, builtinData, bsdfData, preLightData, velocity);

            #if defined(TRANSPARENT_COLOR_SHADOW) && defined(_SURFACE_TYPE_TRANSPARENT)
                // Override the veloctity for this value
                rayIntersection.velocity = velocity;

                // Adjust the color based on the transmittance or opacity
                #if HAS_REFRACTION
                    rayIntersection.color *= lerp(surfaceData.transmittanceColor, float3(0.0, 0.0, 0.0), 1.0 - surfaceData.transmittanceMask);
                #else
                    rayIntersection.color *= (1.0 - builtinData.opacity);
                #endif

                // Ignore to move to the following intersections
                IgnoreHit();
            #else
                // If this fella is opaque, then we need to stop
                rayIntersection.color = float3(0.0, 0.0, 0.0);
                AcceptHitAndEndSearch();
            #endif
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\PassVisibilityDXRLit.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\RayTracingInputStructure.template---------------
.
.
    // Equivalent of the Pixel to Vertex structure
    struct rt_input
    {
        float4 pos;
        ${VFXHDRPLitDeclareVaryings}
		#if USE_FLIPBOOK_INTERPOLATION
		    float4 uv;
		#else
		    #if USE_FLIPBOOK_ARRAY_LAYOUT
		        float3 uv;
		    #else
		        float2 uv;
		    #endif
		#endif
		#if USE_SOFT_PARTICLE
		    VFX_OPTIONAL_INTERPOLATION float invSoftParticleFadeDistance;
		#endif
		#if USE_FLIPBOOK_MOTIONVECTORS
		    VFX_OPTIONAL_INTERPOLATION float2 mvScale;
		#endif
		VFX_OPTIONAL_INTERPOLATION float3 normal;
		#if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
		    VFX_OPTIONAL_INTERPOLATION float3 tangent;
		#endif
		#if USE_NORMAL_BENDING
		    float2 bentFactors;
		#endif
    };

    #define VFX_VARYING_PS_INPUTS rt_input
    #define VFX_VARYING_POSCS pos
    #define VFX_VARYING_UV uv
    #define VFX_VARYING_NORMAL normal
    #define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE invSoftParticleFadeDistance
    #define VFX_VARYING_MOTIONVECTORSCALE mvScale.xy
    #if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
        #define VFX_VARYING_TANGENT tangent
    #endif
    #if USE_NORMAL_BENDING
        #define VFX_VARYING_BENTFACTORS bentFactors
    #endif
	${VFXHDRPLitVaryingsMacros}


.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Lit\RayTracingInputStructure.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\CommonOutput.template---------------
.
.

${VFXBegin:VFXGetColorRT}
    #if USE_FLIPBOOK
        ${VFXLoadParameter:{invFlipBookSize}}
        ${VFXLoadParameter:{flipBookSize}}
        #if USE_FLIPBOOK_INTERPOLATION
            VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, uv, attributes.texIndex, attributes.texIndexBlend);
        #else
            VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, uv, attributes.texIndex);
        #endif
    #else
        VFXUVData uvData = GetUVData(attributeData.barycentrics);
    #endif

    float4 color = float4(attributes.color, attributes.alpha);
    #if VFX_COLORMAPPING_DEFAULT
	    color = color * SampleTexture(VFX_SAMPLER(mainTexture), uvData);
    #endif

    #if VFX_COLORMAPPING_GRADIENTMAPPED
	    ${VFXLoadParameter:{gradient}}
	    color = SampleGradient(gradient, SampleTexture(VFX_SAMPLER(mainTexture),uvData).a * color.a) * float4(color.rgb, 1.0);
    #endif

    #ifdef VFX_VARYING_EXPOSUREWEIGHT
        ${VFXLoadParameter:{exposureWeight}}
        color = VFXApplyPreExposure(color, exposureWeight);
    #elif VFX_BYPASS_EXPOSURE
        color = VFXApplyPreExposure(color, 0.0f);
    #else
        color = VFXApplyPreExposure(color, 1.0f);
    #endif

${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\CommonOutput.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\DXRPasses.template---------------
.
.
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }

		// Required passes by ray tracing
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/PassVisibilityDXR.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/PassIndirectDXR.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/PassGBufferDXR.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/PassForwardDXR.template")}
		${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/PassRayTracingDebug.template")}
	}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\DXRPasses.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\EvaluateMaterialData.template---------------
.
.
void EvaluateUnlitMaterialData(in AttributeData attributeData, out float4 outColor, out float velocity)
{
    VFXAttributes attributes;
    ZERO_INITIALIZE(VFXAttributes, attributes);

    // Index needs to be available in the context for the attribute load to work
    ${VFXGetIndexFromRTPrimitiveIndex}
    ${VFXLoadGraphValues}
    // Load the VFX attributes that we need for this
    ${VFXLoadAttributes}
    ${VFXProcessBlocks}
    ${VFXGetColorRT}

    // Return the color
    outColor = color;

    // Grab the current particle's AABB
    AABB particleAABB = FetchPrimitiveAABB(PrimitiveIndex(),  VFX_AABB_COUNT, instanceIndex);
    float3 inputVertexPosition = 0.0;
    float3 currentOS = (particleAABB.maxPosOS + particleAABB.minPosOS) * 0.5;
    float3 currentWS = TransformObjectToWorld(currentOS);

    ${VFXVertexComputeDisplacement}
    velocity = displacement;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\EvaluateMaterialData.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\IntersectionFunctions.template---------------
.
.
            // Needs to be included after the VFX includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXRayTracingCommon.hlsl"
            // Visibility function required for the intersection shader
            bool AABBPrimitiveIsVisible(RayTracingProceduralData rtProceduralData, float2 uv)
            {
            #if VFX_USE_GRAPH_VALUES
                uint instanceActiveIndex = asuint(_InstanceActiveIndex);
                ${VFXLoadGraphValues}
            #endif
                VFXAttributes attributes = rtProceduralData.attributes;
            #if USE_FLIPBOOK
                ${VFXLoadParameter:{invFlipBookSize}}
                ${VFXLoadParameter:{flipBookSize}}
                #if USE_FLIPBOOK_INTERPOLATION
                    VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, uv, attributes.texIndex, attributes.texIndexBlend);
                #else
                    VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, uv, attributes.texIndex);
                #endif
                uv = uvData.uvs.xy;
            #endif
            #if USE_ALPHA_TEST
                ${VFXLoadParameter:{alphaThreshold}}
                return attributes.alpha * SampleTexture(VFX_SAMPLER(mainTexture), uv, 0).a > alphaThreshold;
            #else
                return true;
            #endif
            }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\IntersectionFunctions.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassForwardDXR.template---------------
.
.

        Pass
        {
            Name "ForwardDXR"
            Tags{ "LightMode" = "ForwardDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma skip_variants INSTANCING_ON

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_FORWARD

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"

            // VFX includes
            ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/RayTracingInputStructure.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/CommonOutput.template")}
            ${VFXPerPassInclude}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/IntersectionFunctions.template")}

            // Material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/AtmosphericScatteringRayTracing.hlsl"

            // Graph functions
            ${VFXGeneratedBlockFunction}

            // Include to evaluate the material data
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/EvaluateMaterialData.template")}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Read the material data
                float4 color = 0.0;
                float velocity = 0.0;
                EvaluateUnlitMaterialData(attributeData, color, velocity);

                // Given that we will be multiplying the final color by the current exposure multiplier outside of this function, we need to make sure that
                // the unlit color is not impacted by that. Thus, we multiply it by the inverse of the current exposure multiplier.
                rayIntersection.color = color * GetInverseCurrentExposureMultiplier();

                // Apply fog attenuation
                ApplyFogAttenuation(WorldRayOrigin(), WorldRayDirection(), rayIntersection.t, rayIntersection.color, true);
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassForwardDXR.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassGBufferDXR.template---------------
.
.

        Pass
        {
            Name "GBufferDXR"
            Tags{ "LightMode" = "GBufferDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma skip_variants INSTANCING_ON

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_GBUFFER

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Deferred/RaytracingIntersectonGBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/StandardLit/StandardLit.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/AtmosphericScatteringRayTracing.hlsl"

            // VFX includes
            ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/RayTracingInputStructure.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/CommonOutput.template")}

            ${VFXPerPassInclude}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/IntersectionFunctions.template")}

            // Lighting and material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"

            // Graph functions
            ${VFXGeneratedBlockFunction}

            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/EvaluateMaterialData.template")}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersectionGBuffer rayIntersectionGbuffer : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersectionGbuffer.t = RayTCurrent();

                // Read the material data
                float4 color = 0.0;
                float velocity = 0.0;
                EvaluateUnlitMaterialData(attributeData, color, velocity);

                // First we pack the data into the standard bsdf data
                StandardBSDFData standardLitData;
                ZERO_INITIALIZE(StandardBSDFData, standardLitData);

                // Output is not to be lit
                // The inverse current exposure multiplier needs to only be applied to the color as it need to be brought to the current exposure value, the emissive
                // color is already in the right exposure space.
                standardLitData.emissiveAndBaked = color * GetInverseCurrentExposureMultiplier();
                standardLitData.isUnlit = 1;

                // Be cause this will not be lit, we need to apply atmospheric scattering right away
                ApplyFogAttenuation(WorldRayOrigin(), WorldRayDirection(), RayTCurrent(), standardLitData.emissiveAndBaked, true);

                // Then export it to the gbuffer
                EncodeIntoStandardGBuffer(standardLitData, rayIntersectionGbuffer.gbuffer0, rayIntersectionGbuffer.gbuffer1, rayIntersectionGbuffer.gbuffer2, rayIntersectionGbuffer.gbuffer3);
                rayIntersectionGbuffer.t = -RayTCurrent();
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassGBufferDXR.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassIndirectDXR.template---------------
.
.

        Pass
        {
            Name "IndirectDXR"
            Tags{ "LightMode" = "IndirectDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma skip_variants INSTANCING_ON

            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_INDIRECT

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"

            // VFX includes
            ${VFXIncludeRP("VFXLitVaryings.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/RayTracingInputStructure.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/CommonOutput.template")}
            ${VFXPerPassInclude}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/IntersectionFunctions.template")}

            // Material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/AtmosphericScatteringRayTracing.hlsl"

            // Graph functions
            ${VFXGeneratedBlockFunction}

            // Include to evaluate the material data
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/EvaluateMaterialData.template")}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Read the material data
                float4 color = 0.0;
                float velocity = 0.0;
                EvaluateUnlitMaterialData(attributeData, color, velocity);

                // Given that we will be multiplying the final color by the current exposure multiplier outside of this function, we need to make sure that
                // the unlit color is not impacted by that. Thus, we multiply it by the inverse of the current exposure multiplier.
                rayIntersection.color = color * GetInverseCurrentExposureMultiplier();

                // Apply fog attenuation
                ApplyFogAttenuation(WorldRayOrigin(), WorldRayDirection(), rayIntersection.t, rayIntersection.color, true);
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassIndirectDXR.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassVisibilityDXR.template---------------
.
.

        Pass
        {
            Name "VisibilityDXR"
            Tags{ "LightMode" = "VisibilityDXR" }

            HLSLPROGRAM
            #pragma target 4.5
            #pragma only_renderers d3d11 xboxseries ps5
            #pragma raytracing surface_shader
            #pragma multi_compile _ TRANSPARENT_COLOR_SHADOW
            #pragma skip_variants INSTANCING_ON


            // Global includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

            // Define the shader pass
            #define SHADERPASS SHADERPASS_RAYTRACING_VISIBILITY

            // Need to override the macros for ray tracing
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"

            // Shader variables
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"

            // VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/RayTracingInputStructure.template")}
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/CommonOutput.template")}
            ${VFXPerPassInclude}

            // Needs to be included after the VFX includes
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/IntersectionFunctions.template")}

            // Material includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Common/RayTracingProcedural.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

            ${VFXGeneratedBlockFunction}

            // Include to evaluate the material data
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Unlit/EvaluateMaterialData.template")}

            [shader("closesthit")]
            void ClosestHit(inout RayIntersectionVisibility rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Read the material data
                float4 color = 0.0;
                float velocity = 0.0;
                EvaluateUnlitMaterialData(attributeData, color, velocity);
                rayIntersection.velocity = velocity;
            }

            [shader("anyhit")]
            void AnyHitVisibility(inout RayIntersectionVisibility rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
            {
                UNITY_XR_ASSIGN_VIEW_INDEX(DispatchRaysIndex().z);

                // Compute the distance of the ray
                rayIntersection.t = RayTCurrent();

                // Read the material data
                float4 color = 0.0;
                float velocity = 0.0;
                EvaluateUnlitMaterialData(attributeData, color, velocity);

            #if defined(TRANSPARENT_COLOR_SHADOW) && defined(_SURFACE_TYPE_TRANSPARENT)
                // Override the veloctity for this value
                rayIntersection.velocity = velocity;

                // Adjust the color based on the transmittance or opacity
                rayIntersection.color *= (1.0 - color.a);

                // Ignore to move to the following intersections
                IgnoreHit();
            #else
                // If this fella is opaque, then we need to stop
                rayIntersection.color = float3(0.0, 0.0, 0.0);
                AcceptHitAndEndSearch();
            #endif
            }

            // Inject the intersection shader
            ${VFXIncludeRP("Templates/PlanarPrimitive/DXR/Common/IntersectionShader.template")}
            ENDHLSL
        }
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\PassVisibilityDXR.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\RayTracingInputStructure.template---------------
.
.
    // Equivalent of the Pixel to Vertex structure
    struct rt_input
    {
        float4 pos;
	    #if VFX_NEEDS_COLOR_INTERPOLATOR
	        float4 color;
	    #endif
		#if USE_FLIPBOOK_INTERPOLATION
		    float4 uv;
		#else
		    #if USE_FLIPBOOK_ARRAY_LAYOUT
		        float3 uv;
		    #else
		        float2 uv;
		    #endif
		#endif
		#if USE_SOFT_PARTICLE
		    float invSoftParticleFadeDistance;
		#endif
		#if USE_FLIPBOOK_MOTIONVECTORS
		    float2 mvScale;
		#endif
        #if USE_EXPOSURE_WEIGHT
            float exposureWeight;
        #endif
	    #if VFX_NEEDS_POSWS_INTERPOLATOR
	        float3 posWS : TEXCOORD3;
	    #endif
        #if SHADERGRAPH_NEEDS_NORMAL_FORWARD
	        float3 normal;
	    #endif
	    #if SHADERGRAPH_NEEDS_TANGENT_FORWARD
	        float3 tangent;
	    #endif
        ${VFXAdditionalInterpolantsDeclaration}

    };

    #define VFX_VARYING_PS_INPUTS rt_input
    #define VFX_VARYING_POSCS pos
    #define VFX_VARYING_COLOR color.rgb
    #define VFX_VARYING_ALPHA color.a
    #define VFX_VARYING_UV uv
    #define VFX_VARYING_NORMAL normal
    #define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE invSoftParticleFadeDistance
    #define VFX_VARYING_MOTIONVECTORSCALE mvScale.xy
    #if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
        #define VFX_VARYING_TANGENT tangent
    #endif
    #if USE_NORMAL_BENDING
        #define VFX_VARYING_BENTFACTORS bentFactors
    #endif
    #if USE_EXPOSURE_WEIGHT
        #define VFX_VARYING_EXPOSUREWEIGHT exposureWeight
    #endif


.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\PlanarPrimitive\DXR\Unlit\RayTracingInputStructure.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassDepth.template---------------
.
.
// Forward pass
Pass
{
    Name "DepthOnly"
	Tags { "LightMode"="DepthOnly" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXIncludeRP("Templates/Sphere/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassDepthForwardOnly.template---------------
.
.
Pass
{
    Name "DepthForwardOnly"
	Tags { "LightMode"="DepthForwardOnly" }

	ZWrite On
	Blend Off

	HLSLPROGRAM

	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXIncludeRP("Templates/Sphere/PassDepthOrMV.template")}


	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassDepthForwardOnly.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassDepthOrMV.template---------------
.
.
#pragma target 4.5
#define UNITY_MATERIAL_LIT
#pragma multi_compile _ WRITE_NORMAL_BUFFER

struct ps_input
{
	SV_POSITION_QUALIFIERS float4 pos : SV_POSITION;
	float2 uv : TEXCOORD1;
	float4 posWS : TEXCOORD2;
	float4 sphereInfo : TEXCOORD3;

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_POSWS posWS.xyz
#define VFX_VARYING_SPHERECENTER sphereInfo.xyz
#define VFX_VARYING_SPHERERADIUS sphereInfo.w

#ifdef WRITE_NORMAL_BUFFER
#define VFX_VARYING_SMOOTHNESS posWS.w
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}

${VFXInclude("Shaders/ParticleSpheres/Pass.template")}
#define SHADERPASS SHADERPASS_DEPTH_ONLY
${VFXIncludeRP("VFXLit.template")}

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
int _ObjectId;
int _PassValue;
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
float4 _SelectionID;
#endif

#pragma fragment frag
void frag(ps_input i
#if defined(WRITE_NORMAL_BUFFER) && VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
, out float4 outNormalBuffer : SV_Target0
#else
, out float4 outColor : SV_Target
#endif
, out float oDepth : DEPTH_OFFSET_SEMANTIC)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	VFXTransformPSInputs(i);
	float3 normalWS;
	VFXClipSphereAndGetDepthOffsetAndNormal(oDepth, normalWS, i);

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
	outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
	outColor = _SelectionID;
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
	#ifdef WRITE_NORMAL_BUFFER
		VFXUVData uvData = (VFXUVData)0;
		VFXComputePixelOutputToNormalBuffer(i,normalWS,uvData,outNormalBuffer);
	#else
		outColor = (float4)0;
	#endif
#else
	#error VFX_PASSDEPTH undefined
#endif
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassForward.template---------------
.
.
Pass
{
    Name "${VFXHDRPForwardPassName}"
	Tags { "LightMode"="${VFXHDRPForwardPassName}"}
	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5


	#define UNITY_MATERIAL_LIT
	#define LIGHTLOOP_TILE_PASS

	${VFXHDRPForwardDefines}
	#pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST
	#pragma multi_compile_fragment PUNCTUAL_SHADOW_LOW PUNCTUAL_SHADOW_MEDIUM PUNCTUAL_SHADOW_HIGH
	#pragma multi_compile_fragment DIRECTIONAL_SHADOW_LOW DIRECTIONAL_SHADOW_MEDIUM DIRECTIONAL_SHADOW_HIGH
	#pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH
	#pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
	#pragma multi_compile _ DEBUG_DISPLAY

	${VFXIncludeRP("VFXLitVaryings.template")}

	struct ps_input
	{
		SV_POSITION_QUALIFIERS float4 pos : SV_POSITION;
		${VFXHDRPLitDeclareVaryings}

		float2 uv : TEXCOORD1;
		float3 posWS : TEXCOORD2;
		float4 sphereInfo : TEXCOORD3;

        ${VFXAdditionalInterpolantsDeclaration}

		UNITY_VERTEX_OUTPUT_STEREO
	};

	${VFXHDRPLitVaryingsMacros}

	#define VFX_VARYING_PS_INPUTS ps_input
	#define VFX_VARYING_POSCS pos
	#define VFX_VARYING_UV uv
	#define VFX_VARYING_POSWS posWS
	#define VFX_VARYING_SPHERECENTER sphereInfo.xyz
	#define VFX_VARYING_SPHERERADIUS sphereInfo.w

	${VFXBegin:VFXVertexAdditionalProcess}
	${VFXHDRPLitFillVaryings}
	${VFXEnd}

	${VFXInclude("Shaders/ParticleSpheres/Pass.template")}
	#define SHADERPASS SHADERPASS_FORWARD
	${VFXIncludeRP("VFXLit.template")}

	#pragma fragment frag
	void frag(ps_input i
	, out float4 outColor : SV_Target0
	, out float oDepth : DEPTH_OFFSET_SEMANTIC
	)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);

		float3 normalWS;
		VFXUVData uvData = (VFXUVData)0;
		VFXClipSphereAndGetDepthOffsetAndNormal(oDepth, normalWS, i);

		outColor = VFXGetPixelOutputForward(i,normalWS,uvData, true);
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassGBuffer.template---------------
.
.
Pass
{
    Name "GBuffer"
	Tags { "LightMode"="GBuffer" }

    ${VFXStencilGBuffer}
	HLSLPROGRAM
	#pragma target 4.5

	#pragma multi_compile _ RENDERING_LAYERS
	#pragma multi_compile _ DEBUG_DISPLAY
    #pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2

	#define UNITY_MATERIAL_LIT

	${VFXIncludeRP("VFXLitVaryings.template")}

	struct ps_input
	{
		SV_POSITION_QUALIFIERS float4 pos : SV_POSITION;

		${VFXHDRPLitDeclareVaryings}

		float2 uv : TEXCOORD1;
		float3 posWS : TEXCOORD2;
		float4 sphereInfo : TEXCOORD3;

		UNITY_VERTEX_OUTPUT_STEREO
	};
	
${VFXHDRPLitVaryingsMacros}	
	
#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_POSWS posWS	
#define VFX_VARYING_SPHERECENTER sphereInfo.xyz
#define VFX_VARYING_SPHERERADIUS sphereInfo.w

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}
	
	${VFXInclude("Shaders/ParticleSpheres/Pass.template")}	
	#define SHADERPASS SHADERPASS_GBUFFER
	${VFXIncludeRP("VFXLit.template")}
					
	#pragma fragment frag
	void frag(ps_input i, OUTPUT_GBUFFER(outGBuffer), out float oDepth : DEPTH_OFFSET_SEMANTIC)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		VFX_FRAG_SETUP_INSTANCE_ID(i);
		float3 normalWS;
		VFXUVData uvData = (VFXUVData)0;
		VFXClipSphereAndGetDepthOffsetAndNormal(oDepth, normalWS, i);		
		VFXComputePixelOutputToGBuffer(i,normalWS,uvData,outGBuffer);
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassGBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassSelection.template---------------
.
.
// Forward pass
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite Off
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXIncludeRP("Templates/Sphere/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite Off
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXIncludeRP("Templates/Sphere/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Sphere\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Volumetric\PassVolumetricFog.template---------------
.
.
#pragma target 4.5

#define SHADERPASS SHADERPASS_VOLUMETRIC_FOG_VFX_VOXELIZATION

// Note: picking is not possible with HDRP Volumetric Fog
#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
int _ObjectId;
int _PassValue;
#endif

struct VertexToFragment
{
    float4 positionCS : SV_POSITION;
    nointerpolation float4 sphereInfo : TEXCOORD0;
    nointerpolation float4 colorAndDensity : TEXCOORD1;
    nointerpolation float4 densityData : TEXCOORD2;
#if defined(HDRP_VOLUMETRIC_MASK)
    float3 uv : TEXCOORD3;
#endif
    float3 viewDirectionWS : TEXCOORD4;
    nointerpolation uint depthSlice : SV_RenderTargetArrayIndex;
};

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
    VFX_DECLARE_INSTANCE_ID
    uint vertexId : SV_VertexID;
};

#define VFX_VARYING_POSCS positionCS

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/HDRenderPipeline.VolumetricLighting.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Editor/Material/FogVolume/ShaderGraph/VolumetricMaterialUtils.hlsl"

int DistanceToSlice(float distance)
{
    float t0 = DecodeLogarithmicDepthGeneralized(0, _VBufferDistanceDecodingParams);
    float de = _VBufferRcpSliceCount; // Log-encoded distance between slices

    float e1 = EncodeLogarithmicDepthGeneralized(distance, _VBufferDistanceEncodingParams);
    e1 -= de;
    e1 /= de;

    return int(max(0, e1 - 0.5));
}

StructuredBuffer<uint> maxSliceCount;

VertexToFragment Vert(vs_input i)
{
    VertexToFragment o = (VertexToFragment)0;

    UNITY_SETUP_INSTANCE_ID(i);

    // Call manually init instancing to get the correct batch index needed to compute the particle ID and call VFXInitInstancing with the correct parameters.
    uint batchIndex, unused1, unused2;
    VFXInitInstancing(0, unused1, batchIndex, unused2);

    uint id = i.vertexId + VFX_GET_INSTANCE_ID(i) * 2048 * 4;
    uint quadCountPerParticle = maxSliceCount[batchIndex];
    uint quadIndex = id / 4;
    uint quadIndexPerParticle = quadIndex % quadCountPerParticle;
    uint particleId = (quadIndex / quadCountPerParticle);
    uint index = particleId;
    uint viewIndex = unity_StereoEyeIndex;

    // Cull particles in case more draw calls were issued than necessary, this happens quite a lot when dispatching large number of quads
    if (quadIndex > indirectBuffer[batchIndex])
        return o;

    ${VFXInitInstancing}

	${VFXLoadContextData}
    uint systemSeed = contextData.systemSeed;
    uint nbMax = contextData.maxParticleCount;

    ${VFXLoadGraphValues}
    VFXAttributes attributes = (VFXAttributes)0;
    VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
    index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
    ${VFXLoadAttributes}
    ${VFXProcessBlocks}

    ${VFXLoadParameter:{fadeRadius}}
    ${VFXLoadParameter:{density}}
    ${VFXLoadParameter:{falloffMode}}
    ${VFXLoadParameter:{fogBlendMode}}
#if defined(HDRP_VOLUMETRIC_MASK)
    ${VFXLoadParameter:{isTextureAlpha8}}
#else
    float isTextureAlpha8 = 0;
#endif

    o.densityData = float4(fadeRadius, falloffMode, fogBlendMode, isTextureAlpha8);

    ${VFXLoadSize}
    float uSize = size3.x * 0.5f;

	float3x3 rot = GetEulerMatrix(radians(float3(attributes.angleX,attributes.angleY,attributes.angleZ)));
	float4x4 elementToVFX = GetElementToVFXMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		rot,
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

	float3 vPos = mul(elementToVFX,float4(0, 0, 0, 1.0f)).xyz;
    float3 particleCenterWorldPosition = TransformPositionVFXToWorld(vPos);

#ifdef VFX_WORLD_SPACE
    particleCenterWorldPosition = GetCameraRelativePositionWS(particleCenterWorldPosition);
#endif

    float distanceToCamera = length(particleCenterWorldPosition);
    float scale = 1.0f - (1.0f - unity_OrthoParams.w) * uSize / distanceToCamera;

    o.sphereInfo.xyz = particleCenterWorldPosition;
    o.sphereInfo.w = uSize;

    float vBufferNearplane = DecodeLogarithmicDepthGeneralized(0, _VBufferDistanceDecodingParams);
    float distanceToParticleSphere = distanceToCamera - uSize;
    bool cameraInsideParticle = distanceToParticleSphere <= 0;
    distanceToParticleSphere = max(distanceToParticleSphere, vBufferNearplane);

    // Calculate the start slice index from the front position of the particle
    uint startSliceIndex = DistanceToSlice(distanceToParticleSphere) + 1;
    uint sliceIndex = startSliceIndex + quadIndexPerParticle;
    o.depthSlice = sliceIndex + viewIndex * _VBufferSliceCount;
    float sliceDistanceToCamera = VBufferDistanceToSliceIndex(sliceIndex);

    float distanceFadeFactor = 1.0f;
#if defined(HDRP_VOLUMETRIC_DISTANCE_FADING)
    ${VFXLoadParameter:{rcpDistanceFadeLength}}
    ${VFXLoadParameter:{endTimesRcpDistanceFadeLength}}

    distanceFadeFactor = Remap10(sliceDistanceToCamera, rcpDistanceFadeLength, endTimesRcpDistanceFadeLength);
#endif
    o.colorAndDensity = float4(attributes.color.rgb, attributes.alpha * density * distanceFadeFactor);

    float distanceBetweenCenterAndSlice = abs(distanceToCamera) - sliceDistanceToCamera;

    float3 viewDirection = -normalize(particleCenterWorldPosition);

    if (cameraInsideParticle)
        viewDirection = -normalize(UNITY_MATRIX_V[2].xyz);

    // When the camera is inside we need to change which algorithm is used to place the slice otherwise the quad
    // may end up being coplanar to the camera which makes the particle disappear.
    float3 offsetPositionRWS;
    if (cameraInsideParticle)
    {
        float3 sliceCenterPosition = viewDirection * sliceDistanceToCamera;
        float3 dir = -normalize(particleCenterWorldPosition - sliceCenterPosition);
        distanceBetweenCenterAndSlice = length(particleCenterWorldPosition - sliceCenterPosition);
        offsetPositionRWS = particleCenterWorldPosition + distanceBetweenCenterAndSlice * dir;
    }
    else
    {
        offsetPositionRWS = particleCenterWorldPosition + (distanceBetweenCenterAndSlice) * viewDirection;
    }

    // Calculate the exact size of the quad to fit the sphere at a certain position.
    float distanceInSphere = length(offsetPositionRWS - particleCenterWorldPosition);
    float normalizedSliceDistanceToCenter = saturate(distanceInSphere / uSize);
    float sphereScale = saturate(sqrt(1 - abs(normalizedSliceDistanceToCenter * normalizedSliceDistanceToCenter))); // sin(acos(distance))

    // Due the the froxel buffer having cone shaped froxel, we need to  disable the sphere scaling as it doesn't take in account the curvature of the froxel
    if (cameraInsideParticle)
        sphereScale = 1;

    // Hack to avoid quad artifacts when getting close to the sphere (still due to the shape of the froxel buffer, the quad size is not accurate)
    sphereScale = lerp(sphereScale, 2, 1.0 - saturate(distanceToParticleSphere / uSize));

    // Manually compute the world position without clip space to reduct SGPR pressure
    float3 tmpCameraRight = UNITY_MATRIX_V[0].xyz;
    float3 cameraUp = normalize(cross(viewDirection, tmpCameraRight));
    float3 cameraRight = normalize(cross(viewDirection, cameraUp));

    // Scale quad depending on how the slice cut the sphere
    float2 quad = float2(float(id & 1), (id & 2) * 0.5f) * 2 - 1;
    float3 positionWS = offsetPositionRWS + cameraUp * uSize * quad.y * sphereScale + cameraRight * uSize * quad.x * sphereScale;

    o.positionCS = TransformWorldToHClip(positionWS);

    o.viewDirectionWS = GetWorldSpaceViewDir(positionWS);

#if defined(HDRP_VOLUMETRIC_MASK)
    o.uv = ((positionWS - o.sphereInfo.xyz) / (attributes.scaleX * attributes.size)) + 0.5; // We don't need to multiply by 0.5 because it's already included in the divide by size.

#if defined(VFX_APPLY_ANGULAR_ROTATION)
    o.uv = o.uv * 2 - 1;
    float3x3 r = mul((float3x3(attributes.axisX, attributes.axisY, attributes.axisZ)), rot);
    o.uv = mul(r, o.uv);
    o.uv = o.uv * 0.5 + 0.5;
#endif

    ${VFXLoadParameter:{uvScale}}
    ${VFXLoadParameter:{uvBias}}
    o.uv *= uvScale;
    o.uv += uvBias;
#endif

    return o;
}

float2 sphIntersect( in float3 ro, in float3 rd, in float3 ce, float ra )
{
    float3 oc = ro - ce;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - ra*ra;
    float h = b*b - c;
    if( h<0.0 ) return -1.0; // no intersection
    h = sqrt( h );
    return float2( -b-h, -b+h );
}

float3 CalculateVoxelCenterWS(VertexToFragment i)
{
    float sliceDepth = VBufferDistanceToSliceIndex(i.depthSlice % _VBufferSliceCount);
    // Compute voxel center position and test against volume OBB
    float3 raycenterDirWS = normalize(-i.viewDirectionWS);
    float3 rayoriginWS    = GetCurrentViewPosition();
    float3 voxelCenterWS = rayoriginWS + sliceDepth * raycenterDirWS;

    return voxelCenterWS;
}

float4 Frag(VertexToFragment i) : SV_Target0
{
    float3 voxelCenterWS = CalculateVoxelCenterWS(i);
    float distanceToCenter = length(voxelCenterWS - i.sphereInfo.xyz);

    if (distanceToCenter > i.sphereInfo.w)
        clip(-1);

    // Fade radius
    float fade = i.densityData.x <= 0 ? 1 : saturate((i.sphereInfo.w - distanceToCenter) / i.densityData.x);
    bool multiplyBlendMode = i.densityData.z == LOCALVOLUMETRICFOGBLENDINGMODE_MULTIPLY;
    bool exponential = i.densityData.y == LOCALVOLUMETRICFOGFALLOFFMODE_EXPONENTIAL;

    ApplyExponentialFadeFactor(fade, exponential, multiplyBlendMode);

    float3 albedo = i.colorAndDensity.xyz;
    float extinction = i.colorAndDensity.w;

#if defined(HDRP_VOLUMETRIC_MASK)
    float4 maskValue = SAMPLE_TEXTURE3D(mask, samplermask, i.uv);
    if (i.densityData.w == 1) // Alpha8 texture handling
        maskValue = float4(1, 1, 1, maskValue.a);
    albedo *= maskValue.rgb;
    extinction *= maskValue.a;
#endif

    if (multiplyBlendMode)
    {
        return max(0, lerp(float4(1.0, 1.0, 1.0, 1.0), float4(saturate(albedo * extinction), extinction), fade.xxxx));
    }
    else
    {
        extinction *= fade;
        return max(0, float4(saturate(albedo * extinction), extinction));
    }
}

float4 FragmentSceneSelection(VertexToFragment i) : SV_Target0
{
    float3 voxelCenterWS = CalculateVoxelCenterWS(i);
    float distanceToCenter = length(voxelCenterWS - i.sphereInfo.xyz);

    if (distanceToCenter > i.sphereInfo.w)
        clip(-1);

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
	return float4(_ObjectId, _PassValue, 1.0, 1.0);
#else
    return 0;
#endif
}

float4 FragmentOverdrawDebug(VertexToFragment i) : SV_Target0
{
    return float4(1, 1, 1, _VBufferRcpSliceCount);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.high-definition\Editor\VFXGraph\Shaders\Templates\Volumetric\PassVolumetricFog.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\Decal\DecalPass.template---------------
.
.
Pass
{ 
    $splice(PassName)
    Tags 
    { 
        $splice(LightMode)
    }

    // Render State
    $splice(RenderState)

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    $splice(PassPragmas)

    // Keywords
    $splice(PassKeywords)
    $splice(GraphKeywords)

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

    // Defines
    $Attributes.normalOS:               #define ATTRIBUTES_NEED_NORMAL
    $Attributes.tangentOS:              #define ATTRIBUTES_NEED_TANGENT
    $Attributes.uv0:                    #define ATTRIBUTES_NEED_TEXCOORD0
    $Attributes.uv1:                    #define ATTRIBUTES_NEED_TEXCOORD1
    $Attributes.uv2:                    #define ATTRIBUTES_NEED_TEXCOORD2
    $Attributes.uv3:                    #define ATTRIBUTES_NEED_TEXCOORD3
    $Attributes.color:                  #define ATTRIBUTES_NEED_COLOR
    $Varyings.positionWS:               #define VARYINGS_NEED_POSITION_WS
    $Varyings.normalWS:                 #define VARYINGS_NEED_NORMAL_WS
    $Varyings.viewDirectionWS:          #define VARYINGS_NEED_VIEWDIRECTION_WS
    $Varyings.tangentWS:                #define VARYINGS_NEED_TANGENT_WS
    $Varyings.texCoord0:                #define VARYINGS_NEED_TEXCOORD0
    $Varyings.texCoord1:                #define VARYINGS_NEED_TEXCOORD1
    $Varyings.texCoord2:                #define VARYINGS_NEED_TEXCOORD2
    $Varyings.texCoord3:                #define VARYINGS_NEED_TEXCOORD3
    $Varyings.color:                    #define VARYINGS_NEED_COLOR
    $Varyings.fogFactorAndVertexLight:  #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT
    $Varyings.sh:                       #define VARYINGS_NEED_SH
    $Varyings.staticLightmapUV:         #define VARYINGS_NEED_STATIC_LIGHTMAP_UV
    $Varyings.dynamicLightmapUV:        #define VARYINGS_NEED_DYNAMIC_LIGHTMAP_UV
    $Varyings.shadowCoord:              #define VARYINGS_NEED_SHADOW_COORD
    
    $features.graphVertex:                  #define HAVE_MESH_MODIFICATION

    $SurfaceDescriptionInputs.FaceSign:     // Define when IsFontFaceNode is included in ShaderGraph
    $SurfaceDescriptionInputs.FaceSign:     #define VARYINGS_NEED_CULLFACE

    $splice(GraphDefines)

    // -- Properties used by ScenePickingPass
    #ifdef SCENEPICKINGPASS
    float4 _SelectionID;
    #endif
    #if _RENDER_PASS_ENABLED
    #define GBUFFER3 0
    #define GBUFFER4 1
    FRAMEBUFFER_INPUT_X_HALF(GBUFFER3);
    FRAMEBUFFER_INPUT_X_HALF(GBUFFER4);
    #endif
    // Includes
    $splice(PreGraphIncludes)

    // --------------------------------------------------
    // Structs and Packing

    $splice(PassStructs)

    $splice(InterpolatorPack)

    // --------------------------------------------------
    // Graph

    // Graph Properties
    $splice(GraphProperties)

    // Graph Includes
    $splice(GraphIncludes)

    // Graph Functions
    $splice(GraphFunctions)

    // Graph Vertex
    $splice(GraphVertex)
    
    // Graph Pixel
    $splice(GraphPixel)

    // --------------------------------------------------
    // Build Graph Inputs

    $features.graphVertex:  $include("VertexAnimation.template.hlsl")
    $features.graphPixel:   $include("SharedCode.template.hlsl")
    $features.graphPixel:   $include("BuildSurfaceDescriptionInputs.template.hlsl")

    // --------------------------------------------------
    // Build Surface Data

    void GetSurfaceData(Varyings input, float4 positionCS, float angleFadeFactor, out DecalSurfaceData surfaceData)
    {
        #if (SHADERPASS == SHADERPASS_DBUFFER_PROJECTOR) || (SHADERPASS == SHADERPASS_FORWARD_EMISSIVE_PROJECTOR) || (SHADERPASS == SHADERPASS_DECAL_SCREEN_SPACE_PROJECTOR) || (SHADERPASS == SHADERPASS_DECAL_GBUFFER_PROJECTOR)
            half4x4 normalToWorld = UNITY_ACCESS_INSTANCED_PROP(Decal, _NormalToWorld);
            half fadeFactor = clamp(normalToWorld[0][3], 0.0f, 1.0f) * angleFadeFactor;
            float2 scale = float2(normalToWorld[3][0], normalToWorld[3][1]);
            float2 offset = float2(normalToWorld[3][2], normalToWorld[3][3]);
            $Varyings.texCoord0: input.texCoord0.xy = input.texCoord0.xy * scale + offset;
            $Varyings.texCoord1: input.texCoord1.xy = input.texCoord1.xy * scale + offset;
            $Varyings.texCoord2: input.texCoord2.xy = input.texCoord2.xy * scale + offset;
            $Varyings.texCoord3: input.texCoord3.xy = input.texCoord3.xy * scale + offset;
            half3 normalWS = TransformObjectToWorldDir(half3(0, 1, 0));
            half3 tangentWS = TransformObjectToWorldDir(half3(1, 0, 0));
            half3 bitangentWS = TransformObjectToWorldDir(half3(0, 0, 1));
            half sign = dot(cross(normalWS, tangentWS), bitangentWS) > 0 ? 1 : -1;
            $Varyings.normalWS:  input.normalWS.xyz = normalWS;
            $Varyings.tangentWS: input.tangentWS.xyzw = half4(tangentWS, sign);
        #else
            #if defined(LOD_FADE_CROSSFADE) && USE_UNITY_CROSSFADE
                LODFadeCrossFade(positionCS);
            #endif

            half fadeFactor = half(1.0);
        #endif

        SurfaceDescriptionInputs surfaceDescriptionInputs = BuildSurfaceDescriptionInputs(input);
        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);

        // setup defaults -- these are used if the graph doesn't output a value
        ZERO_INITIALIZE(DecalSurfaceData, surfaceData);
        surfaceData.occlusion = half(1.0);
        surfaceData.smoothness = half(0);

        #ifdef _MATERIAL_AFFECTS_NORMAL
            surfaceData.normalWS.w = half(1.0);
        #else
            surfaceData.normalWS.w = half(0.0);
        #endif

        $SurfaceDescription.Emission:       surfaceData.emissive.rgb = half3(surfaceDescription.Emission.rgb * fadeFactor);

        // copy across graph values, if defined
        $SurfaceDescription.BaseColor:      surfaceData.baseColor.xyz = half3(surfaceDescription.BaseColor);
        $SurfaceDescription.Alpha:          surfaceData.baseColor.w = half(surfaceDescription.Alpha * fadeFactor);

        #if (SHADERPASS == SHADERPASS_DBUFFER_PROJECTOR) || (SHADERPASS == SHADERPASS_DECAL_SCREEN_SPACE_PROJECTOR) || (SHADERPASS == SHADERPASS_DECAL_GBUFFER_PROJECTOR)
            #if defined(_MATERIAL_AFFECTS_NORMAL)
                $SurfaceDescription.NormalTS:   surfaceData.normalWS.xyz = normalize(mul((half3x3)normalToWorld, surfaceDescription.NormalTS.xyz));
            #else
                surfaceData.normalWS.xyz = normalize(normalToWorld[2].xyz);
            #endif
        #elif (SHADERPASS == SHADERPASS_DBUFFER_MESH) || (SHADERPASS == SHADERPASS_DECAL_SCREEN_SPACE_MESH) || (SHADERPASS == SHADERPASS_DECAL_GBUFFER_MESH)
            #if defined(_MATERIAL_AFFECTS_NORMAL)
                float sgn = input.tangentWS.w;      // should be either +1 or -1
                float3 bitangent = sgn * cross(input.normalWS.xyz, input.tangentWS.xyz);
                half3x3 tangentToWorld = half3x3(input.tangentWS.xyz, bitangent.xyz, input.normalWS.xyz);

                // We need to normalize as we use mikkt tangent space and this is expected (tangent space is not normalize)
                $SurfaceDescription.NormalTS:   surfaceData.normalWS.xyz = normalize(TransformTangentToWorld(surfaceDescription.NormalTS, tangentToWorld));
            #else
                surfaceData.normalWS.xyz = normalize(half3(input.normalWS)); // Default to vertex normal
            #endif
        #endif

        $SurfaceDescription.NormalAlpha:    surfaceData.normalWS.w = surfaceDescription.NormalAlpha * fadeFactor;

        // In case of Smoothness / AO / Metal, all the three are always computed but color mask can change
        $SurfaceDescription.Metallic:       surfaceData.metallic = half(surfaceDescription.Metallic);
        $SurfaceDescription.Occlusion:      surfaceData.occlusion = half(surfaceDescription.Occlusion);
        $SurfaceDescription.Smoothness:     surfaceData.smoothness = half(surfaceDescription.Smoothness);
        $SurfaceDescription.MAOSAlpha:      surfaceData.MAOSAlpha = half(surfaceDescription.MAOSAlpha * fadeFactor);
    }

    // --------------------------------------------------
    // Main

    $splice(PostGraphIncludes)

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\Decal\DecalPass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\ShaderGraph\Templates\ShaderPass.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

// Render State
$splice(RenderState)

// Debug
$splice(Debug)

// --------------------------------------------------
// Pass

HLSLPROGRAM

// Pragmas
$splice(PassPragmas)

// Keywords
$splice(PassKeywords)
$splice(GraphKeywords)

// Defines
$features.graphVFX: #define HAVE_VFX_MODIFICATION

$Normal: #define _NORMALMAP 1
$NormalDropOffTS: #define _NORMAL_DROPOFF_TS 1
$NormalDropOffOS: #define _NORMAL_DROPOFF_OS 1
$NormalDropOffWS: #define _NORMAL_DROPOFF_WS 1
$Attributes.normalOS: #define ATTRIBUTES_NEED_NORMAL
$Attributes.tangentOS: #define ATTRIBUTES_NEED_TANGENT
$Attributes.uv0: #define ATTRIBUTES_NEED_TEXCOORD0
$Attributes.uv1: #define ATTRIBUTES_NEED_TEXCOORD1
$Attributes.uv2: #define ATTRIBUTES_NEED_TEXCOORD2
$Attributes.uv3: #define ATTRIBUTES_NEED_TEXCOORD3
$Attributes.color: #define ATTRIBUTES_NEED_COLOR
$Attributes.vertexID: #define ATTRIBUTES_NEED_VERTEXID
$Attributes.instanceID: #define ATTRIBUTES_NEED_INSTANCEID
$VertexDescriptionInputs.TimeParameters: #define GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT
$VertexDescription.Normal: #define FEATURES_GRAPH_VERTEX_NORMAL_OUTPUT
$VertexDescription.Tangent: #define FEATURES_GRAPH_VERTEX_TANGENT_OUTPUT
$VertexDescription.MotionVector: #define FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT
$Varyings.positionWS: #define VARYINGS_NEED_POSITION_WS
$Varyings.normalWS: #define VARYINGS_NEED_NORMAL_WS
$Varyings.tangentWS: #define VARYINGS_NEED_TANGENT_WS
$Varyings.texCoord0: #define VARYINGS_NEED_TEXCOORD0
$Varyings.texCoord1: #define VARYINGS_NEED_TEXCOORD1
$Varyings.texCoord2: #define VARYINGS_NEED_TEXCOORD2
$Varyings.texCoord3: #define VARYINGS_NEED_TEXCOORD3
$Varyings.color: #define VARYINGS_NEED_COLOR
$Varyings.elementToWorld0:  #define VARYINGS_NEED_ELEMENT_TO_WORLD
$Varyings.worldToElement0:  #define VARYINGS_NEED_WORLD_TO_ELEMENT
$Varyings.bitangentWS: #define VARYINGS_NEED_BITANGENT_WS
$Varyings.screenPosition: #define VARYINGS_NEED_SCREENPOSITION
$Varyings.fogFactorAndVertexLight: #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT
$Varyings.shadowCoord: #define VARYINGS_NEED_SHADOW_COORD
$Varyings.cullFace: #define VARYINGS_NEED_CULLFACE
$Varyings.instanceID: #define VARYINGS_NEED_INSTANCEID
$Varyings.diffuseGIData0: #define VARYINGS_NEED_SIX_WAY_DIFFUSE_GI_DATA
$features.graphVertex: #define FEATURES_GRAPH_VERTEX
$Universal.UseLegacySpriteBlocks: #define UNIVERSAL_USELEGACYSPRITEBLOCKS
$splice(PassInstancing)
$splice(GraphDefines)


// custom interpolator pre-include
$splice(sgci_CustomInterpolatorPreInclude)

// Includes
$splice(PreGraphIncludes)

// --------------------------------------------------
// Structs and Packing

// custom interpolators pre packing
$splice(CustomInterpolatorPrePacking)

$splice(PassStructs)

$splice(InterpolatorPack)

// --------------------------------------------------
// Graph

// Graph Properties
$splice(GraphProperties)

// Graph Includes
$splice(GraphIncludes)

// -- Property used by ScenePickingPass
#ifdef SCENEPICKINGPASS
float4 _SelectionID;
#endif

// -- Properties used by SceneSelectionPass
#ifdef SCENESELECTIONPASS
int _ObjectId;
int _PassValue;
#endif

// Graph Functions
$splice(GraphFunctions)

// Custom interpolators pre vertex
$splice(CustomInterpolatorPreVertex)

// Graph Vertex
$splice(GraphVertex)

// Custom interpolators, pre surface
$splice(CustomInterpolatorPreSurface)

// Graph Pixel
$splice(GraphPixel)

// --------------------------------------------------
// Build Graph Inputs
#ifdef HAVE_VFX_MODIFICATION
#define VFX_SRP_ATTRIBUTES Attributes
#define VFX_SRP_VARYINGS Varyings
#define VFX_SRP_SURFACE_INPUTS SurfaceDescriptionInputs
#endif
$features.graphVFX: $include("VFXConfig.template.hlsl")
$features.graphVertex:  $include("BuildVertexDescriptionInputs.template.hlsl")
$features.graphPixel: $include("SharedCode.template.hlsl")

// --------------------------------------------------
// Main

$splice(PostGraphIncludes)

// --------------------------------------------------
// Visual Effect Vertex Invocations
#ifdef HAVE_VFX_MODIFICATION
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/VisualEffectVertex.hlsl"
#endif

ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\ShaderGraph\Templates\ShaderPass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXDecal.template---------------
.
.
#include "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXLit.hlsl"
#if !defined(SHADERPASS)
#error SHADERPASS_is_not_define
#endif

#ifdef _DECAL_LAYERS
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareRenderingLayerTexture.hlsl"
#endif

#if defined(DECAL_LOAD_NORMAL)
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"
#endif

#if defined(DECAL_PROJECTOR) || defined(DECAL_RECONSTRUCT_NORMAL)
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
#endif

void GetSurfaceDataFromSurfaceDecalData(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
{
    surfaceData.albedo = decalSurfaceData.baseColor.rgb;
    surfaceData.metallic = saturate(decalSurfaceData.metallic);
    surfaceData.specular = 0;
    surfaceData.smoothness = saturate(decalSurfaceData.smoothness);
    surfaceData.occlusion = decalSurfaceData.occlusion;
    surfaceData.emission = decalSurfaceData.emissive;
    surfaceData.alpha = saturate(decalSurfaceData.baseColor.w);
    surfaceData.clearCoatMask = 0;
    surfaceData.clearCoatSmoothness = 1;
}

void VFXGetSurfaceDecalData(out DecalSurfaceData surfaceData, out PositionInputs posInputs, out half3 receiverNormalWS, VFX_VARYING_PS_INPUTS i)
{
	ZERO_INITIALIZE(DecalSurfaceData, surfaceData);
	VFXTransformPSInputs(i);

    float2 positionCS = i.pos.xy;
    // Only screen space needs flip logic, other passes do not setup needed properties so we skip here
#if SHADERPASS == SHADERPASS_DECAL_SCREEN_SPACE_PROJECTOR
    TransformScreenUV(positionCS, _ScreenSize.y);
#endif

//Check Rendering layer
#ifdef _DECAL_LAYERS
    #ifdef _RENDER_PASS_ENABLED
        uint surfaceRenderingLayer = DecodeMeshRenderingLayer(LOAD_FRAMEBUFFER_X_INPUT(GBUFFER4, positionCS.xy).r);
    #else
        uint surfaceRenderingLayer = LoadSceneRenderingLayer(positionCS.xy);
    #endif
    ${VFXLoadParameter:{decalLayerMask}}
    clip((surfaceRenderingLayer & decalLayerMask) - 0.1);
#endif


#if _RENDER_PASS_ENABLED
    float depth = LOAD_FRAMEBUFFER_X_INPUT(GBUFFER3, positionCS.xy).x;
#else
    float depth = LoadSceneDepth(positionCS.xy);
#endif
#if !UNITY_REVERSED_Z
    depth = lerp(UNITY_NEAR_CLIP_VALUE, 1.0f, depth);
#endif

    float2 positionSS = i.pos.xy * _ScreenSize.zw;
	float3 positionWS = ComputeWorldSpacePosition(positionSS, depth, UNITY_MATRIX_I_VP);

    posInputs = GetPositionInput(positionSS, _ScreenSize.zw, positionWS);

	float4x4 worldToElement;
    worldToElement[0] = i.worldToDecal[0];
    worldToElement[1] = i.worldToDecal[1];
    worldToElement[2] = -i.worldToDecal[2];
	worldToElement[3] = float4(0,0,0,1);

    float3 positionDS = mul(worldToElement, float4(positionWS,1.0f)).xyz;
	clip(0.5f - abs(positionDS));

    float3x3 normalToWorld = transpose(float3x3(
                                    VFXSafeNormalize(worldToElement[0].xyz),
                                    VFXSafeNormalize(worldToElement[1].xyz),
                                    VFXSafeNormalize(worldToElement[2].xyz)));

	float2 uv = positionDS.xy + float2(0.5, 0.5);
	VFXUVData uvData = GetUVData(i,uv);
    float angleFadeFactor = 1.0f;

    receiverNormalWS = half3(0,1,0);
#if defined(DECAL_RECONSTRUCT_NORMAL)
    #if defined(_DECAL_NORMAL_BLEND_HIGH)
        receiverNormalWS = half3(ReconstructNormalTap9(i.pos.xy));
    #elif defined(_DECAL_NORMAL_BLEND_MEDIUM)
        receiverNormalWS = half3(ReconstructNormalTap5(i.pos.xy));
    #else
        receiverNormalWS = half3(ReconstructNormalDerivative(i.pos.xy));
    #endif
#elif defined(DECAL_LOAD_NORMAL)
        receiverNormalWS = half3(LoadSceneNormals(i.pos.xy));
#endif

	#ifdef DECAL_ANGLE_FADE
	if (i.VFX_VARYING_ANGLEFADE.y < 0.0f) // if angle fade is enabled
	{
        float3 decalNormal = float3(normalToWorld[0].z, normalToWorld[1].z, normalToWorld[2].z);
		float dotAngle = dot(receiverNormalWS, decalNormal);
        float2 angleFade = i.VFX_VARYING_ANGLEFADE;
		angleFadeFactor = saturate(angleFade.x + angleFade.y * (dotAngle * (dotAngle - 2.0)));
	}
	#endif

	float fadeFactor = i.VFX_VARYING_FADEFACTOR;
	fadeFactor *= angleFadeFactor;

//Compute color even for emissive, to have the correct opacity
    float4 color = float4(1,1,1,1);
    #if URP_USE_BASE_COLOR
        color *= VFXGetParticleColor(i);
    #elif URP_USE_ADDITIONAL_BASE_COLOR
        #if defined(VFX_VARYING_COLOR)
        color.xyz *= i.VFX_VARYING_COLOR;
        #endif
        #if defined(VFX_VARYING_ALPHA)
        color.a *= i.VFX_VARYING_ALPHA;
        #endif
    #endif
    #if URP_USE_BASE_COLOR_MAP
        float4 colorMap = SampleTexture(VFX_SAMPLER(baseColorMap),uvData);
        #if URP_USE_BASE_COLOR_MAP_COLOR
        color.xyz *= colorMap.xyz;
        #endif
        #if URP_USE_BASE_COLOR_MAP_ALPHA
        color.a *= colorMap.a;
        #endif
    #endif
	color.a *= fadeFactor;
    VFXClipFragmentColor(color.a,i);

    #if (SHADERPASS == SHADERPASS_DBUFFER_PROJECTOR) || (SHADERPASS == SHADERPASS_DECAL_SCREEN_SPACE_PROJECTOR) || (SHADERPASS == SHADERPASS_DECAL_GBUFFER_PROJECTOR)

        surfaceData.baseColor.rgb = saturate(color.rgb);
	    surfaceData.baseColor.a = color.a;

	    float albedoMapBlend = surfaceData.baseColor.a;
	    float maskMapBlend = fadeFactor;

        surfaceData.metallic = 0.0f;
        surfaceData.occlusion = 1.0f;

        #ifdef VFX_VARYING_METALLIC
            surfaceData.metallic = i.VFX_VARYING_METALLIC;
        #endif
        #ifdef VFX_VARYING_AMBIENT_OCCLUSION
            surfaceData.occlusion *= i.VFX_VARYING_AMBIENT_OCCLUSION;
        #endif

        surfaceData.smoothness = 0.5f;
        #ifdef VFX_VARYING_SMOOTHNESS
            surfaceData.smoothness = i.VFX_VARYING_SMOOTHNESS;
        #endif

        float4 metallicMapSample = (float4)1.0f;
        float4 specularMapSample = (float4)1.0f;
        #if URP_USE_METALLIC_MAP
            metallicMapSample = SampleTexture(VFX_SAMPLER(metallicMap), uvData);
            surfaceData.metallic *= metallicMapSample.r;
            maskMapBlend *= metallicMapSample.b;
        #endif

        #if URP_USE_OCCLUSION_MAP
            float4 mask = SampleTexture(VFX_SAMPLER(occlusionMap),uvData);
            surfaceData.occlusion *= mask.g;
        #endif

        #if URP_USE_SMOOTHNESS_IN_ALBEDO
            surfaceData.smoothness *= albedoMapBlend;
        #elif URP_USE_SMOOTHNESS_IN_METALLIC
            surfaceData.smoothness *= metallicMapSample.a;
        #elif URP_USE_SMOOTHNESS_IN_SPECULAR
            surfaceData.smoothness *= albedoMapBlend;//TODO: Not implemented yet;
        #endif

        #if  VFX_MAOS_BLEND_BASE_COLOR_ALPHA
	        surfaceData.MAOSAlpha = albedoMapBlend;
        #elif VFX_MAOS_BLEND_METALLIC_BLUE
	        surfaceData.MAOSAlpha = maskMapBlend;
        #endif

        float normalAlpha = 1.0f;

        //No Decal Surface Gradient in URP implementation of Decals
        #if USE_NORMAL_MAP
            float3 normalTS = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
        #else //USE_NORMAL_MAP
	        float3 normalTS = float3(0.0f,0.0f,1.0f);
	    #endif //USE_NORMAL_MAP
        float3 normalWS = mul(normalToWorld, normalTS);
	    normalWS = normalize(normalWS);

	    surfaceData.normalWS.xyz = normalWS;
        #ifdef VFX_VARYING_NORMALALPHA
            surfaceData.normalWS.w = i.VFX_VARYING_NORMALALPHA;
        #else
            surfaceData.normalWS.w = 0.0f;
        #endif

	    #if VFX_NORMAL_BLEND_BASE_COLOR_ALPHA
	        surfaceData.normalWS.w *= albedoMapBlend;
	    #elif VFX_NORMAL_BLEND_METALLIC_BLUE
	        surfaceData.normalWS.w *= maskMapBlend;
	    #endif
    #endif

	#if (SHADERPASS == SHADERPASS_FORWARD_EMISSIVE_PROJECTOR)  || (SHADERPASS == SHADERPASS_DECAL_SCREEN_SPACE_PROJECTOR) || (SHADERPASS == SHADERPASS_DECAL_GBUFFER_PROJECTOR)
        surfaceData.baseColor.a = color.a;
        surfaceData.emissive = float3(1,1,1) * fadeFactor;
        #if defined(VFX_VARYING_EMISSIVE) && (URP_USE_EMISSIVE_COLOR || URP_USE_ADDITIONAL_EMISSIVE_COLOR)
		    surfaceData.emissive *= i.VFX_VARYING_EMISSIVE;
		#else
            surfaceData.emissive = float3(0,0,0);
        #endif
		#ifdef URP_USE_EMISSIVE_MAP
		    float emissiveScale = 1.0f;
		    #ifdef VFX_VARYING_EMISSIVESCALE
		        emissiveScale = i.VFX_VARYING_EMISSIVESCALE;
		    #endif
		    surfaceData.emissive *= SampleTexture(VFX_SAMPLER(emissiveMap), uvData).rgb * emissiveScale;
		#endif
	#endif
}

void PrepareSurfaceAndInputData(VFX_VARYING_PS_INPUTS i, inout SurfaceData surfaceData, inout DecalSurfaceData decalSurfaceData, inout InputData inputData)
{
    PositionInputs posInput;
    ZERO_INITIALIZE(PositionInputs, posInput);
    half3 receiverNormalWS;
    VFXGetSurfaceDecalData(decalSurfaceData, posInput, receiverNormalWS, i);

    GetSurfaceDataFromSurfaceDecalData(decalSurfaceData, surfaceData);

#if (SHADERPASS == SHADERPASS_DECAL_SCREEN_SPACE_PROJECTOR)
    decalSurfaceData.normalWS.xyz = normalize(lerp(receiverNormalWS.xyz, decalSurfaceData.normalWS.xyz, decalSurfaceData.normalWS.w));
#endif

    inputData = VFXGetInputData(i, posInput, decalSurfaceData.normalWS.xyz, true);
}




.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXDecal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXDecalVaryings.template---------------
.
.

#define URP_NEEDS_UVS (URP_USE_BASE_COLOR_MAP || URP_USE_MASK_MAP || USE_NORMAL_MAP || URP_USE_EMISSIVE_MAP)
#define URP_USE_EMISSIVE (URP_USE_EMISSIVE_MAP || URP_USE_EMISSIVE_COLOR || URP_USE_ADDITIONAL_EMISSIVE_COLOR)

${VFXBegin:VFXURPDecalVaryingsMacros}
#if (VFX_NEEDS_COLOR_INTERPOLATOR && URP_USE_BASE_COLOR) || URP_USE_ADDITIONAL_BASE_COLOR
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#endif


#if AFFECT_METALLIC
#define VFX_VARYING_METALLIC materialProperties.x
#endif

#if AFFECT_AMBIENT_OCCLUSION
#define VFX_VARYING_AMBIENT_OCCLUSION materialProperties.y
#endif

#if AFFECT_SMOOTHNESS
#define VFX_VARYING_SMOOTHNESS materialProperties.z
#endif

#if URP_USE_EMISSIVE_MAP
#define VFX_VARYING_EMISSIVESCALE materialProperties.w
#endif

#if URP_USE_EMISSIVE_COLOR || URP_USE_ADDITIONAL_EMISSIVE_COLOR
#define VFX_VARYING_EMISSIVE emissiveColor.rgb
#endif

#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT emissiveColor.a
#endif


#if USE_FLIPBOOK
#if USE_FLIPBOOK_ARRAY_LAYOUT
	#define VFX_VARYING_FLIPBOOKSIZE flipBookSize
#else
	#define VFX_VARYING_FLIPBOOKSIZE flipBookSize.xy
	#define VFX_VARYING_INVFLIPBOOKSIZE flipBookSize.zw
#endif
#if USE_FLIPBOOK_MOTIONVECTORS
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants.xy
#define VFX_VARYING_TEXINDEX builtInInterpolants.z
#define VFX_VARYING_TEXINDEXBLEND builtInInterpolants.w
#else
#define VFX_VARYING_TEXINDEX texIndices.x
#if USE_FLIPBOOK_INTERPOLATION
#define VFX_VARYING_TEXINDEXBLEND texIndices.y
#endif
#endif
#endif

#if USE_UV_SCALE_BIAS
#define VFX_VARYING_UV_SCALE scaleBias.xy
#define VFX_VARYING_UV_BIAS scaleBias.zw
#endif

#if USE_NORMAL_MAP
#define VFX_VARYING_NORMALALPHA normalAlpha
#endif

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_POSWS posWS
#define VFX_VARYING_FADEFACTOR fadeParameters.x
#if DECAL_ANGLE_FADE
#define VFX_VARYING_ANGLEFADE fadeParameters.yz
#endif
#if USE_ALPHA_TEST
#define VFX_VARYING_ALPHATHRESHOLD fadeParameters.w
#endif

${VFXEnd}

${VFXBegin:VFXURPDecalDeclareVaryings}

#if (VFX_NEEDS_COLOR_INTERPOLATOR && URP_USE_BASE_COLOR) || URP_USE_ADDITIONAL_BASE_COLOR
VFX_OPTIONAL_INTERPOLATION float4 color : COLOR0;
#endif
#if URP_USE_EMISSIVE
VFX_OPTIONAL_INTERPOLATION float4 emissiveColor : COLOR2;
#endif

// x: metallic
// y: AO
// z: smoothness
// w: emissive scale
VFX_OPTIONAL_INTERPOLATION float4 materialProperties : TEXCOORD0;
#if USE_FLIPBOOK
#if USE_FLIPBOOK_ARRAY_LAYOUT
	nointerpolation float flipBookSize : TEXCOORD1;
#else
	nointerpolation float4 flipBookSize : TEXCOORD1;
#endif
#if USE_FLIPBOOK_MOTIONVECTORS
// x: motion vectors scale X
// y: motion vectors scale Y
// z: texIndex
// w: texIndexBlend
nointerpolation float4 builtInInterpolants : TEXCOORD2;
#else
// x: texIndex
// y: texIndexBlend
nointerpolation float2 texIndices : TEXCOORD2;
#endif
#endif

#if USE_UV_SCALE_BIAS
nointerpolation float4 scaleBias : TEXCOORD1;
#endif

float3 posWS : TEXCOORD3;
#if USE_ALPHA_TEST
// x: fade factor
// y: angle fade start
// z: angle fade end
// w: alpha threshold
nointerpolation float4 fadeParameters : TEXCOORD4;
#else
// x: fade factor
// y: angle fade start
// z: angle fade end
nointerpolation float3 fadeParameters : TEXCOORD4;
#endif

nointerpolation float4 worldToDecal[3] : TEXCOORD5;

#if USE_NORMAL_MAP
VFX_OPTIONAL_INTERPOLATION float normalAlpha : TEXCOORD8;
#endif

VFX_VERTEX_OUTPUT_INSTANCE_INDEX
${VFXEnd}

${VFXBegin:VFXURPDecalFillVaryings}
#ifndef VFX_SHADERGRAPH

#ifdef VFX_VARYING_SMOOTHNESS
${VFXLoadParameter:{smoothness}}
o.VFX_VARYING_SMOOTHNESS = smoothness;
#endif

#ifdef VFX_VARYING_METALLIC
${VFXLoadParameter:{metallic}}
o.VFX_VARYING_METALLIC = metallic;
#endif

#ifdef VFX_VARYING_AMBIENT_OCCLUSION
${VFXLoadParameter:{ambientOcclusion}}
o.VFX_VARYING_AMBIENT_OCCLUSION = ambientOcclusion;
#endif

#if URP_USE_EMISSIVE_MAP
#ifdef VFX_VARYING_EMISSIVESCALE
${VFXLoadParameter:{emissiveScale}}
o.VFX_VARYING_EMISSIVESCALE = emissiveScale;
#endif
#endif

#ifdef VFX_VARYING_EMISSIVE
#if URP_USE_EMISSIVE_COLOR
o.VFX_VARYING_EMISSIVE = attributes.color;
#elif URP_USE_ADDITIONAL_EMISSIVE_COLOR
${VFXLoadParameter:{emissiveColor}}
o.VFX_VARYING_EMISSIVE = emissiveColor.rgb;
#endif
#endif

#if URP_USE_ADDITIONAL_BASE_COLOR
#ifdef VFX_VARYING_COLOR
${VFXLoadParameter:{baseColor}}
o.VFX_VARYING_COLOR = baseColor;
#endif
#endif
#endif

float4x4 worldToDecal = GetVFXToElementMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

#if VFX_LOCAL_SPACE
worldToDecal = mul(worldToDecal, VFXGetWorldToObjectMatrix());
#endif

for (int k = 0; k < 3; k++)
{
    o.worldToDecal[k] = worldToDecal[k];
}

#ifdef VFX_VARYING_NORMALALPHA
${VFXLoadParameter:{normalAlpha}}
o.VFX_VARYING_NORMALALPHA = normalAlpha;
#endif
${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXDecalVaryings.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXLit.template---------------
.
.
#include "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXLit.hlsl"

#ifndef VFX_SHADERGRAPH

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
#define SurfaceData SixWaySurfaceData
#endif

void VFXGetURPLitData(out SurfaceData surfaceData, out InputData inputData, VFX_VARYING_PS_INPUTS i, float3 normalWS, const VFXUVData uvData, bool frontFace, uint2 tileIndex)
{
    float3 posRWS = VFXGetPositionRWS(i);
    float4 posSS = i.VFX_VARYING_POSCS;
    PositionInputs posInput = GetPositionInput(posSS.xy, _ScreenSize.zw, posSS.z, posSS.w, posRWS, tileIndex);

    surfaceData = VFXGetSurfaceData(i, normalWS, uvData);
    inputData = VFXGetInputData(i, posInput, normalWS, frontFace);
}
#endif


#include "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXLitPixelOutput.hlsl"

.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXLit.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXLitVaryings.template---------------
.
.

#define URP_NEEDS_UVS (URP_USE_BASE_COLOR_MAP || URP_USE_MASK_MAP || USE_NORMAL_MAP || URP_USE_EMISSIVE_MAP)
#define URP_USE_EMISSIVE (URP_USE_EMISSIVE_MAP || URP_USE_EMISSIVE_COLOR || URP_USE_ADDITIONAL_EMISSIVE_COLOR || VFX_SIX_WAY_USE_ONE_EMISSIVE_CHANNEL)

${VFXInclude("Shaders/SixWay/SixWayVaryings.template"), VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}

${VFXBegin:VFXURPLitVaryingsMacros}
#if (VFX_NEEDS_COLOR_INTERPOLATOR && URP_USE_BASE_COLOR) || URP_USE_ADDITIONAL_BASE_COLOR
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#endif

#ifndef VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
    #define VFX_VARYING_SMOOTHNESS materialProperties.x
    #if URP_USE_EMISSIVE_MAP
        #define VFX_VARYING_EMISSIVESCALE materialProperties.w
    #endif
#endif

#if URP_USE_EMISSIVE_COLOR || URP_USE_ADDITIONAL_EMISSIVE_COLOR
#define VFX_VARYING_EMISSIVE emissiveColor.rgb
#endif

#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT emissiveColor.a
#endif

#if URP_WORKFLOW_MODE_METALLIC
#define VFX_VARYING_METALLIC materialProperties.y
#elif URP_WORKFLOW_MODE_SPECULAR
#define VFX_VARYING_SPECULAR specularColor
#endif

#if USE_NORMAL_MAP
#define VFX_VARYING_NORMALSCALE materialProperties.z
#endif

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
    ${SixWayVaryingsMacros}
#endif

${VFXEnd}

${VFXBegin:VFXURPLitDeclareVaryings}

#if (VFX_NEEDS_COLOR_INTERPOLATOR && URP_USE_BASE_COLOR) || URP_USE_ADDITIONAL_BASE_COLOR
VFX_OPTIONAL_INTERPOLATION float4 color : COLOR0;
#endif
#if URP_WORKFLOW_MODE_SPECULAR
VFX_OPTIONAL_INTERPOLATION float3 specularColor : COLOR1;
#endif
#if URP_USE_EMISSIVE_COLOR || URP_USE_ADDITIONAL_EMISSIVE_COLOR
VFX_OPTIONAL_INTERPOLATION float4 emissiveColor : COLOR2;
#endif

#ifndef VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
// x: smoothness
// y: metallic/thickness
// z: normal scale
// w: emissive scale
VFX_OPTIONAL_INTERPOLATION float4 materialProperties : TEXCOORD0;
#endif

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
${SixWayDeclareVaryings}
#endif

${VFXEnd}

${VFXBegin:VFXURPLitFillVaryings}
#ifndef VFX_SHADERGRAPH
#ifdef VFX_VARYING_SMOOTHNESS
${VFXLoadParameter:{smoothness}}
o.VFX_VARYING_SMOOTHNESS = smoothness;
#endif
#if URP_WORKFLOW_MODE_METALLIC
#ifdef VFX_VARYING_METALLIC
${VFXLoadParameter:{metallic}}
o.VFX_VARYING_METALLIC = metallic;
#endif
#elif URP_WORKFLOW_MODE_SPECULAR
#ifdef VFX_VARYING_SPECULAR
${VFXLoadParameter:{specularColor}}
o.VFX_VARYING_SPECULAR = specularColor.rgb;
#endif
#endif
#if USE_NORMAL_MAP
#ifdef VFX_VARYING_NORMALSCALE
${VFXLoadParameter:{normalScale}}
o.VFX_VARYING_NORMALSCALE = normalScale;
#endif
#endif
#if URP_USE_EMISSIVE_MAP
#ifdef VFX_VARYING_EMISSIVESCALE
${VFXLoadParameter:{emissiveScale}}
o.VFX_VARYING_EMISSIVESCALE = emissiveScale;
#endif
#endif
#ifdef VFX_VARYING_EMISSIVE
#if URP_USE_EMISSIVE_COLOR
o.VFX_VARYING_EMISSIVE = attributes.color;
#elif URP_USE_ADDITIONAL_EMISSIVE_COLOR
${VFXLoadParameter:{emissiveColor}}
o.VFX_VARYING_EMISSIVE = emissiveColor.rgb;
#endif
#endif
#if URP_USE_ADDITIONAL_BASE_COLOR
#ifdef VFX_VARYING_COLOR
${VFXLoadParameter:{baseColor}}
o.VFX_VARYING_COLOR = baseColor.rgb;
#endif
#endif

${SixWayFillVaryings}

#endif
${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXLitVaryings.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXPasses.template---------------
.
.
${VFXBegin:VFXPassForward}"UniversalForwardOnly"${VFXEnd}
${VFXBegin:VFXPassForward2D}"Universal2D"${VFXEnd}
${VFXBegin:VFXPassShadow}"ShadowCaster"${VFXEnd}
${VFXBegin:VFXPassVelocity}"MotionVectors"${VFXEnd}
${VFXBegin:VFXPassDepth}"DepthOnly"${VFXEnd}
${VFXBegin:VFXPassDepthNormal}"DepthNormalsOnly"${VFXEnd}

${VFXBegin:VFXPassDepthDefine}
#if defined(WRITE_NORMAL_BUFFER)
#define SHADERPASS SHADERPASS_DEPTHNORMALSONLY
#else
#define SHADERPASS SHADERPASS_DEPTHONLY
#endif
${VFXEnd}
${VFXBegin:VFXPassShadowDefine}#define SHADERPASS SHADERPASS_SHADOWS${VFXEnd}
${VFXBegin:VFXPassVelocityDefine}#define SHADERPASS SHADERPASS_MOTION_VECTORS${VFXEnd}

${VFXBegin:VFXPassForwardAdditionalPragma}
#pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION
#pragma multi_compile _ DEBUG_DISPLAY
#pragma multi_compile_fog
#include_with_pragmas "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Debug/Debugging3D.hlsl"
${VFXEnd}

${VFXBegin:VFXPassForwardLitAdditionalPragma}
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
#pragma multi_compile _ _ADDITIONAL_LIGHTS
#pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS
#pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING
#pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION
#pragma multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH
#pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION
#pragma multi_compile_fragment _ _LIGHT_COOKIES
#pragma multi_compile _ _LIGHT_LAYERS
#pragma multi_compile _ _FORWARD_PLUS
#include_with_pragmas "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl"
#include_with_pragmas "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ProbeVolumeVariants.hlsl"
#pragma multi_compile_fog
#pragma multi_compile _ DEBUG_DISPLAY
${VFXEnd}
${VFXBegin:VFXPassDepthAdditionalPragma}
#pragma multi_compile_fragment _ _GBUFFER_NORMALS_OCT
${VFXEnd}
${VFXBegin:VFXPassGBufferAdditionalPragma}
#pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING
#pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION
#pragma multi_compile_fragment _ _GBUFFER_NORMALS_OCT
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
#pragma multi_compile_fragment _ _RENDER_PASS_ENABLED
#include_with_pragmas "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ProbeVolumeVariants.hlsl"
//See Lit.shader, these multi_compile aren't used in GBuffer
//#pragma multi_compile _ _ADDITIONAL_LIGHTS
//#pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION
#pragma multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH
#include_with_pragmas "Packages/com.unity.render-pipelines.universal/ShaderLibrary/RenderingLayers.hlsl"
${VFXEnd}

${VFXBegin:VFXShaderGraphFunctionsInclude}
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"
#include_with_pragmas "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRendering.hlsl"
${VFXEnd}


${VFXBegin:VFXPassDepthCommonFragmentURPLit}
#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
${VFXPassShadowDefine}
#else
${VFXPassDepthDefine}
#endif
${VFXIncludeRP("VFXLit.template")}

#if defined(WRITE_NORMAL_BUFFER)
${SHADERGRAPH_PIXEL_CODE_DEPTHNORMALS}
#else
${SHADERGRAPH_PIXEL_CODE_DEPTHONLY}
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
int _ObjectId;
int _PassValue;
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
float4 _SelectionID;
#endif

#pragma fragment frag
void frag(ps_input i
#if USE_DOUBLE_SIDED
    , bool frontFace : SV_IsFrontFace
#endif
#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
    , out float4 outMotionVector : SV_Target0
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
    #if defined(WRITE_NORMAL_BUFFER)
    , out float4 outNormalBuffer : SV_Target0
    , out float4 outDepthColor : SV_Target1
    #else
    , out float4 outDepthColor : SV_Target0
    #endif
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
    , out float4 outColor : SV_Target0
#endif
)
{
    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
    VFXTransformPSInputs(i);
    ${VFXComputeNormalWS}

    #ifdef VFX_SHADERGRAPH
        ${VFXAdditionalInterpolantsPreparation}

        #if defined(WRITE_NORMAL_BUFFER)
        ${SHADERGRAPH_PIXEL_CALL_DEPTHNORMALS}
        #else
        ${SHADERGRAPH_PIXEL_CALL_DEPTHONLY}
        #endif

        float alpha = OUTSG.${SHADERGRAPH_PARAM_ALPHA};
    #else

        float alpha = VFXGetFragmentColor(i).a;
        #if URP_USE_BASE_COLOR_MAP_ALPHA
            alpha *= VFXGetTextureColor(VFX_SAMPLER(baseColorMap),i).a;
        #endif

         #if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
            #ifndef VFX_VARYING_NORMAL
			    const VFXUVData uvData = GetUVData(i);
		    #endif
            alpha *= SampleTexture(VFX_SAMPLER(positiveAxesLightmap),uvData).a;
            #if defined(VFX_VARYING_ALPHA_REMAP)
                alpha = SampleCurve(i.VFX_VARYING_ALPHA_REMAP, alpha);
            #endif
        #endif
    #endif

    VFXClipFragmentColor(alpha,i);

    #if defined(WRITE_NORMAL_BUFFER)
        #ifdef VFX_SHADERGRAPH
            #if HAS_SHADERGRAPH_PARAM_NORMALTS
                float3 n =  OUTSG.${SHADERGRAPH_PARAM_NORMALTS};
                normalWS = mul(n,tbn);
            #endif
        #endif
		VFXComputePixelOutputToNormalBuffer(i, normalWS, GetUVData(i), outNormalBuffer);
    #endif

    #if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
        ${VFXComputeOutputMotionVector}
        outMotionVector = encodedMotionVector;
    #elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
        // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly
        outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);
    #elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
        outColor = _SelectionID;
    #elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
        outDepthColor = float4(i.VFX_VARYING_POSCS.z, 0,0,0);
    #elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
        //void
    #else
        #error VFX_PASSDEPTH undefined
    #endif
}
${VFXEnd}

${VFXBegin:VFXUnlitDebugDisplay}
#if defined(DEBUG_DISPLAY)
    InputData inputData;
    SurfaceData surfaceData;
    ZERO_INITIALIZE(SurfaceData, surfaceData);
    ZERO_INITIALIZE(InputData, inputData);
    surfaceData.albedo = o.color.rgb;
    surfaceData.alpha = o.color.a;

    half4 debugColor;
    if (CanDebugOverrideOutputColor(inputData, surfaceData, debugColor))
    {
        o.color = debugColor;
    }
#endif
${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXPasses.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXSGSurfaceData.template---------------
.
.
SurfaceData surface;
surface = (SurfaceData)0;

surface.occlusion = 1.0f;

#if HAS_SHADERGRAPH_PARAM_ALPHA
    surface.alpha = OUTSG.${SHADERGRAPH_PARAM_ALPHA};
    VFXClipFragmentColor(surface.alpha, i);
#endif

#if HAS_SHADERGRAPH_PARAM_SMOOTHNESS
    surface.smoothness = OUTSG.${SHADERGRAPH_PARAM_SMOOTHNESS};
#endif

#if HAS_SHADERGRAPH_PARAM_METALLIC
    surface.metallic = OUTSG.${SHADERGRAPH_PARAM_METALLIC};
#endif

#if HAS_SHADERGRAPH_PARAM_BASECOLOR
    surface.albedo = OUTSG.${SHADERGRAPH_PARAM_BASECOLOR};
#endif

    surface.normalTS = float3(0, 0, 1);
#if HAS_SHADERGRAPH_PARAM_NORMALTS
    float3 n =  OUTSG.${SHADERGRAPH_PARAM_NORMALTS};
    normalWS = mul(n,tbn);
#endif

#if HAS_SHADERGRAPH_PARAM_EMISSION
    surface.emission = OUTSG.${SHADERGRAPH_PARAM_EMISSION};
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXSGSurfaceData.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXVertexProbeSampling.template---------------
.
.
${VFXBegin:VFXVertexProbeDeclareVaryings}
//Store a compacted version of the contributions in the six directions (3xfloat4)
#if defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)
#define INDIRECT_INTERPOLATION
#else
#define INDIRECT_INTERPOLATION nointerpolation
#endif

INDIRECT_INTERPOLATION float4 bakeDiffuseLighting[3] : BAKEDIFFUSE0;
${VFXEnd}

${VFXBegin:VFXVertexProbeVaryingsMacros}
#define VFX_VARYING_BAKE_DIFFUSE_LIGHTING bakeDiffuseLighting
${VFXEnd}

${VFXBegin:VFXVertexProbeFillVaryings}
#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
   EvaluateProbesSixWay(o);
#endif
${VFXEnd}

${VFXBegin:VFXVertexProbeDeclareFunctions}
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/SixWayLighting.hlsl"

void EvaluateProbesSixWay(inout VFX_VARYING_PS_INPUTS input)
{
    float3 positionWS = GetAbsolutePositionWS(input.VFX_VARYING_POSWS);
    float3 normalWS = input.VFX_VARYING_NORMAL.xyz;
    float3 tangentWS = input.VFX_VARYING_TANGENT.xyz;

    GatherDiffuseGIData(positionWS, normalWS, tangentWS, input.VFX_VARYING_BAKE_DIFFUSE_LIGHTING[0],
                                                         input.VFX_VARYING_BAKE_DIFFUSE_LIGHTING[1],
                                                         input.VFX_VARYING_BAKE_DIFFUSE_LIGHTING[2]);
}

${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\VFXVertexProbeSampling.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleBasicCube.template---------------
.
.
{
	SubShader
	{	
		Cull Back
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassSelection.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleHexahedron/PassBasicForward.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
		${VFXIncludeRP("Templates/ParticleHexahedron/PassForward2D.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleBasicCube.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleCube.template---------------
.
.
{
	SubShader
	{	
		Cull Back
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassForward.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleHexahedron/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleCube.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleDecal.template---------------
.
.
{
	SubShader
	{	
		Cull Back
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleDecals/PassSelection.template")}
		${VFXInclude("Shaders/ParticleDecals/PassForward.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleDecal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesHW.template---------------
.
.
{
	SubShader
	{	
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleLines/PassSelection.template")}
		${VFXInclude("Shaders/ParticleLines/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleLines/PassDepthNormal.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleLines/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticleLines/PassForward.template")}
		${VFXInclude("Shaders/ParticleLines/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
		${VFXIncludeRP("Templates/ParticleLines/PassForward2D.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesHW.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesSW.template---------------
.
.
{
	SubShader
	{	
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleLinesSW/PassSelection.template")}
		${VFXInclude("Shaders/ParticleLinesSW/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleLinesSW/PassDepthNormal.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleLinesSW/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticleLinesSW/PassForward.template")}
		${VFXInclude("Shaders/ParticleLinesSW/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
		${VFXIncludeRP("Templates/ParticleLinesSW/PassForward2D.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLinesSW.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLitMesh.template---------------
.
.
{
    SubShader
    {
        ${VFXInclude("Shaders/VFXParticleHeader.template")}
        ${VFXIncludeRP("Templates/ParticleMeshesLit/PassSelection.template")}
        ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepth.template"),IS_OPAQUE_PARTICLE}
        ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepthNormal.template"),IS_OPAQUE_PARTICLE}
        ${VFXIncludeRP("Templates/ParticleMeshesLit/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
        ${VFXIncludeRP("Templates/ParticleMeshesLit/PassGBuffer.template"), !VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}
        ${VFXIncludeRP("Templates/ParticleMeshesLit/PassForward.template")}
        ${VFXIncludeRP("Templates/ParticleMeshesLit/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLitMesh.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLitPlanarPrimitive.template---------------
.
.
{
    SubShader
    {
        Cull Off

        ${VFXInclude("Shaders/VFXParticleHeader.template")}
        ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassSelection.template")}
        ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepth.template"),IS_OPAQUE_PARTICLE}
        ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepthNormal.template"),IS_OPAQUE_PARTICLE}
        ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
        ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassGBuffer.template"), !VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}
        ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassForward.template")}
        ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleLitPlanarPrimitive.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleMeshes.template---------------
.
.
{
	SubShader
	{
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleMeshes/PassSelection.template")}
		${VFXInclude("Shaders/ParticleMeshes/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleMeshes/PassDepthNormal.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticleMeshes/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticleMeshes/PassForward.template")}
		${VFXInclude("Shaders/ParticleMeshes/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
		${VFXIncludeRP("Templates/ParticleMeshes/PassForward2D.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleMeshes.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticlePlanarPrimitive.template---------------
.
.
{
	SubShader
	{	
		Cull Off
		
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassSelection.template")}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepthNormal.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassForward.template")}
		${VFXInclude("Shaders/ParticlePlanarPrimitives/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
		${VFXIncludeRP("Templates/ParticlePlanarPrimitives/PassForward2D.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticlePlanarPrimitive.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticlePoints.template---------------
.
.
{
	SubShader
	{	
		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticlePoints/PassSelection.template")}
		${VFXInclude("Shaders/ParticlePoints/PassDepth.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticlePoints/PassDepthNormal.template"),IS_OPAQUE_PARTICLE}
		${VFXInclude("Shaders/ParticlePoints/PassVelocity.template"),USE_MOTION_VECTORS_PASS}
		${VFXInclude("Shaders/ParticlePoints/PassForward.template")}
		${VFXInclude("Shaders/ParticlePoints/PassShadowCaster.template"),USE_CAST_SHADOWS_PASS}
		${VFXIncludeRP("Templates/ParticlePoints/PassForward2D.template")}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticlePoints.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleURPDecal.template---------------
.
.
{
	SubShader
	{
		HLSLINCLUDE
		#define mainTexture baseColorMap
		ENDHLSL

		${VFXInclude("Shaders/VFXParticleHeader.template")}
		${VFXInclude("Shaders/ParticleHexahedron/PassSelection.template")}
		${VFXIncludeRP("Templates/URPDecal/PassDBuffer.template")}
		${VFXIncludeRP("Templates/URPDecal/PassGBuffer.template")}
		${VFXIncludeRP("Templates/URPDecal/PassScreenSpace.template")}
		${VFXIncludeRP("Templates/URPDecal/PassForwardEmissive.template"), AFFECT_EMISSIVE}
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\VFXParticleURPDecal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleHexahedron\PassForward2D.template---------------
.
.
// 2D Pass
Pass
{		
	Tags { "LightMode"=${VFXPassForward2D} }
	
	HLSLPROGRAM
	#pragma target 4.5	
	${VFXInclude("Shaders/ParticleHexahedron/PassBasicForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleHexahedron\PassForward2D.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleLines\PassForward2D.template---------------
.
.
// 2D Pass
Pass
{		
	Tags { "LightMode"=${VFXPassForward2D} }
	
	HLSLPROGRAM
	#pragma target 4.5
	${VFXInclude("Shaders/ParticleLines/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleLines\PassForward2D.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleLinesSW\PassForward2D.template---------------
.
.
// 2D pass
Pass
{		
	Tags { "LightMode"=${VFXPassForward2D} }
	
	HLSLPROGRAM
	#pragma target 4.5
	${VFXInclude("Shaders/ParticleLinesSW/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleLinesSW\PassForward2D.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshes\PassForward2D.template---------------
.
.
// Forward pass
Pass
{		
	Tags { "LightMode"=${VFXPassForward2D} }
	
	HLSLPROGRAM
	#pragma target 4.5
	${VFXInclude("Shaders/ParticleMeshes/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshes\PassForward2D.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\Pass.template---------------
.
.
#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS and VFX_VARYING_UV must be defined.
#endif

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD0;
    #if VFX_SHADERGRAPH_HAS_UV1
    float4 uv1 : TEXCOORD1;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV2
    float4 uv2 : TEXCOORD2;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV3
    float4 uv3 : TEXCOORD3;
    #endif
    #if VFX_SHADERGRAPH_HAS_COLOR
    float4 vertexColor : COLOR;
    #endif
    float3 normal : NORMAL;
    #if defined(VFX_VARYING_TANGENT) || SHADERGRAPH_HAS_NORMAL
    float4 tangent : TANGENT;
    #endif
    VFX_DECLARE_INSTANCE_ID
};

#pragma vertex vert
VFX_VARYING_PS_INPUTS vert(vs_input i)
{
    VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

    UNITY_SETUP_INSTANCE_ID(i);
    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

    uint index = VFX_GET_INSTANCE_ID(i);

    ${VFXInitInstancing}
    ${VFXLoadGraphValues}

    ${VFXLoadContextData}
    uint systemSeed = contextData.systemSeed;
    uint nbMax = contextData.maxParticleCount;

    ${VFXLoadAttributesOrCull}
    ${VFXProcessBlocks}

    if (!attributes.alive)
        return o;

    o.VFX_VARYING_UV.xy = i.uv;

    #if VFX_SHADERGRAPH_HAS_UV1
    o.uv1 = i.uv1;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV2
    o.uv2 = i.uv2;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV3
    o.uv3 = i.uv3;
    #endif
    #if VFX_SHADERGRAPH_HAS_COLOR
    o.vertexColor = i.vertexColor;
    #endif

    ${VFXLoadSize}

    float3 inputVertexPosition = i.pos;
    float4x4 elementToVFX = GetElementToVFXMatrix(
        attributes.axisX,
        attributes.axisY,
        attributes.axisZ,
        float3(attributes.angleX,attributes.angleY,attributes.angleZ),
        float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
        size3,
        attributes.position);

    float3 vPos = mul(elementToVFX,float4(inputVertexPosition,1.0f)).xyz;
    float4 csPos = TransformPositionVFXToClip(vPos);
    o.VFX_VARYING_POSCS = csPos;

    // TODO This is needed only if in local space (to handle non uniform scale) or if scale attributes are stored/written (no way to know atm)
    float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
        attributes.axisX,
        attributes.axisY,
        attributes.axisZ,
        float3(attributes.angleX,attributes.angleY,attributes.angleZ),
        size3);

    float3 normalWS = normalize(TransformNormalVFXToWorld(mul(elementToVFX_N, i.normal)));
    #ifdef VFX_VARYING_NORMAL
    o.VFX_VARYING_NORMAL = normalWS;
    #endif
    #ifdef VFX_VARYING_TANGENT
    o.VFX_VARYING_TANGENT = float4(normalize(TransformDirectionVFXToWorld(mul((float3x3)elementToVFX,i.tangent.xyz))),i.tangent.w);
    #endif

    ${VFXVertexComputeCurrentAndPreviousClipPos}

    ${VFXVertexCommonProcess}

    ${VFXVertexSetFlipbooksInterpolants}

    ${VFXVertexAdditionalProcess}

    ${VFXAdditionalInterpolantsGeneration}

    return o;
}

${VFXBegin:VFXComputeNormalWS}
#ifdef VFX_VARYING_NORMAL
#if USE_DOUBLE_SIDED
const float faceMul = frontFace ? 1.0f : -1.0f;
#else
const float faceMul = 1.0f;
#endif

float3 normalWS = normalize(i.VFX_VARYING_NORMAL * faceMul);
const VFXUVData uvData = GetUVData(i);

#ifdef VFX_VARYING_TANGENT
float3 tangentWS = normalize(i.VFX_VARYING_TANGENT.xyz);
float3 bitangentWS = cross(normalWS,tangentWS) * (i.VFX_VARYING_TANGENT.w * faceMul);
float3x3 tbn = float3x3(tangentWS,bitangentWS,normalWS);

#if USE_NORMAL_MAP
float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
float normalScale = 1.0f;
#ifdef VFX_VARYING_NORMALSCALE
normalScale = i.VFX_VARYING_NORMALSCALE;
#endif
normalWS = normalize(lerp(normalWS,mul(n,tbn),normalScale));
#endif
#endif
#endif
${VFXEnd}

${VFXBegin:VFXVertexAdditionalProcess}${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassDepth.template---------------
.
.
Pass
{
    Tags { "LightMode"="DepthOnly" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
    ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassDepthNormal.template---------------
.
.
Pass
{
    Tags { "LightMode"="DepthNormals" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
    #define WRITE_NORMAL_BUFFER
    ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassDepthNormal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassDepthOrMV.template---------------
.
.
#pragma target 4.5

#if defined(WRITE_NORMAL_BUFFER)
#define NEEDS_NORMAL 1
#elif (SHADERPASS == SHADERPASS_DEPTHONLY)
#define NEEDS_NORMAL SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY
#elif (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
#define NEEDS_NORMAL SHADERGRAPH_NEEDS_NORMAL_DEPTHNORMALS
#else
#define NEEDS_NORMAL 0
#endif

#if defined(WRITE_NORMAL_BUFFER)
#define NEEDS_TANGENT 1
#elif (SHADERPASS == SHADERPASS_DEPTHONLY)
#define NEEDS_TANGENT SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
#elif (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
#define NEEDS_TANGENT SHADERGRAPH_NEEDS_TANGENT_DEPTHNORMALS
#else
#define NEEDS_TANGENT 0
#endif

struct ps_input
{        
    float4 pos : SV_POSITION;
    #if USE_FLIPBOOK_INTERPOLATION
        float4 uv : TEXCOORD0;
    #else
        #if USE_FLIPBOOK_ARRAY_LAYOUT
        float3 uv : TEXCOORD0;
        #else
        float2 uv : TEXCOORD0;
        #endif    
    #endif
    #if VFX_SHADERGRAPH_HAS_UV1
    float4 uv1 : COLOR2;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV2
    float4 uv2 : COLOR3;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV3
    float4 uv3 : COLOR4;
    #endif
    #if VFX_SHADERGRAPH_HAS_COLOR
    float4 vertexColor : COLOR1;
    #endif
    #if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
    // x: alpha threshold
    // y: frame blending factor
    // z: alpha
    // w: smoothness
    nointerpolation float4 builtInInterpolants : TEXCOORD1;
    #endif
    #if USE_FLIPBOOK_MOTIONVECTORS
    // x: motion vector scale u
    // y: motion vector scale v
    nointerpolation float2 builtInInterpolants2 : TEXCOORD3;
    #endif
    #if NEEDS_NORMAL
    float3 normal : TEXCOORD4;
    #if NEEDS_TANGENT
    float4 tangent : TEXCOORD5;
    #endif
    #endif

    #if VFX_NEEDS_POSWS_INTERPOLATOR
    float3 posWS : TEXCOORD6;
    #endif

    #if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
    VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
    #endif

    ${VFXAdditionalInterpolantsDeclaration}
    
    UNITY_VERTEX_OUTPUT_STEREO
    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.z
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if NEEDS_NORMAL
#define VFX_VARYING_NORMAL normal
#endif

#if NEEDS_TANGENT
#define VFX_VARYING_TANGENT tangent
#endif

#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXURPLitFillVaryings}
${VFXEnd}

${VFXInclude("Shaders/ParticleMeshes/Pass.template")}
${VFXPassDepthCommonFragmentURPLit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Tags { "LightMode"="${VFXURPForwardPassName}" }

    ${VFXStencilForward}

    HLSLPROGRAM
    #pragma target 4.5
    ${VFXPassForwardLitAdditionalPragma}
    ${VFXURPForwardDefines}

    ${VFXIncludeRP("VFXLitVaryings.template")}
	${VFXIncludeRP("VFXVertexProbeSampling.template"),VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}

    struct ps_input
    {
        float4 pos : SV_POSITION;

        ${VFXURPLitDeclareVaryings}

        #if USE_FLIPBOOK_INTERPOLATION
        float4 uv : TEXCOORD1;
        #else
        #if USE_FLIPBOOK_ARRAY_LAYOUT
        float3 uv : TEXCOORD1;
        #else
        float2 uv : TEXCOORD1;
        #endif
        #endif
        #if VFX_SHADERGRAPH_HAS_UV1
        float4 uv1 : COLOR2;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV2
        float4 uv2 : COLOR3;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV3
        float4 uv3 : COLOR4;
        #endif
        #if VFX_SHADERGRAPH_HAS_COLOR
        float4 vertexColor : COLOR1;
        #endif
        float3 normal : TEXCOORD2;
        #if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
        float4 tangent : TEXCOORD3;
        #endif
        #if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_FEATURE_MOTION_VECTORS_FORWARD
        // x: inverse soft particles fade distance
        // y: alpha threshold
        // z: frame blending factor
        nointerpolation float3 builtInInterpolants : TEXCOORD4;
        #endif

        #if USE_FLIPBOOK_MOTIONVECTORS
        // x: motion vector scale u
        // y: motion vector scale v
        nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
        #endif

        float3 posWS : TEXCOORD6; // Needed for fog

        ${VFXAdditionalInterpolantsDeclaration}

        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };

${VFXURPLitVaryingsMacros}

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
${VFXVertexProbeVaryingsMacros}
#endif

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_NORMAL normal
#if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
#define VFX_VARYING_TANGENT tangent
#endif
#define VFX_VARYING_POSWS posWS

${VFXVertexProbeDeclareFunctions}

${VFXBegin:VFXVertexAdditionalProcess}
${VFXURPLitFillVaryings}
${VFXVertexProbeFillVaryings}
${VFXEnd}

    ${VFXIncludeRP("Templates/ParticleMeshesLit/Pass.template")}
    #define SHADERPASS SHADERPASS_FORWARD
    ${VFXIncludeRP("VFXLit.template")}

    ${SHADERGRAPH_PIXEL_CODE_FORWARD}

    #pragma fragment frag
    void frag(ps_input i
    , out float4 outColor : SV_Target0
#if USE_DOUBLE_SIDED
    , bool frontFace : SV_IsFrontFace
#endif
    )
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
        VFXTransformPSInputs(i);
        VFX_FRAG_SETUP_INSTANCE_ID(i);
        ${VFXComputeNormalWS}

#if !USE_DOUBLE_SIDED
		const bool frontFace = true;
#endif

        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_FORWARD}

            ${VFXIncludeRP("VFXSGSurfaceData.template")}
            outColor = VFXGetPixelOutputForwardShaderGraph(i, surface, normalWS);
        #else
            outColor = VFXGetPixelOutputForward(i, normalWS, uvData, frontFace);
        #endif
    }
    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassGBuffer.template---------------
.
.
Pass
{
    Tags { "LightMode"="UniversalGBuffer" }

    ${VFXStencilGBuffer}

    HLSLPROGRAM
    #pragma target 4.5
    ${VFXPassGBufferAdditionalPragma}
    ${VFXURPGBufferDefines}

    ${VFXIncludeRP("VFXLitVaryings.template")}

    struct ps_input
    {
        float4 pos : SV_POSITION;

        ${VFXURPLitDeclareVaryings}

        #if USE_FLIPBOOK_INTERPOLATION
        float4 uv : TEXCOORD1;
        #else
        #if USE_FLIPBOOK_ARRAY_LAYOUT
        float3 uv : TEXCOORD1;
        #else
        float2 uv : TEXCOORD1;
        #endif
        #endif
        #if VFX_SHADERGRAPH_HAS_UV1
        float4 uv1 : COLOR2;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV2
        float4 uv2 : COLOR3;
        #endif
        #if VFX_SHADERGRAPH_HAS_UV3
        float4 uv3 : COLOR4;
        #endif
        #if VFX_SHADERGRAPH_HAS_COLOR
        float4 vertexColor : COLOR1;
        #endif
        float3 normal : TEXCOORD2;
        #if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
        float4 tangent : TEXCOORD3;
        #endif
        #if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION
        // x: inverse soft particles fade distance
        // y: alpha threshold
        // z: frame blending factor
        nointerpolation float3 builtInInterpolants : TEXCOORD4;
        #endif
        #if USE_FLIPBOOK_MOTIONVECTORS
        // x: motion vector scale u
        // y: motion vector scale v
        nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
        #endif

        float3 posWS : TEXCOORD6; //Needed for GI

        ${VFXAdditionalInterpolantsDeclaration}

        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };

    struct ps_output
    {
        float4 color : SV_Target0;
    };

${VFXURPLitVaryingsMacros}

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_NORMAL normal

#if USE_NORMAL_MAP || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
#define VFX_VARYING_TANGENT tangent
#endif
#define VFX_VARYING_POSWS posWS

${VFXBegin:VFXVertexAdditionalProcess}
${VFXURPLitFillVaryings}
${VFXEnd}

    ${VFXInclude("Shaders/ParticleMeshes/Pass.template")}
    #define SHADERPASS SHADERPASS_GBUFFER
    ${VFXIncludeRP("VFXLit.template")}

    ${SHADERGRAPH_PIXEL_CODE_GBUFFER}

    #pragma fragment frag
    void frag(ps_input i
    , out FragmentOutput outGBuffer
#if USE_DOUBLE_SIDED
    , bool frontFace : SV_IsFrontFace
#endif
    )
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
        VFXTransformPSInputs(i);
        VFX_FRAG_SETUP_INSTANCE_ID(i);
        ${VFXComputeNormalWS}

        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_GBUFFER}
            ${VFXIncludeRP("VFXSGSurfaceData.template")}

            VFXComputePixelOutputToGBufferShaderGraph(i, surface, normalWS, outGBuffer);
        #else
            VFXComputePixelOutputToGBuffer(i, normalWS, uvData, outGBuffer);
        #endif
    }
    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassGBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassSelection.template---------------
.
.
Pass
{
    Tags { "LightMode"="SceneSelectionPass" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
    ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepthOrMV.template")}

    ENDHLSL
}

Pass
{
    Tags { "LightMode"="Picking" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
    ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
    Tags { "LightMode"=${VFXPassShadow} }

    ZClip [_ZClip]
    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_SHADOW
    #if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
    #define USE_ALPHA_TEST 1
    #endif
    ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepthOrMV.template")}
    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassVelocity.template---------------
.
.
Pass
{
    Tags { "LightMode"="MotionVectors" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
    ${VFXIncludeRP("Templates/ParticleMeshesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticleMeshesLit\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitives\PassForward2D.template---------------
.
.
// Forward pass
Pass
{		
	Tags { "LightMode"=${VFXPassForward2D} }
	
	HLSLPROGRAM
	#pragma target 4.5
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitives\PassForward2D.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassDepth.template---------------
.
.
Pass
{
    Tags { "LightMode"="DepthOnly" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
    ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassDepthNormal.template---------------
.
.
Pass
{
    Tags { "LightMode"="DepthNormals" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
    #define WRITE_NORMAL_BUFFER
    ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassDepthNormal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassDepthOrMV.template---------------
.
.
#pragma target 4.5

#if defined(WRITE_NORMAL_BUFFER) || FORCE_NORMAL_VARYING
#define NEEDS_NORMAL 1
#elif (SHADERPASS == SHADERPASS_DEPTHONLY)
#define NEEDS_NORMAL SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY
#elif (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
#define NEEDS_NORMAL SHADERGRAPH_NEEDS_NORMAL_DEPTHNORMALS
#else
#define NEEDS_NORMAL 0
#endif

#if defined(WRITE_NORMAL_BUFFER)
#define NEEDS_TANGENT 1
#elif (SHADERPASS == SHADERPASS_DEPTHONLY)
#define NEEDS_TANGENT SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
#elif (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
#define NEEDS_TANGENT SHADERGRAPH_NEEDS_TANGENT_DEPTHNORMALS
#else
#define NEEDS_TANGENT 0
#endif

#define NEEDS_WORLDPOS VFX_NEEDS_POSWS_INTERPOLATOR

struct ps_input
{
    float4 pos : SV_POSITION;
    #if USE_FLIPBOOK_INTERPOLATION
    float4 uv : TEXCOORD0;
    #else
        #if USE_FLIPBOOK_ARRAY_LAYOUT
        float3 uv : TEXCOORD0;
        #else
        float2 uv : TEXCOORD0;    
        #endif
    #endif
    #if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
    // x: alpha threshold
    // y: frame blending factor
    // z: alpha
    // w: smoothness
    VFX_OPTIONAL_INTERPOLATION float4 builtInInterpolants : TEXCOORD1;
    #endif
    
    #if USE_FLIPBOOK_MOTIONVECTORS
    // x: motion vector scale u
    // y: motion vector scale v
    VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD2;
    #endif
    
    #if NEEDS_NORMAL
    float4 normal : TEXCOORD3; // normal scale is stored in w
    #endif
    #if NEEDS_TANGENT
    float3 tangent : TEXCOORD4;
    #endif
    #if USE_NORMAL_BENDING
    float2 bentFactors : TEXCOORD5;
    #endif
    #if NEEDS_WORLDPOS
    float3 posWS : TEXCOORD6;
    #endif

    #if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
    VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
    #endif
    
    ${VFXAdditionalInterpolantsDeclaration}

    UNITY_VERTEX_OUTPUT_STEREO
    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.z
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if NEEDS_NORMAL
#define VFX_VARYING_NORMAL normal.xyz
#endif
#if NEEDS_TANGENT
#define VFX_VARYING_TANGENT tangent
#endif
#if NEEDS_WORLDPOS
#define VFX_VARYING_POSWS posWS
#endif
#if USE_NORMAL_MAP && NEEDS_NORMAL
#define VFX_VARYING_NORMALSCALE normal.w
#endif
#if USE_NORMAL_BENDING
#define VFX_VARYING_BENTFACTORS bentFactors
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXURPLitFillVaryings}
${VFXEnd}

${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
${VFXPassDepthCommonFragmentURPLit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Tags { "LightMode"="${VFXURPForwardPassName}"}

    ${VFXStencilForward}

    HLSLPROGRAM
    #pragma target 4.5
    ${VFXPassForwardLitAdditionalPragma}
    ${VFXURPForwardDefines}

    ${VFXIncludeRP("VFXLitVaryings.template")}
	${VFXIncludeRP("VFXVertexProbeSampling.template"),VFX_MATERIAL_TYPE_SIX_WAY_SMOKE}

    struct ps_input
    {
        float4 pos : SV_POSITION;

        ${VFXURPLitDeclareVaryings}

        #if USE_FLIPBOOK_INTERPOLATION
        float4 uv : TEXCOORD1;
        #else
        #if USE_FLIPBOOK_ARRAY_LAYOUT
        float3 uv : TEXCOORD1;
        #else
        float2 uv : TEXCOORD1;
        #endif
        #endif
        #if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_FEATURE_MOTION_VECTORS_FORWARD
        // x: inverse soft particles fade distance
        // y: alpha threshold
        // z: frame blending factor
        VFX_OPTIONAL_INTERPOLATION float3 builtInInterpolants : TEXCOORD2;
        #endif

        #if USE_FLIPBOOK_MOTIONVECTORS
        // x: motion vector scale u
        // y: motion vector scale v
        VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD3;
        #endif

        VFX_OPTIONAL_INTERPOLATION float3 normal : TEXCOORD4;
        #if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
        VFX_OPTIONAL_INTERPOLATION float3 tangent : TEXCOORD5;
        #endif
        #if USE_NORMAL_BENDING
        float2 bentFactors : TEXCOORD6;
        #endif

        float3 posWS : TEXCOOR9; // Needed for fog

        ${VFXAdditionalInterpolantsDeclaration}

        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };

${VFXURPLitVaryingsMacros}

#if VFX_MATERIAL_TYPE_SIX_WAY_SMOKE
${VFXVertexProbeVaryingsMacros}
#endif

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv
#define VFX_VARYING_NORMAL normal
#if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_FORWARD || VFX_MATERIAL_TYPE_SIX_WAY_SMOKE

#define VFX_VARYING_TANGENT tangent
#endif
#if USE_NORMAL_BENDING
#define VFX_VARYING_BENTFACTORS bentFactors
#endif
#define VFX_VARYING_POSWS posWS

${VFXVertexProbeDeclareFunctions}


${VFXBegin:VFXVertexAdditionalProcess}
${VFXURPLitFillVaryings}
${VFXVertexProbeFillVaryings}
${VFXEnd}

    ${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
    #define SHADERPASS SHADERPASS_FORWARD
    ${VFXIncludeRP("VFXLit.template")}

    ${SHADERGRAPH_PIXEL_CODE_FORWARD}

    #pragma fragment frag
    void frag(ps_input i
    , out float4 outColor : SV_Target0
    #if USE_DOUBLE_SIDED
    , bool frontFace : SV_IsFrontFace
    #endif
    #if VFX_FEATURE_MOTION_VECTORS_FORWARD
    , out float4 outMotionVector : SV_Target1
    #endif
    )
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
        VFXTransformPSInputs(i);
        VFX_FRAG_SETUP_INSTANCE_ID(i);
        ${VFXComputeNormalWS}
#if !USE_DOUBLE_SIDED
		const bool frontFace = true;
#endif
        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_FORWARD}

            ${VFXIncludeRP("VFXSGSurfaceData.template")}
            outColor = VFXGetPixelOutputForwardShaderGraph(i, surface, normalWS);
        #else
            outColor = VFXGetPixelOutputForward(i, normalWS, uvData, frontFace);
        #endif
    }
    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassGBuffer.template---------------
.
.
Pass
{
    Tags { "LightMode"="UniversalGBuffer" }

    ${VFXStencilGBuffer}

    HLSLPROGRAM
    #pragma target 4.5
    ${VFXPassGBufferAdditionalPragma}
    ${VFXURPGBufferDefines}

    ${VFXIncludeRP("VFXLitVaryings.template")}

    struct ps_input
    {
        float4 pos : SV_POSITION;

        ${VFXURPLitDeclareVaryings}

        #if USE_FLIPBOOK_INTERPOLATION
        float4 uv : TEXCOORD1;
        #else
        #if USE_FLIPBOOK_ARRAY_LAYOUT
        float3 uv : TEXCOORD1;
        #else
        float2 uv : TEXCOORD1;
        #endif
        #endif
        #if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION
        // x: inverse soft particles fade distance
        // y: alpha threshold
        // z: frame blending factor
        VFX_OPTIONAL_INTERPOLATION float3 builtInInterpolants : TEXCOORD2;
        #endif
        #if USE_FLIPBOOK_MOTIONVECTORS
        // x: motion vector scale u
        // y: motion vector scale v
        VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD3;
        #endif
        VFX_OPTIONAL_INTERPOLATION float3 normal : TEXCOORD4;
        #if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
        VFX_OPTIONAL_INTERPOLATION float3 tangent : TEXCOORD5;
        #endif
        #if USE_NORMAL_BENDING
        float2 bentFactors : TEXCOORD6;
        #endif

        float3 posWS : TEXCOORD7; //Needed for GI

        ${VFXAdditionalInterpolantsDeclaration}

        UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
    };

${VFXURPLitVaryingsMacros}

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv
#define VFX_VARYING_NORMAL normal
#if USE_NORMAL_MAP || USE_NORMAL_BENDING || SHADERGRAPH_NEEDS_TANGENT_GBUFFER
#define VFX_VARYING_TANGENT tangent
#endif
#define VFX_VARYING_POSWS posWS
#if USE_NORMAL_BENDING
#define VFX_VARYING_BENTFACTORS bentFactors
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXURPLitFillVaryings}
${VFXEnd}

    ${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
    #define SHADERPASS SHADERPASS_GBUFFER
    ${VFXIncludeRP("VFXLit.template")}

    ${SHADERGRAPH_PIXEL_CODE_GBUFFER}
    #pragma fragment frag
    void frag(ps_input i
    , out FragmentOutput outGBuffer
    #if USE_DOUBLE_SIDED
    , bool frontFace : SV_IsFrontFace
    #endif
    )
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
        VFXTransformPSInputs(i);
        VFX_FRAG_SETUP_INSTANCE_ID(i);
        ${VFXComputeNormalWS}

        #ifdef VFX_SHADERGRAPH
            ${VFXAdditionalInterpolantsPreparation}
            ${SHADERGRAPH_PIXEL_CALL_GBUFFER}
            ${VFXIncludeRP("VFXSGSurfaceData.template")}

            VFXComputePixelOutputToGBufferShaderGraph(i, surface, normalWS, outGBuffer);
        #else
            VFXComputePixelOutputToGBuffer(i, normalWS, uvData, outGBuffer);
        #endif
    }
    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassGBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassSelection.template---------------
.
.
Pass
{
    Tags { "LightMode"="SceneSelectionPass" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
    ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepthOrMV.template")}
    ENDHLSL
}

Pass
{
    Tags { "LightMode"="Picking" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
    ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepthOrMV.template")}
    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassShadowCaster.template---------------
.
.
Pass
{
    Tags { "LightMode"=${VFXPassShadow} }

    ZClip [_ZClip]
    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_SHADOW
    #if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
    #define USE_ALPHA_TEST 1
    #endif
    ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassVelocity.template---------------
.
.
Pass
{
    Tags { "LightMode"="MotionVectors" }

    ZWrite On
    Blend Off
    
    HLSLPROGRAM
    #define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
    ${VFXIncludeRP("Templates/ParticlePlanarPrimitivesLit/PassDepthOrMV.template")}

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePlanarPrimitivesLit\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePoints\PassForward2D.template---------------
.
.
// Forward pass
Pass
{		
	Tags { "LightMode"=${VFXPassForward2D} }
	
	HLSLPROGRAM
	#pragma target 4.5
	${VFXInclude("Shaders/ParticlePoints/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\ParticlePoints\PassForward2D.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassDBuffer.template---------------
.
.
Pass
{
    Name "DBufferProjectorVFX"
    Tags
    {
        "LightMode" = "DBufferProjectorVFX"
    }

    // Render State
    Cull Front
    Blend 0 SrcAlpha OneMinusSrcAlpha, Zero OneMinusSrcAlpha
    Blend 1 SrcAlpha OneMinusSrcAlpha, Zero OneMinusSrcAlpha
    Blend 2 SrcAlpha OneMinusSrcAlpha, Zero OneMinusSrcAlpha
    ZTest Greater
    ZWrite Off

    ColorMask ${VFXDBufferColorMask0}
    ColorMask ${VFXDBufferColorMask1} 1
    ColorMask ${VFXDBufferColorMask2} 2

    HLSLPROGRAM

    // Pragmas
    #pragma target 4.5
    #pragma exclude_renderers gles3 glcore
    #pragma editor_sync_compilation

    // Keywords
    #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3
    #include_with_pragmas "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl"
    #pragma multi_compile _ _DECAL_LAYERS

    ${VFXIncludeRP("VFXDecalVaryings.template")}
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DecalInput.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRendering.hlsl"

    struct ps_input
    {
        float4 pos : SV_POSITION;
        ${VFXURPDecalDeclareVaryings}
        UNITY_VERTEX_OUTPUT_STEREO
    };

    ${VFXURPDecalVaryingsMacros}

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXURPDecalFillVaryings}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}
    #define SHADERPASS SHADERPASS_DBUFFER_PROJECTOR
    #if defined(DECAL_ANGLE_FADE)
    #define DECAL_LOAD_NORMAL
    #endif

    ${VFXIncludeRP("VFXDecal.template")}

    #define VFXComputePixelOutputToDBuffer(i,outDBuffer) \
    { \
	    DecalSurfaceData surfaceData; \
        ZERO_INITIALIZE(DecalSurfaceData, surfaceData); \
        PositionInputs posInput; \
        ZERO_INITIALIZE(PositionInputs, posInput); \
        half3 receiverNormalWS; \
        VFXGetSurfaceDecalData(surfaceData, posInput, receiverNormalWS, i); \
     \
        ENCODE_INTO_DBUFFER(surfaceData, outDBuffer); \
    }

    #pragma fragment frag
    void frag(ps_input i, OUTPUT_DBUFFER(outDBuffer))
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i)
        VFXComputePixelOutputToDBuffer(i,outDBuffer);
    }
    ENDHLSL
}




.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassDBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassForwardEmissive.template---------------
.
.
Pass
{
    Name "DecalProjectorForwardEmissive"
    Tags
    {
        "LightMode" = "DecalProjectorForwardEmissive"
    }

    // Render State
    Cull Front
    Blend 0 SrcAlpha One
    ZTest Greater
    ZWrite Off

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    #pragma target 4.5
    #pragma exclude_renderers gles3 glcore
    #pragma editor_sync_compilation

    // Keywords
    #pragma multi_compile _ _DECAL_LAYERS

    ${VFXIncludeRP("VFXDecalVaryings.template")}

    struct ps_input
    {
        float4 pos : SV_POSITION;
        ${VFXURPDecalDeclareVaryings}
        UNITY_VERTEX_OUTPUT_STEREO
    };

    ${VFXURPDecalVaryingsMacros}

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXURPDecalFillVaryings}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}
    #define SHADERPASS SHADERPASS_FORWARD_EMISSIVE_PROJECTOR
    #if defined(DECAL_ANGLE_FADE)
        #define DECAL_LOAD_NORMAL
    #endif
    ${VFXIncludeRP("VFXDecal.template")}

    #pragma fragment frag
    void frag(ps_input i, out half4 outEmissive : SV_Target0)
    {
        SurfaceData surfaceData;
        ZERO_INITIALIZE(SurfaceData, surfaceData);
        InputData inputData;
        ZERO_INITIALIZE(InputData, inputData);
        DecalSurfaceData decalSurfaceData;
        ZERO_INITIALIZE(DecalSurfaceData, decalSurfaceData);

        PrepareSurfaceAndInputData(i, surfaceData, decalSurfaceData, inputData);

        outEmissive.rgb = decalSurfaceData.emissive;
        outEmissive.a = decalSurfaceData.baseColor.a;
    }
    ENDHLSL
}


.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassForwardEmissive.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassGBuffer.template---------------
.
.
Pass
{
    Name "DecalGBufferProjector"
    Tags
    {
        "LightMode" = "DecalGBufferProjector"
    }

    // Render State
    Cull Front
    Blend 0 SrcAlpha OneMinusSrcAlpha
    Blend 1 SrcAlpha OneMinusSrcAlpha
    Blend 2 SrcAlpha OneMinusSrcAlpha
    Blend 3 SrcAlpha OneMinusSrcAlpha
    ZTest Greater
    ZWrite Off

    //TODO: Generate mask in VFXDecalURPOutput.cs
    ColorMask ${VFXGBufferDecalColorMask0}
    ColorMask ${VFXGBufferDecalColorMask1} 1
    ColorMask ${VFXGBufferDecalColorMask2} 2
    ColorMask ${VFXGBufferDecalColorMask3} 3

        HLSLPROGRAM

        // Pragmas
    #pragma target 4.5
    #pragma exclude_renderers gles3 glcore
    #pragma multi_compile_fog //Is this multi_compile really needed ? TODO: Ask Lukas.
    #pragma editor_sync_compilation

        // Keywords
    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
    #pragma multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH
    #pragma multi_compile _DECAL_NORMAL_BLEND_LOW _DECAL_NORMAL_BLEND_MEDIUM _DECAL_NORMAL_BLEND_HIGH
    #pragma multi_compile _ _DECAL_LAYERS
    #pragma multi_compile_fragment _ _GBUFFER_NORMALS_OCT
    #pragma multi_compile_fragment _ _RENDER_PASS_ENABLED

    ${VFXIncludeRP("VFXDecalVaryings.template")}
    #include_with_pragmas "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ProbeVolumeVariants.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityGBuffer.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DecalInput.hlsl"

    #if _RENDER_PASS_ENABLED
    #define GBUFFER3 0
    #define GBUFFER4 1
    FRAMEBUFFER_INPUT_X_HALF(GBUFFER3);
    FRAMEBUFFER_INPUT_X_HALF(GBUFFER4);
    #endif

    struct ps_input
    {
        float4 pos : SV_POSITION;
        ${VFXURPDecalDeclareVaryings}
        UNITY_VERTEX_OUTPUT_STEREO
    };

    ${VFXURPDecalVaryingsMacros}

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXURPDecalFillVaryings}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}

    #define SHADERPASS SHADERPASS_DECAL_GBUFFER_PROJECTOR

    #if ((!defined(AFFECT_NORMAL) && defined(AFFECT_BASE_COLOR)) || (defined(AFFECT_NORMAL)))
        #define DECAL_RECONSTRUCT_NORMAL
    #elif defined(DECAL_ANGLE_FADE)
        #define DECAL_LOAD_NORMAL
    #endif

    #ifdef DECAL_RECONSTRUCT_NORMAL
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/NormalReconstruction.hlsl"
    #endif

    #if defined(DECAL_LOAD_NORMAL)
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"
    #endif

    ${VFXIncludeRP("VFXDecal.template")}

    void VFXComputePixelOutputToGBuffer(const VFX_VARYING_PS_INPUTS i, out FragmentOutput fragmentOutput)
    {
        SurfaceData surfaceData;
        ZERO_INITIALIZE(SurfaceData, surfaceData);
        InputData inputData;
        ZERO_INITIALIZE(InputData, inputData);
        DecalSurfaceData decalSurfaceData;
        ZERO_INITIALIZE(DecalSurfaceData, decalSurfaceData);

        PrepareSurfaceAndInputData(i, surfaceData, decalSurfaceData, inputData);
        BRDFData brdfData;
        InitializeBRDFData(surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.alpha, brdfData);
#if defined(AFFECT_BASE_COLOR)
    #ifdef DECAL_RECONSTRUCT_NORMAL
        #if defined(_DECAL_NORMAL_BLEND_HIGH)
            half3 geomNormalWS = half3(ReconstructNormalTap9(i.pos.xy));
        #elif defined(_DECAL_NORMAL_BLEND_MEDIUM)
            half3 geomNormalWS = half3(ReconstructNormalTap5(i.pos.xy));
        #else
            half3 geomNormalWS = half3(ReconstructNormalDerivative(i.pos.xy));
        #endif
    #elif defined(DECAL_LOAD_NORMAL)
            half3 geomNormalWS = half3(LoadSceneNormals(i.pos.xy));
    #endif
    half3 normalGI = normalize(lerp(geomNormalWS.xyz, decalSurfaceData.normalWS.xyz, decalSurfaceData.normalWS.w));
    Light mainLight = GetMainLight(inputData.shadowCoord, inputData.positionWS, inputData.shadowMask);
    MixRealtimeAndBakedGI(mainLight, normalGI, inputData.bakedGI, inputData.shadowMask);
    half3 color = GlobalIllumination(brdfData, inputData.bakedGI, surfaceData.occlusion, inputData.positionWS, normalGI, inputData.viewDirectionWS);
    // GI needs blended normal
#else
        half3 color = 0;
#endif

        // We can not use usual GBuffer functions (etc. BRDFDataToGbuffer) as we use alpha for blending
        half3 packedNormalWS = PackNormal(decalSurfaceData.normalWS.xyz);
        fragmentOutput.GBuffer0 = half4(decalSurfaceData.baseColor.rgb, decalSurfaceData.baseColor.a);
        fragmentOutput.GBuffer1 = 0;
        fragmentOutput.GBuffer2 = half4(packedNormalWS, decalSurfaceData.normalWS.a);
#if defined(AFFECT_BASE_COLOR) || defined(AFFECT_EMISSIVE)
        fragmentOutput.GBuffer3 = half4(decalSurfaceData.emissive + color, decalSurfaceData.baseColor.a);
#else
        fragmentOutput.GBuffer3 = 0;
#endif
    #if _RENDER_PASS_ENABLED
        fragmentOutput.GBuffer4 = inputData.positionCS.xy;
        #if OUTPUT_SHADOWMASK
            fragmentOutput.GBuffer5 = inputData.shadowMask; // will have unity_ProbesOcclusion value if subtractive lighting is used (baked)
        #endif
    #else
        #if OUTPUT_SHADOWMASK
            fragmentOutput.GBuffer4 = inputData.shadowMask; // will have unity_ProbesOcclusion value if subtractive lighting is used (baked)
        #endif
    #endif
    }

    #pragma fragment frag
    void frag(VFX_VARYING_PS_INPUTS i, out FragmentOutput fragmentOutput)
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i)
        VFXComputePixelOutputToGBuffer(i, fragmentOutput);
    }
    ENDHLSL
}




.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassGBuffer.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassScreenSpace.template---------------
.
.
Pass
{
    Name "DecalScreenSpaceProjector"
    Tags
    {
        "LightMode" = "DecalScreenSpaceProjector"
    }

    // Render State
    Cull Front
    Blend SrcAlpha OneMinusSrcAlpha
    ZTest Greater
    ZWrite Off

    HLSLPROGRAM

    // Pragmas
    #pragma target 2.5
    #pragma multi_compile_fog
    #pragma editor_sync_compilation

    // Keywords
    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
    #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
    #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS
    #pragma multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH
    #pragma multi_compile _ _FORWARD_PLUS
    #include_with_pragmas "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl"
    #pragma multi_compile_fragment _ DEBUG_DISPLAY
    #pragma multi_compile _DECAL_NORMAL_BLEND_LOW _DECAL_NORMAL_BLEND_MEDIUM _DECAL_NORMAL_BLEND_HIGH
    #pragma multi_compile _ _DECAL_LAYERS

    ${VFXIncludeRP("VFXDecalVaryings.template")}
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DecalInput.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRendering.hlsl"

    struct ps_input
    {
        float4 pos : SV_POSITION;
        ${VFXURPDecalDeclareVaryings}
        UNITY_VERTEX_OUTPUT_STEREO
    };

    ${VFXURPDecalVaryingsMacros}

    ${VFXBegin:VFXVertexAdditionalProcess}
    ${VFXURPDecalFillVaryings}
    ${VFXEnd}

    ${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}

    #define SHADERPASS SHADERPASS_DECAL_SCREEN_SPACE_PROJECTOR

    #if ((!defined(AFFECT_NORMAL) && defined(AFFECT_BASE_COLOR)) || (defined(AFFECT_NORMAL)))
        #define DECAL_RECONSTRUCT_NORMAL
    #elif defined(DECAL_ANGLE_FADE)
        #define DECAL_LOAD_NORMAL
    #endif

    #ifdef DECAL_RECONSTRUCT_NORMAL
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/NormalReconstruction.hlsl"
    #endif

    #if defined(DECAL_LOAD_NORMAL)
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"
    #endif

    ${VFXIncludeRP("VFXDecal.template")}

    half4 VFXComputePixelOutputScreenSpaceDecal(VFX_VARYING_PS_INPUTS i)
    {
        SurfaceData surfaceData;
        ZERO_INITIALIZE(SurfaceData, surfaceData);
        InputData inputData;
        ZERO_INITIALIZE(InputData, inputData);
        DecalSurfaceData decalSurfaceData;
        ZERO_INITIALIZE(DecalSurfaceData, decalSurfaceData);

        PrepareSurfaceAndInputData(i, surfaceData, decalSurfaceData, inputData);

        half4 color = UniversalFragmentPBR(inputData, surfaceData);

        color.rgb = MixFog(color.rgb, inputData.fogCoord);
        return color;
    }

    #pragma fragment frag
    void frag(VFX_VARYING_PS_INPUTS i, out half4 outColor : SV_Target0)
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
        outColor = VFXComputePixelOutputScreenSpaceDecal(i);
    }
    ENDHLSL
}

.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.universal\Editor\VFXGraph\Shaders\Templates\URPDecal\PassScreenSpace.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\BuiltIn\Editor\ShaderGraph\Templates\ShaderPass.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

// Render State
$splice(RenderState)

// Debug
$splice(Debug)

// --------------------------------------------------
// Pass

HLSLPROGRAM

// Pragmas
$splice(PassPragmas)

// Keywords
$splice(PassKeywords)
$splice(GraphKeywords)

// Defines
$SurfaceType.Transparent:           // UBER SHADER NOW:  #define _SURFACE_TYPE_TRANSPARENT 1
$AlphaClip:                         // UBER SHADER NOW:  #define _AlphaClip 1
$Normal:                            #define _NORMALMAP 1
$BlendMode.Add:                     // UBER SHADER NOW:  #define _BLENDMODE_ADD 1
$BlendMode.Premultiply:             // UBER SHADER NOW:  #define _ALPHAPREMULTIPLY_ON 1
$SpecularSetup: #define _SPECULAR_SETUP
$NormalDropOffTS: #define _NORMAL_DROPOFF_TS 1
$NormalDropOffOS: #define _NORMAL_DROPOFF_OS 1
$NormalDropOffWS: #define _NORMAL_DROPOFF_WS 1
$Attributes.normalOS: #define ATTRIBUTES_NEED_NORMAL
$Attributes.tangentOS: #define ATTRIBUTES_NEED_TANGENT
$Attributes.uv0: #define ATTRIBUTES_NEED_TEXCOORD0
$Attributes.uv1: #define ATTRIBUTES_NEED_TEXCOORD1
$Attributes.uv2: #define ATTRIBUTES_NEED_TEXCOORD2
$Attributes.uv3: #define ATTRIBUTES_NEED_TEXCOORD3
$Attributes.color: #define ATTRIBUTES_NEED_COLOR
$Attributes.vertexID: #define ATTRIBUTES_NEED_VERTEXID
$Attributes.instanceID: #define ATTRIBUTES_NEED_INSTANCEID
$Varyings.positionWS: #define VARYINGS_NEED_POSITION_WS
$Varyings.normalWS: #define VARYINGS_NEED_NORMAL_WS
$Varyings.tangentWS: #define VARYINGS_NEED_TANGENT_WS
$Varyings.texCoord0: #define VARYINGS_NEED_TEXCOORD0
$Varyings.texCoord1: #define VARYINGS_NEED_TEXCOORD1
$Varyings.texCoord2: #define VARYINGS_NEED_TEXCOORD2
$Varyings.texCoord3: #define VARYINGS_NEED_TEXCOORD3
$Varyings.color: #define VARYINGS_NEED_COLOR
$Varyings.bitangentWS: #define VARYINGS_NEED_BITANGENT_WS
$Varyings.screenPosition: #define VARYINGS_NEED_SCREENPOSITION
$Varyings.fogFactorAndVertexLight: #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT
$Varyings.cullFace: #define VARYINGS_NEED_CULLFACE
$Varyings.instanceID: #define VARYINGS_NEED_INSTANCEID
$features.graphVertex: #define FEATURES_GRAPH_VERTEX
$BuiltIn.UseLegacySpriteBlocks: #define BUILTIN_USELEGACYSPRITEBLOCKS
$splice(PassInstancing)
$splice(GraphDefines)
#ifdef _BUILTIN_SURFACE_TYPE_TRANSPARENT
#define _SURFACE_TYPE_TRANSPARENT _BUILTIN_SURFACE_TYPE_TRANSPARENT
#endif
#ifdef _BUILTIN_ALPHATEST_ON
#define _ALPHATEST_ON _BUILTIN_ALPHATEST_ON
#endif
#ifdef _BUILTIN_AlphaClip
#define _AlphaClip _BUILTIN_AlphaClip
#endif
#ifdef _BUILTIN_ALPHAPREMULTIPLY_ON
#define _ALPHAPREMULTIPLY_ON _BUILTIN_ALPHAPREMULTIPLY_ON
#endif


// custom interpolator pre-include
$splice(sgci_CustomInterpolatorPreInclude)

// Includes
$splice(PreGraphIncludes)

// --------------------------------------------------
// Structs and Packing

// custom interpolators pre packing
$splice(CustomInterpolatorPrePacking)

$splice(PassStructs)

$splice(InterpolatorPack)

// --------------------------------------------------
// Graph

// Graph Properties
$splice(GraphProperties)

// -- Property used by ScenePickingPass
#ifdef SCENEPICKINGPASS
float4 _SelectionID;
#endif

// -- Properties used by SceneSelectionPass
#ifdef SCENESELECTIONPASS
int _ObjectId;
int _PassValue;
#endif

// Graph Includes
$splice(GraphIncludes)

// Graph Functions
$splice(GraphFunctions)

// Custom interpolators pre vertex
$splice(CustomInterpolatorPreVertex)

// Graph Vertex
$splice(GraphVertex)

// Custom interpolators, pre surface
$splice(CustomInterpolatorPreSurface)

// Graph Pixel
$splice(GraphPixel)

// --------------------------------------------------
// Build Graph Inputs

$features.graphVertex:  $include("BuildVertexDescriptionInputs.template.hlsl")
$features.graphPixel: $include("SharedCode.template.hlsl")

// --------------------------------------------------
// Main

$splice(PostGraphIncludes)

ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\BuiltIn\Editor\ShaderGraph\Templates\ShaderPass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\Canvas\Templates\PassUI.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

    // Render State
    $splice(RenderState)

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    $splice(PassPragmas)

    // Keywords
    $splice(PassKeywords)
    $splice(GraphKeywords)

    #define CANVAS_SHADERGRAPH

    // Defines
   #define _SURFACE_TYPE_TRANSPARENT 1
   $AlphaClip:                             #define _AlphaClip 1
   $Normal:                                #define _NORMALMAP 1
   $BlendMode.Add:                         #define _BLENDMODE_ADD 1
   $BlendMode.Premultiply:                 #define _ALPHAPREMULTIPLY_ON 1
   $Attributes.normalOS:                   #define ATTRIBUTES_NEED_NORMAL
   $Attributes.tangentOS:                  #define ATTRIBUTES_NEED_TANGENT
   $Attributes.uv0:                        #define ATTRIBUTES_NEED_TEXCOORD0
   $Attributes.uv1:                        #define ATTRIBUTES_NEED_TEXCOORD1
   $Attributes.uv2:                        #define ATTRIBUTES_NEED_TEXCOORD2
   $Attributes.uv3:                        #define ATTRIBUTES_NEED_TEXCOORD3
   $Attributes.color:                      #define ATTRIBUTES_NEED_COLOR
   $Attributes.vertexID:                   #define ATTRIBUTES_NEED_VERTEXID
   $Attributes.instanceID:                 #define ATTRIBUTES_NEED_INSTANCEID
   $Varyings.positionWS:                   #define VARYINGS_NEED_POSITION_WS
   $Varyings.positionPredisplacementWS:    #define VARYINGS_NEED_POSITIONPREDISPLACEMENT_WS
   $Varyings.normalWS:                     #define VARYINGS_NEED_NORMAL_WS
   $Varyings.tangentWS:                    #define VARYINGS_NEED_TANGENT_WS
   $Varyings.texCoord0:                    #define VARYINGS_NEED_TEXCOORD0
   $Varyings.texCoord1:                    #define VARYINGS_NEED_TEXCOORD1
   $Varyings.texCoord2:                    #define VARYINGS_NEED_TEXCOORD2
   $Varyings.texCoord3:                    #define VARYINGS_NEED_TEXCOORD3
   $Varyings.color:                        #define VARYINGS_NEED_COLOR
   $Varyings.vertexID:                     #define VARYINGS_NEED_VERTEXID
   $Varyings.instanceID:                   #define VARYINGS_NEED_INSTANCEID
   $Varyings.bitangentWS:                  #define VARYINGS_NEED_BITANGENT_WS
   $Varyings.screenPosition:               #define VARYINGS_NEED_SCREENPOSITION
   $Varyings.fogFactorAndVertexLight:      #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT
   $features.graphVertex:                  #define FEATURES_GRAPH_VERTEX
   $features.graphColorInterp:             #define FEATURES_GRAPH_COLOR_INTERP
   $Universal.UseLegacySpriteBlocks:       #define UNIVERSAL_USELEGACYSPRITEBLOCKS

#define REQUIRE_DEPTH_TEXTURE
#define REQUIRE_NORMAL_TEXTURE

   $splice(GraphDefines)

   $splice(PreGraphIncludes)

    // --------------------------------------------------
    // Structs and Packing


    $splice(PassStructs)

    $splice(InterpolatorPack)

    // -- Property used by ScenePickingPass
    #ifdef SCENEPICKINGPASS
    float4 _SelectionID;
    #endif

    // -- Properties used by SceneSelectionPass
    #ifdef SCENESELECTIONPASS
    int _ObjectId;
    int _PassValue;
    #endif

    //UGUI has no keyword for when a renderer has "bloom", so its nessecary to hardcore it here, like all the base UI shaders.
    half4 _TextureSampleAdd;

    // --------------------------------------------------
    // Graph

    // Graph Properties
    $splice(GraphProperties)

    // Graph Includes
    $splice(GraphIncludes)

    // Graph Functions
    $splice(GraphFunctions)

    $splice(CustomInterpolatorPreVertex)

    // Graph Vertex
    $splice(GraphVertex)

    $splice(CustomInterpolatorPreSurface)

    // Graph Pixel
    $splice(GraphPixel)

    // --------------------------------------------------
    // Build Graph Inputs

    $features.graphVertex:  $include("BuildVertexDescriptionInputs.template.hlsl")
    $features.graphPixel:   $include("BuildSurfaceDescriptionInputs.template.hlsl")

    // --------------------------------------------------
    // Main

    $splice(PostGraphIncludes)

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\Canvas\Templates\PassUI.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\CustomRenderTexture\CustomTextureSubShader.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

	Lighting Off
	Blend One Zero

	HLSLPROGRAM
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
	#include "Packages/com.unity.shadergraph/Editor/Generation/Targets/CustomRenderTexture/CustomTexture.hlsl"
	#include "Packages/com.unity.shadergraph/Editor/Generation/Targets/CustomRenderTexture/CustomTextureGraph.hlsl"
	#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl"

	#pragma vertex CustomRenderTextureVertexShader
	#pragma fragment frag
	#pragma target 3.0

    // Pragmas
    $splice(PassPragmas)

    // Keywords
    $splice(PassKeywords)
    $splice(GraphKeywords)

	struct SurfaceDescriptionInputs
	{
		// update input values
		float4	uv0;
		float4	uv1;
		uint	primitiveID;
		float3	direction;

		// ShaderGraph accessors:
		float3 WorldSpaceViewDirection;
		float3 ObjectSpaceViewDirection;
		float3 ObjectSpacePosition;
		float3 TimeParameters;
		float3 WorldSpaceNormal;
		float3 ObjectSpaceNormal;
		float2 NDCPosition;
		float4 ScreenPosition;
	};

	SurfaceDescriptionInputs ConvertV2FToSurfaceInputs( v2f_customrendertexture IN )
	{
		SurfaceDescriptionInputs o;
		
		o.uv0 = float4(IN.localTexcoord, 0);
		o.uv1 = float4(IN.globalTexcoord, 0);
		o.primitiveID = IN.primitiveID;
		o.direction = normalize(IN.direction);

		// other space of view direction are not supported
		$SurfaceDescriptionInputs.WorldSpaceViewDirection:					o.WorldSpaceViewDirection = o.direction;
		$SurfaceDescriptionInputs.ObjectSpaceViewDirection: 				o.ObjectSpaceViewDirection = o.direction;
		$SurfaceDescriptionInputs.ObjectSpacePosition:						o.ObjectSpacePosition = o.direction;
		$SurfaceDescriptionInputs.TimeParameters:							o.TimeParameters = float3(_Time.y, _SinTime.x, _CosTime.y);
		$SurfaceDescriptionInputs.WorldSpaceNormal:                         o.WorldSpaceNormal = o.direction;
		$SurfaceDescriptionInputs.ObjectSpaceNormal							o.ObjectSpaceNormal = o.direction;
		$SurfaceDescriptionInputs.NDCPosition:                              o.NDCPosition = o.uv0.xy;
		$SurfaceDescriptionInputs.ScreenPosition:                           o.ScreenPosition = float4(o.uv0.xy, 0, 1);

		// Unsupported properties:
		$SurfaceDescriptionInputs.WorldSpaceBiTangent: #error 'WorldSpaceBiTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ViewSpaceNormal: #error 'ViewSpaceNormal' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.TangentSpaceNormal: #error 'TangentSpaceNormal' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.WorldSpaceTangent: #error 'WorldSpaceTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.WorldSpaceBiTangent: #error 'WorldSpaceBiTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ObjectSpaceTangent: #error 'ObjectSpaceTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ViewSpaceTangent: #error 'ViewSpaceTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.TangentSpaceTangent: #error 'TangentSpaceTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ObjectSpaceBiTangent: #error 'ObjectSpaceBiTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ViewSpaceBiTangent: #error 'ViewSpaceBiTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.TangentSpaceBiTangent: #error 'TangentSpaceBiTangent' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ViewSpaceViewDirection: #error 'ViewSpaceViewDirection' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.TangentSpaceViewDirection: #error 'TangentSpaceViewDirection' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ViewSpacePosition: #error ViewSpacePosition'' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.TangentSpacePosition: #error 'TangentSpacePosition' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.WorldSpacePositionPredisplacement: #error 'WorldSpacePositionPredisplacement' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ObjectSpacePositionPredisplacement: #error 'ObjectSpacePositionPredisplacement' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ViewSpacePositionPredisplacement: #error 'ViewSpacePositionPredisplacement' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.TangentSpacePositionPredisplacement: #error 'TangentSpacePositionPredisplacement' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.AbsoluteWorldSpacePositionPredisplacement: #error 'AbsoluteWorldSpacePositionPredisplacement' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.uv2: #error 'uv2' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.uv3: #error 'uv3' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.VertexColor: #error 'VertexColor' is not available in Custom Render Textures.

		// We can't fake the positions because we can't differentiate Cube and 2D custom render textures
		$SurfaceDescriptionInputs.WorldSpacePosition: #error 'WorldSpacePosition' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.ObjectSpacePosition: #error 'ObjectSpacePosition' is not available in Custom Render Textures.
		$SurfaceDescriptionInputs.AbsoluteWorldSpacePosition: #error 'AbsoluteWorldSpacePosition' is not available in Custom Render Textures.

		return o;
	}

	// --------------------------------------------------
	// Graph

	// Graph Properties
	$splice(GraphProperties)

	// Graph Includes
	$splice(GraphIncludes)

	// Graph Functions
	$splice(GraphFunctions)

	// Graph Pixel
	$splice(GraphPixel)

	float4 frag(v2f_customrendertexture IN) : SV_Target
	{
		SurfaceDescriptionInputs surfaceInput = ConvertV2FToSurfaceInputs(IN);
		SurfaceDescription surface = SurfaceDescriptionFunction(surfaceInput);

		return float4(surface.BaseColor, surface.Alpha);
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\CustomRenderTexture\CustomTextureSubShader.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\Fullscreen\Templates\ShaderPass.template---------------
.
.
Pass
{
    $splice(PassName)

// Render State
$splice(RenderState)

// Debug
$splice(Debug)

// --------------------------------------------------
// Pass

HLSLPROGRAM

// Pragmas
$splice(PassPragmas)
// #pragma enable_d3d11_debug_symbols

$splice(DotsInstancingOptions)
$splice(HybridV1InjectedBuiltinProperties)

// Keywords
$splice(PassKeywords)
$splice(GraphKeywords)

#define FULLSCREEN_SHADERGRAPH

// Defines
$SurfaceType.Transparent:           // UBER SHADER NOW:  #define _SURFACE_TYPE_TRANSPARENT 1
$Attributes.normalOS: #define ATTRIBUTES_NEED_NORMAL
$Attributes.tangentOS: #define ATTRIBUTES_NEED_TANGENT
$Attributes.uv0: #define ATTRIBUTES_NEED_TEXCOORD0
$Attributes.uv1: #define ATTRIBUTES_NEED_TEXCOORD1
$Attributes.uv2: #define ATTRIBUTES_NEED_TEXCOORD2
$Attributes.uv3: #define ATTRIBUTES_NEED_TEXCOORD3
$Attributes.color: #define ATTRIBUTES_NEED_COLOR
$Attributes.vertexID: #define ATTRIBUTES_NEED_VERTEXID
$Attributes.instanceID: #define ATTRIBUTES_NEED_INSTANCEID
$Varyings.positionWS: #define VARYINGS_NEED_POSITION_WS
$Varyings.normalWS: #define VARYINGS_NEED_NORMAL_WS
$Varyings.tangentWS: #define VARYINGS_NEED_TANGENT_WS
$Varyings.texCoord0: #define VARYINGS_NEED_TEXCOORD0
$Varyings.texCoord1: #define VARYINGS_NEED_TEXCOORD1
$Varyings.texCoord2: #define VARYINGS_NEED_TEXCOORD2
$Varyings.texCoord3: #define VARYINGS_NEED_TEXCOORD3
$Varyings.color: #define VARYINGS_NEED_COLOR
$Varyings.viewDirectionWS: #define VARYINGS_NEED_VIEWDIRECTION_WS
$Varyings.bitangentWS: #define VARYINGS_NEED_BITANGENT_WS
$Varyings.screenPosition: #define VARYINGS_NEED_SCREENPOSITION
$Varyings.fogFactorAndVertexLight: #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT
$Varyings.cullFace: #define VARYINGS_NEED_CULLFACE
$features.graphVertex: #define FEATURES_GRAPH_VERTEX

// Force depth texture because we need it for almost every nodes
// TODO: dependency system that triggers this define from position or view direction usage
#define REQUIRE_DEPTH_TEXTURE
#define REQUIRE_NORMAL_TEXTURE

$splice(PassInstancing)
$splice(GraphDefines)

// custom interpolator pre-include
$splice(sgci_CustomInterpolatorPreInclude)

// Includes
$splice(PreGraphIncludes)

// --------------------------------------------------
// Structs and Packing

// custom interpolators pre packing
$splice(CustomInterpolatorPrePacking)

$splice(PassStructs)

$splice(InterpolatorPack)

// --------------------------------------------------
// Graph

// Graph Properties
$splice(GraphProperties)

// Graph Includes
$splice(GraphIncludes)

// Graph Functions
$splice(GraphFunctions)

// Custom interpolators pre vertex
$splice(CustomInterpolatorPreVertex)

// Graph Vertex
$splice(GraphVertex)

// Custom interpolators, pre surface
$splice(CustomInterpolatorPreSurface)

// Graph Pixel
$splice(GraphPixel)

// --------------------------------------------------
// Build Graph Inputs

$features.graphVertex:  $include("BuildVertexDescriptionInputs.template.hlsl")
$features.graphPixel: $include("SharedCode.template.hlsl")

// --------------------------------------------------
// Main

$splice(PostGraphIncludes)

ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Targets\Fullscreen\Templates\ShaderPass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Templates\PassMesh.template---------------
.
.
Pass
{
    $splice(PassName)
    Tags
    {
        $splice(LightMode)
    }

    // Render State
    $splice(RenderState)

    // Debug
    $splice(Debug)

    // --------------------------------------------------
    // Pass

    HLSLPROGRAM

    // Pragmas
    $splice(PassPragmas)

    // Keywords
    $splice(PassKeywords)
    $splice(GraphKeywords)

    // Defines
    $SurfaceType.Transparent:               #define _SURFACE_TYPE_TRANSPARENT 1
    $AlphaClip:                             #define _AlphaClip 1
    $Normal:                                #define _NORMALMAP 1
    $BlendMode.Add:                         #define _BLENDMODE_ADD 1
    $BlendMode.Premultiply:                 #define _ALPHAPREMULTIPLY_ON 1
    $NormalDropOffTS:                       #define _NORMAL_DROPOFF_TS 1
    $NormalDropOffOS:                       #define _NORMAL_DROPOFF_OS 1
    $NormalDropOffWS:                       #define _NORMAL_DROPOFF_WS 1
    $Attributes.normalOS:                   #define ATTRIBUTES_NEED_NORMAL
    $Attributes.tangentOS:                  #define ATTRIBUTES_NEED_TANGENT
    $Attributes.uv0:                        #define ATTRIBUTES_NEED_TEXCOORD0
    $Attributes.uv1:                        #define ATTRIBUTES_NEED_TEXCOORD1
    $Attributes.uv2:                        #define ATTRIBUTES_NEED_TEXCOORD2
    $Attributes.uv3:                        #define ATTRIBUTES_NEED_TEXCOORD3
    $Attributes.color:                      #define ATTRIBUTES_NEED_COLOR
    $Attributes.vertexID:                   #define ATTRIBUTES_NEED_VERTEXID
    $Attributes.instanceID:                 #define ATTRIBUTES_NEED_INSTANCEID
    $Varyings.positionWS:                   #define VARYINGS_NEED_POSITION_WS
    $Varyings.positionPredisplacementWS:    #define VARYINGS_NEED_POSITIONPREDISPLACEMENT_WS
    $Varyings.normalWS:                     #define VARYINGS_NEED_NORMAL_WS
    $Varyings.tangentWS:                    #define VARYINGS_NEED_TANGENT_WS
    $Varyings.texCoord0:                    #define VARYINGS_NEED_TEXCOORD0
    $Varyings.texCoord1:                    #define VARYINGS_NEED_TEXCOORD1
    $Varyings.texCoord2:                    #define VARYINGS_NEED_TEXCOORD2
    $Varyings.texCoord3:                    #define VARYINGS_NEED_TEXCOORD3
    $Varyings.color:                        #define VARYINGS_NEED_COLOR
    $Varyings.vertexID:                     #define VARYINGS_NEED_VERTEXID
    $Varyings.instanceID:                   #define VARYINGS_NEED_INSTANCEID
    $Varyings.bitangentWS:                  #define VARYINGS_NEED_BITANGENT_WS
    $Varyings.screenPosition:               #define VARYINGS_NEED_SCREENPOSITION
    $Varyings.fogFactorAndVertexLight:      #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT
    $Varyings.cullFace:                     #define VARYINGS_NEED_CULLFACE
    $features.graphVertex:                  #define FEATURES_GRAPH_VERTEX
    $features.graphColorInterp:             #define FEATURES_GRAPH_COLOR_INTERP
    $Universal.UseLegacySpriteBlocks:       #define UNIVERSAL_USELEGACYSPRITEBLOCKS
    $splice(PassInstancing)
    $splice(GraphDefines)

    // Includes
    $splice(CustomInterpolatorPreInclude)

    $splice(PreGraphIncludes)

    // --------------------------------------------------
    // Structs and Packing

    $splice(CustomInterpolatorPrePacking)

    $splice(PassStructs)

    $splice(InterpolatorPack)

    // --------------------------------------------------
    // Graph

    // Graph Properties
    $splice(GraphProperties)

    // Graph Includes
    $splice(GraphIncludes)

    // -- Property used by ScenePickingPass
    #ifdef SCENEPICKINGPASS
    float4 _SelectionID;
    #endif

    // -- Properties used by SceneSelectionPass
    #ifdef SCENESELECTIONPASS
    int _ObjectId;
    int _PassValue;
    #endif

    // Graph Functions
    $splice(GraphFunctions)

    $splice(CustomInterpolatorPreVertex)

    // Graph Vertex
    $splice(GraphVertex)

    $splice(CustomInterpolatorPreSurface)

    // Graph Pixel
    $splice(GraphPixel)

    // --------------------------------------------------
    // Build Graph Inputs

    $features.graphVertex:  $include("BuildVertexDescriptionInputs.template.hlsl")
    $features.graphPixel:   $include("BuildSurfaceDescriptionInputs.template.hlsl")

    // --------------------------------------------------
    // Main

    $splice(PostGraphIncludes)

    ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.shadergraph\Editor\Generation\Templates\PassMesh.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXGlobalSortKeys.template---------------
.
.
#pragma kernel CSMain
${VFXPragmaOnlyRenderers}
${VFXPragmaRequire}

${VFXGlobalInclude}
${VFXGlobalDeclaration}
${VFXInclude("Shaders/VFXParticleCommon.template")}

CBUFFER_START(sortParamsConst)
    uint dispatchWidth;
    ${VFXInstancingConstants}
CBUFFER_END

ByteAddressBuffer attributeBuffer;
StructuredBuffer<uint> inputBuffer;

struct Kvp
{
	float sortKey;
	uint index;
};

RWStructuredBuffer<Kvp> outputBuffer;

${VFXPerPassInclude}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSMain(uint3 groupId          : SV_GroupID,
            uint3 groupThreadId    : SV_GroupThreadID)
{
	uint id = GetThreadId(groupId, groupThreadId, dispatchWidth);
	uint index = id;
    ${VFXInitInstancing}

	uint threshold = inputBuffer[instanceActiveIndex];
    if(index == 0)
        outputBuffer[instanceActiveIndex].index = threshold; //Store the count here

	if (index < threshold)
	{
#if HAVE_VFX_MODIFICATION
        ${VFXLoadGraphValues}

    #if VFX_LOCAL_SPACE
        ${VFXLoadParameter:{localToWorld}}
        vfxLocalToWorld = localToWorld;

        ${VFXLoadParameter:{worldToLocal}}
        vfxWorldToLocal = worldToLocal;
    #else
        vfxWorldToLocal = k_identity4x4;
        vfxLocalToWorld = k_identity4x4;
    #endif
#endif

        uint indirectId = index + instancingBatchSize + instanceActiveIndex * RAW_CAPACITY;
		uint index = inputBuffer[indirectId];

		VFXAttributes attributes = (VFXAttributes)0;
        ${VFXLoadAttributes}

        ${VFXFeedSortingKeys}

        outputBuffer[indirectId] = output;
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXGlobalSortKeys.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXInit.template---------------
.
.
#pragma kernel CSMain
${VFXPragmaOnlyRenderers}
${VFXPragmaRequire}

${VFXGlobalInclude}
${VFXGlobalDeclaration}
${VFXInclude("Shaders/VFXParticleCommon.template")}

#define USE_DEAD_LIST (VFX_USE_ALIVE_CURRENT && !HAS_STRIPS)
#define instancingPrefixSumOffset 0

RWByteAddressBuffer attributeBuffer;
ByteAddressBuffer sourceAttributeBuffer;


#if !VFX_USE_SPAWNER_FROM_GPU
    StructuredBuffer<uint> spawnBuffer;
    #define EVENT_PREFIX_SUM(index)         spawnBuffer[index]
    #define SPAWNCOUNT_PREFIX_SUM_OFFSET    instancingActiveCount
#endif


CBUFFER_START(initParamsConst)
    uint dispatchWidth;
    ${VFXInstancingConstants}
CBUFFER_END

#if USE_DEAD_LIST
RWStructuredBuffer<uint> deadList;
#endif

#if VFX_USE_SPAWNER_FROM_GPU
StructuredBuffer<uint> eventList;
#endif

#if HAS_STRIPS_DATA
RWStructuredBuffer<uint> stripDataBuffer;
#endif

${VFXPerPassInclude}

${VFXGeneratedBlockFunction}

#if HAS_STRIPS
bool GetParticleIndex(inout uint particleIndex, uint stripIndex, uint instanceIndex)
{
    uint relativeIndex;
    uint bufferIndex = STRIP_DATA_INDEX(instanceIndex, stripIndex);

    InterlockedAdd(STRIP_DATA(STRIP_NEXT_INDEX, bufferIndex), 1, relativeIndex);
    bool isFull = relativeIndex >= PARTICLE_PER_STRIP_COUNT;
    if (isFull)
    {
        InterlockedAdd(STRIP_DATA(STRIP_NEXT_INDEX, bufferIndex), -1); // Remove previous increment
    }
    else
    {
        particleIndex = stripIndex * PARTICLE_PER_STRIP_COUNT + ((STRIP_DATA(STRIP_FIRST_INDEX, bufferIndex) + relativeIndex) % PARTICLE_PER_STRIP_COUNT);
    }

    return !isFull;
}
#endif

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSMain(uint3 groupId          : SV_GroupID,
            uint3 groupThreadId    : SV_GroupThreadID)
{
    uint id = groupThreadId.x + groupId.x * NB_THREADS_PER_GROUP;
#if !VFX_USE_SPAWNER_FROM_GPU
    id += groupId.y * dispatchWidth * NB_THREADS_PER_GROUP;
#endif
    ${VFXInitInstancingCompute}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;

    ${VFXLoadGraphValues}

#if VFX_USE_SPAWNER_FROM_GPU
    uint elementCount = eventList[VFXGetEventListBufferElementCount(instanceActiveIndex)];
    uint totalAccumulatedElementCount = eventList[VFXGetEventListBufferAccumulatedCount(instanceActiveIndex)];
    uint maxThreadId = min(contextData.maxParticleCount, elementCount);
    uint currentSpawnIndex = totalAccumulatedElementCount - elementCount;
#else
    uint nbEvents = EVENT_PREFIX_SUM(instanceActiveIndex);
    [branch]
    if (instanceActiveIndex > 0u)
    {
        nbEvents -= EVENT_PREFIX_SUM(instanceActiveIndex - 1);
    }

    uint maxThreadId = instancingPrefixSum[instancingPrefixSumOffset + instanceCurrentIndex];
    [branch]
    if (instanceCurrentIndex > instancingCurrentOffset)
    {
        maxThreadId -= instancingPrefixSum[instancingPrefixSumOffset + instanceCurrentIndex - 1];
    }
    uint currentSpawnIndex = contextData.initSpawnIndex;
#endif

#if USE_DEAD_LIST
    maxThreadId = min(maxThreadId, deadList[DEAD_LIST_COUNT_COPY_OFFSET + instanceIndex]);
#endif

    if (index < maxThreadId)
    {
#if VFX_USE_SPAWNER_FROM_GPU
        int sourceIndex = eventList[VFXGetEventListBufferIndex(id, instanceActiveIndex)];
#endif

        uint startEventIndex = 0u; //tmp for GPU Events
#if !VFX_USE_SPAWNER_FROM_GPU
        int sourceIndex = 0;

        startEventIndex = 0;
        [branch]
        if (instanceActiveIndex > 0u)
        {
            startEventIndex = EVENT_PREFIX_SUM(instanceActiveIndex - 1);
        }
        uint sourceSearchBegin = startEventIndex + SPAWNCOUNT_PREFIX_SUM_OFFSET;
        uint sourceSearchEnd = sourceSearchBegin + nbEvents;
        sourceIndex = BinarySearchPrefixSum(index, spawnBuffer, sourceSearchBegin, sourceSearchEnd) - sourceSearchBegin;

#endif

		VFXAttributes attributes = (VFXAttributes)0;
		VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;

        ${VFXLoadAttributes}

		uint particleIndex = index + currentSpawnIndex;
#if VFX_USE_PARTICLEID_CURRENT
         attributes.particleId = particleIndex;
#endif
#if VFX_USE_SEED_CURRENT
        attributes.seed = WangHash(particleIndex ^ systemSeed);
#endif
#if VFX_USE_SPAWNINDEX_CURRENT
        attributes.spawnIndex = index;
#endif

#if VFX_USE_SPAWNER_FROM_GPU && VFX_USE_SPAWNCOUNT_SOURCE
    //Fix previously incorrectly read or initialized source spawnCount
    sourceAttributes.spawnCount = (float)elementCount;
#endif

#if HAS_STRIPS
#if !VFX_USE_SPAWNER_FROM_GPU
		${VFXLoadParameter:{stripIndex}}
#else
        uint stripIndex = sourceIndex;
#endif

        if (stripIndex >= STRIP_COUNT)
            return;

        if (!GetParticleIndex(particleIndex, stripIndex, instanceIndex))
            return;

        const StripData stripData = GetStripDataFromStripIndex(stripIndex, instanceIndex);
		InitStripAttributesWithSpawn(maxThreadId, particleIndex, attributes, stripData);
		// TODO Change seed to be sure we're deterministic on random with strip
#endif

        ${VFXProcessBlocks}

#if VFX_USE_ALIVE_CURRENT
        if (attributes.alive)
#endif
        {
#if USE_DEAD_LIST
            uint deadIndex;
            InterlockedAdd(deadList[instanceIndex], -1, deadIndex);
            deadIndex -= 1;
            deadIndex += DEAD_LIST_OFFSET + instanceIndex * RAW_CAPACITY;
            uint index = deadList[deadIndex];
#else
            uint index = particleIndex;
#endif
            ${VFXStoreAttributes}
        }
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXInit.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXOutputUpdate.template---------------
.
.
#pragma kernel CSMain
${VFXPragmaOnlyRenderers}
${VFXPragmaRequire}

${VFXGlobalInclude}
${VFXGlobalDeclaration}

#ifdef VFX_IS_RAYTRACED
#pragma multi_compile _ VFX_COMPUTE_AABBS
#endif

#if USE_MULTI_COMPILE_XR_IN_OUTPUT_UPDATE
#pragma multi_compile _ UNITY_SINGLE_PASS_STEREO STEREO_INSTANCING_ON STEREO_MULTIVIEW_ON
#endif

#if HAS_STRIPS_DATA
StructuredBuffer<uint> stripDataBuffer;
#endif

${VFXInclude("Shaders/VFXParticleCommon.template")}

ByteAddressBuffer attributeBuffer;

#if VFX_FEATURE_MOTION_VECTORS
RWByteAddressBuffer elementToVFXBuffer;
#endif

#if VFX_FEATURE_SORT
struct Kvp
{
	float sortKey;
	uint index;
};
#define IndirectOutputType Kvp
#else
#define IndirectOutputType uint
#endif

#if INDIRECT_BUFFER_COUNT > 0
RWStructuredBuffer<IndirectOutputType> outputBuffer0;
#endif
#if INDIRECT_BUFFER_COUNT > 1
RWStructuredBuffer<IndirectOutputType> outputBuffer1;
#endif
#if INDIRECT_BUFFER_COUNT > 2
RWStructuredBuffer<IndirectOutputType> outputBuffer2;
#endif
#if INDIRECT_BUFFER_COUNT > 3
RWStructuredBuffer<IndirectOutputType> outputBuffer3;
#endif
#if INDIRECT_BUFFER_COUNT > 4
#error Too many indirect buffers defined.
#endif

CBUFFER_START(updateParamsConst)
    uint dispatchWidth;
    ${VFXInstancingConstants}
    float3 cameraXRSettings;
CBUFFER_END

${VFXPerPassInclude}

${VFXGeneratedBlockFunction}

#if VFX_FEATURE_FRUSTUM_CULL || VFX_FEATURE_LOD
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"

bool IsSphereOutsideFrustum(float3 pos, float radius, float4 frustumPlanes[6])
{
    bool outside = false;
    [unroll]
    for (int i = 0; i < 6; ++i)
        outside = outside || DistanceFromPlane(pos, frustumPlanes[i]) < -radius;
    return outside;
}
#endif

#if HAS_STRIPS
${VFXDeclareGetStripTangent}
#endif

${VFXDeclareAppendOutputIndirectBuffer}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSMain(uint3 groupId		: SV_GroupID,
			uint3 groupThreadId	: SV_GroupThreadID)
{
	uint id = GetThreadId(groupId, groupThreadId, dispatchWidth);

    ${VFXInitInstancingCompute}

    ${VFXLoadContextData}
    uint systemSeed = contextData.systemSeed;
    uint nbMax = contextData.maxParticleCount;

	if (index < nbMax)
	{
        ${VFXLoadGraphValues}

#if VFX_LOCAL_SPACE
        ${VFXLoadParameter:{localToWorld}}
        vfxLocalToWorld = localToWorld;

        ${VFXLoadParameter:{worldToLocal}}
        vfxWorldToLocal = worldToLocal;
#else
        vfxWorldToLocal = k_identity4x4;
        vfxLocalToWorld = k_identity4x4;
#endif

		VFXAttributes attributes = (VFXAttributes)0;
		VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
		${VFXLoadAttributes:{alive}}
#if HAS_STRIPS
        // For strips, we need to render the entire strip, even if some particles are dead.
        const StripData stripData = GetStripDataFromParticleIndex(index, instanceIndex);
        InitStripAttributes(index, attributes, stripData);
        uint relativeIndexInStrip = GetRelativeIndex(index, stripData);
		if (relativeIndexInStrip < stripData.nextIndex)
#else
		if (attributes.alive)
#endif
		{
			${VFXLoadAttributes:{(?!(alive))(\b\w)}}
			${VFXProcessBlocks}

#if !HAS_STRIPS
            // Recheck alive as blocks can set it to false for manual culling.
            // Test will be stripped if it's not the case anyway.
            if (attributes.alive)
#endif
            {
                ${VFXLoadSize}
                float3 center = attributes.position;
#if HAS_STRIPS
                // Add an epsilon so that size is never 0 for strips
                size3.x += size3.x < 0.0f ? -VFX_EPSILON : VFX_EPSILON;
                size3.y += size3.y < 0.0f ? -VFX_EPSILON : VFX_EPSILON;
                size3.z += size3.z < 0.0f ? -VFX_EPSILON : VFX_EPSILON;

                if (relativeIndexInStrip < stripData.nextIndex - 1)
                {
                    uint nextIndex = GetParticleIndex(relativeIndexInStrip + 1,stripData);
                    center = (center + GetParticlePosition(nextIndex, instanceIndex)) * 0.5f;
                    size3 += abs(center - attributes.position) * sign(size3);
                }
#endif
                float4x4 elementToVFX = GetElementToVFXMatrix(
                    attributes.axisX,
                    attributes.axisY,
                    attributes.axisZ,
                    float3(attributes.angleX,attributes.angleY,attributes.angleZ),
                    float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
                    size3,
                    center);

#if VFX_FEATURE_FRUSTUM_CULL || VFX_FEATURE_LOD
#if VFX_WORLD_SPACE
	            float4x4 elementToWorld = elementToVFX;
                elementToWorld._m03_m13_m23 = GetCameraRelativePositionWS(elementToWorld._m03_m13_m23);
#else
                float4x4 elementToWorld = mul(GetObjectToWorldMatrix(),elementToVFX);
#endif

	            float xAxisSqrLength = dot(elementToWorld._m00_m10_m20, elementToWorld._m00_m10_m20);
	            float yAxisSqrLength = dot(elementToWorld._m01_m11_m21, elementToWorld._m01_m11_m21);
	            float zAxisSqrLength = dot(elementToWorld._m02_m12_m22, elementToWorld._m02_m12_m22);
                float radius = 0.5f * sqrt(xAxisSqrLength + yAxisSqrLength + zAxisSqrLength);

                ${VFXLoadParameter:{radiusScale}}
                radius *= radiusScale;

#if VFX_FEATURE_FRUSTUM_CULL
                if (IsSphereOutsideFrustum(elementToWorld._m03_m13_m23, radius, _FrustumPlanes))
                    return;
#endif
#endif

#if INDIRECT_BUFFER_COUNT > 0
#if VFX_FEATURE_LOD
                uint outputIndex = ~0u;
#if !VFX_FEATURE_FRUSTUM_CULL
                // If particle is out of frustum and frustum culling is disabled, use the lowest LOD
                // This is useful for shadow passes for instance to avoid out of frustum particles to be culled from shadows
                if (IsSphereOutsideFrustum(elementToWorld._m03_m13_m23, radius, _FrustumPlanes))
                    outputIndex = INDIRECT_BUFFER_COUNT - 1;
                else
#endif
                {
                    float viewZ = mul(GetWorldToViewMatrix(), float4(elementToWorld._m03_m13_m23, 1)).z;
                    float4x4 centeredProjMatrix = GetViewToHClipMatrix();
                    centeredProjMatrix._13_14_23_24 = 0.0f; //Cancels the jittering and/or the eye offset when in VR
                    float4 clip = mul(centeredProjMatrix, float4(radius, radius, viewZ, 1));
                    float lodValue = max(abs(clip.x),abs(clip.y)) * rcp(max(VFX_EPSILON, clip.w));

                    ${VFXLoadParameter:{lodValues}}

                    for (uint i = 0; i < INDIRECT_BUFFER_COUNT; ++i)
                        if (lodValue > lodValues[i])
                        {
                            outputIndex = i;
                            break;
                        }
                }
#elif INDIRECT_BUFFER_COUNT == 1
                uint outputIndex = 0;
#else
                uint outputIndex = attributes.meshIndex;
#endif
                if (outputIndex >= INDIRECT_BUFFER_COUNT)
                    return;


#if VFX_FEATURE_SORT
${VFXFeedSortingKeys}
#else
                uint output = index;
#endif

                if (outputIndex == 0)
                {
                    AppendOutputBuffer(outputBuffer0, output, instanceActiveIndex);
                }
#if INDIRECT_BUFFER_COUNT > 1
                else if (outputIndex == 1)
                {
                    AppendOutputBuffer(outputBuffer1, output, instanceActiveIndex);
                }
#if INDIRECT_BUFFER_COUNT > 2
                else if (outputIndex == 2)
                {
                    AppendOutputBuffer(outputBuffer2, output, instanceActiveIndex);
                }
#if INDIRECT_BUFFER_COUNT > 3
                else if (outputIndex == 3)
                {
                    AppendOutputBuffer(outputBuffer3, output, instanceActiveIndex);
                }
#endif
#endif
#endif
#endif

#if VFX_FEATURE_MOTION_VECTORS
                uint offsetedIndex = (RAW_CAPACITY * instanceIndex) + index;
#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
                uint viewTotal = asuint(cameraXRSettings.x);
                uint viewCount = asuint(cameraXRSettings.y);
                uint viewOffset = asuint(cameraXRSettings.z);
                uint elementToVFXIndex = offsetedIndex * (VFX_FEATURE_MOTION_VECTORS_VERTS * 2 * viewTotal + 1);
#else
                uint elementToVFXIndex = offsetedIndex * 13;
#endif
                ${VFXLoadParameter:{currentFrameIndex}}
                elementToVFXBuffer.Store(elementToVFXIndex++ << 2, attributes.alive ? asuint(currentFrameIndex) : 0u);
#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
                elementToVFXIndex += viewOffset * viewCount * VFX_FEATURE_MOTION_VECTORS_VERTS * 2;
                ${VFXLoadParameter:{targetOffset}}
                ${VFXMotionVectorVerts}
#ifdef USING_STEREO_MATRICES
                if (viewCount == 2)
                {
                    float4 stereoOffset = float4(GetWorldStereoOffset(), 0.0f);
                    UNITY_UNROLL
                    for (int itIndexVert = 0; itIndexVert < VFX_FEATURE_MOTION_VECTORS_VERTS; ++itIndexVert)
                    {
                        float4 vertPosWorld = float4(TransformPositionVFXToWorld(verts[itIndexVert]), 1.0f);
                        vertPosWorld.xyz = VFXTransformPositionWorldToCameraRelative(vertPosWorld.xyz);
                        float4 vertPosA = mul(GetNonJitteredViewProjMatrix(0), vertPosWorld);
                        float4 vertPosB = mul(GetNonJitteredViewProjMatrix(1), vertPosWorld + stereoOffset);
                        elementToVFXBuffer.Store4(elementToVFXIndex << 2, asuint(float4(vertPosA.xy / vertPosA.w, vertPosB.xy / vertPosB.w)));
                        elementToVFXIndex += 4; // 1 vert * 2 floats * 2 views
                    }
                }
                else
#endif
                {
                    UNITY_UNROLL
                    for (int itIndexVert = 0; itIndexVert < VFX_FEATURE_MOTION_VECTORS_VERTS - 1; itIndexVert += 2)
                    {
                        float4 vertPosA = TransformPositionVFXToNonJitteredClip(verts[itIndexVert]);
                        float4 vertPosB = TransformPositionVFXToNonJitteredClip(verts[itIndexVert + 1]);
                        elementToVFXBuffer.Store4(elementToVFXIndex << 2, asuint(float4(vertPosA.xy / vertPosA.w, vertPosB.xy / vertPosB.w)));
                        elementToVFXIndex += 4; // 2 verts * 2 floats
                    }
                    if (VFX_FEATURE_MOTION_VECTORS_VERTS % 2 == 1)
                    {
                        int itIndexVert = VFX_FEATURE_MOTION_VECTORS_VERTS - 1;
                        float4 vertPos = TransformPositionVFXToNonJitteredClip(verts[itIndexVert]);
                        elementToVFXBuffer.Store2(elementToVFXIndex << 2, asuint(vertPos.xy / vertPos.w));
                        elementToVFXIndex += 2; // 1 verts * 2 floats
                    }
               }
#else
                UNITY_UNROLL
                for (int itIndexMatrixRow = 0; itIndexMatrixRow < 3; ++itIndexMatrixRow)
                {
                    float4 value = elementToVFX[itIndexMatrixRow] * attributes.alive;
                    elementToVFXBuffer.Store4(elementToVFXIndex << 2, asuint(value));
                    elementToVFXIndex += 4; // 1 row * 4 floats
                }
#endif
#endif
            }
		}
        #if VFX_COMPUTE_AABBS
                ${VFXLoadSizeRT}
                int rayTracingDecimationFactor = VFX_RT_DECIMATION_FACTOR;
                FillAabbBuffer(attributes, size3, index, instanceIndex, rayTracingDecimationFactor);
        #endif
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXOutputUpdate.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXParticleCommon.template---------------
.
.

${VFXBegin:VFXVertexCommonProcess}
#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
o.VFX_VARYING_COLOR = attributes.color;
#endif
#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
o.VFX_VARYING_ALPHA = attributes.alpha;
#endif

#ifdef VFX_VARYING_EXPOSUREWEIGHT
${VFXLoadParameter:{exposureWeight}}
o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
#endif

#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
${VFXLoadParameter:{invSoftParticlesFadeDistance}}
o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
#endif

#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
${VFXLoadParameter:{alphaThreshold}}
o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
#endif

#if USE_UV_SCALE_BIAS
${VFXLoadParameter:{uvScale}}
${VFXLoadParameter:{uvBias}}
#if defined (VFX_VARYING_UV)
o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
#endif
#endif

#ifdef VFX_VARYING_ANGLEFADE
${VFXLoadParameter:{angleFade}}
o.VFX_VARYING_ANGLEFADE = angleFade;
#endif

#ifdef VFX_VARYING_FADEFACTOR
${VFXLoadParameter:{fadeFactor}}
o.VFX_VARYING_FADEFACTOR = fadeFactor;
#endif

#ifdef VFX_VARYING_DECALLAYER
${VFXLoadParameter:{decalLayerMask}}
o.VFX_VARYING_DECALLAYER = decalLayerMask;
#endif

#if defined(VFX_VARYING_POSWS)
o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
#endif

#if VFX_USE_INSTANCING
    #ifdef UNITY_INSTANCING_ENABLED
    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
    #endif
o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
#endif
${VFXEnd}

${VFXBegin:VFXGetRTScalingFactor}
float3 rtScale = float3(1,1,1);
#if VFX_USE_RT_CUSTOM_SCALE
    ${VFXLoadParameter:{rayTracedScaling}}
    rtScale = float3(rayTracedScaling, 1.0f);
#else
    #ifdef VFX_RT_DEFAULT_SCALE
        rtScale = VFX_RT_DEFAULT_SCALE;
    #endif
#endif
${VFXEnd}


${VFXBegin:VFXLoadSize}
float3 size3 = float3(attributes.size,attributes.size,attributes.size);
#if VFX_USE_SCALEX_CURRENT
size3.x *= attributes.scaleX;
#endif
#if VFX_USE_SCALEY_CURRENT
size3.y *= attributes.scaleY;
#endif
#if VFX_USE_SCALEZ_CURRENT
size3.z *= attributes.scaleZ;
#endif
${VFXEnd}

${VFXBegin:VFXLoadSizeRT}
float3 size3 = float3(attributes.size,attributes.size,attributes.size);
${VFXGetRTScalingFactor}
size3 *= rtScale;
#if VFX_USE_SCALEX_CURRENT
size3.x *= attributes.scaleX;
#endif
#if VFX_USE_SCALEY_CURRENT
size3.y *= attributes.scaleY;
#endif
#if VFX_USE_SCALEZ_CURRENT
size3.z *= attributes.scaleZ;
#endif
${VFXEnd}

${VFXBegin:VFXVertexSetFlipbooksInterpolants}
#if USE_FLIPBOOK && defined(VFX_VARYING_UV)
	#if USE_FLIPBOOK_ARRAY_LAYOUT
		${VFXLoadParameter:{flipBookSize}}
		#if USE_FLIPBOOK_INTERPOLATION
			VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
		#else
			VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
		#endif
		o.VFX_VARYING_UV.xyz = uvData.uvs.xyz;
		#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
			o.VFX_VARYING_UV.w = uvData.uvs.w;
			o.VFX_VARYING_FRAMEBLEND = uvData.blend;
			#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
				${VFXLoadParameter:{motionVectorScale}}
				o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale;
			#endif
		#endif
	#else
		${VFXLoadParameter:{invFlipBookSize}}
		${VFXLoadParameter:{flipBookSize}}
		#if USE_FLIPBOOK_INTERPOLATION
			VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
		#else
			VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
		#endif
		o.VFX_VARYING_UV.xy = uvData.uvs.xy;
		#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
			o.VFX_VARYING_UV.zw = uvData.uvs.zw;
			o.VFX_VARYING_FRAMEBLEND = uvData.blend;
			#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
				${VFXLoadParameter:{motionVectorScale}}
				o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale * invFlipBookSize;
			#endif
		#endif
	#endif
#endif
${VFXEnd}

${VFXBegin:VFXLoadAttributesOrCull}
#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
	// We render one particle less for each strip in this case
	nbMax -= STRIP_COUNT;
#endif

uint deadCount = 0;
#if USE_DEAD_LIST_COUNT
deadCount = deadList[instanceIndex];
#endif
#if VFX_USE_INSTANCING
if (index >= nbMax - deadCount)
#else
if (index >= asuint(nbMax) - deadCount)
#endif
{
	CULL_VERTEX(o);
}

VFXAttributes attributes = (VFXAttributes)0;
VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;

#if VFX_HAS_INDIRECT_DRAW
if (index >= indirectBuffer[instanceActiveIndex])
{
	CULL_VERTEX(o);
}
index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
#endif

#if HAS_STRIPS_DATA
StripData stripData;
uint relativeIndexInStrip = 0;
if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
{
	CULL_VERTEX(o);
}
#endif

#if VFX_HAS_INDIRECT_DRAW
${VFXLoadAttributes}
#else
${VFXLoadAttributes:{alive}}
#if !HAS_STRIPS
if (!attributes.alive)
{
	CULL_VERTEX(o);
}
#endif

${VFXLoadAttributes:{(?!(alive))(\b\w)}}
#endif

// Initialize built-in needed attributes
#if HAS_STRIPS_DATA
InitStripAttributes(index, attributes, stripData);
#endif
${VFXEnd}

${VFXBegin:VFXVertexComputeCurrentAndPreviousClipPos}
#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)

#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
	o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
#else
	o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
#endif

${VFXLoadParameter:{currentFrameIndex}}
uint elementToVFXBaseIndex;
if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
{
float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);

#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
	o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
	o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
#else
	float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
	float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
	o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
	o.VFX_VARYING_VELOCITY_CPOS = cPos;
#endif

}
#endif
${VFXEnd}

${VFXBegin:VFXVertexComputeDisplacement}
float displacement = 0.0;
#if VFX_FEATURE_MOTION_VECTORS
uint elementToVFXBaseIndex;
float3 previousWS;

${VFXLoadParameter:{currentFrameIndex}}
if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
{
    float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
    previousWS = TransformPreviousVFXPositionToWorld(mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz);
    displacement = length(currentWS - previousWS);
}
#endif
${VFXEnd}

${VFXBegin:VFXComputeOutputMotionVector}

//No w division with fast path of motion vectors
#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
#else
float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
#endif

#if UNITY_UV_STARTS_AT_TOP
	velocity.y = -velocity.y;
#endif
float4 encodedMotionVector = 0.0f;
VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
${VFXEnd}

${VFXBegin:VFXApplyColor}

float4 color = VFXGetFragmentColor(i);

#ifndef VFX_TEXTURE_COLOR
	#define VFX_TEXTURE_COLOR float4(1.0,1.0,1.0,1.0)
#endif

#if VFX_COLORMAPPING_DEFAULT
	o.color = color * VFX_TEXTURE_COLOR;
#endif

#if VFX_COLORMAPPING_GRADIENTMAPPED
	${VFXLoadParameter:{gradient}}
	o.color = SampleGradient(gradient, VFX_TEXTURE_COLOR.a * color.a) * float4(color.rgb,1.0);
#endif

${VFXEnd}

${VFXBegin:VFXPassDepthCommonFragmentUnlit}

#ifndef VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
#endif

#ifdef VFX_SHADERGRAPH
	#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
	${SHADERGRAPH_PIXEL_CODE_DEPTHNORMALS}
	#else
	${SHADERGRAPH_PIXEL_CODE_DEPTHONLY}
	#endif
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
int _ObjectId;
int _PassValue;
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
float4 _SelectionID;
#endif

#pragma fragment frag
void frag(ps_input i
#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
    #ifdef WRITE_MSAA_DEPTH
    // We need the depth color as SV_Target0 for alpha to coverage
    , out float4 outDepthColor : SV_Target0
    , out float4 outMotionVector : SV_Target1
    #else
    // When no MSAA, the motion vector is always the first buffer
    , out float4 outMotionVector : SV_Target0
    #endif
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
    #if defined(WRITE_MSAA_DEPTH)
	#if defined(WRITE_NORMAL_BUFFER)
	#error Unexpected depth setup mssa + depth normal
	#endif
    , out float4 outDepthColor : SV_Target0
    #elif defined(WRITE_NORMAL_BUFFER)
	, out float4 outNormalBuffer : SV_Target0
	#else
    , out float4 dummy : SV_Target0
    #endif
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
    , out float4 outSelection : SV_Target0
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
    , out float4 dummy : SV_Target0
#endif
)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	VFXTransformPSInputs(i);
	${VFXComputeNormalWS}

    #ifdef VFX_SHADERGRAPH
        ${VFXAdditionalInterpolantsPreparation}
		#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
		${SHADERGRAPH_PIXEL_CALL_DEPTHNORMALS}
		#else
		${SHADERGRAPH_PIXEL_CALL_DEPTHONLY}
		#endif
        float alpha = OUTSG.${SHADERGRAPH_PARAM_ALPHA};
    #else
        float alpha = VFXGetFragmentColor(i).a;
		#if VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
			#ifdef VFX_PROCEDURAL_UV
				alpha *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFX_PROCEDURAL_UV(i)).a;
			#else
				alpha *= VFXGetTextureColor(VFX_SAMPLER(mainTexture),i).a;
			#endif
		#endif
    #endif
	VFXClipFragmentColor(alpha,i);

	#ifdef WRITE_MSAA_DEPTH
		outDepthColor = i.VFX_VARYING_POSCS.z;
		#if VFX_USE_ALPHA_TO_MASK
			outDepthColor.a = alpha;
		#endif
	#endif

	#ifdef WRITE_NORMAL_BUFFER
		#ifdef VFX_VARYING_NORMAL
			VFXComputePixelOutputToNormalBuffer(i, normalWS, GetUVData(i), outNormalBuffer);
		#else
			//Fallback for point and lines, render normal as if those are face camera plane
			VFXComputePixelOutputToNormalBuffer(i, VFXGetWorldToViewRotMatrix()[2], GetUVData(i), outNormalBuffer);
		#endif
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
		${VFXComputeOutputMotionVector}
		outMotionVector = encodedMotionVector;
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
		outSelection = float4(_ObjectId, _PassValue, 1.0, 1.0);
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
		outSelection = _SelectionID;
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
		#if !defined(WRITE_MSAA_DEPTH) && !defined(WRITE_NORMAL_BUFFER)
		    dummy = float4(i.VFX_VARYING_POSCS.z, 0,0,0);
		#endif
	#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
		dummy = (float4)0;
	#else
		#error VFX_PASSDEPTH undefined
	#endif
}
${VFXEnd}

// Strips tangent computation
${VFXBegin:VFXDeclareGetStripTangent}
float3 GetParticlePosition(uint index, uint instanceIndex)
{
	VFXAttributes attributes = (VFXAttributes)0;
	${VFXLoadAttributes:{position}}
	return attributes.position;
}

float3 GetStripTangent(float3 currentPos, uint instanceIndex, uint relativeIndex, const StripData stripData)
{
	float3 prevTangent = (float3)0.0f;
	if (relativeIndex > 0)
	{
		uint prevIndex = GetParticleIndex(relativeIndex - 1,stripData);
		float3 tangent = currentPos - GetParticlePosition(prevIndex,instanceIndex);
		float sqrLength = dot(tangent, tangent);
		if (sqrLength > VFX_EPSILON * VFX_EPSILON)
			prevTangent = tangent * rsqrt(sqrLength);
	}

	float3 nextTangent = (float3)0.0f;
	if (relativeIndex < stripData.nextIndex - 1)
	{
		uint nextIndex = GetParticleIndex(relativeIndex + 1,stripData);
		float3 tangent = GetParticlePosition(nextIndex, instanceIndex) - currentPos;
		float sqrLength = dot(tangent, tangent);
		if (sqrLength > VFX_EPSILON * VFX_EPSILON)
			nextTangent = tangent * rsqrt(sqrLength);
	}

	return normalize(prevTangent + nextTangent);
}
${VFXEnd}

${VFXBegin:VFXInitInstancing}
uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
${VFXEnd}

${VFXBegin:VFXInitInstancingCompute}
uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
#if defined(VFX_INSTANCING_FIXED_SIZE)
	uint index = GetThreadId(groupId, 0, dispatchWidth);
	index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
	index += groupThreadId.x;
#else
	uint index = VFXInitInstancing(id, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
#endif

${VFXEnd}

${VFXBegin:VFXInstancingConstants}
float4 instancingConstants;
uint2 instancingBufferOffsets;
${VFXEnd}

${VFXBegin:VFXFeedSortingKeys}
                Kvp output;
#if VFX_CUSTOM_SORT_KEY
                ${VFXLoadParameter:{sortKey}}
                output.sortKey = -1.0f * sortKey; //Lowest values are rendered first
#elif VFX_DISTANCE_SORT_KEY
#if VFX_LOCAL_SPACE
                float3 posRWS = TransformObjectToWorld(attributes.position);
#else
                float3 posRWS = GetCameraRelativePositionWS(attributes.position);
#endif
                float3 camToPos = posRWS - GetCurrentViewPosition();

                output.sortKey = dot(camToPos,camToPos); // sqr distance to the camera
#elif VFX_DEPTH_SORT_KEY
#if VFX_LOCAL_SPACE
                float3 posRWS = TransformObjectToWorld(attributes.position);
#else
                float3 posRWS = GetCameraRelativePositionWS(attributes.position);
#endif
                float3 zAxisCam = -GetWorldToViewMatrix()[2].xyz;
                float depth = dot(posRWS, zAxisCam);
                output.sortKey = depth;

#elif VFX_YOUNGEST_SORT_KEY
                ${VFXLoadAttributes:{age}}
                output.sortKey = attributes.age;

#endif //VFX_[CRITERION]_SORT_KEY
                output.index = index;
                output.sortKey *= SORTING_SIGN;
${VFXEnd}

${VFXBegin:VFXGetIndexFromRTPrimitiveIndex}
#ifdef VFX_RT_DECIMATION_FACTOR
int rayTracingDecimationFactor = VFX_RT_DECIMATION_FACTOR;
#else
int rayTracingDecimationFactor = 1;
#endif
uint index = PrimitiveIndex() * rayTracingDecimationFactor;
uint instanceIndex =  asuint(_InstanceIndex);
uint instanceActiveIndex = asuint(_InstanceActiveIndex);
VFXGetInstanceCurrentIndex(index);
${VFXEnd}

${VFXBegin:VFXDeclareAppendOutputIndirectBuffer}
void AppendOutputBuffer(RWStructuredBuffer<IndirectOutputType> outputBuffer, IndirectOutputType output, uint instanceActiveIndex, uint increment = 1)
{
    uint indirectIndex;

#if VFX_FEATURE_SORT
    InterlockedAdd(outputBuffer[instanceActiveIndex].index, increment, indirectIndex);
#else
    InterlockedAdd(outputBuffer[instanceActiveIndex], increment, indirectIndex);
#endif
    indirectIndex /= increment;
    indirectIndex += instancingBatchSize + instanceActiveIndex * RAW_CAPACITY;
    outputBuffer[indirectIndex] = output;
}
${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXParticleCommon.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXParticleHeader.template---------------
.
.
${VFXShaderTags}

${VFXInclude("Shaders/VFXParticleCommon.template")}
${VFXOutputRenderState}

HLSLINCLUDE
${VFXPragmaOnlyRenderers}
${VFXPragmaRequire}
${VFXGlobalInclude}
${VFXGlobalDeclaration}

#define VFX_NEEDS_COLOR_INTERPOLATOR (VFX_USE_COLOR_CURRENT || VFX_USE_ALPHA_CURRENT)
#if HAS_STRIPS
#define VFX_OPTIONAL_INTERPOLATION
#else
#define VFX_OPTIONAL_INTERPOLATION nointerpolation
#endif

#if VFX_USE_INSTANCING
#define VFX_VERTEX_OUTPUT_INSTANCE_INDEX nointerpolation uint2 instanceIndices : INDEX0; //instanceCurrentIndex, instanceActiveIndex
#define VFX_VARYINGS_INSTANCE_CURRENT_INDEX instanceIndices.x
#define VFX_VARYINGS_INSTANCE_ACTIVE_INDEX instanceIndices.y
#ifdef UNITY_INSTANCING_ENABLED
    #define VFX_FRAG_SETUP_INSTANCE_ID(i) unity_InstanceID = i.VFX_VARYINGS_INSTANCE_CURRENT_INDEX
#else
    #define VFX_FRAG_SETUP_INSTANCE_ID(i)
#endif
#else
#define VFX_VERTEX_OUTPUT_INSTANCE_INDEX
#endif

ByteAddressBuffer attributeBuffer;

#if VFX_HAS_INDIRECT_DRAW
StructuredBuffer<uint> indirectBuffer;
#endif

#if USE_DEAD_LIST_COUNT
StructuredBuffer<uint> deadList;
#endif

#if HAS_STRIPS_DATA
StructuredBuffer<uint> stripDataBuffer;
#endif

#if VFX_FEATURE_MOTION_VECTORS
ByteAddressBuffer elementToVFXBufferPrevious;

#if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)

#define VFX_DECLARE_MOTION_VECTORS_STORAGE(coordA, coordB)\
noperspective float4 cPosPreviousAndNonJiterred : TEXCOORD##coordA;

#define VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS cPosPreviousAndNonJiterred.xy
#define VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER cPosPreviousAndNonJiterred.zw

#else

#define VFX_DECLARE_MOTION_VECTORS_STORAGE(coordA, coordB)\
float4 cPosPrevious : TEXCOORD##coordA;\
float4 cPosNonJiterred : TEXCOORD##coordB;

#define VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS cPosPrevious
#define VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER cPosNonJiterred

#endif
#endif

CBUFFER_START(outputParamsConst)
    ${VFXInstancingConstants}
    float3 cameraXRSettings;
CBUFFER_END

UNITY_INSTANCING_BUFFER_START(PerInstance)
    UNITY_DEFINE_INSTANCED_PROP(float, _InstanceIndex)
    UNITY_DEFINE_INSTANCED_PROP(float, _InstanceActiveIndex)
UNITY_INSTANCING_BUFFER_END(PerInstance)

// Helper macros to always use a valid instanceID
#if defined(UNITY_STEREO_INSTANCING_ENABLED)
	#define VFX_DECLARE_INSTANCE_ID     UNITY_VERTEX_INPUT_INSTANCE_ID
	#define VFX_GET_INSTANCE_ID(i)      unity_InstanceID
#else
	#define VFX_DECLARE_INSTANCE_ID     uint instanceID : SV_InstanceID;
	#define VFX_GET_INSTANCE_ID(i)      i.instanceID
#endif

ENDHLSL
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXParticleHeader.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXUpdate.template---------------
.
.
#pragma kernel CSMain
${VFXPragmaOnlyRenderers}
${VFXPragmaRequire}

${VFXGlobalInclude}
${VFXGlobalDeclaration}

#define IndirectOutputType uint

${VFXInclude("Shaders/VFXParticleCommon.template")}

#ifdef VFX_IS_RAYTRACED
#pragma multi_compile _ VFX_COMPUTE_AABBS
#endif

#define USE_DEAD_LIST (VFX_USE_ALIVE_CURRENT && !HAS_STRIPS)

RWByteAddressBuffer attributeBuffer;

#if USE_DEAD_LIST
RWStructuredBuffer<uint> deadList;
#endif

#if VFX_HAS_INDIRECT_DRAW
RWStructuredBuffer<uint> indirectBuffer;
#endif

#if HAS_STRIPS_DATA
RWStructuredBuffer<uint> stripDataBuffer;
#endif

#if VFX_USE_STRIPALIVE_CURRENT
StructuredBuffer<uint> attachedStripDataBuffer;
#endif

CBUFFER_START(updateParamsConst)
    uint dispatchWidth;
    ${VFXInstancingConstants}
    float3 cameraXRSettings;
CBUFFER_END

${VFXPerPassInclude}

#if VFX_HAS_INDIRECT_DRAW
${VFXDeclareAppendOutputIndirectBuffer}
#endif

${VFXGeneratedBlockFunction}



[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSMain(uint3 groupId          : SV_GroupID,
            uint3 groupThreadId    : SV_GroupThreadID)
{
	uint id = GetThreadId(groupId, groupThreadId, dispatchWidth);

	${VFXInitInstancingCompute}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

#if VFX_COMPUTE_BOUNDS
	uint tid = groupThreadId.x;
#endif

	if (index < nbMax)
	{
#if HAS_STRIPS
		if (index == 0)
		{
			STRIP_PARTICLE_COUNTER(instanceIndex) = 0;
		}
#endif

		${VFXLoadGraphValues}

		VFXAttributes attributes = (VFXAttributes)0;
		VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;

#if VFX_USE_ALIVE_CURRENT
		${VFXLoadAttributes:{alive|stripAlive}}
		if (attributes.alive)
		{
			${VFXLoadAttributes:{(?!(alive|stripAlive))(\b\w)}}
#if VFX_USE_OLDVELOCITY_CURRENT && VFX_USE_VELOCITY_CURRENT
			attributes.oldVelocity = attributes.velocity;
#endif
#if HAS_STRIPS
			const StripData stripData = GetStripDataFromParticleIndex(index, instanceIndex);
			InitStripAttributes(index, attributes, stripData);
#endif

#if VFX_UPDATE_SKIP_ZERO_DELTA_TIME
			${VFXLoadParameter:{deltaTime}}
			if (deltaTime != 0.0f)
#endif
			{
				${VFXProcessBlocks}
			}

			${VFXStoreAttributes:{(?!(alive))(\b\w)}}
			if (attributes.alive)
			{

#if VFX_HAS_INDIRECT_DRAW
                AppendOutputBuffer(indirectBuffer, index, instanceActiveIndex);
#endif

#if HAS_STRIPS
				uint bufferIndex = STRIP_DATA_INDEX(instanceIndex, stripData.stripIndex);
				uint relativeIndexInStrip = GetRelativeIndex(index, stripData);
				InterlockedMin(STRIP_DATA(STRIP_MIN_ALIVE, bufferIndex), relativeIndexInStrip);
				InterlockedMax(STRIP_DATA(STRIP_MAX_ALIVE, bufferIndex), relativeIndexInStrip);
#endif
			}
			else
			{
				${VFXStoreAttributes:{alive}}
#if USE_DEAD_LIST && !VFX_USE_STRIPALIVE_CURRENT
	            uint deadIndex;
		        InterlockedAdd(deadList[instanceIndex], 1, deadIndex);
				deadIndex += DEAD_LIST_OFFSET + instanceIndex * RAW_CAPACITY;
				deadList[deadIndex] = index;
#endif
			}
		}
#if USE_DEAD_LIST && VFX_USE_STRIPALIVE_CURRENT
        else if (attributes.stripAlive)
        {
            if (STRIP_DATA_X(attachedStripDataBuffer, STRIP_MIN_ALIVE, index) == ~1) // Attached strip is no longer alive, recycle the particle
            {
	            uint deadIndex;
		        InterlockedAdd(deadList[instanceIndex], 1, deadIndex);
				deadIndex += DEAD_LIST_OFFSET + instanceIndex * RAW_CAPACITY;
				deadList[deadIndex] = index;
                attributes.stripAlive = false;
                ${VFXStoreAttributes:{stripAlive}}
            }
        }
#endif

// For strips, we still need to render some dead particles if they are in the middle of the strip
#if HAS_STRIPS && VFX_HAS_INDIRECT_DRAW
		if (!attributes.alive)
		{
			const StripData stripData = GetStripDataFromParticleIndex(index, instanceIndex);
			uint relativeIndexInStrip = GetRelativeIndex(index, stripData);
			if (relativeIndexInStrip > 0 && relativeIndexInStrip < stripData.nextIndex - 1)
			{
				AppendOutputBuffer(indirectBuffer, index, instanceActiveIndex);
			}
		}
#endif

#else
		${VFXLoadAttributes}
#if VFX_USE_OLDVELOCITY_CURRENT && VFX_USE_VELOCITY_CURRENT
		attributes.oldVelocity = attributes.velocity;
#endif
#if VFX_USE_CONTINUOUSCOLLISIONCOUNT_CURRENT
		//attributes.continuousCollisionCount = 0;
#endif
#if HAS_STRIPS
        const StripData stripData = GetStripDataFromParticleIndex(index, instanceIndex);
        InitStripAttributes(index, attributes, stripData);
#endif

#if VFX_UPDATE_SKIP_ZERO_DELTA_TIME
		${VFXLoadParameter:{deltaTime}}
		if (deltaTime != 0.0f)
#endif
		{
			${VFXProcessBlocks}
		}
		${VFXStoreAttributes}
#if VFX_HAS_INDIRECT_DRAW
        AppendOutputBuffer(indirectBuffer, index, instanceActiveIndex);
#endif
#endif
#if VFX_COMPUTE_BOUNDS || VFX_COMPUTE_AABBS
    {
    #if VFX_COMPUTE_BOUNDS
        ${VFXLoadSize}
        #if VFX_WORLD_SPACE
            ${VFXLoadParameter:{worldToLocal}}
        #else
            float4x4 worldToLocal = (float4x4)0;
        #endif
		InitReduction(attributes, size3, tid, worldToLocal);
    #endif
    }
    #if VFX_COMPUTE_AABBS
            ${VFXLoadSizeRT}
            int rayTracingDecimationFactor = VFX_RT_DECIMATION_FACTOR;
            FillAabbBuffer(attributes, size3, index, instanceIndex, rayTracingDecimationFactor);
    #endif
#endif
	}
	#if VFX_COMPUTE_BOUNDS
	PerformBoundsReduction(index, tid, instanceIndex, nbMax);
	#endif
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXUpdate.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXVolumetricFogUpdate.template---------------
.
.
#pragma kernel CSMain
${VFXPragmaOnlyRenderers}
${VFXPragmaRequire}

${VFXGlobalInclude}
${VFXGlobalDeclaration}
${VFXInclude("Shaders/VFXParticleCommon.template")}

// Indirect draw is always enabled for volumetric fog output
RWStructuredBuffer<uint> indirectBuffer;

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/HDRenderPipeline.VolumetricLighting.cs.hlsl"

#if VFX_FEATURE_FRUSTUM_CULL
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"

bool IsSphereOutsideFrustum(float3 pos, float radius, float4 frustumPlanes[6])
{
    bool outside = false;
    [unroll]
    for (int i = 0; i < 6; ++i)
        outside = outside || DistanceFromPlane(pos, frustumPlanes[i]) < -radius;
    return outside;
}
#endif

uint DistanceToSlice(float distance)
{
    float t0 = DecodeLogarithmicDepthGeneralized(0, _VBufferDistanceDecodingParams);
    float de = _VBufferRcpSliceCount; // Log-encoded distance between slices

    float e1 = EncodeLogarithmicDepthGeneralized(max(t0, distance), _VBufferDistanceEncodingParams);
    e1 -= de;
    e1 /= de;

    return uint(max(0, e1 - 0.5));
}

RWStructuredBuffer<uint> maxSliceCount;

RWByteAddressBuffer attributeBuffer;

#if defined(VFX_VOLUMETRIC_FOG_PASS_1)
RWStructuredBuffer<uint> outputBuffer;
#endif

CBUFFER_START(updateParamsConst)
    uint dispatchWidth;
    ${VFXInstancingConstants}
    float3 cameraXRSettings;
CBUFFER_END

${VFXPerPassInclude}

#define IndirectOutputType uint

${VFXDeclareAppendOutputIndirectBuffer}

${VFXGeneratedBlockFunction}

groupshared uint maxSliceCountLDS[NB_THREADS_PER_GROUP];

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSMain(uint3 groupId          : SV_GroupID,
            uint3 groupThreadId    : SV_GroupThreadID)
{
    uint id = GetThreadId(groupId, groupThreadId, dispatchWidth);

    ${VFXInitInstancingCompute}

    ${VFXLoadContextData}
    uint systemSeed = contextData.systemSeed;
    uint maxParticleCount = contextData.maxParticleCount;
    uint threadIdInGroup = groupThreadId.x;

#if defined(VFX_VOLUMETRIC_FOG_PASS_CLEAR)
    if (index <= instanceActiveIndex)
        maxSliceCount[instanceActiveIndex] = 0;
    return;
#endif

    ${VFXLoadGraphValues}

    VFXAttributes attributes = (VFXAttributes)0;
    VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;

    // Load static matrix for compute shader access to local to world
#if VFX_LOCAL_SPACE
    ${VFXLoadParameter:{localToWorld}}
    vfxLocalToWorld = localToWorld;
#else
    vfxLocalToWorld = k_identity4x4;
#endif
    vfxWorldToLocal = k_identity4x4;

    ${VFXLoadAttributes}
    {
        ${VFXProcessBlocks}
    }

    // Compute the max amount of slices hit by the particles
    uint hitSliceCount = 0;
    uint startSliceIndex = 0;
    if (index < maxParticleCount)
    {
        ${VFXLoadSize}

        float3x3 rot = GetEulerMatrix(radians(float3(attributes.angleX,attributes.angleY,attributes.angleZ)));
        float4x4 elementToVFX = GetElementToVFXMatrix(
            attributes.axisX,
            attributes.axisY,
            attributes.axisZ,
            rot,
            float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
            size3,
            attributes.position);

        float3 vPos = mul(elementToVFX,float4(0, 0, 0,1.0f)).xyz;
        float3 vPosWS = TransformPositionVFXToWorld(vPos);

#ifdef VFX_WORLD_SPACE
        vPosWS = GetCameraRelativePositionWS(vPosWS);
#endif

        float radius = attributes.size * attributes.scaleX * 0.5;
        float distanceToCamera = length(vPosWS);
        uint stopSliceIndex = 0;
        startSliceIndex = max(DistanceToSlice(distanceToCamera - radius), 0);
        bool fogParticleVisible = startSliceIndex <= uint(_MaxSliceCount);

#if defined(VFX_FEATURE_FRUSTUM_CULL)
        if (!IsSphereOutsideFrustum(vPosWS, radius, _FrustumPlanes))
#endif

        if (attributes.alive && fogParticleVisible)
        {
            stopSliceIndex = min(DistanceToSlice(distanceToCamera + radius), uint(_MaxSliceCount));
            hitSliceCount = clamp(stopSliceIndex - startSliceIndex, 0, uint(_MaxSliceCount));
        }
    }

#if defined(VFX_VOLUMETRIC_FOG_PASS_0)

    // Load slice hit count in LDS
    maxSliceCountLDS[threadIdInGroup] = clamp(hitSliceCount, 0, int(_MaxSliceCount) - startSliceIndex);

    // Perform reduction on LDS to get the max slice count in the final buffer
    GroupMemoryBarrierWithGroupSync();
    for (uint s = NB_THREADS_PER_GROUP / 2; s > 0; s >>= 1)
    {
        if (threadIdInGroup < s)
            maxSliceCountLDS[threadIdInGroup] = max(maxSliceCountLDS[threadIdInGroup], maxSliceCountLDS[threadIdInGroup + s]);
        GroupMemoryBarrierWithGroupSync();
    }

    // Aggregate final result in maxSliceCount buffer with an interlocked op
    if (threadIdInGroup == 0)
        InterlockedMax(maxSliceCount[instanceActiveIndex], maxSliceCountLDS[0]);

#elif defined(VFX_VOLUMETRIC_FOG_PASS_1)

    // Fill indirect buffer
    if (attributes.alive && maxSliceCount[instanceActiveIndex] > 0 && hitSliceCount > 0)
    {
        AppendOutputBuffer(outputBuffer, index, instanceActiveIndex, maxSliceCount[instanceActiveIndex]);
    }

#endif
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\VFXVolumetricFogUpdate.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleDecals\Pass.template---------------
.
.
#pragma target 4.5
${VFXPassForwardAdditionalPragma}

struct ps_input
{
	float4 pos : SV_POSITION;

	#if VFX_NEEDS_COLOR_INTERPOLATOR
	nointerpolation float4 color : COLOR0;
	#endif
	#if USE_ALPHA_TEST || USE_FLIPBOOK || USE_EXPOSURE_WEIGHT
	// x: alpha threshold
	// y: texture index
	// z: exposure weight
	// w: texture index blend
	nointerpolation float4 builtInInterpolants : TEXCOORD0;
	#if USE_FLIPBOOK
	#if USE_FLIPBOOK_ARRAY_LAYOUT
			nointerpolation float flipBookSize : TEXCOORD6;
		#else
			nointerpolation float4 flipBookSize : TEXCOORD6;
		#endif
	#endif
	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vectors scale X
	// y: motion vectors scale Y
	nointerpolation float2 builtInInterpolants2 : TEXCOORD7;
	#endif
	#endif

	nointerpolation float4 worldToDecal0 : TEXCOORD2;
	nointerpolation float4 worldToDecal1 : TEXCOORD3;
	nointerpolation float4 worldToDecal2 : TEXCOORD4;

	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD5;
	#endif

	UNITY_VERTEX_OUTPUT_STEREO

	#if USE_UV_SCALE_BIAS
	nointerpolation float4 scaleBias : TEXCOORD6;
	#endif
    VFX_VERTEX_OUTPUT_INSTANCE_INDEX

};

struct ps_output
{
	float4 color : SV_Target0;
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
#if USE_FLIPBOOK
#define VFX_VARYING_TEXINDEX builtInInterpolants.y
#if USE_FLIPBOOK_INTERPOLATION
#define VFX_VARYING_TEXINDEXBLEND builtInInterpolants.w
#endif
#if USE_FLIPBOOK_ARRAY_LAYOUT
	#define VFX_VARYING_FLIPBOOKSIZE flipBookSize
#else
	#define VFX_VARYING_FLIPBOOKSIZE flipBookSize.xy
	#define VFX_VARYING_INVFLIPBOOKSIZE flipBookSize.zw
#endif
#endif
#if USE_FLIPBOOK_MOTIONVECTORS
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#endif
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.z
#endif
#if USE_UV_SCALE_BIAS
#define VFX_VARYING_UV_SCALE scaleBias.xy
#define VFX_VARYING_UV_BIAS scaleBias.zw
#endif

${VFXBegin:VFXVertexAdditionalProcess}
float4x4 worldToDecal = GetVFXToElementMatrix(
	attributes.axisX,
	attributes.axisY,
	attributes.axisZ,
	float3(attributes.angleX,attributes.angleY,attributes.angleZ),
	float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
	size3,
	attributes.position);

#if VFX_LOCAL_SPACE
worldToDecal = mul(worldToDecal, VFXGetWorldToObjectMatrix());
#endif
o.worldToDecal0 = worldToDecal[0];
o.worldToDecal1 = worldToDecal[1];
o.worldToDecal2 = worldToDecal[2];
${VFXEnd}

${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
int _ObjectId;
int _PassValue;
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
float4 _SelectionID;
#endif

#pragma fragment frag
ps_output frag(ps_input i)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	ps_output o = (ps_output)0;
	VFXTransformPSInputs(i);
#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif
	float3 clipPos;

	clipPos.xy = VFXGetNormalizedScreenSpaceUV(i.pos) * 2.0f - 1.0f;
	clipPos.z = VFXSampleDepth(i.pos);
	clipPos.y *= _ProjectionParams.x;

    float4 hpositionWS = mul(UNITY_MATRIX_I_VP, float4(clipPos,1.0f));
    float4 worldPos = float4(hpositionWS.xyz / hpositionWS.w, 1.0f);

	float4x4 worldToElement;
	worldToElement[0] = i.worldToDecal0;
	worldToElement[1] = i.worldToDecal1;
	worldToElement[2] = -1.0f * i.worldToDecal2; //Z points TOWARDS the surface, so we need to revert it
	worldToElement[3] = float4(0,0,0,1);

    float3 positionDS = mul(worldToElement, worldPos).xyz * 2.0f;

	const float bias = 0.0f;
	clip(1.0f - abs(positionDS) + bias);

	float2 uv = positionDS.xy * 0.5f + 0.5f;

	#define VFX_TEXTURE_COLOR VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,uv)
	${VFXApplyColor}

	o.color = VFXApplyPreExposure(o.color, i);
	o.color = VFXApplyFog(o.color,i);
	VFXClipFragmentColor(o.color.a,i);

#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
	o.color = float4(_ObjectId, _PassValue, 1.0, 1.0);
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
	o.color = _SelectionID;
#else
	//VFX_PASSDEPTH isn't defined in forward (but we are sharing the same template)
	o.color.a = saturate(o.color.a);
	o.color = VFXTransformFinalColor(o.color,i);
#endif
	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleDecals\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleDecals\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	ZWrite Off

	HLSLPROGRAM
	${VFXPassForwardDefine}
	${VFXInclude("Shaders/ParticleDecals/Pass.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleDecals\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleDecals\PassSelection.template---------------
.
.
// Forward pass
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXInclude("Shaders/ParticleDecals/Pass.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXInclude("Shaders/ParticleDecals/Pass.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleDecals\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\Pass.template---------------
.
.
#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS must be defined.
#endif

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
	VFX_DECLARE_INSTANCE_ID
};

#pragma vertex vert
VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
{
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

	UNITY_SETUP_INSTANCE_ID(i);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	uint index = (id >> 3) + VFX_GET_INSTANCE_ID(i) * 1024;

	${VFXInitInstancing}
	${VFXLoadGraphValues}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}

	if (!attributes.alive)
		return o;

	float3 offsets = (float3)0;
	offsets.x = float(id & 1);
	offsets.y = (id & 2) * 0.5f;
	offsets.z = (id & 4) * 0.25f;
	offsets -= 0.5f;

	${VFXLoadSize}

	float3x3 rot = GetEulerMatrix(radians(float3(attributes.angleX,attributes.angleY,attributes.angleZ)));
	float4x4 elementToVFX = GetElementToVFXMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		rot,
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

	float3 inputVertexPosition = offsets;
	float3 vPos = mul(elementToVFX,float4(inputVertexPosition,1.0f)).xyz;
	float3 vPosWS = TransformPositionVFXToWorld(vPos);

#ifdef VFX_VARYING_POSWS
	o.VFX_VARYING_POSWS = vPosWS;
#endif
#ifdef VFX_VARYING_OFFSETS
	o.VFX_VARYING_OFFSETS = offsets * 2.0f;
#endif
#ifdef VFX_VARYING_FACEID
	o.VFX_VARYING_FACEID = (id & 7) % 5;
#endif
#if defined(VFX_VARYING_ROTX) && defined(VFX_VARYING_ROTY)
	rot = mul(transpose(float3x3(attributes.axisX,attributes.axisY,attributes.axisZ)),rot);
#ifdef VFX_LOCAL_SPACE
	rot = mul((float3x3)VFXGetObjectToWorldMatrix(),rot);
#endif
	o.VFX_VARYING_ROTX = rot[0];
	o.VFX_VARYING_ROTY = rot[1];
#endif
	o.VFX_VARYING_POSCS = VFXTransformPositionWorldToClip(vPosWS);

	${VFXVertexComputeCurrentAndPreviousClipPos}

	${VFXVertexCommonProcess}


	#if USE_UV_SCALE_BIAS && defined(VFX_VARYING_UV_SCALE) && defined(VFX_VARYING_UV_BIAS)
	o.VFX_VARYING_UV_SCALE = uvScale;
	o.VFX_VARYING_UV_BIAS = uvBias;
	#endif

	#if USE_FLIPBOOK
		${VFXLoadParameter:{flipBookSize}}
		${VFXLoadParameter:{invFlipBookSize}}
		#ifdef VFX_VARYING_TEXINDEX
			o.VFX_VARYING_TEXINDEX = attributes.texIndex;
		#endif
		#ifdef VFX_VARYING_TEXINDEXBLEND
			o.VFX_VARYING_TEXINDEXBLEND = attributes.texIndexBlend;
		#endif

		#if defined(VFX_VARYING_FLIPBOOKSIZE)
			o.VFX_VARYING_FLIPBOOKSIZE = flipBookSize;
		#endif
		#if defined(VFX_VARYING_INVFLIPBOOKSIZE)
			o.VFX_VARYING_INVFLIPBOOKSIZE = invFlipBookSize;
		#endif
		#ifdef VFX_VARYING_TEXINDEX
			#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
				${VFXLoadParameter:{motionVectorScale}}
				#if USE_FLIPBOOK_ARRAY_LAYOUT
					o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale;
				#else
					o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale * invFlipBookSize;
				#endif
			#endif
		#endif
	#endif

	${VFXVertexAdditionalProcess}

	return o;
}

float3 VFXCubeGetLocalNormal(VFX_VARYING_PS_INPUTS i)
{
#ifdef VFX_VARYING_OFFSETS
	//float3 s = i.VFX_VARYING_OFFSETS > 0 ? 1.0f : -1.0f;
	//return s * (step(1.0f,s * i.VFX_VARYING_OFFSETS + 1e-5));
	return int3(i.VFX_VARYING_OFFSETS * 1.00001f); // cast uses round_z
#else
	return 0.0f;
#endif
}

float3 VFXCubeTransformNormalTS(float3 faceNormal,float3 normal)
{
	float3x3 tbn = float3x3(faceNormal.zyx,faceNormal.xzy,faceNormal.xyz);
	return mul(tbn,normal);
}

float3 VFXCubeTransformNormalTS(VFX_VARYING_PS_INPUTS i,float3 normal,bool frontFace = true)
{
#if defined(VFX_VARYING_OFFSETS) && defined(VFX_VARYING_FACEID)
	float3x3 tbn;
	float3 faceNormal = VFXCubeGetLocalNormal(i);
	if (i.VFX_VARYING_FACEID == 0)
		tbn = float3x3(-faceNormal.zxy,faceNormal.yzx * faceNormal.yzx,faceNormal.xyz);
	else if (i.VFX_VARYING_FACEID == 1)
		tbn = float3x3(faceNormal.yxz, faceNormal.xzy, float3(0, 1, 0));
	else
		tbn = float3x3(faceNormal.yzx, float3(0,1,0),faceNormal.xyz);
#ifdef USE_DOUBLE_SIDED
	float multiplier = frontFace ? 1.0f : -1.0f;
	tbn[0] *= multiplier;
	tbn[2] *= multiplier;
#endif
	return mul(tbn, normal);
#else
	return normal;
#endif
}

float3 VFXCubeTransformNormalWS(VFX_VARYING_PS_INPUTS i,float3 normal)
{
#if defined(VFX_VARYING_ROTX) && defined(VFX_VARYING_ROTY)
	float3x3 rot = float3x3(i.rotX,i.rotY,cross(i.rotX,i.rotY));
	return mul(rot,normal);
#else
	return normal;
#endif
}

float2 VFXCubeGetUV(VFX_VARYING_PS_INPUTS i)
{
#if defined(VFX_VARYING_OFFSETS) && defined(VFX_VARYING_FACEID)
	float2 uv;
	if (i.VFX_VARYING_FACEID == 0)
		uv = i.VFX_VARYING_OFFSETS.xy * float2(-i.VFX_VARYING_OFFSETS.z,1);
	else if (i.VFX_VARYING_FACEID == 1)
		uv = i.VFX_VARYING_OFFSETS.xz * float2(i.VFX_VARYING_OFFSETS.y,1);
	else
		uv = i.VFX_VARYING_OFFSETS.zy * float2(i.VFX_VARYING_OFFSETS.x,1);
	return uv * 0.5f + 0.5f;
#else
	return 0.0f;
#endif
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassBasicForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}

	${VFXInclude("Shaders/ParticleHexahedron/PassBasicForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassBasicForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassBasicForwardCommon.template---------------
.
.
struct ps_input
{
	float4 pos : SV_POSITION;
	float3 offsets : TEXCOORD0;
	#if VFX_NEEDS_COLOR_INTERPOLATOR
	nointerpolation float4 color : COLOR0;
	#endif
	#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD
	// x: inverse soft particles fade distance
	// y: alpha threshold
	nointerpolation float2 builtInInterpolants : TEXCOORD1;
	#endif
	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vectors scale X
	// y: motion vectors scale Y
	nointerpolation float2 builtInInterpolants2 : TEXCOORD2;
	#endif
	nointerpolation uint faceID : TEXCOORD3;
	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD4;
	#endif
	#if USE_UV_SCALE_BIAS
	nointerpolation float4 scaleBias : TEXCOORD5;
	#endif
	#if USE_FLIPBOOK
	#if USE_FLIPBOOK_ARRAY_LAYOUT
		nointerpolation float flipBookSize : TEXCOORD6;
	#else
		nointerpolation float4 flipBookSize : TEXCOORD6;
	#endif
	// x: texIndex
	// y: texIndexBlend
	nointerpolation float2 texIndices : TEXCOORD7;
	#endif
	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_DECLARE_MOTION_VECTORS_STORAGE(7, 8)
	#endif
	VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	UNITY_VERTEX_OUTPUT_STEREO
};

struct ps_output
{
	float4 color : SV_Target0;
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	float4 outMotionVector : SV_Target1;
#endif
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_OFFSETS offsets
#define VFX_VARYING_FACEID faceID
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_UV_SCALE_BIAS
#define VFX_VARYING_UV_SCALE scaleBias.xy
#define VFX_VARYING_UV_BIAS scaleBias.zw
#endif
#if USE_FLIPBOOK
#define VFX_VARYING_TEXINDEX texIndices.x
#if USE_FLIPBOOK_INTERPOLATION
#define VFX_VARYING_TEXINDEXBLEND texIndices.y
#endif
#if USE_FLIPBOOK_ARRAY_LAYOUT
#define VFX_VARYING_FLIPBOOKSIZE flipBookSize
#else
#define VFX_VARYING_FLIPBOOKSIZE flipBookSize.xy
#define VFX_VARYING_INVFLIPBOOKSIZE flipBookSize.zw
#endif
#endif
#if USE_FLIPBOOK_MOTIONVECTORS
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#endif

#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXPassForwardDefine}
${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}

#pragma fragment frag
ps_output frag(ps_input i)
{
#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	ps_output o = (ps_output)0;
	VFXTransformPSInputs(i);
	o.color = VFXGetFragmentColor(i);

	o.color *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFXCubeGetUV(i));
	o.color = VFXApplyFog(o.color,i);
	VFXClipFragmentColor(o.color.a,i);

#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	${VFXComputeOutputMotionVector}
	o.outMotionVector = encodedMotionVector;
	o.outMotionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
#endif

    ${VFXUnlitDebugDisplay}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassBasicForwardCommon.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassDepth.template---------------
.
.
// Depth pass
Pass
{
    Name ${VFXPassDepth}
	Tags { "LightMode"=${VFXPassDepth} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticleHexahedron/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassDepthOrMV.template---------------
.
.
#pragma target 4.5

struct ps_input
{
	float4 pos : SV_POSITION;
	float3 offsets : TEXCOORD0;
	#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
	// x: alpha
	// y: alpha threshold
	nointerpolation float2 builtInInterpolants : TEXCOORD1;
	#endif
	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(2,3)
	#endif
	
	nointerpolation uint faceID : TEXCOORD4;

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX

};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
#define VFX_VARYING_ALPHA builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#endif
#define VFX_VARYING_OFFSETS offsets
#define VFX_VARYING_FACEID faceID
#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
${VFXPassShadowDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
${VFXPassDepthDefine}
#endif

${VFXBegin:VFXVertexAdditionalProcess}
#if VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
VFXApplyShadowBias(o.VFX_VARYING_POSCS, vPosWS);
#endif
${VFXEnd}

${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}
#define VFX_PROCEDURAL_UV VFXCubeGetUV
#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 1
${VFXPassDepthCommonFragmentUnlit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5

	struct ps_input
	{
		float4 pos : SV_POSITION;

		#if VFX_NEEDS_COLOR_INTERPOLATOR
		nointerpolation float4 color : COLOR0;
		#endif
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_EXPOSURE_WEIGHT
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: exposure weight
		nointerpolation float3 builtInInterpolants : TEXCOORD1;
		#endif

        UNITY_VERTEX_OUTPUT_STEREO

        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

	struct ps_output
	{
		float4 color : SV_Target0;
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.z
#endif

	${VFXPassForwardDefine}
	${VFXInclude("Shaders/ParticleHexahedron/Pass.template")}

	#pragma fragment frag
	ps_output frag(ps_input i)
	{
    #if VFX_USE_GRAPH_VALUES
        uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
        ${VFXLoadGraphValues}
    #endif
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		ps_output o = (ps_output)0;
		VFXTransformPSInputs(i);

		o.color = VFXGetFragmentColor(i);

        o.color = VFXApplyPreExposure(o.color, i);
		o.color = VFXApplyFog(o.color,i);
		VFXClipFragmentColor(o.color.a,i);
		o.color.a = saturate(o.color.a);
        o.color = VFXTransformFinalColor(o.color,i);
		return o;
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassSelection.template---------------
.
.
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXInclude("Shaders/ParticleHexahedron/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXInclude("Shaders/ParticleHexahedron/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SHADOW
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif
	${VFXInclude("Shaders/ParticleHexahedron/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassVelocity.template---------------
.
.
Pass
{
    Name ${VFXPassVelocity}
	Tags { "LightMode"=${VFXPassVelocity} }

	${VFXStencilMotionVector}

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	${VFXPassVelocityAdditionalPragma}
	${VFXInclude("Shaders/ParticleHexahedron/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleHexahedron\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\Pass.template---------------
.
.
#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
#error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
#endif

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
	VFX_DECLARE_INSTANCE_ID
};

#if HAS_STRIPS
${VFXDeclareGetStripTangent}
#endif

#pragma vertex vert

VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
{
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

	UNITY_SETUP_INSTANCE_ID(i);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	uint index = id >> 1;

	${VFXInitInstancing}

	${VFXLoadGraphValues}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}

	#if HAS_STRIPS
	float3 vPos = attributes.position;
	#else

	if (!attributes.alive)
		return o;

	#if TARGET_FROM_ATTRIBUTES
	${VFXLoadSize}
	float4x4 elementToVFX = GetElementToVFXMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

	attributes.position = mul(elementToVFX,float4(0,0,0,1)).xyz;

	${VFXLoadParameter:{targetOffset}}
	attributes.targetPosition = mul(elementToVFX,float4(targetOffset,1)).xyz;
	#endif

	// If ever used we need the position in vfx space (we dont take into account the pixel offset)
	float3 vPos = id & 1 ? attributes.targetPosition : attributes.position;
	#endif

	o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);

	${VFXVertexComputeCurrentAndPreviousClipPos}
	${VFXVertexCommonProcess}
	${VFXVertexAdditionalProcess}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassDepth.template---------------
.
.
// Depth pass
Pass
{
    Name ${VFXPassDepth}
	Tags { "LightMode"=${VFXPassDepth} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticleLines/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassDepthNormal.template---------------
.
.
// Depth Normal pass
Pass
{
	Name ${VFXPassDepthNormal}
	Tags { "LightMode"=${VFXPassDepthNormal} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#define WRITE_NORMAL_BUFFER
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticleLines/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassDepthNormal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassDepthOrMV.template---------------
.
.
#pragma target 4.5

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
	VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants : TEXCOORD0;
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(1,2)
	#endif

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.y
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
${VFXPassDepthDefine}
#endif

${VFXInclude("Shaders/ParticleLines/Pass.template")}
#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
${VFXPassDepthCommonFragmentUnlit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}

	${VFXInclude("Shaders/ParticleLines/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassForwardCommon.template---------------
.
.
struct ps_input
{
	float4 pos : SV_POSITION;
	#if VFX_NEEDS_COLOR_INTERPOLATOR
	VFX_OPTIONAL_INTERPOLATION float4 color : COLOR0;
	#endif
	#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_OPTIONAL_INTERPOLATION float3 builtInInterpolants : TEXCOORD0;
	#endif
	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD1;
	#endif

	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_DECLARE_MOTION_VECTORS_STORAGE(2,3)
	#endif

	UNITY_VERTEX_OUTPUT_STEREO
    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

struct ps_output
{
	float4 color : SV_Target0;
	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	float4 motionVector : SV_Target1;
	#endif
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.z
#endif
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXPassForwardDefine}
${VFXInclude("Shaders/ParticleLines/Pass.template")}

#pragma fragment frag
ps_output frag(ps_input i)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	ps_output o = (ps_output)0;
	VFXTransformPSInputs(i);

#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif

	${VFXApplyColor}
	o.color = VFXApplyPreExposure(o.color, i);
	o.color = VFXApplyAO(o.color,i);
	o.color = VFXApplyFog(o.color,i);
	VFXClipFragmentColor(o.color.a,i);
	o.color.a = saturate(o.color.a);
	o.color = VFXTransformFinalColor(o.color,i);

	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	${VFXComputeOutputMotionVector}
	o.motionVector = encodedMotionVector;
	o.motionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
	#endif

    ${VFXUnlitDebugDisplay}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassForwardCommon.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassSelection.template---------------
.
.
Pass
{		
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off
	
	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXInclude("Shaders/ParticleLines/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{		
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off
	
	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXInclude("Shaders/ParticleLines/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#pragma target 4.5
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif

	struct ps_input
	{
		float4 pos : SV_POSITION;
		#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
		VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants : TEXCOORD0;
		#endif

		UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.y
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x

${VFXBegin:VFXVertexAdditionalProcess}
float3 posWS = TransformPositionVFXToWorld(vPos);
VFXApplyShadowBias(o.VFX_VARYING_POSCS, posWS);
${VFXEnd}

	${VFXPassShadowDefine}
	${VFXInclude("Shaders/ParticleLines/Pass.template")}

	#pragma fragment frag
	float frag(ps_input i) : SV_TARGET
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		float alpha = VFXGetFragmentColor(i).a;
		VFXClipFragmentColor(alpha,i);
		return 0;
	}
	ENDHLSL

${VFXBegin:VFXVertexAdditionalProcess}
${VFXEnd}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassVelocity.template---------------
.
.
Pass
{
    Name ${VFXPassVelocity}
	Tags { "LightMode"=${VFXPassVelocity} }

	${VFXStencilMotionVector}

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	${VFXPassVelocityAdditionalPragma}
	${VFXInclude("Shaders/ParticleLines/PassDepthOrMV.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLines\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\Pass.template---------------
.
.
#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
#error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
#endif

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
	VFX_DECLARE_INSTANCE_ID
};

#pragma vertex vert
float4 ClipOnNearPlane(float4 pos, float4 other)
{
	if (pos.w >= _ProjectionParams.y || other.w < _ProjectionParams.y)
		return pos;

	// Project on near plane
	float ratio = (_ProjectionParams.y - pos.w) / (other.w - pos.w);
	return pos + (other - pos) * ratio;
}

VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
{
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

	UNITY_SETUP_INSTANCE_ID(i);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	uint index = (id >> 2) + VFX_GET_INSTANCE_ID(i) * 2048;

	${VFXInitInstancing}
	${VFXLoadGraphValues}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}

	if (!attributes.alive)
		return o;

	#if TARGET_FROM_ATTRIBUTES
	${VFXLoadSize}
	float4x4 elementToVFX = GetElementToVFXMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

	attributes.position = mul(elementToVFX,float4(0,0,0,1)).xyz;

	${VFXLoadParameter:{targetOffset}}
	attributes.targetPosition = mul(elementToVFX,float4(targetOffset,1)).xyz;
	#endif

	float4 pos0 = TransformPositionVFXToClip(attributes.position);
	float4 pos1 = TransformPositionVFXToClip(attributes.targetPosition);

	pos0 = ClipOnNearPlane(pos0, pos1);
	pos1 = ClipOnNearPlane(pos1, pos0);

	float2 ndcPos0 = pos0.xy / pos0.w;
	float2 ndcPos1 = pos1.xy / pos1.w;

	float2 dir = ndcPos0 - ndcPos1;
	float2 normal = normalize(dir.yx * float2(-1,abs(UNITY_MATRIX_P[1][1]) / UNITY_MATRIX_P[0][0]));

#if IS_OPAQUE_PARTICLE
	const float thicknessMul = 1.0f; // pixel perfect
#else
	const float thicknessMul = 2.0f; // for AA
#endif
	normal *= thicknessMul / _ScreenParams.xy;

	float4 dPos0 = float4(normal * pos0.w, 0.0f, 0.0f);
	float4 dPos1 = float4(normal * pos1.w, 0.0f, 0.0f);
	float4 vPosArray[4] = { pos0 + dPos0, pos0 - dPos0, pos1 + dPos1, pos1 - dPos1};

	#ifdef VFX_VARYING_PIXELOFFSET
	o.VFX_VARYING_PIXELOFFSET = (id & 1) ? -1.0f : 1.0f;
	#endif

	// If ever used we need the position in vfx space (we dont take into account the pixel offset)
	float3 vPos = ((id >> 1) & 1) ? attributes.targetPosition : attributes.position;

	o.VFX_VARYING_POSCS = vPosArray[id & 3];

	${VFXVertexComputeCurrentAndPreviousClipPos}
	${VFXVertexCommonProcess}
	${VFXVertexAdditionalProcess}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassDepth.template---------------
.
.
// Depth pass
Pass
{
    Name ${VFXPassDepth}
	Tags { "LightMode"=${VFXPassDepth} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticleLinesSW/PassDepthOrMV.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassDepthNormal.template---------------
.
.
// Depth Normal pass
Pass
{
	Name ${VFXPassDepthNormal}
	Tags { "LightMode"=${VFXPassDepthNormal} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#define WRITE_NORMAL_BUFFER
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticleLinesSW/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassDepthNormal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassDepthOrMV.template---------------
.
.
#pragma target 4.5

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
	VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants : TEXCOORD0;
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(1,2)
	#endif

	UNITY_VERTEX_OUTPUT_STEREO
    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.y
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
${VFXPassDepthDefine}
#endif

${VFXInclude("Shaders/ParticleLinesSW/Pass.template")}
#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
${VFXPassDepthCommonFragmentUnlit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}

	${VFXInclude("Shaders/ParticleLinesSW/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassForwardCommon.template---------------
.
.
struct ps_input
{
	float4 pos : SV_POSITION;
	#if IS_TRANSPARENT_PARTICLE
#if defined (SHADER_API_PSSL) || defined(SHADER_API_GAMECORE)
	/*noperspective (see case 1237742)*/ float pixelOffset : TEXCOORD0; // for AA
#else
	noperspective float pixelOffset : TEXCOORD0; // for AA
#endif
	#endif
	#if VFX_NEEDS_COLOR_INTERPOLATOR
	VFX_OPTIONAL_INTERPOLATION float4 color : COLOR0;
	#endif
	#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_OPTIONAL_INTERPOLATION float3 builtInInterpolants : TEXCOORD1;
	#endif
	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD2;
	#endif

	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_DECLARE_MOTION_VECTORS_STORAGE(3,4)
	#endif

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX

};

struct ps_output
{
	float4 color : SV_Target0;
	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	float4 motionVector : SV_Target1;
	#endif
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#if IS_TRANSPARENT_PARTICLE
#define VFX_VARYING_PIXELOFFSET pixelOffset
#endif
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.z
#endif
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXPassForwardDefine}
${VFXInclude("Shaders/ParticleLinesSW/Pass.template")}

#pragma fragment frag
ps_output frag(ps_input i)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	ps_output o = (ps_output)0;
	VFXTransformPSInputs(i);

#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif

	${VFXApplyColor}

	// Line AA
	#if IS_TRANSPARENT_PARTICLE
	o.color.a *= 1.0f - abs(i.pixelOffset);
	#endif

	o.color = VFXApplyPreExposure(o.color, i);
	o.color = VFXApplyAO(o.color,i);
	o.color = VFXApplyFog(o.color,i);
	VFXClipFragmentColor(o.color.a,i);
	o.color.a = saturate(o.color.a);
	o.color = VFXTransformFinalColor(o.color,i);

	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	${VFXComputeOutputMotionVector}
	o.motionVector = encodedMotionVector;
	o.motionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
	#endif

    ${VFXUnlitDebugDisplay}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassForwardCommon.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassSelection.template---------------
.
.
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXInclude("Shaders/ParticleLinesSW/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXInclude("Shaders/ParticleLinesSW/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#pragma target 4.5
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif

	struct ps_input
	{
		float4 pos : SV_POSITION;
		#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
		VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants : TEXCOORD0;
		#endif

		UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.y
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x

${VFXBegin:VFXVertexAdditionalProcess}
float3 posWS = TransformPositionVFXToWorld(vPos);
VFXApplyShadowBias(o.VFX_VARYING_POSCS, posWS);
${VFXEnd}

	${VFXPassShadowDefine}
	${VFXInclude("Shaders/ParticleLinesSW/Pass.template")}

	#pragma fragment frag
	float frag(ps_input i) : SV_TARGET
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		float alpha = VFXGetFragmentColor(i).a;
		VFXClipFragmentColor(alpha,i);
		return 0;
	}
	ENDHLSL

${VFXBegin:VFXVertexAdditionalProcess}
${VFXEnd}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassVelocity.template---------------
.
.
Pass
{
    Name ${VFXPassVelocity}
	Tags { "LightMode"=${VFXPassVelocity} }

	${VFXStencilMotionVector}

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	${VFXPassVelocityAdditionalPragma}
	${VFXInclude("Shaders/ParticleLinesSW/PassDepthOrMV.template")}

	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleLinesSW\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\Pass.template---------------
.
.
#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS and VFX_VARYING_UV must be defined.
#endif

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
	float3 pos : POSITION;
	float2 uv : TEXCOORD0;
    #if VFX_SHADERGRAPH_HAS_UV1
    float4 uv1 : TEXCOORD1;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV2
    float4 uv2 : TEXCOORD2;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV3
    float4 uv3 : TEXCOORD3;
    #endif
    #if VFX_SHADERGRAPH_HAS_COLOR
    float4 vertexColor : COLOR;
    #endif
	float3 normal : NORMAL;
	#if defined(VFX_VARYING_TANGENT) || SHADERGRAPH_HAS_NORMAL
	float4 tangent : TANGENT;
	#endif
	VFX_DECLARE_INSTANCE_ID
};

#pragma vertex vert
VFX_VARYING_PS_INPUTS vert(vs_input i)
{
    VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

	UNITY_SETUP_INSTANCE_ID(i);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	uint index = VFX_GET_INSTANCE_ID(i);

	${VFXInitInstancing}
	${VFXLoadGraphValues}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}

	if (!attributes.alive)
		return o;

    #ifdef VFX_VARYING_UV
    o.VFX_VARYING_UV.xy = i.uv;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV1
    o.uv1 = i.uv1;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV2
    o.uv2 = i.uv2;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV3
    o.uv3 = i.uv3;
    #endif
    #if VFX_SHADERGRAPH_HAS_COLOR
    o.vertexColor = i.vertexColor;
    #endif

	${VFXLoadSize}

	float3 inputVertexPosition = i.pos;
	float4x4 elementToVFX = GetElementToVFXMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

	float3 vPos = mul(elementToVFX,float4(inputVertexPosition,1.0f)).xyz;
	float4 csPos = TransformPositionVFXToClip(vPos);
	o.VFX_VARYING_POSCS = csPos;

	// TODO This is needed only if in local space (to handle non uniform scale) or if scale attributes are stored/written (no way to know atm)
	float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		size3);

	float3 normalWS = normalize(TransformNormalVFXToWorld(mul(elementToVFX_N, i.normal)));
	#ifdef VFX_VARYING_NORMAL
	float normalFlip = (size3.x * size3.y * size3.z) < 0 ? -1 : 1;
	o.VFX_VARYING_NORMAL = normalFlip * normalWS;
	#endif
	#ifdef VFX_VARYING_TANGENT
	o.VFX_VARYING_TANGENT = float4(normalize(TransformDirectionVFXToWorld(mul((float3x3)elementToVFX,i.tangent.xyz))),i.tangent.w);
	#endif

	${VFXVertexComputeCurrentAndPreviousClipPos}

	${VFXVertexCommonProcess}

	${VFXVertexSetFlipbooksInterpolants}

	${VFXVertexAdditionalProcess}

    ${VFXAdditionalInterpolantsGeneration}

	return o;
}

${VFXBegin:VFXComputeNormalWS}
#ifdef VFX_VARYING_NORMAL
#if USE_DOUBLE_SIDED
const float faceMul = frontFace ? 1.0f : -1.0f;
#else
const float faceMul = 1.0f;
#endif

float3 normalWS = normalize(i.VFX_VARYING_NORMAL * faceMul);
const VFXUVData uvData = GetUVData(i);

#ifdef VFX_VARYING_TANGENT
float3 tangentWS = normalize(i.VFX_VARYING_TANGENT.xyz);
float3 bitangentWS = cross(normalWS,tangentWS) * (i.VFX_VARYING_TANGENT.w * faceMul);
float3x3 tbn = float3x3(tangentWS,bitangentWS,normalWS);

#if USE_NORMAL_MAP
float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
float normalScale = 1.0f;
#ifdef VFX_VARYING_NORMALSCALE
normalScale = i.VFX_VARYING_NORMALSCALE;
#endif
normalWS = normalize(lerp(normalWS,mul(n,tbn),normalScale));
#endif
#endif
#endif
${VFXEnd}

${VFXBegin:VFXVertexAdditionalProcess}${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassDepth.template---------------
.
.
// Depth pass
Pass
{
    Name ${VFXPassDepth}
	Tags { "LightMode"=${VFXPassDepth} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticleMeshes/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassDepthNormal.template---------------
.
.
// Depth Normal pass
Pass
{
	Name ${VFXPassDepthNormal}
	Tags { "LightMode"=${VFXPassDepthNormal} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#define WRITE_NORMAL_BUFFER
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticleMeshes/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassDepthNormal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassDepthOrMV.template---------------
.
.
#pragma target 4.5

#if SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY || defined(WRITE_NORMAL_BUFFER) || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
#define NEEDS_NORMAL 1
#endif

#if SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
#define NEEDS_TANGENT 1
#endif

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_FLIPBOOK_INTERPOLATION
	float4 uv : TEXCOORD0;
	#else
	#if USE_FLIPBOOK_ARRAY_LAYOUT
	float3 uv : TEXCOORD0;
	#else
	float2 uv : TEXCOORD0;
	#endif
	#endif
    #if VFX_SHADERGRAPH_HAS_UV1
    float4 uv1 : TEXCOORD1;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV2
    float4 uv2 : TEXCOORD2;
    #endif
    #if VFX_SHADERGRAPH_HAS_UV3
    float4 uv3 : TEXCOORD3;
    #endif
    #if VFX_SHADERGRAPH_HAS_COLOR
    float4 vertexColor : COLOR;
    #endif
	#if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
	// x: alpha threshold
	// y: frame blending factor
	// z: alpha
	nointerpolation float3 builtInInterpolants : TEXCOORD4;
	#endif

	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vectors scale X
	// y: motion vectors scale Y
	nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
	#endif

    #if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD6;
    #endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
	#endif
    ${VFXAdditionalInterpolantsDeclaration}

    #if NEEDS_NORMAL
    float3 normal : TEXCOORD9;
    #endif

    #if NEEDS_TANGENT
    float4 tangent : TEXCOORD10;
    #endif

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.z
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv

#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif

#if NEEDS_NORMAL
#define VFX_VARYING_NORMAL normal
#endif

#if NEEDS_TANGENT
#define VFX_VARYING_TANGENT tangent
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
${VFXPassDepthDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
${VFXPassShadowDefine}
#endif

${VFXInclude("Shaders/ParticleMeshes/Pass.template")}
#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 1
${VFXPassDepthCommonFragmentUnlit}

.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}

	${VFXInclude("Shaders/ParticleMeshes/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassForwardCommon.template---------------
.
.
struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_FLIPBOOK_INTERPOLATION
	float4 uv : TEXCOORD0;
	#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD0;
		#else
		float2 uv : TEXCOORD0;
		#endif
	#endif
	#if VFX_SHADERGRAPH_HAS_UV1
	float4 uv1 : TEXCOORD1;
	#endif
	#if VFX_SHADERGRAPH_HAS_UV2
	float4 uv2 : TEXCOORD2;
	#endif
	#if VFX_SHADERGRAPH_HAS_UV3
	float4 uv3 : TEXCOORD3;
	#endif
	#if VFX_SHADERGRAPH_HAS_COLOR
	float4 vertexColor : COLOR1;
	#endif
	#if VFX_NEEDS_COLOR_INTERPOLATOR
	nointerpolation float4 color : COLOR0;
	#endif
	#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
	// x: inverse soft particles fade distance
	// y: alpha threshold
	// z: frame blending factor
	// w: exposure weight
	nointerpolation float4 builtInInterpolants : TEXCOORD4;
	#endif
	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vectors scale X
	// y: motion vectors scale Y
	nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
	#endif
	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD6;
	#endif

	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
	#endif

	#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
	float3 normal : TEXCOORD9;
	#endif
	#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
	float4 tangent : TEXCOORD10;
	#endif

	${VFXAdditionalInterpolantsDeclaration}

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

struct ps_output
{
	float4 color : SV_Target0;
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	float4 outMotionVector : SV_Target1;
#endif
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.w
#endif
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXPassForwardDefine}

#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
#define VFX_VARYING_NORMAL normal
#endif
#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
#define VFX_VARYING_TANGENT tangent
#endif

${VFXInclude("Shaders/ParticleMeshes/Pass.template")}

${SHADERGRAPH_PIXEL_CODE_FORWARD}

#pragma fragment frag
ps_output frag(ps_input i)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	ps_output o = (ps_output)0;
	VFXTransformPSInputs(i);

#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif

	${VFXComputeNormalWS}

	#if VFX_SHADERGRAPH
		${VFXAdditionalInterpolantsPreparation}
		${SHADERGRAPH_PIXEL_CALL_FORWARD}

		#if HAS_SHADERGRAPH_PARAM_BASECOLOR
			o.color.rgb = OUTSG.${SHADERGRAPH_PARAM_BASECOLOR}.rgb;
			o.color = VFXApplyPreExposure(o.color, i);
		#endif

		#if HAS_SHADERGRAPH_PARAM_EMISSION
			float4 emission = float4(OUTSG.${SHADERGRAPH_PARAM_EMISSION}.rgb, 0.0f);
			emission = VFXApplyPreExposure(emission, 1.0f);
			o.color.rgb += emission.rgb;
		#endif

		#if HAS_SHADERGRAPH_PARAM_ALPHA
			o.color.a = OUTSG.${SHADERGRAPH_PARAM_ALPHA};
		#endif
	#else
		#define VFX_TEXTURE_COLOR VFXGetTextureColor(VFX_SAMPLER(mainTexture),i)
		${VFXApplyColor}
		o.color = VFXApplyPreExposure(o.color, i);
	#endif

	o.color = VFXApplyAO(o.color,i);
	o.color = VFXApplyFog(o.color,i);
	VFXClipFragmentColor(o.color.a,i);
	o.color.a = saturate(o.color.a);
	o.color = VFXTransformFinalColor(o.color,i);

#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	${VFXComputeOutputMotionVector}
	o.outMotionVector = encodedMotionVector;
	o.outMotionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
#endif

    ${VFXUnlitDebugDisplay}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassForwardCommon.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassSelection.template---------------
.
.
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXInclude("Shaders/ParticleMeshes/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXInclude("Shaders/ParticleMeshes/PassDepthOrMV.template")}
	ENDHLSL
}

.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#pragma target 4.5
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif

	#define VFX_PASSDEPTH VFX_PASSDEPTH_SHADOW
	${VFXInclude("Shaders/ParticleMeshes/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassVelocity.template---------------
.
.
Pass
{
    Name ${VFXPassVelocity}
	Tags { "LightMode"=${VFXPassVelocity} }

	${VFXStencilMotionVector}

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	${VFXPassVelocityAdditionalPragma}
	${VFXInclude("Shaders/ParticleMeshes/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleMeshes\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\Pass.template---------------
.
.
#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS and VFX_VARYING_UV must be defined.
#endif

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

${VFXInclude("Shaders/ParticlePlanarPrimitives/PassVS.template"),!USE_GEOMETRY_SHADER}
${VFXInclude("Shaders/ParticlePlanarPrimitives/PassGS.template"),USE_GEOMETRY_SHADER}

${VFXBegin:VFXComputeNormalWS}
#ifdef VFX_VARYING_NORMAL
    #if USE_DOUBLE_SIDED
    const float faceMul = frontFace ? 1.0f : -1.0f;
    #else
    const float faceMul = 1.0f;
    #endif

    float3 normalWS = i.VFX_VARYING_NORMAL * faceMul;
    const VFXUVData uvData = GetUVData(i);

    #ifdef VFX_VARYING_TANGENT
        float3 tangentWS = i.VFX_VARYING_TANGENT;
        float3 bitangentWS = cross(i.VFX_VARYING_TANGENT,i.VFX_VARYING_NORMAL);

        #if defined(VFX_VARYING_BENTFACTORS) && USE_NORMAL_BENDING
        float3 bentFactors = float3(i.VFX_VARYING_BENTFACTORS.xy,sqrt(max(0.0f,1.0f - dot(i.VFX_VARYING_BENTFACTORS,i.VFX_VARYING_BENTFACTORS))));
        normalWS = tangentWS * bentFactors.x + bitangentWS * bentFactors.y + normalWS * bentFactors.z;
        tangentWS = normalize(cross(normalWS,bitangentWS));
        bitangentWS = cross(tangentWS,normalWS);
        tangentWS *= faceMul;
        #endif

        float3x3 tbn = float3x3(tangentWS,bitangentWS,normalWS);

        #if USE_NORMAL_MAP
            float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
            float normalScale = 1.0f;
            #ifdef VFX_VARYING_NORMALSCALE
            normalScale = i.VFX_VARYING_NORMALSCALE;
            #endif
            normalWS = normalize(lerp(normalWS,mul(n,tbn),normalScale));
        #endif
    #endif
#endif
${VFXEnd}

${VFXBegin:VFXVertexAdditionalProcess}${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassDepth.template---------------
.
.
// Depth pass
Pass
{
    Name ${VFXPassDepth}
	Tags { "LightMode"=${VFXPassDepth} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassDepthNormal.template---------------
.
.
// Depth Normal pass
Pass
{
	Name ${VFXPassDepthNormal}
	Tags { "LightMode"=${VFXPassDepthNormal} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#define WRITE_NORMAL_BUFFER
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassDepthNormal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassDepthOrMV.template---------------
.
.
#pragma target 4.5

#if SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY || defined(WRITE_NORMAL_BUFFER) || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
#define NEEDS_NORMAL 1
#endif

#if SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
#define NEEDS_TANGENT 1
#endif

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_FLIPBOOK_INTERPOLATION
	float4 uv : TEXCOORD0;
	#else
		#if USE_FLIPBOOK_ARRAY_LAYOUT
		float3 uv : TEXCOORD0;
		#else
		float2 uv : TEXCOORD0;
		#endif
	#endif
	#if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
	// x: alpha threshold
	// y: frame blending factor
	// z: alpha
	VFX_OPTIONAL_INTERPOLATION float3 builtInInterpolants : TEXCOORD1;
	#endif

	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vectors scale X
	// y: motion vectors scale Y
	VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD2;
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(3,4)
	#endif

    #if VFX_NEEDS_POSWS_INTERPOLATOR
    float3 posWS : TEXCOORD5;
    #endif
    ${VFXAdditionalInterpolantsDeclaration}

    #if NEEDS_NORMAL
    float3 normal : TEXCOORD6;
    #endif

    #if NEEDS_TANGENT
    float4 tangent : TEXCOORD7;
    #endif

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX

};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.z
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv

#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif

#if NEEDS_NORMAL
#define VFX_VARYING_NORMAL normal
#endif

#if NEEDS_TANGENT
#define VFX_VARYING_TANGENT tangent
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
${VFXPassShadowDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
${VFXPassDepthDefine}
#endif

${VFXBegin:VFXVertexAdditionalProcess}
#if VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
float3 posWS = TransformPositionVFXToWorld(vPos);
VFXApplyShadowBias(o.VFX_VARYING_POSCS, posWS, normalWS);
#endif
${VFXEnd}

${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 1
${VFXPassDepthCommonFragmentUnlit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassForwardCommon.template---------------
.
.
${VFXPassForwardAdditionalPragma}

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_FLIPBOOK_INTERPOLATION
	float4 uv : TEXCOORD0;
	#else
	#if USE_FLIPBOOK_ARRAY_LAYOUT
	float3 uv : TEXCOORD0;
	#else
	float2 uv : TEXCOORD0;
	#endif
	#endif
	#if VFX_NEEDS_COLOR_INTERPOLATOR
	VFX_OPTIONAL_INTERPOLATION float4 color : COLOR0;
	#endif
	#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
	// x: inverse soft particles fade distance
	// y: alpha threshold
	// z: frame blending factor
	// w: exposure weight
	VFX_OPTIONAL_INTERPOLATION float4 builtInInterpolants : TEXCOORD1;
	#endif
	#if USE_FLIPBOOK_MOTIONVECTORS
	// x: motion vectors scale X
	// y: motion vectors scale Y
	VFX_OPTIONAL_INTERPOLATION float2 builtInInterpolants2 : TEXCOORD2;
	#endif
	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD3;
	#endif

	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_DECLARE_MOTION_VECTORS_STORAGE(4,5)
	#endif

	#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
	float3 normal : TEXCOORD6;
	#endif
	#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
	float3 tangent : TEXCOORD7;
	#endif

	${VFXAdditionalInterpolantsDeclaration}

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

struct ps_output
{
	float4 color : SV_Target0;
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	float4 outMotionVector : SV_Target1;
#endif
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
#define VFX_VARYING_UV uv
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.w
#endif
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXPassForwardDefine}

#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
#define VFX_VARYING_NORMAL normal
#endif
#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
#define VFX_VARYING_TANGENT tangent
#endif

${VFXInclude("Shaders/ParticlePlanarPrimitives/Pass.template")}
#if VFX_SHADERGRAPH
${SHADERGRAPH_PIXEL_CODE_FORWARD}
#endif

#pragma fragment frag
ps_output frag(ps_input i,
	bool frontFace : SV_IsFrontFace)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	ps_output o = (ps_output)0;
	VFXTransformPSInputs(i);
	${VFXComputeNormalWS}
#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif
#if VFX_SHADERGRAPH
	${VFXAdditionalInterpolantsPreparation}

	${SHADERGRAPH_PIXEL_CALL_FORWARD}

	#if HAS_SHADERGRAPH_PARAM_BASECOLOR
		o.color.rgb = OUTSG.${SHADERGRAPH_PARAM_BASECOLOR}.rgb;
		o.color = VFXApplyPreExposure(o.color, i);
	#endif

	#if HAS_SHADERGRAPH_PARAM_EMISSION
		float4 emission = float4(OUTSG.${SHADERGRAPH_PARAM_EMISSION}.rgb, 0.0f);
		emission = VFXApplyPreExposure(emission, 1.0f);
		o.color.rgb += emission.rgb;
	#endif

	#if HAS_SHADERGRAPH_PARAM_ALPHA
		o.color.a = OUTSG.${SHADERGRAPH_PARAM_ALPHA};
	#endif
#else

	#define VFX_TEXTURE_COLOR VFXGetTextureColor(VFX_SAMPLER(mainTexture),i)
	${VFXApplyColor}
	o.color = VFXApplyPreExposure(o.color, i);
#endif

	o.color = VFXApplyAO(o.color,i);
	o.color = VFXApplyFog(o.color,i);
	VFXClipFragmentColor(o.color.a,i);
	o.color.a = saturate(o.color.a);
	o.color = VFXTransformFinalColor(o.color,i);

#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	${VFXComputeOutputMotionVector}
	o.outMotionVector = encodedMotionVector;
	o.outMotionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
#endif

    ${VFXUnlitDebugDisplay}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassForwardCommon.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassGS.template---------------
.
.
#pragma require geometry
#pragma vertex vert
#pragma geometry geom

#define VFX_NON_UNIFORM_SCALE VFX_LOCAL_SPACE

uint vert(uint id : SV_VertexID) : TEXCOORD0
{
	return id;
}

#if VFX_PRIMITIVE_TRIANGLE
#define VERTEX_COUNT 3
#elif VFX_PRIMITIVE_QUAD
#define VERTEX_COUNT 4
#elif VFX_PRIMITIVE_OCTAGON
#define VERTEX_COUNT 8
#endif

[maxvertexcount(VERTEX_COUNT)]
void geom(point uint intStream[1] : TEXCOORD0,inout TriangleStream<VFX_VARYING_PS_INPUTS> outStream)
{
	uint index = intStream[0];
	
	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}
			
	if (!attributes.alive)
		return;
		
	${VFXLoadSize}
	
	const float4x4 elementToVFX = GetElementToVFXMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);
	
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
	
#if VFX_NON_UNIFORM_SCALE
	float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		size3);
#else
	float3x3 elementToVFX_N = (float3x3)elementToVFX;
#endif
	
	#ifdef VFX_VARYING_NORMAL
	float normalFlip = (size3.x * size3.y * size3.z) < 0 ? -1 : 1;
	o.VFX_VARYING_NORMAL = normalFlip * normalize(TransformNormalVFXToWorld(normalize(-transpose(elementToVFX_N)[2].xyz)));
	#endif
	#ifdef VFX_VARYING_TANGENT
	o.VFX_VARYING_TANGENT = normalize(TransformDirectionVFXToWorld(normalize(transpose(elementToVFX)[0].xyz)));
	#endif
	
	[unroll]
	for (int id = 0; id < VERTEX_COUNT; ++id)
	{
		float2 varyingUV = (float2)0.0f;
		
#if VFX_PRIMITIVE_QUAD

	    varyingUV.x = float(id & 1);
	    varyingUV.y = (id & 2) * 0.5f;
	    const float2 vOffsets = varyingUV.xy - 0.5f;
	
#elif VFX_PRIMITIVE_TRIANGLE

	    const float2 kOffsets[] = {
		    float2(-0.5f, 	-0.288675129413604736328125f),
		    float2(0.0f, 	0.57735025882720947265625f),
		    float2(0.5f,	-0.288675129413604736328125f),
	    };
	
	    const float kUVScale = 0.866025388240814208984375f;
	
	    const float2 vOffsets = kOffsets[id % 3];
	    varyingUV.xy = (vOffsets * kUVScale) + 0.5f;
	
#elif VFX_PRIMITIVE_OCTAGON	
	    // TODO Not working at the moment. Order of strips has to be fixed
        // But need to fine a nice way to know whether a vertex needs displacement or not (cannot use & 1)
	    const float2 kUvs[8] = 
	    {
		    float2(-0.5f,	0.0f),
		    float2(-0.5f,	0.5f),
		    float2(0.0f,	0.5f),
		    float2(0.5f,	0.5f),
		    float2(0.5f,	0.0f),
		    float2(0.5f,	-0.5f),
		    float2(0.0f,	-0.5f),
		    float2(-0.5f,	-0.5f),
	    };
	
	    ${VFXLoadParameter:{cropFactor}}
	    cropFactor = id & 1 ? 1.0f - cropFactor : 1.0f;
	    const float2 vOffsets = kUvs[id & 7] * cropFactor;
	    varyingUV.xy = vOffsets + 0.5f;
	
#endif
						
		const float3 vPos = mul(elementToVFX,float4(vOffsets,0.0f,1.0f)).xyz;
		o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);
		
		#ifdef VFX_VARYING_UV
		o.VFX_VARYING_UV.xy = varyingUV;
		#endif
		
		#ifdef VFX_VARYING_BENTFACTORS
		${VFXLoadParameter:{normalBendingFactor}}
		o.VFX_VARYING_BENTFACTORS = vOffsets * normalBendingFactor;
		#endif

		${VFXVertexCommonProcess}
		
		${VFXVertexSetFlipbooksInterpolants}
		
		${VFXVertexAdditionalProcess}
		
		outStream.Append(o);
	}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassGS.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassSelection.template---------------
.
.
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#pragma target 4.5
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif

	#define VFX_PASSDEPTH VFX_PASSDEPTH_SHADOW
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassVelocity.template---------------
.
.
Pass
{
    Name ${VFXPassVelocity}
	Tags { "LightMode"=${VFXPassVelocity} }

	${VFXStencilMotionVector}

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	${VFXPassVelocityAdditionalPragma}
	${VFXInclude("Shaders/ParticlePlanarPrimitives/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassVS.template---------------
.
.
#if defined(HAS_STRIPS) && !defined(VFX_PRIMITIVE_QUAD)
#error VFX_PRIMITIVE_QUAD must be defined when HAS_STRIPS is.
#endif

#define VFX_NON_UNIFORM_SCALE VFX_LOCAL_SPACE

struct vs_input
{
	VFX_DECLARE_INSTANCE_ID
};

#if HAS_STRIPS
${VFXDeclareGetStripTangent}
#endif

#pragma vertex vert
VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
{
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

	UNITY_SETUP_INSTANCE_ID(i);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

#if VFX_PRIMITIVE_TRIANGLE
	uint index = id / 3;
#elif VFX_PRIMITIVE_QUAD
	uint index = (id >> 2) + VFX_GET_INSTANCE_ID(i) * 2048;
#elif VFX_PRIMITIVE_OCTAGON
	uint index = (id >> 3) + VFX_GET_INSTANCE_ID(i) * 1024;
#endif

	${VFXInitInstancing}

	${VFXLoadGraphValues}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}

#if !HAS_STRIPS
	if (!attributes.alive)
		return o;
#endif

	float2 varyingUV = (float2)0.0f;

#if VFX_PRIMITIVE_QUAD

#if HAS_STRIPS
#if VFX_STRIPS_UV_STRECHED
	varyingUV.x = (float)(relativeIndexInStrip) / (stripData.nextIndex - 1);
#elif VFX_STRIPS_UV_PER_SEGMENT
	varyingUV.x = STRIP_PARTICLE_IN_EDGE;
#else
	${VFXLoadParameter:{texCoord}}
    varyingUV.x = texCoord;
#endif

	varyingUV.y = (id & 2) * 0.5f;
	const float2 vOffsets = float2(0.0f,varyingUV.y - 0.5f);

#if VFX_STRIPS_SWAP_UV
	varyingUV.xy = float2(1.0f - varyingUV.y, varyingUV.x);
#endif

#else
	varyingUV.x = float(id & 1);
	varyingUV.y = (id & 2) * 0.5f;
	const float2 vOffsets = varyingUV.xy - 0.5f;
#endif

#elif VFX_PRIMITIVE_TRIANGLE

	const float2 kOffsets[] = {
		float2(-0.5f, 	-0.288675129413604736328125f),
		float2(0.0f, 	0.57735025882720947265625f),
		float2(0.5f,	-0.288675129413604736328125f),
	};

	const float kUVScale = 0.866025388240814208984375f;

	const float2 vOffsets = kOffsets[id % 3];
	varyingUV.xy = (vOffsets * kUVScale) + 0.5f;

#elif VFX_PRIMITIVE_OCTAGON

	const float2 kUvs[8] =
	{
		float2(-0.5f,	0.0f),
		float2(-0.5f,	0.5f),
		float2(0.0f,	0.5f),
		float2(0.5f,	0.5f),
		float2(0.5f,	0.0f),
		float2(0.5f,	-0.5f),
		float2(0.0f,	-0.5f),
		float2(-0.5f,	-0.5f),
	};
	${VFXLoadParameter:{cropFactor}}
	cropFactor = id & 1 ? 1.0f - cropFactor : 1.0f;
	const float2 vOffsets = kUvs[id & 7] * cropFactor;
	varyingUV.xy = vOffsets + 0.5f;

#endif

	${VFXLoadSize}
#if HAS_STRIPS
	size3 += size3 < 0.0f ? -VFX_EPSILON : VFX_EPSILON; // Add an epsilon so that size is never 0 for strips
#endif

	const float4x4 elementToVFX = GetElementToVFXMatrix(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
		size3,
		attributes.position);

	float3 inputVertexPosition = float3(vOffsets, 0.0f);
	float3 vPos = mul(elementToVFX,float4(inputVertexPosition, 1.0f)).xyz;

	o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);

    float3 vPosWS = TransformPositionVFXToWorld(vPos);

    #ifdef VFX_VARYING_POSWS
        o.VFX_VARYING_POSWS = vPosWS;
    #endif

	#ifdef VFX_VARYING_UV
		o.VFX_VARYING_UV.xy = varyingUV;
	#endif

#if VFX_NON_UNIFORM_SCALE
	float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
		attributes.axisX,
		attributes.axisY,
		attributes.axisZ,
		float3(attributes.angleX,attributes.angleY,attributes.angleZ),
		size3);
#else
	float3x3 elementToVFX_N = (float3x3)elementToVFX;
#endif

	float3 normalWS = normalize(TransformNormalVFXToWorld((-transpose(elementToVFX_N)[2])));
	#ifdef VFX_VARYING_NORMAL
	float normalFlip = (size3.x * size3.y * size3.z) < 0 ? -1 : 1;
	o.VFX_VARYING_NORMAL = normalFlip * normalWS;
	#endif
	#ifdef VFX_VARYING_TANGENT
	o.VFX_VARYING_TANGENT.xyz = normalize(TransformDirectionVFXToWorld(normalize(transpose(elementToVFX)[0].xyz)));
	#endif
	#ifdef VFX_VARYING_BENTFACTORS
	${VFXLoadParameter:{normalBendingFactor}}
	#if HAS_STRIPS
	#define BENT_FACTOR_MULTIPLIER 2.0f
	#else
	#define BENT_FACTOR_MULTIPLIER 1.41421353816986083984375f
	#endif
	o.VFX_VARYING_BENTFACTORS = vOffsets * normalBendingFactor * BENT_FACTOR_MULTIPLIER;
	#endif

	${VFXVertexComputeCurrentAndPreviousClipPos}

	${VFXVertexCommonProcess}

	${VFXVertexSetFlipbooksInterpolants}

	${VFXVertexAdditionalProcess}

    ${VFXAdditionalInterpolantsGeneration}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePlanarPrimitives\PassVS.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\Pass.template---------------
.
.
#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
#error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
#endif

${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
	VFX_DECLARE_INSTANCE_ID
};

#pragma vertex vert

VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
{
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

	UNITY_SETUP_INSTANCE_ID(i);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	uint index = id;

	${VFXInitInstancing}
	${VFXLoadGraphValues}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}

	if (!attributes.alive)
	{
		o.pos.x = VFX_NAN;
		return o; // cull
	}

	float3 inputVertexPosition = float3(0.0f, 0.0f, 0.0f);
	float3 vPos = attributes.position;
	o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);

	${VFXVertexComputeCurrentAndPreviousClipPos}
	${VFXVertexCommonProcess}
	${VFXVertexAdditionalProcess}

    o.pointSize = 1;

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassDepth.template---------------
.
.
// Depth pass
Pass
{
    Name ${VFXPassDepth}
	Tags { "LightMode"=${VFXPassDepth} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticlePoints/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassDepthNormal.template---------------
.
.
// Depth Normal pass
Pass
{
	Name ${VFXPassDepthNormal}
	Tags { "LightMode"=${VFXPassDepthNormal} }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
	#define WRITE_NORMAL_BUFFER
	${VFXPassDepthAdditionalPragma}
	${VFXInclude("Shaders/ParticlePoints/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassDepthNormal.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassDepthOrMV.template---------------
.
.

#pragma target 4.5

struct ps_input
{
	float4 pos : SV_POSITION;
	#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
	nointerpolation float2 builtInInterpolants : TEXCOORD0;
	#endif

	#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
	VFX_DECLARE_MOTION_VECTORS_STORAGE(1,2)
	#endif

	float pointSize : PSIZE;

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#undef VFX_VARYING_COLOR // Not used
#define VFX_VARYING_ALPHA builtInInterpolants.x
#undef VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
${VFXPassVelocityDefine}
#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
${VFXPassDepthDefine}
#endif

${VFXInclude("Shaders/ParticlePoints/Pass.template")}
#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
${VFXPassDepthCommonFragmentUnlit}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassDepthOrMV.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassForward.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassForward}
	Tags { "LightMode"=${VFXPassForward} }

	${VFXStencilForward}

	HLSLPROGRAM
	#pragma target 4.5
	${VFXPassForwardAdditionalPragma}

	${VFXInclude("Shaders/ParticlePoints/PassForwardCommon.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassForward.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassForwardCommon.template---------------
.
.
struct ps_input
{
	float4 pos : SV_POSITION;
	#if VFX_NEEDS_COLOR_INTERPOLATOR
	nointerpolation float4 color : COLOR0;
	#endif
	#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
	nointerpolation float3 builtInInterpolants : TEXCOORD0;
	#endif
	#if VFX_NEEDS_POSWS_INTERPOLATOR
	float3 posWS : TEXCOORD1;
	#endif

	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	VFX_DECLARE_MOTION_VECTORS_STORAGE(2,3)
	#endif

	float pointSize : PSIZE;

	UNITY_VERTEX_OUTPUT_STEREO

    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
};

struct ps_output
{
	float4 color : SV_Target0;
	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	float4 motionVector : SV_Target1;
	#endif
};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_COLOR color.rgb
#define VFX_VARYING_ALPHA color.a
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#if VFX_NEEDS_POSWS_INTERPOLATOR
#define VFX_VARYING_POSWS posWS
#endif
#if USE_EXPOSURE_WEIGHT
#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.z
#endif
#if VFX_FEATURE_MOTION_VECTORS_FORWARD
#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
#endif

${VFXPassForwardDefine}
${VFXInclude("Shaders/ParticlePoints/Pass.template")}

#pragma fragment frag
ps_output frag(ps_input i)
{
	UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
	VFXTransformPSInputs(i);

#if VFX_USE_GRAPH_VALUES
    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
    ${VFXLoadGraphValues}
#endif

	ps_output o = (ps_output)0;
	${VFXApplyColor}
	o.color = VFXApplyPreExposure(o.color, i);
	o.color = VFXApplyAO(o.color,i);
	o.color = VFXApplyFog(o.color,i);
	VFXClipFragmentColor(o.color.a,i);
	o.color.a = saturate(o.color.a);
	o.color = VFXTransformFinalColor(o.color,i);
	#if VFX_FEATURE_MOTION_VECTORS_FORWARD
	${VFXComputeOutputMotionVector}
	o.motionVector = encodedMotionVector;
	o.motionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
	#endif

    ${VFXUnlitDebugDisplay}

	return o;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassForwardCommon.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassSelection.template---------------
.
.
// Depth pass
Pass
{
    Name "SceneSelectionPass"
	Tags { "LightMode"="SceneSelectionPass" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
	${VFXInclude("Shaders/ParticlePoints/PassDepthOrMV.template")}
	ENDHLSL
}

Pass
{
    Name "Picking"
	Tags { "LightMode"="Picking" }

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
	${VFXInclude("Shaders/ParticlePoints/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassSelection.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#pragma target 4.5
	#if !USE_ALPHA_TEST && IS_TRANSPARENT_PARTICLE
	#define USE_ALPHA_TEST 1
	#endif

	struct ps_input
	{
		float4 pos : SV_POSITION;
		#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
		nointerpolation float2 builtInInterpolants : TEXCOORD0;
		#endif

		float pointSize : PSIZE;

		UNITY_VERTEX_OUTPUT_STEREO
        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_ALPHA builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y

${VFXBegin:VFXVertexAdditionalProcess}
float3 posWS = TransformPositionVFXToWorld(vPos);
VFXApplyShadowBias(o.VFX_VARYING_POSCS, posWS);
${VFXEnd}

	${VFXPassShadowDefine}
	${VFXInclude("Shaders/ParticlePoints/Pass.template")}

	#pragma fragment frag
	float frag(ps_input i) : SV_TARGET
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		float alpha = VFXGetFragmentColor(i).a;
		VFXClipFragmentColor(alpha,i);
		return 0;
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassVelocity.template---------------
.
.
Pass
{
    Name ${VFXPassVelocity}
	Tags { "LightMode"=${VFXPassVelocity} }

	${VFXStencilMotionVector}

	ZWrite On
	Blend Off

	HLSLPROGRAM
	#define VFX_PASSDEPTH VFX_PASSDEPTH_MOTION_VECTOR
	${VFXPassVelocityAdditionalPragma}
	${VFXInclude("Shaders/ParticlePoints/PassDepthOrMV.template")}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticlePoints\PassVelocity.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleSpheres\Pass.template---------------
.
.
${VFXPerPassInclude}
${VFXGeneratedBlockFunction}

struct vs_input
{
	VFX_DECLARE_INSTANCE_ID
};

#pragma vertex vert
VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
{
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;

	UNITY_SETUP_INSTANCE_ID(i);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	uint index = (id >> 2) + VFX_GET_INSTANCE_ID(i) * 2048;

	${VFXInitInstancing}
	${VFXLoadGraphValues}

	${VFXLoadContextData}
	uint systemSeed = contextData.systemSeed;
	uint nbMax = contextData.maxParticleCount;

	${VFXLoadAttributesOrCull}
	${VFXProcessBlocks}

	if (!attributes.alive)
		return o;

	o.VFX_VARYING_UV.x = float(id & 1) * 2.0f - 1.0f;
	o.VFX_VARYING_UV.y = float(id & 2) - 1.0f;

	${VFXLoadSize}
	float uSize = size3.x * 0.5f;

	float camDist = length(GetViewVFXPosition() - attributes.position);
	float scale = 1.0f - (1.0f - unity_OrthoParams.w) * uSize / camDist;

	float3 vPos = attributes.position;
	vPos += attributes.axisX * (o.VFX_VARYING_UV.x * uSize * scale);
	vPos += attributes.axisY * (o.VFX_VARYING_UV.y * uSize * scale);
	vPos -= attributes.axisZ * uSize;

	#ifdef VFX_VARYING_SPHERECENTER
	o.VFX_VARYING_SPHERECENTER = TransformPositionVFXToWorld(attributes.position);
	#endif
	#ifdef VFX_VARYING_SPHERERADIUS
	o.VFX_VARYING_SPHERERADIUS = uSize;
	#endif

	o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);

	${VFXVertexCommonProcess}
	${VFXVertexAdditionalProcess}

	return o;
}

void VFXClipSphereAndGetDepthOffsetAndNormal(out float depthOffset, out float3 normalWS ,VFX_VARYING_PS_INPUTS i)
{
	float lsqr = dot(i.VFX_VARYING_UV, i.VFX_VARYING_UV);
	clip(1.0f - lsqr);

	float nDepthOffset = 1.0f - sqrt(1.0f - lsqr); // normalized depth offset

	float3 camToPosDir = normalize(i.VFX_VARYING_POSWS - VFXGetViewWorldPosition());
	float3 posWS = i.VFX_VARYING_POSWS + (camToPosDir * (nDepthOffset * i.VFX_VARYING_SPHERERADIUS));

	float4 posCS = VFXTransformPositionWorldToClip(posWS);
	depthOffset = posCS.z / posCS.w;

	normalWS = normalize(posWS - i.VFX_VARYING_SPHERECENTER);
}

${VFXBegin:VFXVertexAdditionalProcess}${VFXEnd}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleSpheres\Pass.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleSpheres\PassDepth.template---------------
.
.
// Forward pass
Pass
{
    Name ${VFXPassDepth}
	Tags { "LightMode"=${VFXPassDepth} }

	HLSLPROGRAM
	#pragma target 4.5

	struct ps_input
	{
		SV_POSITION_QUALIFIERS float4 pos : SV_POSITION;
		float2 uv : TEXCOORD0;
		float3 posWS : TEXCOORD1;
		float4 sphereInfo : TEXCOORD2;

		UNITY_VERTEX_OUTPUT_STEREO

        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

	struct ps_output
	{
		float depth : DEPTH_OFFSET_SEMANTIC;
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_POSWS posWS
#define VFX_VARYING_SPHERECENTER sphereInfo.xyz
#define VFX_VARYING_SPHERERADIUS sphereInfo.w

	${VFXPassDepthDefine}
	${VFXInclude("Shaders/ParticleSpheres/Pass.template")}

	#pragma fragment frag
	ps_output frag(ps_input i)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		ps_output o = (ps_output)0;
		float3 dummy;
		VFXClipSphereAndGetDepthOffsetAndNormal(o.depth,dummy,i);
		return o;
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleSpheres\PassDepth.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleSpheres\PassShadowCaster.template---------------
.
.
// Shadow pass
Pass
{
	Name ${VFXPassShadow}
	Tags { "LightMode"=${VFXPassShadow} }

	ZClip [_ZClip]
	ZWrite On
	Blend Off

	HLSLPROGRAM
	#pragma target 4.5

	struct ps_input
	{
		SV_POSITION_QUALIFIERS float4 pos : SV_POSITION;
		float2 uv : TEXCOORD0;
		float3 posWS : TEXCOORD1;
		float4 sphereInfo : TEXCOORD2;

		UNITY_VERTEX_OUTPUT_STEREO

        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
	};

	struct ps_output
	{
		float depth : DEPTH_OFFSET_SEMANTIC;
	};

#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_POSWS posWS
#define VFX_VARYING_SPHERECENTER sphereInfo.xyz
#define VFX_VARYING_SPHERERADIUS sphereInfo.w

${VFXBegin:VFXVertexAdditionalProcess}
float3 posWS = TransformPositionVFXToWorld(vPos);
VFXApplyShadowBias(o.VFX_VARYING_POSCS, posWS);
${VFXEnd}

	${VFXPassShadowDefine}
	${VFXInclude("Shaders/ParticleSpheres/Pass.template")}

	#pragma fragment frag
	ps_output frag(ps_input i)
	{
		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		VFXTransformPSInputs(i);
		ps_output o = (ps_output)0;
		float3 dummy;
		VFXClipSphereAndGetDepthOffsetAndNormal(o.depth,dummy,i);
		return o;
	}
	ENDHLSL
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\ParticleSpheres\PassShadowCaster.template---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\SixWay\SixWayVaryings.template---------------
.
.
#define USE_EMISSIVE_MAP HDRP_USE_EMISSIVE_MAP || URP_USE_EMISSIVE_MAP

${VFXBegin:SixWayVaryingsMacros}
    #if VFX_SIX_WAY_COLOR_ABSORPTION
        #define VFX_VARYING_ABSORPTIONRANGE absorptionRange
    #endif
    #if VFX_SIX_WAY_USE_ALPHA_REMAP
        #define VFX_VARYING_ALPHA_REMAP alphaRemap
    #endif
    #if VFX_SIX_WAY_USE_ONE_EMISSIVE_CHANNEL
        #define VFX_VARYING_EMISSIVE_GRADIENT emissiveControls.xy
        #if VFX_SIX_WAY_EMISSIVE_CHANNEL_SCALE
            #define VFX_VARYING_EMISSIVE_CHANNEL_SCALE emissiveControls.z
        #endif
        #define VFX_VARYING_EMISSIVE_MULTIPLIER emissiveControls.w
    #endif

    #if VFX_SIX_WAY_REMAP_RANGES
        #define VFX_VARYING_LIGHTMAP_REMAP_RANGES lightmapRemapRanges
    #endif
    #if VFX_SIX_WAY_REMAP_NONLIN
        #define VFX_VARYING_LIGHTMAP_REMAP_CONTROLS lightmapRemapControls
    #endif
    #if VFX_SIX_WAY_REMAP_CURVE
        #define VFX_VARYING_LIGHTMAP_REMAP_CURVE lightRemapCurve
    #endif
    #if USE_EMISSIVE_MAP
        #define VFX_VARYING_EMISSIVESCALE emissiveScale
    #endif
${VFXEnd}

${VFXBegin:SixWayDeclareVaryings}
    #if VFX_SIX_WAY_USE_ALPHA_REMAP
        nointerpolation float4 alphaRemap : TEXCOORD10;
    #endif
    #if VFX_SIX_WAY_USE_ONE_EMISSIVE_CHANNEL
        nointerpolation float4 emissiveControls : TEXCOORD11;
    #endif
    #if VFX_SIX_WAY_REMAP_NONLIN
        VFX_OPTIONAL_INTERPOLATION float2 lightmapRemapControls : TEXCOORD12;
    #endif

    #if VFX_SIX_WAY_REMAP_CURVE
    nointerpolation float4 lightRemapCurve : TEXCOORD13;
    #endif

    #if VFX_SIX_WAY_REMAP_RANGES
        VFX_OPTIONAL_INTERPOLATION float4 lightmapRemapRanges : TEXCOORD14;
    #endif

    #if USE_EMISSIVE_MAP
        VFX_OPTIONAL_INTERPOLATION float emissiveScale : TEXCOORD0;
    #endif

    #if VFX_SIX_WAY_COLOR_ABSORPTION
        VFX_OPTIONAL_INTERPOLATION float absorptionRange : TEXCOORD15;
    #endif
${VFXVertexProbeDeclareVaryings}
${VFXEnd}

${VFXBegin:SixWayFillVaryings}
#if defined(VFX_VARYING_EMISSIVE_MULTIPLIER)
${VFXLoadParameter:{emissiveMultiplier}}
o.VFX_VARYING_EMISSIVE_MULTIPLIER = emissiveMultiplier;
#endif

#if defined(VFX_VARYING_EMISSIVE_CHANNEL_SCALE)
${VFXLoadParameter:{emissiveChannelScale}}
o.VFX_VARYING_EMISSIVE_CHANNEL_SCALE = emissiveChannelScale;
#endif
#if defined(VFX_VARYING_ALPHA_REMAP)
${VFXLoadParameter:{alphaRemap}}
o.VFX_VARYING_ALPHA_REMAP = alphaRemap;
#endif
#if defined(VFX_VARYING_EMISSIVE_GRADIENT)
${VFXLoadParameter:{emissiveGradient}}
o.VFX_VARYING_EMISSIVE_GRADIENT = emissiveGradient;
#endif

#ifdef VFX_VARYING_ABSORPTIONRANGE
${VFXLoadParameter:{absorptionRange}}
o.VFX_VARYING_ABSORPTIONRANGE = absorptionRange;
#endif

#if defined(VFX_VARYING_LIGHTMAP_REMAP_CONTROLS)
${VFXLoadParameter:{lightmapRemapControls}}
o.VFX_VARYING_LIGHTMAP_REMAP_CONTROLS = lightmapRemapControls;
#endif

#if defined(VFX_VARYING_LIGHTMAP_REMAP_RANGES)
${VFXLoadParameter:{remapFrom}}
${VFXLoadParameter:{remapTo}}
o.VFX_VARYING_LIGHTMAP_REMAP_RANGES = float4(remapFrom, remapTo);
#endif

#if defined(VFX_VARYING_LIGHTMAP_REMAP_CURVE)
${VFXLoadParameter:{lightRemapCurve}}
o.VFX_VARYING_LIGHTMAP_REMAP_CURVE = lightRemapCurve;
#endif
${VFXEnd}

.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.visualeffectgraph\Shaders\SixWay\SixWayVaryings.template---------------
.
.
