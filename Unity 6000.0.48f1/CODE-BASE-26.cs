 
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\char-conversions.cpp---------------


#include "il2cpp-config.h"
#include "char-conversions.h"

uint8_t const CategoryData_v4[] =
{
    /* Page 0, 0 indirect uses */
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    11, 24, 24, 24, 26, 24, 24, 24, 20, 21, 24, 25, 24, 19, 24, 24,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 24, 24, 25, 25, 25, 24,
    24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 24, 21, 27, 18,
    27, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 25, 21, 25, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    11, 24, 26, 26, 26, 26, 28, 28, 27, 28, 1, 22, 25, 19, 28, 27,
    28, 25, 10, 10, 27, 1, 28, 24, 27, 10, 1, 23, 10, 10, 10, 24,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 25, 1, 1, 1, 1, 1, 1, 1, 1,
    /* Page 1, 0 indirect uses */
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0,
    1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1,
    1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0,
    0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0,
    0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0,
    1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 4, 0, 1, 1, 1,
    4, 4, 4, 4, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 1, 0,
    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    1, 0, 2, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,
    /* Page 2, 0 indirect uses */
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1,
    1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 27, 27, 27, 27, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    3, 3, 3, 3, 3, 27, 27, 27, 27, 27, 27, 27, 3, 27, 3, 27,
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    /* Page 3, 0 indirect uses */
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    0, 1, 0, 1, 3, 27, 0, 1, 29, 29, 3, 1, 1, 1, 24, 29,
    29, 29, 29, 29, 27, 27, 0, 24, 0, 0, 0, 29, 0, 29, 0, 0,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
    1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    1, 1, 1, 1, 0, 1, 25, 0, 1, 0, 0, 1, 1, 0, 0, 0,
    /* Page 4, 0 indirect uses */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 28, 5, 5, 5, 5, 5, 7, 7, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    /* Page 5, 0 indirect uses */
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 29, 29, 3, 24, 24, 24, 24, 24, 24,
    29, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 29, 24, 19, 29, 29, 29, 29, 29,
    29, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 19, 5,
    24, 5, 5, 24, 5, 5, 24, 5, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29,
    4, 4, 4, 24, 24, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 6, 0 indirect uses */
    15, 15, 15, 15, 29, 29, 25, 25, 25, 24, 24, 26, 24, 24, 28, 28,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 24, 29, 29, 24, 24,
    29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 24, 24, 24, 24, 4, 4,
    5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 24, 4, 5, 5, 5, 5, 5, 5, 5, 15, 7, 5,
    5, 5, 5, 5, 5, 3, 3, 5, 5, 28, 5, 5, 5, 5, 4, 4,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 28, 28, 4,
    /* Page 7, 0 indirect uses */
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 29, 15,
    4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 29, 29, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 3, 3, 28, 24, 24, 24, 3, 29, 29, 29, 29, 29,
    /*
     * Page 8, 3390 indirect uses:
     *  10500-107FF (astral_index),
     *  10B00-11FFF (astral_index),
     *  12500-1CFFF (astral_index),
     *  1D800-1EFFF (astral_index),
     *  1F100-1FFFF (astral_index),
     *  2A700-2F7FF (astral_index),
     *  2FB00-DFFFF (astral_index),
     *  E0200-EFFFF (astral_index)
     */
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 9, 0 indirect uses */
    29, 5, 5, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 5, 4, 6, 6,
    6, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 5, 29, 29,
    4, 5, 5, 5, 5, 29, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 5, 5, 24, 24, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    24, 3, 4, 29, 29, 29, 29, 29, 29, 29, 29, 4, 4, 4, 4, 4,
    29, 5, 6, 6, 29, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 4,
    4, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 29, 4, 29, 29, 29, 4, 4, 4, 4, 29, 29, 5, 4, 6, 6,
    6, 5, 5, 5, 5, 29, 29, 6, 6, 29, 29, 6, 6, 5, 4, 29,
    29, 29, 29, 29, 29, 29, 29, 6, 29, 29, 29, 29, 4, 4, 29, 4,
    4, 4, 5, 5, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    4, 4, 26, 26, 10, 10, 10, 10, 10, 10, 28, 29, 29, 29, 29, 29,
    /* Page 10, 0 indirect uses */
    29, 5, 5, 6, 29, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 4,
    4, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 29, 4, 4, 29, 4, 4, 29, 4, 4, 29, 29, 5, 29, 6, 6,
    6, 5, 5, 29, 29, 29, 29, 5, 5, 29, 29, 5, 5, 5, 29, 29,
    29, 5, 29, 29, 29, 29, 29, 29, 29, 4, 4, 4, 4, 29, 4, 29,
    29, 29, 29, 29, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    5, 5, 4, 4, 4, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 5, 5, 6, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4,
    4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 29, 4, 4, 29, 4, 4, 4, 4, 4, 29, 29, 5, 4, 6, 6,
    6, 5, 5, 5, 5, 5, 29, 5, 5, 6, 29, 6, 6, 5, 29, 29,
    4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 5, 5, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    29, 26, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 11, 0 indirect uses */
    29, 5, 6, 6, 29, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 4,
    4, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 29, 4, 4, 29, 4, 4, 4, 4, 4, 29, 29, 5, 4, 6, 5,
    6, 5, 5, 5, 5, 29, 29, 6, 6, 29, 29, 6, 6, 5, 29, 29,
    29, 29, 29, 29, 29, 29, 5, 6, 29, 29, 29, 29, 4, 4, 29, 4,
    4, 4, 5, 5, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    28, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 5, 4, 29, 4, 4, 4, 4, 4, 4, 29, 29, 29, 4, 4,
    4, 29, 4, 4, 4, 4, 29, 29, 29, 4, 4, 29, 4, 29, 4, 4,
    29, 29, 29, 4, 4, 29, 29, 29, 4, 4, 4, 29, 29, 29, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 6, 6,
    5, 6, 6, 29, 29, 29, 6, 6, 6, 29, 6, 6, 6, 5, 29, 29,
    4, 29, 29, 29, 29, 29, 29, 6, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    10, 10, 10, 28, 28, 28, 28, 28, 28, 26, 28, 29, 29, 29, 29, 29,
    /* Page 12, 0 indirect uses */
    29, 6, 6, 6, 29, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4,
    4, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 29, 29, 29, 4, 5, 5,
    5, 6, 6, 6, 6, 29, 5, 5, 5, 29, 5, 5, 5, 5, 29, 29,
    29, 29, 29, 29, 29, 5, 5, 29, 4, 4, 29, 29, 29, 29, 29, 29,
    4, 4, 5, 5, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    29, 29, 29, 29, 29, 29, 29, 29, 10, 10, 10, 10, 10, 10, 10, 28,
    29, 29, 6, 6, 29, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4,
    4, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 29, 29, 5, 4, 6, 5,
    6, 6, 6, 6, 6, 29, 5, 6, 6, 29, 6, 6, 5, 5, 29, 29,
    29, 29, 29, 29, 29, 6, 6, 29, 29, 29, 29, 29, 29, 29, 4, 29,
    4, 4, 5, 5, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    29, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 13, 0 indirect uses */
    29, 29, 6, 6, 29, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4,
    4, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 4, 6, 6,
    6, 5, 5, 5, 5, 29, 6, 6, 6, 29, 6, 6, 6, 5, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 6, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 5, 5, 29, 29, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    10, 10, 10, 10, 10, 10, 29, 29, 29, 28, 4, 4, 4, 4, 4, 4,
    29, 29, 6, 6, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 5, 29, 29, 29, 29, 6,
    6, 6, 5, 5, 5, 29, 5, 29, 6, 6, 6, 6, 6, 6, 6, 6,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 6, 6, 24, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 14, 0 indirect uses */
    29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 29, 29, 29, 29, 26,
    4, 4, 4, 4, 4, 4, 3, 5, 5, 5, 5, 5, 5, 5, 5, 24,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 24, 24, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 4, 4, 29, 4, 29, 29, 4, 4, 29, 4, 29, 29, 4, 29, 29,
    29, 29, 29, 29, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4,
    29, 4, 4, 4, 29, 4, 29, 4, 29, 29, 4, 4, 29, 4, 4, 4,
    4, 5, 4, 4, 5, 5, 5, 5, 5, 5, 29, 5, 5, 4, 29, 29,
    4, 4, 4, 4, 4, 29, 3, 29, 5, 5, 5, 5, 5, 5, 29, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 4, 4, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 15, 0 indirect uses */
    4, 28, 28, 28, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 28, 28, 28, 28, 28, 5, 5, 28, 28, 28, 28, 28, 28,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 28, 5, 28, 5, 28, 5, 20, 21, 20, 21, 6, 6,
    4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29,
    29, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
    5, 5, 5, 5, 5, 24, 5, 5, 4, 4, 4, 4, 29, 29, 29, 29,
    5, 5, 5, 5, 5, 5, 5, 5, 29, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 29, 28, 28,
    28, 28, 28, 28, 28, 28, 5, 28, 28, 28, 28, 28, 28, 29, 28, 28,
    24, 24, 24, 24, 24, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 16, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 5, 5, 5,
    5, 6, 5, 5, 5, 5, 5, 5, 6, 5, 5, 6, 6, 5, 5, 4,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 24, 24, 24, 24, 24, 24,
    4, 4, 4, 4, 4, 4, 6, 6, 5, 5, 4, 4, 4, 4, 5, 5,
    5, 4, 6, 6, 6, 4, 4, 6, 6, 6, 6, 6, 6, 6, 4, 4,
    4, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 5, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 5, 4, 6,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 29, 28, 28,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 24, 3, 29, 29, 29,
    /* Page 17, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 29, 29, 29, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29,
    /* Page 18, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 29, 4, 4, 4, 4, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 29, 4, 4, 4, 4, 29, 29, 4, 4, 4, 4, 4, 4, 4, 29,
    4, 29, 4, 4, 4, 4, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 19, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 29, 4, 4, 4, 4, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 5,
    28, 24, 24, 24, 24, 24, 24, 24, 24, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 20, 0 indirect uses */
    29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /*
     * Page 21, 171 indirect uses:
     *  12000-122FF (astral_index),
     *  20000-2A5FF (astral_index),
     *  2F800-2F9FF (astral_index)
     */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 22, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 24, 24, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 20, 21, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 24, 24, 24, 9, 9,
    9, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 23, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4,
    4, 4, 5, 5, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 5, 5, 5, 24, 24, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 5, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4,
    4, 29, 5, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 15, 15, 6, 5, 5, 5, 5, 5, 5, 5, 6, 6,
    6, 6, 6, 6, 6, 6, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 24, 24, 24, 3, 24, 24, 24, 26, 4, 5, 29, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 29, 29, 29,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 29, 29, 29, 29, 29, 29,
    /* Page 24, 0 indirect uses */
    24, 24, 24, 24, 24, 24, 19, 24, 24, 24, 24, 5, 5, 5, 11, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 25, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29,
    5, 5, 5, 6, 6, 6, 6, 5, 5, 6, 6, 6, 29, 29, 29, 29,
    6, 6, 5, 6, 6, 6, 6, 6, 6, 5, 5, 5, 29, 29, 29, 29,
    28, 29, 29, 29, 24, 24, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29,
    4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 4, 4, 4, 4, 4, 4, 4, 6, 6, 29, 29, 29, 29, 29, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 29, 24, 24,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    /* Page 26, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 29, 29, 24, 24,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 27, 0 indirect uses */
    5, 5, 5, 5, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 5, 6, 5, 5, 5, 5, 5, 6, 5, 6, 6, 6,
    6, 6, 5, 6, 6, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 24, 24, 24, 24, 24, 24,
    24, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29,
    5, 5, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 6, 5, 5, 5, 5, 6, 6, 5, 5, 6, 29, 29, 29, 4, 4,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 28, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5,
    5, 5, 5, 5, 6, 6, 5, 5, 29, 29, 29, 24, 24, 24, 24, 24,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 4, 4, 4,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 24, 24,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 29, 0 indirect uses */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 5, 5,
    /* Page 30, 0 indirect uses */
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    /* Page 31, 0 indirect uses */
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 29, 29, 0, 0, 0, 0, 0, 0, 29, 29,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 29, 29, 0, 0, 0, 0, 0, 0, 29, 29,
    1, 1, 1, 1, 1, 1, 1, 1, 29, 0, 29, 0, 29, 0, 29, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 29, 29,
    1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
    1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
    1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
    1, 1, 1, 1, 1, 29, 1, 1, 0, 0, 0, 0, 2, 27, 1, 27,
    27, 27, 1, 1, 1, 29, 1, 1, 0, 0, 0, 0, 2, 27, 27, 27,
    1, 1, 1, 1, 29, 29, 1, 1, 0, 0, 0, 0, 29, 27, 27, 27,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 27, 27, 27,
    29, 29, 1, 1, 1, 29, 1, 1, 0, 0, 0, 0, 2, 27, 27, 29,
    /* Page 32, 0 indirect uses */
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 15, 15, 15, 15, 15,
    19, 19, 19, 19, 19, 19, 24, 24, 22, 23, 20, 22, 22, 23, 20, 22,
    24, 24, 24, 24, 24, 24, 24, 24, 12, 13, 15, 15, 15, 15, 15, 11,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 22, 23, 24, 24, 24, 24, 18,
    18, 24, 24, 24, 25, 20, 21, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 25, 24, 18, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 11,
    15, 15, 15, 15, 15, 29, 29, 29, 29, 29, 15, 15, 15, 15, 15, 15,
    10, 1, 29, 29, 10, 10, 10, 10, 10, 10, 25, 25, 25, 20, 21, 1,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 25, 25, 25, 20, 21, 29,
    3, 3, 3, 3, 3, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7,
    7, 5, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 33, 0 indirect uses */
    28, 28, 0, 28, 28, 28, 28, 0, 28, 28, 1, 0, 0, 0, 1, 1,
    0, 0, 0, 1, 28, 0, 28, 28, 28, 0, 0, 0, 0, 0, 28, 28,
    28, 28, 28, 28, 0, 28, 0, 28, 0, 28, 0, 0, 0, 0, 28, 1,
    0, 0, 0, 0, 1, 4, 4, 4, 4, 1, 28, 28, 1, 1, 0, 0,
    25, 25, 25, 25, 25, 0, 1, 1, 1, 1, 28, 25, 28, 28, 1, 28,
    29, 29, 29, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 0, 1, 9, 9, 9, 9, 29, 29, 29, 29, 29, 29, 29,
    25, 25, 25, 25, 25, 28, 28, 28, 28, 28, 25, 25, 28, 28, 28, 28,
    25, 28, 28, 25, 28, 28, 25, 28, 28, 28, 28, 28, 28, 28, 25, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 25, 25,
    28, 28, 25, 28, 25, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    /* Page 34, 0 indirect uses */
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    /* Page 35, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 25, 25, 25, 25, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    25, 25, 28, 28, 28, 28, 28, 28, 28, 20, 21, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 25, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 25, 25, 25, 25,
    25, 25, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 36, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    /* Page 37, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 25, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 25, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 25, 25, 25, 25, 25, 25, 25, 25,
    /* Page 38, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 25,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29,
    28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 39, 0 indirect uses */
    29, 28, 28, 28, 28, 29, 28, 28, 28, 28, 29, 29, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 29, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 28, 29, 28,
    28, 28, 28, 29, 29, 29, 28, 29, 28, 28, 28, 28, 28, 28, 28, 29,
    29, 28, 28, 28, 28, 28, 28, 28, 20, 21, 20, 21, 20, 21, 20, 21,
    20, 21, 20, 21, 20, 21, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 28, 29, 29, 29, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    29, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,
    25, 25, 25, 25, 25, 20, 21, 25, 25, 25, 25, 29, 25, 29, 29, 29,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 20, 21, 20, 21, 20, 21, 20, 21, 20, 21,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    /* Page 40, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    /* Page 41, 0 indirect uses */
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 20, 21, 20, 21, 20, 21, 20, 21, 20, 21, 20, 21, 20,
    21, 20, 21, 20, 21, 20, 21, 20, 21, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 20, 21, 20, 21, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 20, 21, 25, 25,
    /* Page 42, 0 indirect uses */
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    /* Page 43, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 28, 28, 25, 25, 25, 25, 25, 25, 29, 29, 29,
    28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 44, 0 indirect uses */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 29,
    0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0,
    29, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 3, 29, 29,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 1, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 24, 24, 24, 24, 10, 24, 24,
    /* Page 45, 0 indirect uses */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 3,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 29,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 29,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 29,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 29,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    /* Page 46, 0 indirect uses */
    24, 24, 22, 23, 22, 23, 24, 24, 24, 22, 23, 24, 22, 23, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 19, 24, 24, 19, 24, 22, 23, 24, 24,
    22, 23, 20, 21, 20, 21, 20, 21, 20, 21, 24, 24, 24, 24, 24, 3,
    24, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 47, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29,
    /* Page 48, 0 indirect uses */
    11, 24, 24, 24, 28, 3, 4, 9, 20, 21, 20, 21, 20, 21, 20, 21,
    20, 21, 28, 28, 20, 21, 20, 21, 20, 21, 20, 21, 19, 20, 21, 21,
    28, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5, 5, 5, 5,
    19, 3, 3, 3, 3, 3, 28, 28, 9, 9, 9, 3, 4, 24, 28, 28,
    29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 29, 5, 5, 27, 27, 3, 3, 4,
    19, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 24, 3, 3, 3, 4,
    /* Page 49, 0 indirect uses */
    29, 29, 29, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29,
    29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29,
    28, 28, 10, 10, 10, 10, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 50, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    28, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,
    /* Page 51, 0 indirect uses */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    /* Page 52, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 53, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 54, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 55, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 56, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 57, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 58, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 59, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 60, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 61, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 62, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 63, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 64, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 65, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 66, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 67, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 68, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 69, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 70, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 71, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 72, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 73, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 74, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 75, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 76, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 77, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    /* Page 78, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 79, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 80, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 81, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 82, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 83, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 84, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 85, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 86, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 87, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 88, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 89, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 90, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 91, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 92, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 93, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 94, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 95, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 96, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 97, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 98, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 99, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 100, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 101, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 102, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 103, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 104, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 105, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 106, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 107, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 108, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 109, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 110, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 111, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 112, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 113, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 114, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 115, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 116, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 117, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 118, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 119, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 120, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 121, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 122, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 123, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 124, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 125, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 126, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 127, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 128, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 129, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 130, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 131, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 132, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 133, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 134, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 135, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 136, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 137, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 138, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 139, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 140, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 141, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 142, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 143, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 144, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 145, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 146, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 147, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 148, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 149, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 150, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 151, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 152, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 153, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 154, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 155, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 156, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 157, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 158, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 159, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 160, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 161, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 162, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 163, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 164, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 165, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 166, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 24, 24, 24,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    29, 29, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 4, 5,
    7, 7, 7, 24, 29, 29, 29, 29, 29, 29, 29, 29, 5, 5, 24, 3,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 167, 0 indirect uses */
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    27, 27, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
    3, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1,
    0, 1, 0, 1, 0, 1, 0, 1, 3, 27, 27, 0, 1, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 4, 4, 4, 4, 4,
    /* Page 168, 0 indirect uses */
    4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 6, 6, 5, 5, 6, 28, 28, 28, 28, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 24, 24, 24, 24, 29, 29, 29, 29, 29, 29, 29, 29,
    6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29, 24, 24,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 169, 0 indirect uses */
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 24, 24,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 6, 6, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 24,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 170, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6,
    6, 5, 5, 6, 6, 5, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 6, 29, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 24, 24, 24, 24,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 171, 0 indirect uses */
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 172, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 173, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 174, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 175, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 176, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 177, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 178, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 179, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 180, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 181, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 182, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 183, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 184, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 185, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 186, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 187, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 188, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 189, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 190, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 191, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 192, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 193, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 194, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 195, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 196, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 197, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 198, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 199, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 200, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 201, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 202, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 203, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 204, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 205, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 206, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 207, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 208, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 209, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 210, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 211, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 212, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 213, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 214, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 215, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 216, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /* Page 217, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /* Page 218, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /* Page 219, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /* Page 220, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /* Page 221, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /* Page 222, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /* Page 223, 0 indirect uses */
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    /*
     * Page 224, 510 indirect uses:
     *  F0000-FFEFF (astral_index),
     *  100000-10FEFF (astral_index)
     */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 225, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 226, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 227, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 228, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 229, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 230, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 231, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 232, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 233, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 234, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 235, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 236, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 237, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 238, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 239, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 240, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 241, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 242, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 243, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 244, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 245, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 246, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 247, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 248, 0 indirect uses */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    /* Page 249, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 250, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 251, 0 indirect uses */
    1, 1, 1, 1, 1, 1, 1, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 1, 1, 1, 1, 1, 29, 29, 29, 29, 29, 4, 5, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 25, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 29, 4, 29,
    4, 4, 29, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 252, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    /* Page 253, 0 indirect uses */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 20, 21,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    29, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 26, 28, 29, 29,
    /* Page 254, 0 indirect uses */
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    24, 24, 24, 24, 24, 24, 24, 20, 21, 24, 29, 29, 29, 29, 29, 29,
    5, 5, 5, 5, 5, 5, 5, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    24, 19, 19, 18, 18, 20, 21, 20, 21, 20, 21, 20, 21, 20, 21, 20,
    21, 20, 21, 20, 21, 24, 24, 20, 21, 24, 24, 24, 24, 18, 18, 18,
    24, 24, 24, 29, 24, 24, 24, 24, 19, 20, 21, 20, 21, 20, 21, 24,
    24, 24, 25, 19, 25, 25, 25, 29, 24, 26, 24, 24, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 15,
    /* Page 255, 0 indirect uses */
    29, 24, 24, 24, 26, 24, 24, 24, 20, 21, 24, 25, 24, 19, 24, 24,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 24, 24, 25, 25, 25, 24,
    24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 24, 21, 27, 18,
    27, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 25, 21, 25, 20,
    21, 24, 20, 21, 24, 24, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29,
    29, 29, 4, 4, 4, 4, 4, 4, 29, 29, 4, 4, 4, 4, 4, 4,
    29, 29, 4, 4, 4, 4, 4, 4, 29, 29, 4, 4, 4, 29, 29, 29,
    26, 26, 25, 27, 28, 26, 26, 29, 28, 25, 25, 25, 25, 28, 28, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 15, 15, 15, 28, 28, 29, 29,
    /* Page 256, 1 indirect use: 10000-100FF (astral_index) */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 4, 4, 29, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29,
    /* Page 257, 1 indirect use: 10100-101FF (astral_index) */
    24, 24, 28, 29, 29, 29, 29, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 29, 29, 29, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 10, 10, 10, 10, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 10, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 5, 29, 29,
    /* Page 258, 1 indirect use: 10200-102FF (astral_index) */
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 259, 1 indirect use: 10300-103FF (astral_index) */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29,
    10, 10, 10, 10, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 9, 4, 4, 4, 4, 4, 4, 4, 4, 9, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 24,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 29, 29, 29, 29, 4, 4, 4, 4, 4, 4, 4, 4,
    24, 9, 9, 9, 9, 9, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 260, 1 indirect use: 10400-104FF (astral_index) */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 261, 1 indirect use: 10800-108FF (astral_index) */
    4, 4, 4, 4, 4, 4, 29, 29, 4, 29, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 29, 4, 4, 29, 29, 29, 4, 29, 29, 4,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 262, 1 indirect use: 10900-109FF (astral_index) */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 10, 10, 10, 10, 29, 29, 29, 29, 29, 24,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 24,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 263, 1 indirect use: 10A00-10AFF (astral_index) */
    4, 5, 5, 5, 29, 5, 5, 29, 29, 29, 29, 29, 5, 5, 5, 5,
    4, 4, 4, 4, 29, 4, 4, 4, 29, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 29, 29, 29, 29, 5, 5, 5, 29, 29, 29, 29, 5,
    10, 10, 10, 10, 10, 10, 10, 10, 29, 29, 29, 29, 29, 29, 29, 29,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 264, 1 indirect use: 12300-123FF (astral_index) */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 265, 1 indirect use: 12400-124FF (astral_index) */
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    24, 24, 24, 24, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 266, 1 indirect use: 1D000-1D0FF (astral_index) */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 267, 1 indirect use: 1D100-1D1FF (astral_index) */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 29, 29, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 6, 6, 5, 5, 5, 28, 28, 28, 6, 6, 6,
    6, 6, 6, 15, 15, 15, 15, 15, 15, 15, 15, 5, 5, 5, 5, 5,
    5, 5, 5, 28, 28, 5, 5, 5, 5, 5, 5, 5, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 5, 5, 5, 5, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 268, 1 indirect use: 1D200-1D2FF (astral_index) */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 5, 5, 5, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 269, 1 indirect use: 1D300-1D3FF (astral_index) */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 270, 1 indirect use: 1D400-1D4FF (astral_index) */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 1, 1, 1, 29, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 29, 0, 0,
    29, 29, 0, 29, 29, 0, 0, 29, 29, 0, 0, 0, 0, 29, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 29, 1, 29, 1, 1, 1,
    1, 1, 1, 1, 29, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    /* Page 271, 1 indirect use: 1D500-1D5FF (astral_index) */
    1, 1, 1, 1, 0, 0, 29, 0, 0, 0, 0, 29, 29, 0, 0, 0,
    0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 29, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 29, 0, 0, 0, 0, 29,
    0, 0, 0, 0, 0, 29, 0, 29, 29, 29, 0, 0, 0, 0, 0, 0,
    0, 29, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    /* Page 272, 1 indirect use: 1D600-1D6FF (astral_index) */
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 29, 29, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 25, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 25, 1, 1, 1, 1,
    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 1, 1, 1, 1,
    /* Page 273, 1 indirect use: 1D700-1D7FF (astral_index) */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 25, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 25, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 25,
    1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 25, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 25, 1, 1, 1, 1, 1, 1, 0, 1, 29, 29, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    /* Page 274, 1 indirect use: 1F000-1F0FF (astral_index) */
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 275, 1 indirect use: 2A600-2A6FF (astral_index) */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 276, 1 indirect use: 2FA00-2FAFF (astral_index) */
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 277, 1 indirect use: E0000-E00FF (astral_index) */
    29, 15, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /* Page 278, 1 indirect use: E0100-E01FF (astral_index) */
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    /*
     * Page 279, 2 indirect uses:
     *  FFF00-FFFFF (astral_index),
     *  10FF00-10FFFF (astral_index)
     */
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 29, 29
};

const uint8_t NumericData[] =
{
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1,
    2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 2, 3, 57, 57, 57, 57, 57, 1, 57, 57, 44, 33, 45, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 1, 2,
    3, 4, 57, 16, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 1, 2, 3,
    4, 5, 6, 7, 8, 9, 10, 28, 30, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 33, 34, 35, 36, 37, 38, 39, 40, 41, 56, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 22, 23, 24, 25, 26, 27, 28, 32, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 17, 18, 19, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 0, 57, 57, 57, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 42, 43, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 1, 1, 2, 3, 4, 5, 6,
    7, 8, 9, 10, 11, 12, 23, 28, 29, 30, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 23, 28, 29, 30, 30, 31, 32, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    0, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 0, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 1, 2, 3, 4, 5, 6, 7, 8, 9, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 10, 20, 21, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 1, 2, 3, 4, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
};

const double NumericDataValues[] =
{
    0,  1,   2,  3,  4,  5,  6,  7,  8,  9,
    10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 30, 40, 50, 60, 70, 80, 90, 100, 500,
    1000, 5000, 10000, 1 / 2, 3 / 2, 5 / 2, 7 / 2, 9 / 2, 11 / 2, 13 / 2,
    15 / 2, 17 / 2, 1 / 3, 2 / 3, 1 / 4, 3 / 4, 1 / 5, 2 / 5, 3 / 5, 4 / 5,
    1 / 6, 5 / 6, 1 / 8, 3 / 8, 5 / 8, 7 / 8, -1 / 2, -1
};

const Il2CppChar ToLowerDataLow[] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
    50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 97, 98, 99,
    100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 224, 225, 226, 227, 228, 229, 230, 231,
    232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 215, 248, 249, 250, 251, 252, 253, 254, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,
    250, 251, 252, 253, 254, 255, 257, 257, 259, 259, 261, 261, 263, 263, 265, 265, 267, 267, 269, 269, 271, 271, 273, 273, 275, 275, 277, 277, 279, 279, 281, 281, 283, 283, 285, 285, 287, 287, 289, 289, 291, 291, 293, 293, 295, 295, 297, 297, 299, 299,
    301, 301, 303, 303, 304, 305, 307, 307, 309, 309, 311, 311, 312, 314, 314, 316, 316, 318, 318, 320, 320, 322, 322, 324, 324, 326, 326, 328, 328, 329, 331, 331, 333, 333, 335, 335, 337, 337, 339, 339, 341, 341, 343, 343, 345, 345, 347, 347, 349, 349,
    351, 351, 353, 353, 355, 355, 357, 357, 359, 359, 361, 361, 363, 363, 365, 365, 367, 367, 369, 369, 371, 371, 373, 373, 375, 375, 255, 378, 378, 380, 380, 382, 382, 383, 384, 595, 387, 387, 389, 389, 596, 392, 392, 598, 599, 396, 396, 397, 477, 601,
    603, 402, 402, 608, 611, 405, 617, 616, 409, 409, 410, 411, 623, 626, 414, 629, 417, 417, 419, 419, 421, 421, 422, 424, 424, 643, 426, 427, 429, 429, 648, 432, 432, 650, 651, 436, 436, 438, 438, 658, 441, 441, 442, 443, 445, 445, 446, 447, 448, 449,
    450, 451, 454, 453, 454, 457, 456, 457, 460, 459, 460, 462, 462, 464, 464, 466, 466, 468, 468, 470, 470, 472, 472, 474, 474, 476, 476, 477, 479, 479, 481, 481, 483, 483, 485, 485, 487, 487, 489, 489, 491, 491, 493, 493, 495, 495, 496, 499, 498, 499,
    501, 501, 502, 503, 504, 505, 507, 507, 509, 509, 511, 511, 513, 513, 515, 515, 517, 517, 519, 519, 521, 521, 523, 523, 525, 525, 527, 527, 529, 529, 531, 531, 533, 533, 535, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549,
    550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599,
    600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649,
    650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699,
    700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749,
    750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799,
    800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849,
    850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899,
    900, 901, 940, 903, 941, 942, 943, 907, 972, 909, 973, 974, 912, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 930, 963, 964, 965, 966, 967, 968, 969, 970, 971, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949,
    950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 995, 995, 997, 997, 999, 999,
    1001, 1001, 1003, 1003, 1005, 1005, 1007, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1037, 1118, 1119, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081,
    1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099,
    1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1121, 1121, 1123, 1123, 1125, 1125, 1127, 1127, 1129, 1129, 1131, 1131, 1133, 1133, 1135, 1135, 1137, 1137, 1139, 1139, 1141, 1141, 1143, 1143, 1145, 1145, 1147, 1147, 1149, 1149,
    1151, 1151, 1153, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1169, 1169, 1171, 1171, 1173, 1173, 1175, 1175, 1177, 1177, 1179, 1179, 1181, 1181, 1183, 1183, 1185, 1185, 1187, 1187, 1189, 1189, 1191, 1191, 1193, 1193, 1195, 1195, 1197, 1197, 1199, 1199,
    1201, 1201, 1203, 1203, 1205, 1205, 1207, 1207, 1209, 1209, 1211, 1211, 1213, 1213, 1215, 1215, 1216, 1218, 1218, 1220, 1220, 1221, 1222, 1224, 1224, 1225, 1226, 1228, 1228, 1229, 1230, 1231, 1233, 1233, 1235, 1235, 1237, 1237, 1239, 1239, 1241, 1241, 1243, 1243, 1245, 1245, 1247, 1247, 1249, 1249,
    1251, 1251, 1253, 1253, 1255, 1255, 1257, 1257, 1259, 1259, 1260, 1261, 1263, 1263, 1265, 1265, 1267, 1267, 1269, 1269, 1270, 1271, 1273, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299,
    1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397,
    1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399,
    1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449,
    1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499,
    1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549,
    1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599,
    1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649,
    1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699,
    1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749,
    1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799,
    1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849,
    1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899,
    1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949,
    1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049,
    2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099,
    2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149,
    2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199,
    2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249,
    2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299,
    2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349,
    2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399,
    2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449,
    2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499,
    2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549,
    2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599,
    2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649,
    2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699,
    2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749,
    2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799,
    2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849,
    2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899,
    2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949,
    2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999,
    3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049,
    3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099,
    3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149,
    3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199,
    3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249,
    3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299,
    3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349,
    3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399,
    3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449,
    3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499,
    3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549,
    3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599,
    3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649,
    3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699,
    3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749,
    3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799,
    3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849,
    3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899,
    3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949,
    3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999,
    4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049,
    4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099,
    4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149,
    4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199,
    4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249,
    4250, 4251, 4252, 4253, 4254, 4255, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4294, 4295, 4296, 4297, 4298, 4299,
    4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349,
    4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399,
    4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449,
    4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499,
    4500, 4501, 4502, 4503, 4504, 4505, 4506, 4507, 4508, 4509, 4510, 4511, 4512, 4513, 4514, 4515, 4516, 4517, 4518, 4519, 4520, 4521, 4522, 4523, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4546, 4547, 4548, 4549,
    4550, 4551, 4552, 4553, 4554, 4555, 4556, 4557, 4558, 4559, 4560, 4561, 4562, 4563, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4574, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586, 4587, 4588, 4589, 4590, 4591, 4592, 4593, 4594, 4595, 4596, 4597, 4598, 4599,
    4600, 4601, 4602, 4603, 4604, 4605, 4606, 4607, 4608, 4609, 4610, 4611, 4612, 4613, 4614, 4615, 4616, 4617, 4618, 4619, 4620, 4621, 4622, 4623, 4624, 4625, 4626, 4627, 4628, 4629, 4630, 4631, 4632, 4633, 4634, 4635, 4636, 4637, 4638, 4639, 4640, 4641, 4642, 4643, 4644, 4645, 4646, 4647, 4648, 4649,
    4650, 4651, 4652, 4653, 4654, 4655, 4656, 4657, 4658, 4659, 4660, 4661, 4662, 4663, 4664, 4665, 4666, 4667, 4668, 4669, 4670, 4671, 4672, 4673, 4674, 4675, 4676, 4677, 4678, 4679, 4680, 4681, 4682, 4683, 4684, 4685, 4686, 4687, 4688, 4689, 4690, 4691, 4692, 4693, 4694, 4695, 4696, 4697, 4698, 4699,
    4700, 4701, 4702, 4703, 4704, 4705, 4706, 4707, 4708, 4709, 4710, 4711, 4712, 4713, 4714, 4715, 4716, 4717, 4718, 4719, 4720, 4721, 4722, 4723, 4724, 4725, 4726, 4727, 4728, 4729, 4730, 4731, 4732, 4733, 4734, 4735, 4736, 4737, 4738, 4739, 4740, 4741, 4742, 4743, 4744, 4745, 4746, 4747, 4748, 4749,
    4750, 4751, 4752, 4753, 4754, 4755, 4756, 4757, 4758, 4759, 4760, 4761, 4762, 4763, 4764, 4765, 4766, 4767, 4768, 4769, 4770, 4771, 4772, 4773, 4774, 4775, 4776, 4777, 4778, 4779, 4780, 4781, 4782, 4783, 4784, 4785, 4786, 4787, 4788, 4789, 4790, 4791, 4792, 4793, 4794, 4795, 4796, 4797, 4798, 4799,
    4800, 4801, 4802, 4803, 4804, 4805, 4806, 4807, 4808, 4809, 4810, 4811, 4812, 4813, 4814, 4815, 4816, 4817, 4818, 4819, 4820, 4821, 4822, 4823, 4824, 4825, 4826, 4827, 4828, 4829, 4830, 4831, 4832, 4833, 4834, 4835, 4836, 4837, 4838, 4839, 4840, 4841, 4842, 4843, 4844, 4845, 4846, 4847, 4848, 4849,
    4850, 4851, 4852, 4853, 4854, 4855, 4856, 4857, 4858, 4859, 4860, 4861, 4862, 4863, 4864, 4865, 4866, 4867, 4868, 4869, 4870, 4871, 4872, 4873, 4874, 4875, 4876, 4877, 4878, 4879, 4880, 4881, 4882, 4883, 4884, 4885, 4886, 4887, 4888, 4889, 4890, 4891, 4892, 4893, 4894, 4895, 4896, 4897, 4898, 4899,
    4900, 4901, 4902, 4903, 4904, 4905, 4906, 4907, 4908, 4909, 4910, 4911, 4912, 4913, 4914, 4915, 4916, 4917, 4918, 4919, 4920, 4921, 4922, 4923, 4924, 4925, 4926, 4927, 4928, 4929, 4930, 4931, 4932, 4933, 4934, 4935, 4936, 4937, 4938, 4939, 4940, 4941, 4942, 4943, 4944, 4945, 4946, 4947, 4948, 4949,
    4950, 4951, 4952, 4953, 4954, 4955, 4956, 4957, 4958, 4959, 4960, 4961, 4962, 4963, 4964, 4965, 4966, 4967, 4968, 4969, 4970, 4971, 4972, 4973, 4974, 4975, 4976, 4977, 4978, 4979, 4980, 4981, 4982, 4983, 4984, 4985, 4986, 4987, 4988, 4989, 4990, 4991, 4992, 4993, 4994, 4995, 4996, 4997, 4998, 4999,
    5000, 5001, 5002, 5003, 5004, 5005, 5006, 5007, 5008, 5009, 5010, 5011, 5012, 5013, 5014, 5015, 5016, 5017, 5018, 5019, 5020, 5021, 5022, 5023, 5024, 5025, 5026, 5027, 5028, 5029, 5030, 5031, 5032, 5033, 5034, 5035, 5036, 5037, 5038, 5039, 5040, 5041, 5042, 5043, 5044, 5045, 5046, 5047, 5048, 5049,
    5050, 5051, 5052, 5053, 5054, 5055, 5056, 5057, 5058, 5059, 5060, 5061, 5062, 5063, 5064, 5065, 5066, 5067, 5068, 5069, 5070, 5071, 5072, 5073, 5074, 5075, 5076, 5077, 5078, 5079, 5080, 5081, 5082, 5083, 5084, 5085, 5086, 5087, 5088, 5089, 5090, 5091, 5092, 5093, 5094, 5095, 5096, 5097, 5098, 5099,
    5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 5110, 5111, 5112, 5113, 5114, 5115, 5116, 5117, 5118, 5119, 5120, 5121, 5122, 5123, 5124, 5125, 5126, 5127, 5128, 5129, 5130, 5131, 5132, 5133, 5134, 5135, 5136, 5137, 5138, 5139, 5140, 5141, 5142, 5143, 5144, 5145, 5146, 5147, 5148, 5149,
    5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 5171, 5172, 5173, 5174, 5175, 5176, 5177, 5178, 5179, 5180, 5181, 5182, 5183, 5184, 5185, 5186, 5187, 5188, 5189, 5190, 5191, 5192, 5193, 5194, 5195, 5196, 5197, 5198, 5199,
    5200, 5201, 5202, 5203, 5204, 5205, 5206, 5207, 5208, 5209, 5210, 5211, 5212, 5213, 5214, 5215, 5216, 5217, 5218, 5219, 5220, 5221, 5222, 5223, 5224, 5225, 5226, 5227, 5228, 5229, 5230, 5231, 5232, 5233, 5234, 5235, 5236, 5237, 5238, 5239, 5240, 5241, 5242, 5243, 5244, 5245, 5246, 5247, 5248, 5249,
    5250, 5251, 5252, 5253, 5254, 5255, 5256, 5257, 5258, 5259, 5260, 5261, 5262, 5263, 5264, 5265, 5266, 5267, 5268, 5269, 5270, 5271, 5272, 5273, 5274, 5275, 5276, 5277, 5278, 5279, 5280, 5281, 5282, 5283, 5284, 5285, 5286, 5287, 5288, 5289, 5290, 5291, 5292, 5293, 5294, 5295, 5296, 5297, 5298, 5299,
    5300, 5301, 5302, 5303, 5304, 5305, 5306, 5307, 5308, 5309, 5310, 5311, 5312, 5313, 5314, 5315, 5316, 5317, 5318, 5319, 5320, 5321, 5322, 5323, 5324, 5325, 5326, 5327, 5328, 5329, 5330, 5331, 5332, 5333, 5334, 5335, 5336, 5337, 5338, 5339, 5340, 5341, 5342, 5343, 5344, 5345, 5346, 5347, 5348, 5349,
    5350, 5351, 5352, 5353, 5354, 5355, 5356, 5357, 5358, 5359, 5360, 5361, 5362, 5363, 5364, 5365, 5366, 5367, 5368, 5369, 5370, 5371, 5372, 5373, 5374, 5375, 5376, 5377, 5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395, 5396, 5397, 5398, 5399,
    5400, 5401, 5402, 5403, 5404, 5405, 5406, 5407, 5408, 5409, 5410, 5411, 5412, 5413, 5414, 5415, 5416, 5417, 5418, 5419, 5420, 5421, 5422, 5423, 5424, 5425, 5426, 5427, 5428, 5429, 5430, 5431, 5432, 5433, 5434, 5435, 5436, 5437, 5438, 5439, 5440, 5441, 5442, 5443, 5444, 5445, 5446, 5447, 5448, 5449,
    5450, 5451, 5452, 5453, 5454, 5455, 5456, 5457, 5458, 5459, 5460, 5461, 5462, 5463, 5464, 5465, 5466, 5467, 5468, 5469, 5470, 5471, 5472, 5473, 5474, 5475, 5476, 5477, 5478, 5479, 5480, 5481, 5482, 5483, 5484, 5485, 5486, 5487, 5488, 5489, 5490, 5491, 5492, 5493, 5494, 5495, 5496, 5497, 5498, 5499,
    5500, 5501, 5502, 5503, 5504, 5505, 5506, 5507, 5508, 5509, 5510, 5511, 5512, 5513, 5514, 5515, 5516, 5517, 5518, 5519, 5520, 5521, 5522, 5523, 5524, 5525, 5526, 5527, 5528, 5529, 5530, 5531, 5532, 5533, 5534, 5535, 5536, 5537, 5538, 5539, 5540, 5541, 5542, 5543, 5544, 5545, 5546, 5547, 5548, 5549,
    5550, 5551, 5552, 5553, 5554, 5555, 5556, 5557, 5558, 5559, 5560, 5561, 5562, 5563, 5564, 5565, 5566, 5567, 5568, 5569, 5570, 5571, 5572, 5573, 5574, 5575, 5576, 5577, 5578, 5579, 5580, 5581, 5582, 5583, 5584, 5585, 5586, 5587, 5588, 5589, 5590, 5591, 5592, 5593, 5594, 5595, 5596, 5597, 5598, 5599,
    5600, 5601, 5602, 5603, 5604, 5605, 5606, 5607, 5608, 5609, 5610, 5611, 5612, 5613, 5614, 5615, 5616, 5617, 5618, 5619, 5620, 5621, 5622, 5623, 5624, 5625, 5626, 5627, 5628, 5629, 5630, 5631, 5632, 5633, 5634, 5635, 5636, 5637, 5638, 5639, 5640, 5641, 5642, 5643, 5644, 5645, 5646, 5647, 5648, 5649,
    5650, 5651, 5652, 5653, 5654, 5655, 5656, 5657, 5658, 5659, 5660, 5661, 5662, 5663, 5664, 5665, 5666, 5667, 5668, 5669, 5670, 5671, 5672, 5673, 5674, 5675, 5676, 5677, 5678, 5679, 5680, 5681, 5682, 5683, 5684, 5685, 5686, 5687, 5688, 5689, 5690, 5691, 5692, 5693, 5694, 5695, 5696, 5697, 5698, 5699,
    5700, 5701, 5702, 5703, 5704, 5705, 5706, 5707, 5708, 5709, 5710, 5711, 5712, 5713, 5714, 5715, 5716, 5717, 5718, 5719, 5720, 5721, 5722, 5723, 5724, 5725, 5726, 5727, 5728, 5729, 5730, 5731, 5732, 5733, 5734, 5735, 5736, 5737, 5738, 5739, 5740, 5741, 5742, 5743, 5744, 5745, 5746, 5747, 5748, 5749,
    5750, 5751, 5752, 5753, 5754, 5755, 5756, 5757, 5758, 5759, 5760, 5761, 5762, 5763, 5764, 5765, 5766, 5767, 5768, 5769, 5770, 5771, 5772, 5773, 5774, 5775, 5776, 5777, 5778, 5779, 5780, 5781, 5782, 5783, 5784, 5785, 5786, 5787, 5788, 5789, 5790, 5791, 5792, 5793, 5794, 5795, 5796, 5797, 5798, 5799,
    5800, 5801, 5802, 5803, 5804, 5805, 5806, 5807, 5808, 5809, 5810, 5811, 5812, 5813, 5814, 5815, 5816, 5817, 5818, 5819, 5820, 5821, 5822, 5823, 5824, 5825, 5826, 5827, 5828, 5829, 5830, 5831, 5832, 5833, 5834, 5835, 5836, 5837, 5838, 5839, 5840, 5841, 5842, 5843, 5844, 5845, 5846, 5847, 5848, 5849,
    5850, 5851, 5852, 5853, 5854, 5855, 5856, 5857, 5858, 5859, 5860, 5861, 5862, 5863, 5864, 5865, 5866, 5867, 5868, 5869, 5870, 5871, 5872, 5873, 5874, 5875, 5876, 5877, 5878, 5879, 5880, 5881, 5882, 5883, 5884, 5885, 5886, 5887, 5888, 5889, 5890, 5891, 5892, 5893, 5894, 5895, 5896, 5897, 5898, 5899,
    5900, 5901, 5902, 5903, 5904, 5905, 5906, 5907, 5908, 5909, 5910, 5911, 5912, 5913, 5914, 5915, 5916, 5917, 5918, 5919, 5920, 5921, 5922, 5923, 5924, 5925, 5926, 5927, 5928, 5929, 5930, 5931, 5932, 5933, 5934, 5935, 5936, 5937, 5938, 5939, 5940, 5941, 5942, 5943, 5944, 5945, 5946, 5947, 5948, 5949,
    5950, 5951, 5952, 5953, 5954, 5955, 5956, 5957, 5958, 5959, 5960, 5961, 5962, 5963, 5964, 5965, 5966, 5967, 5968, 5969, 5970, 5971, 5972, 5973, 5974, 5975, 5976, 5977, 5978, 5979, 5980, 5981, 5982, 5983, 5984, 5985, 5986, 5987, 5988, 5989, 5990, 5991, 5992, 5993, 5994, 5995, 5996, 5997, 5998, 5999,
    6000, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010, 6011, 6012, 6013, 6014, 6015, 6016, 6017, 6018, 6019, 6020, 6021, 6022, 6023, 6024, 6025, 6026, 6027, 6028, 6029, 6030, 6031, 6032, 6033, 6034, 6035, 6036, 6037, 6038, 6039, 6040, 6041, 6042, 6043, 6044, 6045, 6046, 6047, 6048, 6049,
    6050, 6051, 6052, 6053, 6054, 6055, 6056, 6057, 6058, 6059, 6060, 6061, 6062, 6063, 6064, 6065, 6066, 6067, 6068, 6069, 6070, 6071, 6072, 6073, 6074, 6075, 6076, 6077, 6078, 6079, 6080, 6081, 6082, 6083, 6084, 6085, 6086, 6087, 6088, 6089, 6090, 6091, 6092, 6093, 6094, 6095, 6096, 6097, 6098, 6099,
    6100, 6101, 6102, 6103, 6104, 6105, 6106, 6107, 6108, 6109, 6110, 6111, 6112, 6113, 6114, 6115, 6116, 6117, 6118, 6119, 6120, 6121, 6122, 6123, 6124, 6125, 6126, 6127, 6128, 6129, 6130, 6131, 6132, 6133, 6134, 6135, 6136, 6137, 6138, 6139, 6140, 6141, 6142, 6143, 6144, 6145, 6146, 6147, 6148, 6149,
    6150, 6151, 6152, 6153, 6154, 6155, 6156, 6157, 6158, 6159, 6160, 6161, 6162, 6163, 6164, 6165, 6166, 6167, 6168, 6169, 6170, 6171, 6172, 6173, 6174, 6175, 6176, 6177, 6178, 6179, 6180, 6181, 6182, 6183, 6184, 6185, 6186, 6187, 6188, 6189, 6190, 6191, 6192, 6193, 6194, 6195, 6196, 6197, 6198, 6199,
    6200, 6201, 6202, 6203, 6204, 6205, 6206, 6207, 6208, 6209, 6210, 6211, 6212, 6213, 6214, 6215, 6216, 6217, 6218, 6219, 6220, 6221, 6222, 6223, 6224, 6225, 6226, 6227, 6228, 6229, 6230, 6231, 6232, 6233, 6234, 6235, 6236, 6237, 6238, 6239, 6240, 6241, 6242, 6243, 6244, 6245, 6246, 6247, 6248, 6249,
    6250, 6251, 6252, 6253, 6254, 6255, 6256, 6257, 6258, 6259, 6260, 6261, 6262, 6263, 6264, 6265, 6266, 6267, 6268, 6269, 6270, 6271, 6272, 6273, 6274, 6275, 6276, 6277, 6278, 6279, 6280, 6281, 6282, 6283, 6284, 6285, 6286, 6287, 6288, 6289, 6290, 6291, 6292, 6293, 6294, 6295, 6296, 6297, 6298, 6299,
    6300, 6301, 6302, 6303, 6304, 6305, 6306, 6307, 6308, 6309, 6310, 6311, 6312, 6313, 6314, 6315, 6316, 6317, 6318, 6319, 6320, 6321, 6322, 6323, 6324, 6325, 6326, 6327, 6328, 6329, 6330, 6331, 6332, 6333, 6334, 6335, 6336, 6337, 6338, 6339, 6340, 6341, 6342, 6343, 6344, 6345, 6346, 6347, 6348, 6349,
    6350, 6351, 6352, 6353, 6354, 6355, 6356, 6357, 6358, 6359, 6360, 6361, 6362, 6363, 6364, 6365, 6366, 6367, 6368, 6369, 6370, 6371, 6372, 6373, 6374, 6375, 6376, 6377, 6378, 6379, 6380, 6381, 6382, 6383, 6384, 6385, 6386, 6387, 6388, 6389, 6390, 6391, 6392, 6393, 6394, 6395, 6396, 6397, 6398, 6399,
    6400, 6401, 6402, 6403, 6404, 6405, 6406, 6407, 6408, 6409, 6410, 6411, 6412, 6413, 6414, 6415, 6416, 6417, 6418, 6419, 6420, 6421, 6422, 6423, 6424, 6425, 6426, 6427, 6428, 6429, 6430, 6431, 6432, 6433, 6434, 6435, 6436, 6437, 6438, 6439, 6440, 6441, 6442, 6443, 6444, 6445, 6446, 6447, 6448, 6449,
    6450, 6451, 6452, 6453, 6454, 6455, 6456, 6457, 6458, 6459, 6460, 6461, 6462, 6463, 6464, 6465, 6466, 6467, 6468, 6469, 6470, 6471, 6472, 6473, 6474, 6475, 6476, 6477, 6478, 6479, 6480, 6481, 6482, 6483, 6484, 6485, 6486, 6487, 6488, 6489, 6490, 6491, 6492, 6493, 6494, 6495, 6496, 6497, 6498, 6499,
    6500, 6501, 6502, 6503, 6504, 6505, 6506, 6507, 6508, 6509, 6510, 6511, 6512, 6513, 6514, 6515, 6516, 6517, 6518, 6519, 6520, 6521, 6522, 6523, 6524, 6525, 6526, 6527, 6528, 6529, 6530, 6531, 6532, 6533, 6534, 6535, 6536, 6537, 6538, 6539, 6540, 6541, 6542, 6543, 6544, 6545, 6546, 6547, 6548, 6549,
    6550, 6551, 6552, 6553, 6554, 6555, 6556, 6557, 6558, 6559, 6560, 6561, 6562, 6563, 6564, 6565, 6566, 6567, 6568, 6569, 6570, 6571, 6572, 6573, 6574, 6575, 6576, 6577, 6578, 6579, 6580, 6581, 6582, 6583, 6584, 6585, 6586, 6587, 6588, 6589, 6590, 6591, 6592, 6593, 6594, 6595, 6596, 6597, 6598, 6599,
    6600, 6601, 6602, 6603, 6604, 6605, 6606, 6607, 6608, 6609, 6610, 6611, 6612, 6613, 6614, 6615, 6616, 6617, 6618, 6619, 6620, 6621, 6622, 6623, 6624, 6625, 6626, 6627, 6628, 6629, 6630, 6631, 6632, 6633, 6634, 6635, 6636, 6637, 6638, 6639, 6640, 6641, 6642, 6643, 6644, 6645, 6646, 6647, 6648, 6649,
    6650, 6651, 6652, 6653, 6654, 6655, 6656, 6657, 6658, 6659, 6660, 6661, 6662, 6663, 6664, 6665, 6666, 6667, 6668, 6669, 6670, 6671, 6672, 6673, 6674, 6675, 6676, 6677, 6678, 6679, 6680, 6681, 6682, 6683, 6684, 6685, 6686, 6687, 6688, 6689, 6690, 6691, 6692, 6693, 6694, 6695, 6696, 6697, 6698, 6699,
    6700, 6701, 6702, 6703, 6704, 6705, 6706, 6707, 6708, 6709, 6710, 6711, 6712, 6713, 6714, 6715, 6716, 6717, 6718, 6719, 6720, 6721, 6722, 6723, 6724, 6725, 6726, 6727, 6728, 6729, 6730, 6731, 6732, 6733, 6734, 6735, 6736, 6737, 6738, 6739, 6740, 6741, 6742, 6743, 6744, 6745, 6746, 6747, 6748, 6749,
    6750, 6751, 6752, 6753, 6754, 6755, 6756, 6757, 6758, 6759, 6760, 6761, 6762, 6763, 6764, 6765, 6766, 6767, 6768, 6769, 6770, 6771, 6772, 6773, 6774, 6775, 6776, 6777, 6778, 6779, 6780, 6781, 6782, 6783, 6784, 6785, 6786, 6787, 6788, 6789, 6790, 6791, 6792, 6793, 6794, 6795, 6796, 6797, 6798, 6799,
    6800, 6801, 6802, 6803, 6804, 6805, 6806, 6807, 6808, 6809, 6810, 6811, 6812, 6813, 6814, 6815, 6816, 6817, 6818, 6819, 6820, 6821, 6822, 6823, 6824, 6825, 6826, 6827, 6828, 6829, 6830, 6831, 6832, 6833, 6834, 6835, 6836, 6837, 6838, 6839, 6840, 6841, 6842, 6843, 6844, 6845, 6846, 6847, 6848, 6849,
    6850, 6851, 6852, 6853, 6854, 6855, 6856, 6857, 6858, 6859, 6860, 6861, 6862, 6863, 6864, 6865, 6866, 6867, 6868, 6869, 6870, 6871, 6872, 6873, 6874, 6875, 6876, 6877, 6878, 6879, 6880, 6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889, 6890, 6891, 6892, 6893, 6894, 6895, 6896, 6897, 6898, 6899,
    6900, 6901, 6902, 6903, 6904, 6905, 6906, 6907, 6908, 6909, 6910, 6911, 6912, 6913, 6914, 6915, 6916, 6917, 6918, 6919, 6920, 6921, 6922, 6923, 6924, 6925, 6926, 6927, 6928, 6929, 6930, 6931, 6932, 6933, 6934, 6935, 6936, 6937, 6938, 6939, 6940, 6941, 6942, 6943, 6944, 6945, 6946, 6947, 6948, 6949,
    6950, 6951, 6952, 6953, 6954, 6955, 6956, 6957, 6958, 6959, 6960, 6961, 6962, 6963, 6964, 6965, 6966, 6967, 6968, 6969, 6970, 6971, 6972, 6973, 6974, 6975, 6976, 6977, 6978, 6979, 6980, 6981, 6982, 6983, 6984, 6985, 6986, 6987, 6988, 6989, 6990, 6991, 6992, 6993, 6994, 6995, 6996, 6997, 6998, 6999,
    7000, 7001, 7002, 7003, 7004, 7005, 7006, 7007, 7008, 7009, 7010, 7011, 7012, 7013, 7014, 7015, 7016, 7017, 7018, 7019, 7020, 7021, 7022, 7023, 7024, 7025, 7026, 7027, 7028, 7029, 7030, 7031, 7032, 7033, 7034, 7035, 7036, 7037, 7038, 7039, 7040, 7041, 7042, 7043, 7044, 7045, 7046, 7047, 7048, 7049,
    7050, 7051, 7052, 7053, 7054, 7055, 7056, 7057, 7058, 7059, 7060, 7061, 7062, 7063, 7064, 7065, 7066, 7067, 7068, 7069, 7070, 7071, 7072, 7073, 7074, 7075, 7076, 7077, 7078, 7079, 7080, 7081, 7082, 7083, 7084, 7085, 7086, 7087, 7088, 7089, 7090, 7091, 7092, 7093, 7094, 7095, 7096, 7097, 7098, 7099,
    7100, 7101, 7102, 7103, 7104, 7105, 7106, 7107, 7108, 7109, 7110, 7111, 7112, 7113, 7114, 7115, 7116, 7117, 7118, 7119, 7120, 7121, 7122, 7123, 7124, 7125, 7126, 7127, 7128, 7129, 7130, 7131, 7132, 7133, 7134, 7135, 7136, 7137, 7138, 7139, 7140, 7141, 7142, 7143, 7144, 7145, 7146, 7147, 7148, 7149,
    7150, 7151, 7152, 7153, 7154, 7155, 7156, 7157, 7158, 7159, 7160, 7161, 7162, 7163, 7164, 7165, 7166, 7167, 7168, 7169, 7170, 7171, 7172, 7173, 7174, 7175, 7176, 7177, 7178, 7179, 7180, 7181, 7182, 7183, 7184, 7185, 7186, 7187, 7188, 7189, 7190, 7191, 7192, 7193, 7194, 7195, 7196, 7197, 7198, 7199,
    7200, 7201, 7202, 7203, 7204, 7205, 7206, 7207, 7208, 7209, 7210, 7211, 7212, 7213, 7214, 7215, 7216, 7217, 7218, 7219, 7220, 7221, 7222, 7223, 7224, 7225, 7226, 7227, 7228, 7229, 7230, 7231, 7232, 7233, 7234, 7235, 7236, 7237, 7238, 7239, 7240, 7241, 7242, 7243, 7244, 7245, 7246, 7247, 7248, 7249,
    7250, 7251, 7252, 7253, 7254, 7255, 7256, 7257, 7258, 7259, 7260, 7261, 7262, 7263, 7264, 7265, 7266, 7267, 7268, 7269, 7270, 7271, 7272, 7273, 7274, 7275, 7276, 7277, 7278, 7279, 7280, 7281, 7282, 7283, 7284, 7285, 7286, 7287, 7288, 7289, 7290, 7291, 7292, 7293, 7294, 7295, 7296, 7297, 7298, 7299,
    7300, 7301, 7302, 7303, 7304, 7305, 7306, 7307, 7308, 7309, 7310, 7311, 7312, 7313, 7314, 7315, 7316, 7317, 7318, 7319, 7320, 7321, 7322, 7323, 7324, 7325, 7326, 7327, 7328, 7329, 7330, 7331, 7332, 7333, 7334, 7335, 7336, 7337, 7338, 7339, 7340, 7341, 7342, 7343, 7344, 7345, 7346, 7347, 7348, 7349,
    7350, 7351, 7352, 7353, 7354, 7355, 7356, 7357, 7358, 7359, 7360, 7361, 7362, 7363, 7364, 7365, 7366, 7367, 7368, 7369, 7370, 7371, 7372, 7373, 7374, 7375, 7376, 7377, 7378, 7379, 7380, 7381, 7382, 7383, 7384, 7385, 7386, 7387, 7388, 7389, 7390, 7391, 7392, 7393, 7394, 7395, 7396, 7397, 7398, 7399,
    7400, 7401, 7402, 7403, 7404, 7405, 7406, 7407, 7408, 7409, 7410, 7411, 7412, 7413, 7414, 7415, 7416, 7417, 7418, 7419, 7420, 7421, 7422, 7423, 7424, 7425, 7426, 7427, 7428, 7429, 7430, 7431, 7432, 7433, 7434, 7435, 7436, 7437, 7438, 7439, 7440, 7441, 7442, 7443, 7444, 7445, 7446, 7447, 7448, 7449,
    7450, 7451, 7452, 7453, 7454, 7455, 7456, 7457, 7458, 7459, 7460, 7461, 7462, 7463, 7464, 7465, 7466, 7467, 7468, 7469, 7470, 7471, 7472, 7473, 7474, 7475, 7476, 7477, 7478, 7479, 7480, 7481, 7482, 7483, 7484, 7485, 7486, 7487, 7488, 7489, 7490, 7491, 7492, 7493, 7494, 7495, 7496, 7497, 7498, 7499,
    7500, 7501, 7502, 7503, 7504, 7505, 7506, 7507, 7508, 7509, 7510, 7511, 7512, 7513, 7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7522, 7523, 7524, 7525, 7526, 7527, 7528, 7529, 7530, 7531, 7532, 7533, 7534, 7535, 7536, 7537, 7538, 7539, 7540, 7541, 7542, 7543, 7544, 7545, 7546, 7547, 7548, 7549,
    7550, 7551, 7552, 7553, 7554, 7555, 7556, 7557, 7558, 7559, 7560, 7561, 7562, 7563, 7564, 7565, 7566, 7567, 7568, 7569, 7570, 7571, 7572, 7573, 7574, 7575, 7576, 7577, 7578, 7579, 7580, 7581, 7582, 7583, 7584, 7585, 7586, 7587, 7588, 7589, 7590, 7591, 7592, 7593, 7594, 7595, 7596, 7597, 7598, 7599,
    7600, 7601, 7602, 7603, 7604, 7605, 7606, 7607, 7608, 7609, 7610, 7611, 7612, 7613, 7614, 7615, 7616, 7617, 7618, 7619, 7620, 7621, 7622, 7623, 7624, 7625, 7626, 7627, 7628, 7629, 7630, 7631, 7632, 7633, 7634, 7635, 7636, 7637, 7638, 7639, 7640, 7641, 7642, 7643, 7644, 7645, 7646, 7647, 7648, 7649,
    7650, 7651, 7652, 7653, 7654, 7655, 7656, 7657, 7658, 7659, 7660, 7661, 7662, 7663, 7664, 7665, 7666, 7667, 7668, 7669, 7670, 7671, 7672, 7673, 7674, 7675, 7676, 7677, 7678, 7679, 7681, 7681, 7683, 7683, 7685, 7685, 7687, 7687, 7689, 7689, 7691, 7691, 7693, 7693, 7695, 7695, 7697, 7697, 7699, 7699,
    7701, 7701, 7703, 7703, 7705, 7705, 7707, 7707, 7709, 7709, 7711, 7711, 7713, 7713, 7715, 7715, 7717, 7717, 7719, 7719, 7721, 7721, 7723, 7723, 7725, 7725, 7727, 7727, 7729, 7729, 7731, 7731, 7733, 7733, 7735, 7735, 7737, 7737, 7739, 7739, 7741, 7741, 7743, 7743, 7745, 7745, 7747, 7747, 7749, 7749,
    7751, 7751, 7753, 7753, 7755, 7755, 7757, 7757, 7759, 7759, 7761, 7761, 7763, 7763, 7765, 7765, 7767, 7767, 7769, 7769, 7771, 7771, 7773, 7773, 7775, 7775, 7777, 7777, 7779, 7779, 7781, 7781, 7783, 7783, 7785, 7785, 7787, 7787, 7789, 7789, 7791, 7791, 7793, 7793, 7795, 7795, 7797, 7797, 7799, 7799,
    7801, 7801, 7803, 7803, 7805, 7805, 7807, 7807, 7809, 7809, 7811, 7811, 7813, 7813, 7815, 7815, 7817, 7817, 7819, 7819, 7821, 7821, 7823, 7823, 7825, 7825, 7827, 7827, 7829, 7829, 7830, 7831, 7832, 7833, 7834, 7835, 7836, 7837, 7838, 7839, 7841, 7841, 7843, 7843, 7845, 7845, 7847, 7847, 7849, 7849,
    7851, 7851, 7853, 7853, 7855, 7855, 7857, 7857, 7859, 7859, 7861, 7861, 7863, 7863, 7865, 7865, 7867, 7867, 7869, 7869, 7871, 7871, 7873, 7873, 7875, 7875, 7877, 7877, 7879, 7879, 7881, 7881, 7883, 7883, 7885, 7885, 7887, 7887, 7889, 7889, 7891, 7891, 7893, 7893, 7895, 7895, 7897, 7897, 7899, 7899,
    7901, 7901, 7903, 7903, 7905, 7905, 7907, 7907, 7909, 7909, 7911, 7911, 7913, 7913, 7915, 7915, 7917, 7917, 7919, 7919, 7921, 7921, 7923, 7923, 7925, 7925, 7927, 7927, 7929, 7929, 7930, 7931, 7932, 7933, 7934, 7935, 7936, 7937, 7938, 7939, 7940, 7941, 7942, 7943, 7936, 7937, 7938, 7939, 7940, 7941,
    7942, 7943, 7952, 7953, 7954, 7955, 7956, 7957, 7958, 7959, 7952, 7953, 7954, 7955, 7956, 7957, 7966, 7967, 7968, 7969, 7970, 7971, 7972, 7973, 7974, 7975, 7968, 7969, 7970, 7971, 7972, 7973, 7974, 7975, 7984, 7985, 7986, 7987, 7988, 7989, 7990, 7991, 7984, 7985, 7986, 7987, 7988, 7989, 7990, 7991,
    8000, 8001, 8002, 8003, 8004, 8005, 8006, 8007, 8000, 8001, 8002, 8003, 8004, 8005, 8014, 8015, 8016, 8017, 8018, 8019, 8020, 8021, 8022, 8023, 8024, 8017, 8026, 8019, 8028, 8021, 8030, 8023, 8032, 8033, 8034, 8035, 8036, 8037, 8038, 8039, 8032, 8033, 8034, 8035, 8036, 8037, 8038, 8039, 8048, 8049,
    8050, 8051, 8052, 8053, 8054, 8055, 8056, 8057, 8058, 8059, 8060, 8061, 8062, 8063, 8064, 8065, 8066, 8067, 8068, 8069, 8070, 8071, 8072, 8073, 8074, 8075, 8076, 8077, 8078, 8079, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098, 8099,
    8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 8109, 8110, 8111, 8112, 8113, 8114, 8115, 8116, 8117, 8118, 8119, 8112, 8113, 8048, 8049, 8124, 8125, 8126, 8127, 8128, 8129, 8130, 8131, 8132, 8133, 8134, 8135, 8050, 8051, 8052, 8053, 8140, 8141, 8142, 8143, 8144, 8145, 8146, 8147, 8148, 8149,
    8150, 8151, 8144, 8145, 8054, 8055, 8156, 8157, 8158, 8159, 8160, 8161, 8162, 8163, 8164, 8165, 8166, 8167, 8160, 8161, 8058, 8059, 8165, 8173, 8174, 8175, 8176, 8177, 8178, 8179, 8180, 8181, 8182, 8183, 8056, 8057, 8060, 8061, 8188, 8189, 8190, 8191, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199,
    8200, 8201, 8202, 8203, 8204, 8205, 8206, 8207, 8208, 8209, 8210, 8211, 8212, 8213, 8214, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8223, 8224, 8225, 8226, 8227, 8228, 8229, 8230, 8231, 8232, 8233, 8234, 8235, 8236, 8237, 8238, 8239, 8240, 8241, 8242, 8243, 8244, 8245, 8246, 8247, 8248, 8249,
    8250, 8251, 8252, 8253, 8254, 8255, 8256, 8257, 8258, 8259, 8260, 8261, 8262, 8263, 8264, 8265, 8266, 8267, 8268, 8269, 8270, 8271, 8272, 8273, 8274, 8275, 8276, 8277, 8278, 8279, 8280, 8281, 8282, 8283, 8284, 8285, 8286, 8287, 8288, 8289, 8290, 8291, 8292, 8293, 8294, 8295, 8296, 8297, 8298, 8299,
    8300, 8301, 8302, 8303, 8304, 8305, 8306, 8307, 8308, 8309, 8310, 8311, 8312, 8313, 8314, 8315, 8316, 8317, 8318, 8319, 8320, 8321, 8322, 8323, 8324, 8325, 8326, 8327, 8328, 8329, 8330, 8331, 8332, 8333, 8334, 8335, 8336, 8337, 8338, 8339, 8340, 8341, 8342, 8343, 8344, 8345, 8346, 8347, 8348, 8349,
    8350, 8351, 8352, 8353, 8354, 8355, 8356, 8357, 8358, 8359, 8360, 8361, 8362, 8363, 8364, 8365, 8366, 8367, 8368, 8369, 8370, 8371, 8372, 8373, 8374, 8375, 8376, 8377, 8378, 8379, 8380, 8381, 8382, 8383, 8384, 8385, 8386, 8387, 8388, 8389, 8390, 8391, 8392, 8393, 8394, 8395, 8396, 8397, 8398, 8399,
    8400, 8401, 8402, 8403, 8404, 8405, 8406, 8407, 8408, 8409, 8410, 8411, 8412, 8413, 8414, 8415, 8416, 8417, 8418, 8419, 8420, 8421, 8422, 8423, 8424, 8425, 8426, 8427, 8428, 8429, 8430, 8431, 8432, 8433, 8434, 8435, 8436, 8437, 8438, 8439, 8440, 8441, 8442, 8443, 8444, 8445, 8446, 8447, 8448, 8449,
    8450, 8451, 8452, 8453, 8454, 8455, 8456, 8457, 8458, 8459, 8460, 8461, 8462, 8463, 8464, 8465, 8466, 8467, 8468, 8469, 8470, 8471, 8472, 8473, 8474, 8475, 8476, 8477, 8478, 8479, 8480, 8481, 8482, 8483, 8484, 8485, 8486, 8487, 8488, 8489, 8490, 8491, 8492, 8493, 8494, 8495, 8496, 8497, 8498, 8499,
    8500, 8501, 8502, 8503, 8504, 8505, 8506, 8507, 8508, 8509, 8510, 8511, 8512, 8513, 8514, 8515, 8516, 8517, 8518, 8519, 8520, 8521, 8522, 8523, 8524, 8525, 8526, 8527, 8528, 8529, 8530, 8531, 8532, 8533, 8534, 8535, 8536, 8537, 8538, 8539, 8540, 8541, 8542, 8543, 8560, 8561, 8562, 8563, 8564, 8565,
    8566, 8567, 8568, 8569, 8570, 8571, 8572, 8573, 8574, 8575, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8570, 8571, 8572, 8573, 8574, 8575, 8576, 8577, 8578, 8579, 8580, 8581, 8582, 8583, 8584, 8585, 8586, 8587, 8588, 8589, 8590, 8591, 8592, 8593, 8594, 8595, 8596, 8597, 8598, 8599,
    8600, 8601, 8602, 8603, 8604, 8605, 8606, 8607, 8608, 8609, 8610, 8611, 8612, 8613, 8614, 8615, 8616, 8617, 8618, 8619, 8620, 8621, 8622, 8623, 8624, 8625, 8626, 8627, 8628, 8629, 8630, 8631, 8632, 8633, 8634, 8635, 8636, 8637, 8638, 8639, 8640, 8641, 8642, 8643, 8644, 8645, 8646, 8647, 8648, 8649,
    8650, 8651, 8652, 8653, 8654, 8655, 8656, 8657, 8658, 8659, 8660, 8661, 8662, 8663, 8664, 8665, 8666, 8667, 8668, 8669, 8670, 8671, 8672, 8673, 8674, 8675, 8676, 8677, 8678, 8679, 8680, 8681, 8682, 8683, 8684, 8685, 8686, 8687, 8688, 8689, 8690, 8691, 8692, 8693, 8694, 8695, 8696, 8697, 8698, 8699,
    8700, 8701, 8702, 8703, 8704, 8705, 8706, 8707, 8708, 8709, 8710, 8711, 8712, 8713, 8714, 8715, 8716, 8717, 8718, 8719, 8720, 8721, 8722, 8723, 8724, 8725, 8726, 8727, 8728, 8729, 8730, 8731, 8732, 8733, 8734, 8735, 8736, 8737, 8738, 8739, 8740, 8741, 8742, 8743, 8744, 8745, 8746, 8747, 8748, 8749,
    8750, 8751, 8752, 8753, 8754, 8755, 8756, 8757, 8758, 8759, 8760, 8761, 8762, 8763, 8764, 8765, 8766, 8767, 8768, 8769, 8770, 8771, 8772, 8773, 8774, 8775, 8776, 8777, 8778, 8779, 8780, 8781, 8782, 8783, 8784, 8785, 8786, 8787, 8788, 8789, 8790, 8791, 8792, 8793, 8794, 8795, 8796, 8797, 8798, 8799,
    8800, 8801, 8802, 8803, 8804, 8805, 8806, 8807, 8808, 8809, 8810, 8811, 8812, 8813, 8814, 8815, 8816, 8817, 8818, 8819, 8820, 8821, 8822, 8823, 8824, 8825, 8826, 8827, 8828, 8829, 8830, 8831, 8832, 8833, 8834, 8835, 8836, 8837, 8838, 8839, 8840, 8841, 8842, 8843, 8844, 8845, 8846, 8847, 8848, 8849,
    8850, 8851, 8852, 8853, 8854, 8855, 8856, 8857, 8858, 8859, 8860, 8861, 8862, 8863, 8864, 8865, 8866, 8867, 8868, 8869, 8870, 8871, 8872, 8873, 8874, 8875, 8876, 8877, 8878, 8879, 8880, 8881, 8882, 8883, 8884, 8885, 8886, 8887, 8888, 8889, 8890, 8891, 8892, 8893, 8894, 8895, 8896, 8897, 8898, 8899,
    8900, 8901, 8902, 8903, 8904, 8905, 8906, 8907, 8908, 8909, 8910, 8911, 8912, 8913, 8914, 8915, 8916, 8917, 8918, 8919, 8920, 8921, 8922, 8923, 8924, 8925, 8926, 8927, 8928, 8929, 8930, 8931, 8932, 8933, 8934, 8935, 8936, 8937, 8938, 8939, 8940, 8941, 8942, 8943, 8944, 8945, 8946, 8947, 8948, 8949,
    8950, 8951, 8952, 8953, 8954, 8955, 8956, 8957, 8958, 8959, 8960, 8961, 8962, 8963, 8964, 8965, 8966, 8967, 8968, 8969, 8970, 8971, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999,
    9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 9009, 9010, 9011, 9012, 9013, 9014, 9015, 9016, 9017, 9018, 9019, 9020, 9021, 9022, 9023, 9024, 9025, 9026, 9027, 9028, 9029, 9030, 9031, 9032, 9033, 9034, 9035, 9036, 9037, 9038, 9039, 9040, 9041, 9042, 9043, 9044, 9045, 9046, 9047, 9048, 9049,
    9050, 9051, 9052, 9053, 9054, 9055, 9056, 9057, 9058, 9059, 9060, 9061, 9062, 9063, 9064, 9065, 9066, 9067, 9068, 9069, 9070, 9071, 9072, 9073, 9074, 9075, 9076, 9077, 9078, 9079, 9080, 9081, 9082, 9083, 9084, 9085, 9086, 9087, 9088, 9089, 9090, 9091, 9092, 9093, 9094, 9095, 9096, 9097, 9098, 9099,
    9100, 9101, 9102, 9103, 9104, 9105, 9106, 9107, 9108, 9109, 9110, 9111, 9112, 9113, 9114, 9115, 9116, 9117, 9118, 9119, 9120, 9121, 9122, 9123, 9124, 9125, 9126, 9127, 9128, 9129, 9130, 9131, 9132, 9133, 9134, 9135, 9136, 9137, 9138, 9139, 9140, 9141, 9142, 9143, 9144, 9145, 9146, 9147, 9148, 9149,
    9150, 9151, 9152, 9153, 9154, 9155, 9156, 9157, 9158, 9159, 9160, 9161, 9162, 9163, 9164, 9165, 9166, 9167, 9168, 9169, 9170, 9171, 9172, 9173, 9174, 9175, 9176, 9177, 9178, 9179, 9180, 9181, 9182, 9183, 9184, 9185, 9186, 9187, 9188, 9189, 9190, 9191, 9192, 9193, 9194, 9195, 9196, 9197, 9198, 9199,
    9200, 9201, 9202, 9203, 9204, 9205, 9206, 9207, 9208, 9209, 9210, 9211, 9212, 9213, 9214, 9215, 9216, 9217, 9218, 9219, 9220, 9221, 9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229, 9230, 9231, 9232, 9233, 9234, 9235, 9236, 9237, 9238, 9239, 9240, 9241, 9242, 9243, 9244, 9245, 9246, 9247, 9248, 9249,
    9250, 9251, 9252, 9253, 9254, 9255, 9256, 9257, 9258, 9259, 9260, 9261, 9262, 9263, 9264, 9265, 9266, 9267, 9268, 9269, 9270, 9271, 9272, 9273, 9274, 9275, 9276, 9277, 9278, 9279, 9280, 9281, 9282, 9283, 9284, 9285, 9286, 9287, 9288, 9289, 9290, 9291, 9292, 9293, 9294, 9295, 9296, 9297, 9298, 9299,
    9300, 9301, 9302, 9303, 9304, 9305, 9306, 9307, 9308, 9309, 9310, 9311, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9322, 9323, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349,
    9350, 9351, 9352, 9353, 9354, 9355, 9356, 9357, 9358, 9359, 9360, 9361, 9362, 9363, 9364, 9365, 9366, 9367, 9368, 9369, 9370, 9371, 9372, 9373, 9374, 9375, 9376, 9377, 9378, 9379, 9380, 9381, 9382, 9383, 9384, 9385, 9386, 9387, 9388, 9389, 9390, 9391, 9392, 9393, 9394, 9395, 9396, 9397, 9424, 9425,
    9426, 9427, 9428, 9429, 9430, 9431, 9432, 9433, 9434, 9435, 9436, 9437, 9438, 9439, 9440, 9441, 9442, 9443, 9444, 9445, 9446, 9447, 9448, 9449
};

const Il2CppChar ToLowerDataHigh[] =
{
    65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 65339, 65340, 65341, 65342, 65343, 65344, 65345, 65346, 65347, 65348, 65349,
    65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370, 65371, 65372, 65373, 65374, 65375, 65376, 65377, 65378, 65379, 65380, 65381, 65382, 65383, 65384, 65385, 65386, 65387, 65388, 65389, 65390, 65391, 65392, 65393, 65394, 65395, 65396, 65397, 65398, 65399,
    65400, 65401, 65402, 65403, 65404, 65405, 65406, 65407, 65408, 65409, 65410, 65411, 65412, 65413, 65414, 65415, 65416, 65417, 65418, 65419, 65420, 65421, 65422, 65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430, 65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438, 65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446, 65447, 65448, 65449,
    65450, 65451, 65452, 65453, 65454, 65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462, 65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470, 65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494, 65495, 65496, 65497, 65498, 65499,
    65500, 65501, 65502, 65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518, 65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534, 65535
};

const Il2CppChar ToUpperDataLow[] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
    50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 65, 66, 67,
    68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
    200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 247, 216, 217,
    218, 219, 220, 221, 222, 376, 256, 256, 258, 258, 260, 260, 262, 262, 264, 264, 266, 266, 268, 268, 270, 270, 272, 272, 274, 274, 276, 276, 278, 278, 280, 280, 282, 282, 284, 284, 286, 286, 288, 288, 290, 290, 292, 292, 294, 294, 296, 296, 298, 298,
    300, 300, 302, 302, 304, 305, 306, 306, 308, 308, 310, 310, 312, 313, 313, 315, 315, 317, 317, 319, 319, 321, 321, 323, 323, 325, 325, 327, 327, 329, 330, 330, 332, 332, 334, 334, 336, 336, 338, 338, 340, 340, 342, 342, 344, 344, 346, 346, 348, 348,
    350, 350, 352, 352, 354, 354, 356, 356, 358, 358, 360, 360, 362, 362, 364, 364, 366, 366, 368, 368, 370, 370, 372, 372, 374, 374, 376, 377, 377, 379, 379, 381, 381, 383, 384, 385, 386, 386, 388, 388, 390, 391, 391, 393, 394, 395, 395, 397, 398, 399,
    400, 401, 401, 403, 404, 405, 406, 407, 408, 408, 410, 411, 412, 413, 414, 415, 416, 416, 418, 418, 420, 420, 422, 423, 423, 425, 426, 427, 428, 428, 430, 431, 431, 433, 434, 435, 435, 437, 437, 439, 440, 440, 442, 443, 444, 444, 446, 447, 448, 449,
    450, 451, 452, 453, 452, 455, 456, 455, 458, 459, 458, 461, 461, 463, 463, 465, 465, 467, 467, 469, 469, 471, 471, 473, 473, 475, 475, 398, 478, 478, 480, 480, 482, 482, 484, 484, 486, 486, 488, 488, 490, 490, 492, 492, 494, 494, 496, 497, 498, 497,
    500, 500, 502, 503, 504, 505, 506, 506, 508, 508, 510, 510, 512, 512, 514, 514, 516, 516, 518, 518, 520, 520, 522, 522, 524, 524, 526, 526, 528, 528, 530, 530, 532, 532, 534, 534, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549,
    550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 385, 390, 597, 393, 394,
    600, 399, 602, 400, 604, 605, 606, 607, 403, 609, 610, 404, 612, 613, 614, 615, 407, 406, 618, 619, 620, 621, 622, 412, 624, 625, 413, 627, 628, 415, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 425, 644, 645, 646, 647, 430, 649,
    433, 434, 652, 653, 654, 655, 656, 657, 439, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699,
    700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749,
    750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799,
    800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849,
    850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899,
    900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 902, 904, 905, 906, 944, 913, 914, 915, 916, 917,
    918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 931, 932, 933, 934, 935, 936, 937, 938, 939, 908, 910, 911, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 994, 996, 996, 998, 998,
    1000, 1000, 1002, 1002, 1004, 1004, 1006, 1006, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049,
    1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067,
    1068, 1069, 1070, 1071, 1104, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1117, 1038, 1039, 1120, 1120, 1122, 1122, 1124, 1124, 1126, 1126, 1128, 1128, 1130, 1130, 1132, 1132, 1134, 1134, 1136, 1136, 1138, 1138, 1140, 1140, 1142, 1142, 1144, 1144, 1146, 1146, 1148, 1148,
    1150, 1150, 1152, 1152, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1168, 1170, 1170, 1172, 1172, 1174, 1174, 1176, 1176, 1178, 1178, 1180, 1180, 1182, 1182, 1184, 1184, 1186, 1186, 1188, 1188, 1190, 1190, 1192, 1192, 1194, 1194, 1196, 1196, 1198, 1198,
    1200, 1200, 1202, 1202, 1204, 1204, 1206, 1206, 1208, 1208, 1210, 1210, 1212, 1212, 1214, 1214, 1216, 1217, 1217, 1219, 1219, 1221, 1222, 1223, 1223, 1225, 1226, 1227, 1227, 1229, 1230, 1231, 1232, 1232, 1234, 1234, 1236, 1236, 1238, 1238, 1240, 1240, 1242, 1242, 1244, 1244, 1246, 1246, 1248, 1248,
    1250, 1250, 1252, 1252, 1254, 1254, 1256, 1256, 1258, 1258, 1260, 1261, 1262, 1262, 1264, 1264, 1266, 1266, 1268, 1268, 1270, 1271, 1272, 1272, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299,
    1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349,
    1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351,
    1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449,
    1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499,
    1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549,
    1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599,
    1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649,
    1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699,
    1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749,
    1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799,
    1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849,
    1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899,
    1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949,
    1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049,
    2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099,
    2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149,
    2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199,
    2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249,
    2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299,
    2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349,
    2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399,
    2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449,
    2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499,
    2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549,
    2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599,
    2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649,
    2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699,
    2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749,
    2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799,
    2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849,
    2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899,
    2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949,
    2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999,
    3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049,
    3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099,
    3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149,
    3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199,
    3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249,
    3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299,
    3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349,
    3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399,
    3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449,
    3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499,
    3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549,
    3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599,
    3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649,
    3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699,
    3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749,
    3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799,
    3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849,
    3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899,
    3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949,
    3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999,
    4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049,
    4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099,
    4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149,
    4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199,
    4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249,
    4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299,
    4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349,
    4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399,
    4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449,
    4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499,
    4500, 4501, 4502, 4503, 4504, 4505, 4506, 4507, 4508, 4509, 4510, 4511, 4512, 4513, 4514, 4515, 4516, 4517, 4518, 4519, 4520, 4521, 4522, 4523, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4546, 4547, 4548, 4549,
    4550, 4551, 4552, 4553, 4554, 4555, 4556, 4557, 4558, 4559, 4560, 4561, 4562, 4563, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4574, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586, 4587, 4588, 4589, 4590, 4591, 4592, 4593, 4594, 4595, 4596, 4597, 4598, 4599,
    4600, 4601, 4602, 4603, 4604, 4605, 4606, 4607, 4608, 4609, 4610, 4611, 4612, 4613, 4614, 4615, 4616, 4617, 4618, 4619, 4620, 4621, 4622, 4623, 4624, 4625, 4626, 4627, 4628, 4629, 4630, 4631, 4632, 4633, 4634, 4635, 4636, 4637, 4638, 4639, 4640, 4641, 4642, 4643, 4644, 4645, 4646, 4647, 4648, 4649,
    4650, 4651, 4652, 4653, 4654, 4655, 4656, 4657, 4658, 4659, 4660, 4661, 4662, 4663, 4664, 4665, 4666, 4667, 4668, 4669, 4670, 4671, 4672, 4673, 4674, 4675, 4676, 4677, 4678, 4679, 4680, 4681, 4682, 4683, 4684, 4685, 4686, 4687, 4688, 4689, 4690, 4691, 4692, 4693, 4694, 4695, 4696, 4697, 4698, 4699,
    4700, 4701, 4702, 4703, 4704, 4705, 4706, 4707, 4708, 4709, 4710, 4711, 4712, 4713, 4714, 4715, 4716, 4717, 4718, 4719, 4720, 4721, 4722, 4723, 4724, 4725, 4726, 4727, 4728, 4729, 4730, 4731, 4732, 4733, 4734, 4735, 4736, 4737, 4738, 4739, 4740, 4741, 4742, 4743, 4744, 4745, 4746, 4747, 4748, 4749,
    4750, 4751, 4752, 4753, 4754, 4755, 4756, 4757, 4758, 4759, 4760, 4761, 4762, 4763, 4764, 4765, 4766, 4767, 4768, 4769, 4770, 4771, 4772, 4773, 4774, 4775, 4776, 4777, 4778, 4779, 4780, 4781, 4782, 4783, 4784, 4785, 4786, 4787, 4788, 4789, 4790, 4791, 4792, 4793, 4794, 4795, 4796, 4797, 4798, 4799,
    4800, 4801, 4802, 4803, 4804, 4805, 4806, 4807, 4808, 4809, 4810, 4811, 4812, 4813, 4814, 4815, 4816, 4817, 4818, 4819, 4820, 4821, 4822, 4823, 4824, 4825, 4826, 4827, 4828, 4829, 4830, 4831, 4832, 4833, 4834, 4835, 4836, 4837, 4838, 4839, 4840, 4841, 4842, 4843, 4844, 4845, 4846, 4847, 4848, 4849,
    4850, 4851, 4852, 4853, 4854, 4855, 4856, 4857, 4858, 4859, 4860, 4861, 4862, 4863, 4864, 4865, 4866, 4867, 4868, 4869, 4870, 4871, 4872, 4873, 4874, 4875, 4876, 4877, 4878, 4879, 4880, 4881, 4882, 4883, 4884, 4885, 4886, 4887, 4888, 4889, 4890, 4891, 4892, 4893, 4894, 4895, 4896, 4897, 4898, 4899,
    4900, 4901, 4902, 4903, 4904, 4905, 4906, 4907, 4908, 4909, 4910, 4911, 4912, 4913, 4914, 4915, 4916, 4917, 4918, 4919, 4920, 4921, 4922, 4923, 4924, 4925, 4926, 4927, 4928, 4929, 4930, 4931, 4932, 4933, 4934, 4935, 4936, 4937, 4938, 4939, 4940, 4941, 4942, 4943, 4944, 4945, 4946, 4947, 4948, 4949,
    4950, 4951, 4952, 4953, 4954, 4955, 4956, 4957, 4958, 4959, 4960, 4961, 4962, 4963, 4964, 4965, 4966, 4967, 4968, 4969, 4970, 4971, 4972, 4973, 4974, 4975, 4976, 4977, 4978, 4979, 4980, 4981, 4982, 4983, 4984, 4985, 4986, 4987, 4988, 4989, 4990, 4991, 4992, 4993, 4994, 4995, 4996, 4997, 4998, 4999,
    5000, 5001, 5002, 5003, 5004, 5005, 5006, 5007, 5008, 5009, 5010, 5011, 5012, 5013, 5014, 5015, 5016, 5017, 5018, 5019, 5020, 5021, 5022, 5023, 5024, 5025, 5026, 5027, 5028, 5029, 5030, 5031, 5032, 5033, 5034, 5035, 5036, 5037, 5038, 5039, 5040, 5041, 5042, 5043, 5044, 5045, 5046, 5047, 5048, 5049,
    5050, 5051, 5052, 5053, 5054, 5055, 5056, 5057, 5058, 5059, 5060, 5061, 5062, 5063, 5064, 5065, 5066, 5067, 5068, 5069, 5070, 5071, 5072, 5073, 5074, 5075, 5076, 5077, 5078, 5079, 5080, 5081, 5082, 5083, 5084, 5085, 5086, 5087, 5088, 5089, 5090, 5091, 5092, 5093, 5094, 5095, 5096, 5097, 5098, 5099,
    5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 5110, 5111, 5112, 5113, 5114, 5115, 5116, 5117, 5118, 5119, 5120, 5121, 5122, 5123, 5124, 5125, 5126, 5127, 5128, 5129, 5130, 5131, 5132, 5133, 5134, 5135, 5136, 5137, 5138, 5139, 5140, 5141, 5142, 5143, 5144, 5145, 5146, 5147, 5148, 5149,
    5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 5171, 5172, 5173, 5174, 5175, 5176, 5177, 5178, 5179, 5180, 5181, 5182, 5183, 5184, 5185, 5186, 5187, 5188, 5189, 5190, 5191, 5192, 5193, 5194, 5195, 5196, 5197, 5198, 5199,
    5200, 5201, 5202, 5203, 5204, 5205, 5206, 5207, 5208, 5209, 5210, 5211, 5212, 5213, 5214, 5215, 5216, 5217, 5218, 5219, 5220, 5221, 5222, 5223, 5224, 5225, 5226, 5227, 5228, 5229, 5230, 5231, 5232, 5233, 5234, 5235, 5236, 5237, 5238, 5239, 5240, 5241, 5242, 5243, 5244, 5245, 5246, 5247, 5248, 5249,
    5250, 5251, 5252, 5253, 5254, 5255, 5256, 5257, 5258, 5259, 5260, 5261, 5262, 5263, 5264, 5265, 5266, 5267, 5268, 5269, 5270, 5271, 5272, 5273, 5274, 5275, 5276, 5277, 5278, 5279, 5280, 5281, 5282, 5283, 5284, 5285, 5286, 5287, 5288, 5289, 5290, 5291, 5292, 5293, 5294, 5295, 5296, 5297, 5298, 5299,
    5300, 5301, 5302, 5303, 5304, 5305, 5306, 5307, 5308, 5309, 5310, 5311, 5312, 5313, 5314, 5315, 5316, 5317, 5318, 5319, 5320, 5321, 5322, 5323, 5324, 5325, 5326, 5327, 5328, 5329, 5330, 5331, 5332, 5333, 5334, 5335, 5336, 5337, 5338, 5339, 5340, 5341, 5342, 5343, 5344, 5345, 5346, 5347, 5348, 5349,
    5350, 5351, 5352, 5353, 5354, 5355, 5356, 5357, 5358, 5359, 5360, 5361, 5362, 5363, 5364, 5365, 5366, 5367, 5368, 5369, 5370, 5371, 5372, 5373, 5374, 5375, 5376, 5377, 5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395, 5396, 5397, 5398, 5399,
    5400, 5401, 5402, 5403, 5404, 5405, 5406, 5407, 5408, 5409, 5410, 5411, 5412, 5413, 5414, 5415, 5416, 5417, 5418, 5419, 5420, 5421, 5422, 5423, 5424, 5425, 5426, 5427, 5428, 5429, 5430, 5431, 5432, 5433, 5434, 5435, 5436, 5437, 5438, 5439, 5440, 5441, 5442, 5443, 5444, 5445, 5446, 5447, 5448, 5449,
    5450, 5451, 5452, 5453, 5454, 5455, 5456, 5457, 5458, 5459, 5460, 5461, 5462, 5463, 5464, 5465, 5466, 5467, 5468, 5469, 5470, 5471, 5472, 5473, 5474, 5475, 5476, 5477, 5478, 5479, 5480, 5481, 5482, 5483, 5484, 5485, 5486, 5487, 5488, 5489, 5490, 5491, 5492, 5493, 5494, 5495, 5496, 5497, 5498, 5499,
    5500, 5501, 5502, 5503, 5504, 5505, 5506, 5507, 5508, 5509, 5510, 5511, 5512, 5513, 5514, 5515, 5516, 5517, 5518, 5519, 5520, 5521, 5522, 5523, 5524, 5525, 5526, 5527, 5528, 5529, 5530, 5531, 5532, 5533, 5534, 5535, 5536, 5537, 5538, 5539, 5540, 5541, 5542, 5543, 5544, 5545, 5546, 5547, 5548, 5549,
    5550, 5551, 5552, 5553, 5554, 5555, 5556, 5557, 5558, 5559, 5560, 5561, 5562, 5563, 5564, 5565, 5566, 5567, 5568, 5569, 5570, 5571, 5572, 5573, 5574, 5575, 5576, 5577, 5578, 5579, 5580, 5581, 5582, 5583, 5584, 5585, 5586, 5587, 5588, 5589, 5590, 5591, 5592, 5593, 5594, 5595, 5596, 5597, 5598, 5599,
    5600, 5601, 5602, 5603, 5604, 5605, 5606, 5607, 5608, 5609, 5610, 5611, 5612, 5613, 5614, 5615, 5616, 5617, 5618, 5619, 5620, 5621, 5622, 5623, 5624, 5625, 5626, 5627, 5628, 5629, 5630, 5631, 5632, 5633, 5634, 5635, 5636, 5637, 5638, 5639, 5640, 5641, 5642, 5643, 5644, 5645, 5646, 5647, 5648, 5649,
    5650, 5651, 5652, 5653, 5654, 5655, 5656, 5657, 5658, 5659, 5660, 5661, 5662, 5663, 5664, 5665, 5666, 5667, 5668, 5669, 5670, 5671, 5672, 5673, 5674, 5675, 5676, 5677, 5678, 5679, 5680, 5681, 5682, 5683, 5684, 5685, 5686, 5687, 5688, 5689, 5690, 5691, 5692, 5693, 5694, 5695, 5696, 5697, 5698, 5699,
    5700, 5701, 5702, 5703, 5704, 5705, 5706, 5707, 5708, 5709, 5710, 5711, 5712, 5713, 5714, 5715, 5716, 5717, 5718, 5719, 5720, 5721, 5722, 5723, 5724, 5725, 5726, 5727, 5728, 5729, 5730, 5731, 5732, 5733, 5734, 5735, 5736, 5737, 5738, 5739, 5740, 5741, 5742, 5743, 5744, 5745, 5746, 5747, 5748, 5749,
    5750, 5751, 5752, 5753, 5754, 5755, 5756, 5757, 5758, 5759, 5760, 5761, 5762, 5763, 5764, 5765, 5766, 5767, 5768, 5769, 5770, 5771, 5772, 5773, 5774, 5775, 5776, 5777, 5778, 5779, 5780, 5781, 5782, 5783, 5784, 5785, 5786, 5787, 5788, 5789, 5790, 5791, 5792, 5793, 5794, 5795, 5796, 5797, 5798, 5799,
    5800, 5801, 5802, 5803, 5804, 5805, 5806, 5807, 5808, 5809, 5810, 5811, 5812, 5813, 5814, 5815, 5816, 5817, 5818, 5819, 5820, 5821, 5822, 5823, 5824, 5825, 5826, 5827, 5828, 5829, 5830, 5831, 5832, 5833, 5834, 5835, 5836, 5837, 5838, 5839, 5840, 5841, 5842, 5843, 5844, 5845, 5846, 5847, 5848, 5849,
    5850, 5851, 5852, 5853, 5854, 5855, 5856, 5857, 5858, 5859, 5860, 5861, 5862, 5863, 5864, 5865, 5866, 5867, 5868, 5869, 5870, 5871, 5872, 5873, 5874, 5875, 5876, 5877, 5878, 5879, 5880, 5881, 5882, 5883, 5884, 5885, 5886, 5887, 5888, 5889, 5890, 5891, 5892, 5893, 5894, 5895, 5896, 5897, 5898, 5899,
    5900, 5901, 5902, 5903, 5904, 5905, 5906, 5907, 5908, 5909, 5910, 5911, 5912, 5913, 5914, 5915, 5916, 5917, 5918, 5919, 5920, 5921, 5922, 5923, 5924, 5925, 5926, 5927, 5928, 5929, 5930, 5931, 5932, 5933, 5934, 5935, 5936, 5937, 5938, 5939, 5940, 5941, 5942, 5943, 5944, 5945, 5946, 5947, 5948, 5949,
    5950, 5951, 5952, 5953, 5954, 5955, 5956, 5957, 5958, 5959, 5960, 5961, 5962, 5963, 5964, 5965, 5966, 5967, 5968, 5969, 5970, 5971, 5972, 5973, 5974, 5975, 5976, 5977, 5978, 5979, 5980, 5981, 5982, 5983, 5984, 5985, 5986, 5987, 5988, 5989, 5990, 5991, 5992, 5993, 5994, 5995, 5996, 5997, 5998, 5999,
    6000, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010, 6011, 6012, 6013, 6014, 6015, 6016, 6017, 6018, 6019, 6020, 6021, 6022, 6023, 6024, 6025, 6026, 6027, 6028, 6029, 6030, 6031, 6032, 6033, 6034, 6035, 6036, 6037, 6038, 6039, 6040, 6041, 6042, 6043, 6044, 6045, 6046, 6047, 6048, 6049,
    6050, 6051, 6052, 6053, 6054, 6055, 6056, 6057, 6058, 6059, 6060, 6061, 6062, 6063, 6064, 6065, 6066, 6067, 6068, 6069, 6070, 6071, 6072, 6073, 6074, 6075, 6076, 6077, 6078, 6079, 6080, 6081, 6082, 6083, 6084, 6085, 6086, 6087, 6088, 6089, 6090, 6091, 6092, 6093, 6094, 6095, 6096, 6097, 6098, 6099,
    6100, 6101, 6102, 6103, 6104, 6105, 6106, 6107, 6108, 6109, 6110, 6111, 6112, 6113, 6114, 6115, 6116, 6117, 6118, 6119, 6120, 6121, 6122, 6123, 6124, 6125, 6126, 6127, 6128, 6129, 6130, 6131, 6132, 6133, 6134, 6135, 6136, 6137, 6138, 6139, 6140, 6141, 6142, 6143, 6144, 6145, 6146, 6147, 6148, 6149,
    6150, 6151, 6152, 6153, 6154, 6155, 6156, 6157, 6158, 6159, 6160, 6161, 6162, 6163, 6164, 6165, 6166, 6167, 6168, 6169, 6170, 6171, 6172, 6173, 6174, 6175, 6176, 6177, 6178, 6179, 6180, 6181, 6182, 6183, 6184, 6185, 6186, 6187, 6188, 6189, 6190, 6191, 6192, 6193, 6194, 6195, 6196, 6197, 6198, 6199,
    6200, 6201, 6202, 6203, 6204, 6205, 6206, 6207, 6208, 6209, 6210, 6211, 6212, 6213, 6214, 6215, 6216, 6217, 6218, 6219, 6220, 6221, 6222, 6223, 6224, 6225, 6226, 6227, 6228, 6229, 6230, 6231, 6232, 6233, 6234, 6235, 6236, 6237, 6238, 6239, 6240, 6241, 6242, 6243, 6244, 6245, 6246, 6247, 6248, 6249,
    6250, 6251, 6252, 6253, 6254, 6255, 6256, 6257, 6258, 6259, 6260, 6261, 6262, 6263, 6264, 6265, 6266, 6267, 6268, 6269, 6270, 6271, 6272, 6273, 6274, 6275, 6276, 6277, 6278, 6279, 6280, 6281, 6282, 6283, 6284, 6285, 6286, 6287, 6288, 6289, 6290, 6291, 6292, 6293, 6294, 6295, 6296, 6297, 6298, 6299,
    6300, 6301, 6302, 6303, 6304, 6305, 6306, 6307, 6308, 6309, 6310, 6311, 6312, 6313, 6314, 6315, 6316, 6317, 6318, 6319, 6320, 6321, 6322, 6323, 6324, 6325, 6326, 6327, 6328, 6329, 6330, 6331, 6332, 6333, 6334, 6335, 6336, 6337, 6338, 6339, 6340, 6341, 6342, 6343, 6344, 6345, 6346, 6347, 6348, 6349,
    6350, 6351, 6352, 6353, 6354, 6355, 6356, 6357, 6358, 6359, 6360, 6361, 6362, 6363, 6364, 6365, 6366, 6367, 6368, 6369, 6370, 6371, 6372, 6373, 6374, 6375, 6376, 6377, 6378, 6379, 6380, 6381, 6382, 6383, 6384, 6385, 6386, 6387, 6388, 6389, 6390, 6391, 6392, 6393, 6394, 6395, 6396, 6397, 6398, 6399,
    6400, 6401, 6402, 6403, 6404, 6405, 6406, 6407, 6408, 6409, 6410, 6411, 6412, 6413, 6414, 6415, 6416, 6417, 6418, 6419, 6420, 6421, 6422, 6423, 6424, 6425, 6426, 6427, 6428, 6429, 6430, 6431, 6432, 6433, 6434, 6435, 6436, 6437, 6438, 6439, 6440, 6441, 6442, 6443, 6444, 6445, 6446, 6447, 6448, 6449,
    6450, 6451, 6452, 6453, 6454, 6455, 6456, 6457, 6458, 6459, 6460, 6461, 6462, 6463, 6464, 6465, 6466, 6467, 6468, 6469, 6470, 6471, 6472, 6473, 6474, 6475, 6476, 6477, 6478, 6479, 6480, 6481, 6482, 6483, 6484, 6485, 6486, 6487, 6488, 6489, 6490, 6491, 6492, 6493, 6494, 6495, 6496, 6497, 6498, 6499,
    6500, 6501, 6502, 6503, 6504, 6505, 6506, 6507, 6508, 6509, 6510, 6511, 6512, 6513, 6514, 6515, 6516, 6517, 6518, 6519, 6520, 6521, 6522, 6523, 6524, 6525, 6526, 6527, 6528, 6529, 6530, 6531, 6532, 6533, 6534, 6535, 6536, 6537, 6538, 6539, 6540, 6541, 6542, 6543, 6544, 6545, 6546, 6547, 6548, 6549,
    6550, 6551, 6552, 6553, 6554, 6555, 6556, 6557, 6558, 6559, 6560, 6561, 6562, 6563, 6564, 6565, 6566, 6567, 6568, 6569, 6570, 6571, 6572, 6573, 6574, 6575, 6576, 6577, 6578, 6579, 6580, 6581, 6582, 6583, 6584, 6585, 6586, 6587, 6588, 6589, 6590, 6591, 6592, 6593, 6594, 6595, 6596, 6597, 6598, 6599,
    6600, 6601, 6602, 6603, 6604, 6605, 6606, 6607, 6608, 6609, 6610, 6611, 6612, 6613, 6614, 6615, 6616, 6617, 6618, 6619, 6620, 6621, 6622, 6623, 6624, 6625, 6626, 6627, 6628, 6629, 6630, 6631, 6632, 6633, 6634, 6635, 6636, 6637, 6638, 6639, 6640, 6641, 6642, 6643, 6644, 6645, 6646, 6647, 6648, 6649,
    6650, 6651, 6652, 6653, 6654, 6655, 6656, 6657, 6658, 6659, 6660, 6661, 6662, 6663, 6664, 6665, 6666, 6667, 6668, 6669, 6670, 6671, 6672, 6673, 6674, 6675, 6676, 6677, 6678, 6679, 6680, 6681, 6682, 6683, 6684, 6685, 6686, 6687, 6688, 6689, 6690, 6691, 6692, 6693, 6694, 6695, 6696, 6697, 6698, 6699,
    6700, 6701, 6702, 6703, 6704, 6705, 6706, 6707, 6708, 6709, 6710, 6711, 6712, 6713, 6714, 6715, 6716, 6717, 6718, 6719, 6720, 6721, 6722, 6723, 6724, 6725, 6726, 6727, 6728, 6729, 6730, 6731, 6732, 6733, 6734, 6735, 6736, 6737, 6738, 6739, 6740, 6741, 6742, 6743, 6744, 6745, 6746, 6747, 6748, 6749,
    6750, 6751, 6752, 6753, 6754, 6755, 6756, 6757, 6758, 6759, 6760, 6761, 6762, 6763, 6764, 6765, 6766, 6767, 6768, 6769, 6770, 6771, 6772, 6773, 6774, 6775, 6776, 6777, 6778, 6779, 6780, 6781, 6782, 6783, 6784, 6785, 6786, 6787, 6788, 6789, 6790, 6791, 6792, 6793, 6794, 6795, 6796, 6797, 6798, 6799,
    6800, 6801, 6802, 6803, 6804, 6805, 6806, 6807, 6808, 6809, 6810, 6811, 6812, 6813, 6814, 6815, 6816, 6817, 6818, 6819, 6820, 6821, 6822, 6823, 6824, 6825, 6826, 6827, 6828, 6829, 6830, 6831, 6832, 6833, 6834, 6835, 6836, 6837, 6838, 6839, 6840, 6841, 6842, 6843, 6844, 6845, 6846, 6847, 6848, 6849,
    6850, 6851, 6852, 6853, 6854, 6855, 6856, 6857, 6858, 6859, 6860, 6861, 6862, 6863, 6864, 6865, 6866, 6867, 6868, 6869, 6870, 6871, 6872, 6873, 6874, 6875, 6876, 6877, 6878, 6879, 6880, 6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889, 6890, 6891, 6892, 6893, 6894, 6895, 6896, 6897, 6898, 6899,
    6900, 6901, 6902, 6903, 6904, 6905, 6906, 6907, 6908, 6909, 6910, 6911, 6912, 6913, 6914, 6915, 6916, 6917, 6918, 6919, 6920, 6921, 6922, 6923, 6924, 6925, 6926, 6927, 6928, 6929, 6930, 6931, 6932, 6933, 6934, 6935, 6936, 6937, 6938, 6939, 6940, 6941, 6942, 6943, 6944, 6945, 6946, 6947, 6948, 6949,
    6950, 6951, 6952, 6953, 6954, 6955, 6956, 6957, 6958, 6959, 6960, 6961, 6962, 6963, 6964, 6965, 6966, 6967, 6968, 6969, 6970, 6971, 6972, 6973, 6974, 6975, 6976, 6977, 6978, 6979, 6980, 6981, 6982, 6983, 6984, 6985, 6986, 6987, 6988, 6989, 6990, 6991, 6992, 6993, 6994, 6995, 6996, 6997, 6998, 6999,
    7000, 7001, 7002, 7003, 7004, 7005, 7006, 7007, 7008, 7009, 7010, 7011, 7012, 7013, 7014, 7015, 7016, 7017, 7018, 7019, 7020, 7021, 7022, 7023, 7024, 7025, 7026, 7027, 7028, 7029, 7030, 7031, 7032, 7033, 7034, 7035, 7036, 7037, 7038, 7039, 7040, 7041, 7042, 7043, 7044, 7045, 7046, 7047, 7048, 7049,
    7050, 7051, 7052, 7053, 7054, 7055, 7056, 7057, 7058, 7059, 7060, 7061, 7062, 7063, 7064, 7065, 7066, 7067, 7068, 7069, 7070, 7071, 7072, 7073, 7074, 7075, 7076, 7077, 7078, 7079, 7080, 7081, 7082, 7083, 7084, 7085, 7086, 7087, 7088, 7089, 7090, 7091, 7092, 7093, 7094, 7095, 7096, 7097, 7098, 7099,
    7100, 7101, 7102, 7103, 7104, 7105, 7106, 7107, 7108, 7109, 7110, 7111, 7112, 7113, 7114, 7115, 7116, 7117, 7118, 7119, 7120, 7121, 7122, 7123, 7124, 7125, 7126, 7127, 7128, 7129, 7130, 7131, 7132, 7133, 7134, 7135, 7136, 7137, 7138, 7139, 7140, 7141, 7142, 7143, 7144, 7145, 7146, 7147, 7148, 7149,
    7150, 7151, 7152, 7153, 7154, 7155, 7156, 7157, 7158, 7159, 7160, 7161, 7162, 7163, 7164, 7165, 7166, 7167, 7168, 7169, 7170, 7171, 7172, 7173, 7174, 7175, 7176, 7177, 7178, 7179, 7180, 7181, 7182, 7183, 7184, 7185, 7186, 7187, 7188, 7189, 7190, 7191, 7192, 7193, 7194, 7195, 7196, 7197, 7198, 7199,
    7200, 7201, 7202, 7203, 7204, 7205, 7206, 7207, 7208, 7209, 7210, 7211, 7212, 7213, 7214, 7215, 7216, 7217, 7218, 7219, 7220, 7221, 7222, 7223, 7224, 7225, 7226, 7227, 7228, 7229, 7230, 7231, 7232, 7233, 7234, 7235, 7236, 7237, 7238, 7239, 7240, 7241, 7242, 7243, 7244, 7245, 7246, 7247, 7248, 7249,
    7250, 7251, 7252, 7253, 7254, 7255, 7256, 7257, 7258, 7259, 7260, 7261, 7262, 7263, 7264, 7265, 7266, 7267, 7268, 7269, 7270, 7271, 7272, 7273, 7274, 7275, 7276, 7277, 7278, 7279, 7280, 7281, 7282, 7283, 7284, 7285, 7286, 7287, 7288, 7289, 7290, 7291, 7292, 7293, 7294, 7295, 7296, 7297, 7298, 7299,
    7300, 7301, 7302, 7303, 7304, 7305, 7306, 7307, 7308, 7309, 7310, 7311, 7312, 7313, 7314, 7315, 7316, 7317, 7318, 7319, 7320, 7321, 7322, 7323, 7324, 7325, 7326, 7327, 7328, 7329, 7330, 7331, 7332, 7333, 7334, 7335, 7336, 7337, 7338, 7339, 7340, 7341, 7342, 7343, 7344, 7345, 7346, 7347, 7348, 7349,
    7350, 7351, 7352, 7353, 7354, 7355, 7356, 7357, 7358, 7359, 7360, 7361, 7362, 7363, 7364, 7365, 7366, 7367, 7368, 7369, 7370, 7371, 7372, 7373, 7374, 7375, 7376, 7377, 7378, 7379, 7380, 7381, 7382, 7383, 7384, 7385, 7386, 7387, 7388, 7389, 7390, 7391, 7392, 7393, 7394, 7395, 7396, 7397, 7398, 7399,
    7400, 7401, 7402, 7403, 7404, 7405, 7406, 7407, 7408, 7409, 7410, 7411, 7412, 7413, 7414, 7415, 7416, 7417, 7418, 7419, 7420, 7421, 7422, 7423, 7424, 7425, 7426, 7427, 7428, 7429, 7430, 7431, 7432, 7433, 7434, 7435, 7436, 7437, 7438, 7439, 7440, 7441, 7442, 7443, 7444, 7445, 7446, 7447, 7448, 7449,
    7450, 7451, 7452, 7453, 7454, 7455, 7456, 7457, 7458, 7459, 7460, 7461, 7462, 7463, 7464, 7465, 7466, 7467, 7468, 7469, 7470, 7471, 7472, 7473, 7474, 7475, 7476, 7477, 7478, 7479, 7480, 7481, 7482, 7483, 7484, 7485, 7486, 7487, 7488, 7489, 7490, 7491, 7492, 7493, 7494, 7495, 7496, 7497, 7498, 7499,
    7500, 7501, 7502, 7503, 7504, 7505, 7506, 7507, 7508, 7509, 7510, 7511, 7512, 7513, 7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7522, 7523, 7524, 7525, 7526, 7527, 7528, 7529, 7530, 7531, 7532, 7533, 7534, 7535, 7536, 7537, 7538, 7539, 7540, 7541, 7542, 7543, 7544, 7545, 7546, 7547, 7548, 7549,
    7550, 7551, 7552, 7553, 7554, 7555, 7556, 7557, 7558, 7559, 7560, 7561, 7562, 7563, 7564, 7565, 7566, 7567, 7568, 7569, 7570, 7571, 7572, 7573, 7574, 7575, 7576, 7577, 7578, 7579, 7580, 7581, 7582, 7583, 7584, 7585, 7586, 7587, 7588, 7589, 7590, 7591, 7592, 7593, 7594, 7595, 7596, 7597, 7598, 7599,
    7600, 7601, 7602, 7603, 7604, 7605, 7606, 7607, 7608, 7609, 7610, 7611, 7612, 7613, 7614, 7615, 7616, 7617, 7618, 7619, 7620, 7621, 7622, 7623, 7624, 7625, 7626, 7627, 7628, 7629, 7630, 7631, 7632, 7633, 7634, 7635, 7636, 7637, 7638, 7639, 7640, 7641, 7642, 7643, 7644, 7645, 7646, 7647, 7648, 7649,
    7650, 7651, 7652, 7653, 7654, 7655, 7656, 7657, 7658, 7659, 7660, 7661, 7662, 7663, 7664, 7665, 7666, 7667, 7668, 7669, 7670, 7671, 7672, 7673, 7674, 7675, 7676, 7677, 7678, 7679, 7680, 7680, 7682, 7682, 7684, 7684, 7686, 7686, 7688, 7688, 7690, 7690, 7692, 7692, 7694, 7694, 7696, 7696, 7698, 7698,
    7700, 7700, 7702, 7702, 7704, 7704, 7706, 7706, 7708, 7708, 7710, 7710, 7712, 7712, 7714, 7714, 7716, 7716, 7718, 7718, 7720, 7720, 7722, 7722, 7724, 7724, 7726, 7726, 7728, 7728, 7730, 7730, 7732, 7732, 7734, 7734, 7736, 7736, 7738, 7738, 7740, 7740, 7742, 7742, 7744, 7744, 7746, 7746, 7748, 7748,
    7750, 7750, 7752, 7752, 7754, 7754, 7756, 7756, 7758, 7758, 7760, 7760, 7762, 7762, 7764, 7764, 7766, 7766, 7768, 7768, 7770, 7770, 7772, 7772, 7774, 7774, 7776, 7776, 7778, 7778, 7780, 7780, 7782, 7782, 7784, 7784, 7786, 7786, 7788, 7788, 7790, 7790, 7792, 7792, 7794, 7794, 7796, 7796, 7798, 7798,
    7800, 7800, 7802, 7802, 7804, 7804, 7806, 7806, 7808, 7808, 7810, 7810, 7812, 7812, 7814, 7814, 7816, 7816, 7818, 7818, 7820, 7820, 7822, 7822, 7824, 7824, 7826, 7826, 7828, 7828, 7830, 7831, 7832, 7833, 7834, 7835, 7836, 7837, 7838, 7839, 7840, 7840, 7842, 7842, 7844, 7844, 7846, 7846, 7848, 7848,
    7850, 7850, 7852, 7852, 7854, 7854, 7856, 7856, 7858, 7858, 7860, 7860, 7862, 7862, 7864, 7864, 7866, 7866, 7868, 7868, 7870, 7870, 7872, 7872, 7874, 7874, 7876, 7876, 7878, 7878, 7880, 7880, 7882, 7882, 7884, 7884, 7886, 7886, 7888, 7888, 7890, 7890, 7892, 7892, 7894, 7894, 7896, 7896, 7898, 7898,
    7900, 7900, 7902, 7902, 7904, 7904, 7906, 7906, 7908, 7908, 7910, 7910, 7912, 7912, 7914, 7914, 7916, 7916, 7918, 7918, 7920, 7920, 7922, 7922, 7924, 7924, 7926, 7926, 7928, 7928, 7930, 7931, 7932, 7933, 7934, 7935, 7944, 7945, 7946, 7947, 7948, 7949, 7950, 7951, 7944, 7945, 7946, 7947, 7948, 7949,
    7950, 7951, 7960, 7961, 7962, 7963, 7964, 7965, 7958, 7959, 7960, 7961, 7962, 7963, 7964, 7965, 7966, 7967, 7976, 7977, 7978, 7979, 7980, 7981, 7982, 7983, 7976, 7977, 7978, 7979, 7980, 7981, 7982, 7983, 7992, 7993, 7994, 7995, 7996, 7997, 7998, 7999, 7992, 7993, 7994, 7995, 7996, 7997, 7998, 7999,
    8008, 8009, 8010, 8011, 8012, 8013, 8006, 8007, 8008, 8009, 8010, 8011, 8012, 8013, 8014, 8015, 8016, 8025, 8018, 8027, 8020, 8029, 8022, 8031, 8024, 8025, 8026, 8027, 8028, 8029, 8030, 8031, 8040, 8041, 8042, 8043, 8044, 8045, 8046, 8047, 8040, 8041, 8042, 8043, 8044, 8045, 8046, 8047, 8122, 8123,
    8136, 8137, 8138, 8139, 8154, 8155, 8184, 8185, 8170, 8171, 8186, 8187, 8062, 8063, 8064, 8065, 8066, 8067, 8068, 8069, 8070, 8071, 8072, 8073, 8074, 8075, 8076, 8077, 8078, 8079, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098, 8099,
    8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 8109, 8110, 8111, 8120, 8121, 8114, 8115, 8116, 8117, 8118, 8119, 8120, 8121, 8122, 8123, 8124, 8125, 8126, 8127, 8128, 8129, 8130, 8131, 8132, 8133, 8134, 8135, 8136, 8137, 8138, 8139, 8140, 8141, 8142, 8143, 8152, 8153, 8146, 8147, 8148, 8149,
    8150, 8151, 8152, 8153, 8154, 8155, 8156, 8157, 8158, 8159, 8168, 8169, 8162, 8163, 8164, 8172, 8166, 8167, 8168, 8169, 8170, 8171, 8172, 8173, 8174, 8175, 8176, 8177, 8178, 8179, 8180, 8181, 8182, 8183, 8184, 8185, 8186, 8187, 8188, 8189, 8190, 8191, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199,
    8200, 8201, 8202, 8203, 8204, 8205, 8206, 8207, 8208, 8209, 8210, 8211, 8212, 8213, 8214, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8223, 8224, 8225, 8226, 8227, 8228, 8229, 8230, 8231, 8232, 8233, 8234, 8235, 8236, 8237, 8238, 8239, 8240, 8241, 8242, 8243, 8244, 8245, 8246, 8247, 8248, 8249,
    8250, 8251, 8252, 8253, 8254, 8255, 8256, 8257, 8258, 8259, 8260, 8261, 8262, 8263, 8264, 8265, 8266, 8267, 8268, 8269, 8270, 8271, 8272, 8273, 8274, 8275, 8276, 8277, 8278, 8279, 8280, 8281, 8282, 8283, 8284, 8285, 8286, 8287, 8288, 8289, 8290, 8291, 8292, 8293, 8294, 8295, 8296, 8297, 8298, 8299,
    8300, 8301, 8302, 8303, 8304, 8305, 8306, 8307, 8308, 8309, 8310, 8311, 8312, 8313, 8314, 8315, 8316, 8317, 8318, 8319, 8320, 8321, 8322, 8323, 8324, 8325, 8326, 8327, 8328, 8329, 8330, 8331, 8332, 8333, 8334, 8335, 8336, 8337, 8338, 8339, 8340, 8341, 8342, 8343, 8344, 8345, 8346, 8347, 8348, 8349,
    8350, 8351, 8352, 8353, 8354, 8355, 8356, 8357, 8358, 8359, 8360, 8361, 8362, 8363, 8364, 8365, 8366, 8367, 8368, 8369, 8370, 8371, 8372, 8373, 8374, 8375, 8376, 8377, 8378, 8379, 8380, 8381, 8382, 8383, 8384, 8385, 8386, 8387, 8388, 8389, 8390, 8391, 8392, 8393, 8394, 8395, 8396, 8397, 8398, 8399,
    8400, 8401, 8402, 8403, 8404, 8405, 8406, 8407, 8408, 8409, 8410, 8411, 8412, 8413, 8414, 8415, 8416, 8417, 8418, 8419, 8420, 8421, 8422, 8423, 8424, 8425, 8426, 8427, 8428, 8429, 8430, 8431, 8432, 8433, 8434, 8435, 8436, 8437, 8438, 8439, 8440, 8441, 8442, 8443, 8444, 8445, 8446, 8447, 8448, 8449,
    8450, 8451, 8452, 8453, 8454, 8455, 8456, 8457, 8458, 8459, 8460, 8461, 8462, 8463, 8464, 8465, 8466, 8467, 8468, 8469, 8470, 8471, 8472, 8473, 8474, 8475, 8476, 8477, 8478, 8479, 8480, 8481, 8482, 8483, 8484, 8485, 8486, 8487, 8488, 8489, 8490, 8491, 8492, 8493, 8494, 8495, 8496, 8497, 8498, 8499,
    8500, 8501, 8502, 8503, 8504, 8505, 8506, 8507, 8508, 8509, 8510, 8511, 8512, 8513, 8514, 8515, 8516, 8517, 8518, 8519, 8520, 8521, 8522, 8523, 8524, 8525, 8526, 8527, 8528, 8529, 8530, 8531, 8532, 8533, 8534, 8535, 8536, 8537, 8538, 8539, 8540, 8541, 8542, 8543, 8544, 8545, 8546, 8547, 8548, 8549,
    8550, 8551, 8552, 8553, 8554, 8555, 8556, 8557, 8558, 8559, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 8554, 8555, 8556, 8557, 8558, 8559, 8576, 8577, 8578, 8579, 8580, 8581, 8582, 8583, 8584, 8585, 8586, 8587, 8588, 8589, 8590, 8591, 8592, 8593, 8594, 8595, 8596, 8597, 8598, 8599,
    8600, 8601, 8602, 8603, 8604, 8605, 8606, 8607, 8608, 8609, 8610, 8611, 8612, 8613, 8614, 8615, 8616, 8617, 8618, 8619, 8620, 8621, 8622, 8623, 8624, 8625, 8626, 8627, 8628, 8629, 8630, 8631, 8632, 8633, 8634, 8635, 8636, 8637, 8638, 8639, 8640, 8641, 8642, 8643, 8644, 8645, 8646, 8647, 8648, 8649,
    8650, 8651, 8652, 8653, 8654, 8655, 8656, 8657, 8658, 8659, 8660, 8661, 8662, 8663, 8664, 8665, 8666, 8667, 8668, 8669, 8670, 8671, 8672, 8673, 8674, 8675, 8676, 8677, 8678, 8679, 8680, 8681, 8682, 8683, 8684, 8685, 8686, 8687, 8688, 8689, 8690, 8691, 8692, 8693, 8694, 8695, 8696, 8697, 8698, 8699,
    8700, 8701, 8702, 8703, 8704, 8705, 8706, 8707, 8708, 8709, 8710, 8711, 8712, 8713, 8714, 8715, 8716, 8717, 8718, 8719, 8720, 8721, 8722, 8723, 8724, 8725, 8726, 8727, 8728, 8729, 8730, 8731, 8732, 8733, 8734, 8735, 8736, 8737, 8738, 8739, 8740, 8741, 8742, 8743, 8744, 8745, 8746, 8747, 8748, 8749,
    8750, 8751, 8752, 8753, 8754, 8755, 8756, 8757, 8758, 8759, 8760, 8761, 8762, 8763, 8764, 8765, 8766, 8767, 8768, 8769, 8770, 8771, 8772, 8773, 8774, 8775, 8776, 8777, 8778, 8779, 8780, 8781, 8782, 8783, 8784, 8785, 8786, 8787, 8788, 8789, 8790, 8791, 8792, 8793, 8794, 8795, 8796, 8797, 8798, 8799,
    8800, 8801, 8802, 8803, 8804, 8805, 8806, 8807, 8808, 8809, 8810, 8811, 8812, 8813, 8814, 8815, 8816, 8817, 8818, 8819, 8820, 8821, 8822, 8823, 8824, 8825, 8826, 8827, 8828, 8829, 8830, 8831, 8832, 8833, 8834, 8835, 8836, 8837, 8838, 8839, 8840, 8841, 8842, 8843, 8844, 8845, 8846, 8847, 8848, 8849,
    8850, 8851, 8852, 8853, 8854, 8855, 8856, 8857, 8858, 8859, 8860, 8861, 8862, 8863, 8864, 8865, 8866, 8867, 8868, 8869, 8870, 8871, 8872, 8873, 8874, 8875, 8876, 8877, 8878, 8879, 8880, 8881, 8882, 8883, 8884, 8885, 8886, 8887, 8888, 8889, 8890, 8891, 8892, 8893, 8894, 8895, 8896, 8897, 8898, 8899,
    8900, 8901, 8902, 8903, 8904, 8905, 8906, 8907, 8908, 8909, 8910, 8911, 8912, 8913, 8914, 8915, 8916, 8917, 8918, 8919, 8920, 8921, 8922, 8923, 8924, 8925, 8926, 8927, 8928, 8929, 8930, 8931, 8932, 8933, 8934, 8935, 8936, 8937, 8938, 8939, 8940, 8941, 8942, 8943, 8944, 8945, 8946, 8947, 8948, 8949,
    8950, 8951, 8952, 8953, 8954, 8955, 8956, 8957, 8958, 8959, 8960, 8961, 8962, 8963, 8964, 8965, 8966, 8967, 8968, 8969, 8970, 8971, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999,
    9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 9009, 9010, 9011, 9012, 9013, 9014, 9015, 9016, 9017, 9018, 9019, 9020, 9021, 9022, 9023, 9024, 9025, 9026, 9027, 9028, 9029, 9030, 9031, 9032, 9033, 9034, 9035, 9036, 9037, 9038, 9039, 9040, 9041, 9042, 9043, 9044, 9045, 9046, 9047, 9048, 9049,
    9050, 9051, 9052, 9053, 9054, 9055, 9056, 9057, 9058, 9059, 9060, 9061, 9062, 9063, 9064, 9065, 9066, 9067, 9068, 9069, 9070, 9071, 9072, 9073, 9074, 9075, 9076, 9077, 9078, 9079, 9080, 9081, 9082, 9083, 9084, 9085, 9086, 9087, 9088, 9089, 9090, 9091, 9092, 9093, 9094, 9095, 9096, 9097, 9098, 9099,
    9100, 9101, 9102, 9103, 9104, 9105, 9106, 9107, 9108, 9109, 9110, 9111, 9112, 9113, 9114, 9115, 9116, 9117, 9118, 9119, 9120, 9121, 9122, 9123, 9124, 9125, 9126, 9127, 9128, 9129, 9130, 9131, 9132, 9133, 9134, 9135, 9136, 9137, 9138, 9139, 9140, 9141, 9142, 9143, 9144, 9145, 9146, 9147, 9148, 9149,
    9150, 9151, 9152, 9153, 9154, 9155, 9156, 9157, 9158, 9159, 9160, 9161, 9162, 9163, 9164, 9165, 9166, 9167, 9168, 9169, 9170, 9171, 9172, 9173, 9174, 9175, 9176, 9177, 9178, 9179, 9180, 9181, 9182, 9183, 9184, 9185, 9186, 9187, 9188, 9189, 9190, 9191, 9192, 9193, 9194, 9195, 9196, 9197, 9198, 9199,
    9200, 9201, 9202, 9203, 9204, 9205, 9206, 9207, 9208, 9209, 9210, 9211, 9212, 9213, 9214, 9215, 9216, 9217, 9218, 9219, 9220, 9221, 9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229, 9230, 9231, 9232, 9233, 9234, 9235, 9236, 9237, 9238, 9239, 9240, 9241, 9242, 9243, 9244, 9245, 9246, 9247, 9248, 9249,
    9250, 9251, 9252, 9253, 9254, 9255, 9256, 9257, 9258, 9259, 9260, 9261, 9262, 9263, 9264, 9265, 9266, 9267, 9268, 9269, 9270, 9271, 9272, 9273, 9274, 9275, 9276, 9277, 9278, 9279, 9280, 9281, 9282, 9283, 9284, 9285, 9286, 9287, 9288, 9289, 9290, 9291, 9292, 9293, 9294, 9295, 9296, 9297, 9298, 9299,
    9300, 9301, 9302, 9303, 9304, 9305, 9306, 9307, 9308, 9309, 9310, 9311, 9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9322, 9323, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 9332, 9333, 9334, 9335, 9336, 9337, 9338, 9339, 9340, 9341, 9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349,
    9350, 9351, 9352, 9353, 9354, 9355, 9356, 9357, 9358, 9359, 9360, 9361, 9362, 9363, 9364, 9365, 9366, 9367, 9368, 9369, 9370, 9371, 9372, 9373, 9374, 9375, 9376, 9377, 9378, 9379, 9380, 9381, 9382, 9383, 9384, 9385, 9386, 9387, 9388, 9389, 9390, 9391, 9392, 9393, 9394, 9395, 9396, 9397, 9398, 9399,
    9400, 9401, 9402, 9403, 9404, 9405, 9406, 9407, 9408, 9409, 9410, 9411, 9412, 9413, 9414, 9415, 9416, 9417, 9418, 9419, 9420, 9421, 9422, 9423, 9398, 9399, 9400, 9401, 9402, 9403, 9404, 9405, 9406, 9407, 9408, 9409, 9410, 9411, 9412, 9413, 9414, 9415, 9416, 9417, 9418, 9419, 9420, 9421, 9422, 9423
};

const Il2CppChar ToUpperDataHigh[] =
{
    65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324,
    65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336,
    65337, 65338, 65339, 65340, 65341, 65342, 65343, 65344, 65313, 65314, 65315, 65316,
    65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328,
    65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338, 65371, 65372,
    65373, 65374, 65375, 65376, 65377, 65378, 65379, 65380, 65381, 65382, 65383, 65384,
    65385, 65386, 65387, 65388, 65389, 65390, 65391, 65392, 65393, 65394, 65395, 65396,
    65397, 65398, 65399, 65400, 65401, 65402, 65403, 65404, 65405, 65406, 65407, 65408,
    65409, 65410, 65411, 65412, 65413, 65414, 65415, 65416, 65417, 65418, 65419, 65420,
    65421, 65422, 65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430, 65431, 65432,
    65433, 65434, 65435, 65436, 65437, 65438, 65439, 65440, 65441, 65442, 65443, 65444,
    65445, 65446, 65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454, 65455, 65456,
    65457, 65458, 65459, 65460, 65461, 65462, 65463, 65464, 65465, 65466, 65467, 65468,
    65469, 65470, 65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478, 65479, 65480,
    65481, 65482, 65483, 65484, 65485, 65486, 65487, 65488, 65489, 65490, 65491, 65492,
    65493, 65494, 65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502, 65503, 65504,
    65505, 65506, 65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516,
    65517, 65518, 65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528,
    65529, 65530, 65531, 65532, 65533, 65534, 65535
};


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\char-conversions.cpp---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-api.cpp---------------


#include "il2cpp-api.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-runtime-stats.h"

#include "gc/WriteBarrier.h"
#include "os/StackTrace.h"
#include "os/Image.h"
#include "vm/AndroidRuntime.h"
#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Image.h"
#include "vm/InternalCalls.h"
#include "vm/Liveness.h"
#include "vm/MemoryInformation.h"
#include "vm/Method.h"
#include "vm/Monitor.h"
#include "vm/Object.h"
#include "vm/Path.h"
#include "vm/PlatformInvoke.h"
#include "vm/Profiler.h"
#include "vm/Property.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/StackTrace.h"
#include "vm/String.h"
#include "vm/Thread.h"
#include "vm/Type.h"
#include "utils/Exception.h"
#include "utils/Logging.h"
#include "utils/Memory.h"
#include "utils/MemoryPool.h"
#include "utils/StringUtils.h"
#include "utils/Runtime.h"
#include "utils/Environment.h"
#include "vm-utils/Debugger.h"
#include "vm-utils/NativeSymbol.h"

#include "gc/GarbageCollector.h"
#include "gc/GCHandle.h"
#include "gc/WriteBarrierValidation.h"

#include <locale.h>
#include <fstream>
#include <string>

using namespace il2cpp::vm;
using il2cpp::utils::Memory;
using namespace il2cpp::gc;

#if IL2CPP_API_DYNAMIC_NO_DLSYM
#include <map>

struct SymbolCompare
{
    bool operator()(const char* lhs, const char* rhs) const
    {
        return strcmp(lhs, rhs) < 0;
    }
};

typedef std::map<const char*, void*, SymbolCompare> SymbolTable;
static SymbolTable s_SymbolTable;

static void RegisterAPIFunction(const char* name, void* symbol)
{
    s_SymbolTable.insert(std::make_pair(name, symbol));
}

void il2cpp_api_register_symbols(void)
{
    #define DO_API(r, n, p) RegisterAPIFunction(#n, (void*)n);
    #include "il2cpp-api-functions.h"
    #undef DO_API
}

void* il2cpp_api_lookup_symbol(const char* name)
{
    SymbolTable::iterator it = s_SymbolTable.find(name);
    if (it != s_SymbolTable.end())
    {
        return it->second;
    }
    return NULL;
}

#endif // IL2CPP_API_DYNAMIC_NO_DLSYM

int il2cpp_init(const char* domain_name)
{
    // Use environment's default locale
    setlocale(LC_ALL, "");

    return Runtime::Init(domain_name);
}

int il2cpp_init_utf16(const Il2CppChar* domain_name)
{
    return il2cpp_init(il2cpp::utils::StringUtils::Utf16ToUtf8(domain_name).c_str());
}

void il2cpp_shutdown()
{
    Runtime::Shutdown();
}

void il2cpp_set_config_dir(const char *config_path)
{
    il2cpp::vm::Runtime::SetConfigDir(config_path);
}

void il2cpp_set_data_dir(const char *data_path)
{
    il2cpp::utils::Runtime::SetDataDir(data_path);
}

void il2cpp_set_temp_dir(const char *temp_dir)
{
    il2cpp::vm::Path::SetTempPath(temp_dir);
}

void il2cpp_set_commandline_arguments(int argc, const char* const argv[], const char* basedir)
{
    il2cpp::utils::Environment::SetMainArgs(argv, argc);
}

void il2cpp_set_commandline_arguments_utf16(int argc, const Il2CppChar* const argv[], const char* basedir)
{
    il2cpp::utils::Environment::SetMainArgs(argv, argc);
}

void il2cpp_set_config_utf16(const Il2CppChar* executablePath)
{
    il2cpp::vm::Runtime::SetConfigUtf16(executablePath);
}

void il2cpp_set_config(const char* executablePath)
{
    il2cpp::vm::Runtime::SetConfig(executablePath);
}

void il2cpp_set_memory_callbacks(Il2CppMemoryCallbacks* callbacks)
{
    Memory::SetMemoryCallbacks(callbacks);
}

void il2cpp_memory_pool_set_region_size(size_t size)
{
    il2cpp::utils::MemoryPool::SetRegionSize(size);
}

size_t il2cpp_memory_pool_get_region_size()
{
    return il2cpp::utils::MemoryPool::GetRegionSize();
}

const Il2CppImage* il2cpp_get_corlib()
{
    return Image::GetCorlib();
}

void il2cpp_add_internal_call(const char* name, Il2CppMethodPointer method)
{
    return InternalCalls::Add(name, method);
}

Il2CppMethodPointer il2cpp_resolve_icall(const char* name)
{
    return InternalCalls::Resolve(name);
}

void* il2cpp_alloc(size_t size)
{
    return IL2CPP_MALLOC(size);
}

void il2cpp_free(void* ptr)
{
    IL2CPP_FREE(ptr);
}

// array

Il2CppClass *il2cpp_array_class_get(Il2CppClass *element_class, uint32_t rank)
{
    return Class::GetArrayClass(element_class, rank);
}

uint32_t il2cpp_array_length(Il2CppArray* array)
{
    return Array::GetLength(array);
}

uint32_t il2cpp_array_get_byte_length(Il2CppArray *array)
{
    return Array::GetByteLength(array);
}

Il2CppArray* il2cpp_array_new(Il2CppClass *elementTypeInfo, il2cpp_array_size_t length)
{
    return Array::New(elementTypeInfo, length);
}

Il2CppArray* il2cpp_array_new_specific(Il2CppClass *arrayTypeInfo, il2cpp_array_size_t length)
{
    return Array::NewSpecific(arrayTypeInfo, length);
}

Il2CppArray* il2cpp_array_new_full(Il2CppClass *array_class, il2cpp_array_size_t *lengths, il2cpp_array_size_t *lower_bounds)
{
    return Array::NewFull(array_class, lengths, lower_bounds);
}

Il2CppClass* il2cpp_bounded_array_class_get(Il2CppClass *element_class, uint32_t rank, bool bounded)
{
    return Class::GetBoundedArrayClass(element_class, rank, bounded);
}

int il2cpp_array_element_size(const Il2CppClass* klass)
{
    return Array::GetElementSize(klass);
}

// assembly
const Il2CppImage* il2cpp_assembly_get_image(const Il2CppAssembly *assembly)
{
    return Assembly::GetImage(assembly);
}

// class

const Il2CppType* il2cpp_class_enum_basetype(Il2CppClass *klass)
{
    return Class::GetEnumBaseType(klass);
}

Il2CppClass* il2cpp_class_from_system_type(Il2CppReflectionType *type)
{
    return Class::FromSystemType(type);
}

bool il2cpp_class_is_inited(const Il2CppClass *klass)
{
    return klass->initialized;
}

bool il2cpp_class_is_generic(const Il2CppClass *klass)
{
    return Class::IsGeneric(klass);
}

bool il2cpp_class_is_inflated(const Il2CppClass *klass)
{
    return Class::IsInflated(klass);
}

bool il2cpp_class_is_assignable_from(Il2CppClass *klass, Il2CppClass *oklass)
{
    return Class::IsAssignableFrom(klass, oklass);
}

bool il2cpp_class_is_subclass_of(Il2CppClass *klass, Il2CppClass *klassc, bool check_interfaces)
{
    return Class::IsSubclassOf(klass, klassc, check_interfaces);
}

bool il2cpp_class_has_parent(Il2CppClass *klass, Il2CppClass *klassc)
{
    return Class::HasParent(klass, klassc);
}

Il2CppClass* il2cpp_class_from_il2cpp_type(const Il2CppType* type)
{
    return Class::FromIl2CppType(type);
}

Il2CppClass* il2cpp_class_from_name(const Il2CppImage* image, const char* namespaze, const char *name)
{
    return Class::FromName(image, namespaze, name);
}

Il2CppClass* il2cpp_class_get_element_class(Il2CppClass *klass)
{
    return Class::GetElementClass(klass);
}

const EventInfo* il2cpp_class_get_events(Il2CppClass *klass, void* *iter)
{
    return Class::GetEvents(klass, iter);
}

FieldInfo* il2cpp_class_get_fields(Il2CppClass *klass, void* *iter)
{
    return Class::GetFields(klass, iter);
}

Il2CppClass* il2cpp_class_get_nested_types(Il2CppClass *klass, void* *iter)
{
    return Class::GetNestedTypes(klass, iter);
}

Il2CppClass* il2cpp_class_get_interfaces(Il2CppClass *klass, void* *iter)
{
    return Class::GetInterfaces(klass, iter);
}

const PropertyInfo* il2cpp_class_get_properties(Il2CppClass *klass, void* *iter)
{
    return Class::GetProperties(klass, iter);
}

const PropertyInfo* il2cpp_class_get_property_from_name(Il2CppClass *klass, const char *name)
{
    return Class::GetPropertyFromName(klass, name);
}

FieldInfo* il2cpp_class_get_field_from_name(Il2CppClass* klass, const char *name)
{
    return Class::GetFieldFromName(klass, name);
}

const MethodInfo* il2cpp_class_get_methods(Il2CppClass *klass, void* *iter)
{
    return Class::GetMethods(klass, iter);
}

const MethodInfo* il2cpp_class_get_method_from_name(Il2CppClass *klass, const char* name, int argsCount)
{
    return Class::GetMethodFromName(klass, name, argsCount);
}

const char* il2cpp_class_get_name(Il2CppClass *klass)
{
    return Class::GetName(klass);
}

const char* il2cpp_class_get_namespace(Il2CppClass *klass)
{
    return Class::GetNamespace(klass);
}

Il2CppClass* il2cpp_class_get_parent(Il2CppClass *klass)
{
    return Class::GetParent(klass);
}

Il2CppClass* il2cpp_class_get_declaring_type(Il2CppClass* klass)
{
    return Class::GetDeclaringType(klass);
}

int32_t il2cpp_class_instance_size(Il2CppClass *klass)
{
    return Class::GetInstanceSize(klass);
}

size_t il2cpp_class_num_fields(const Il2CppClass* klass)
{
    return Class::GetNumFields(klass);
}

bool il2cpp_class_is_valuetype(const Il2CppClass* klass)
{
    return Class::IsValuetype(klass);
}

bool il2cpp_class_is_blittable(const Il2CppClass* klass)
{
    return Class::IsBlittable(klass);
}

int32_t il2cpp_class_value_size(Il2CppClass *klass, uint32_t *align)
{
    return Class::GetValueSize(klass, align);
}

int il2cpp_class_get_flags(const Il2CppClass *klass)
{
    return Class::GetFlags(klass);
}

bool il2cpp_class_is_abstract(const Il2CppClass *klass)
{
    return Class::IsAbstract(klass);
}

bool il2cpp_class_is_interface(const Il2CppClass *klass)
{
    return Class::IsInterface(klass);
}

int il2cpp_class_array_element_size(const Il2CppClass *klass)
{
    return Class::GetArrayElementSize(klass);
}

Il2CppClass* il2cpp_class_from_type(const Il2CppType *type)
{
    return Class::FromIl2CppType(type);
}

const Il2CppType* il2cpp_class_get_type(Il2CppClass *klass)
{
    return Class::GetType(klass);
}

uint32_t il2cpp_class_get_type_token(Il2CppClass *klass)
{
    return klass->token;
}

bool il2cpp_class_has_attribute(Il2CppClass *klass, Il2CppClass *attr_class)
{
    return Class::HasAttribute(klass, attr_class);
}

bool il2cpp_class_has_references(Il2CppClass *klass)
{
    return Class::HasReferences(klass);
}

bool il2cpp_class_is_enum(const Il2CppClass *klass)
{
    return Class::IsEnum(klass);
}

const Il2CppImage* il2cpp_class_get_image(Il2CppClass* klass)
{
    return Class::GetImage(klass);
}

const char *il2cpp_class_get_assemblyname(const Il2CppClass *klass)
{
    return Class::GetAssemblyNameNoExtension(klass);
}

int il2cpp_class_get_rank(const Il2CppClass *klass)
{
    return klass->rank;
}

uint32_t il2cpp_class_get_data_size(const Il2CppClass *klass)
{
    return klass->static_fields_size;
}

void* il2cpp_class_get_static_field_data(const Il2CppClass *klass)
{
    return klass->static_fields;
}

// stats

extern Il2CppRuntimeStats il2cpp_runtime_stats;

bool il2cpp_stats_dump_to_file(const char *path)
{
    std::fstream fs;

    fs.open(path, std::fstream::out | std::fstream::trunc);

    fs << "New object count: " << il2cpp_stats_get_value(IL2CPP_STAT_NEW_OBJECT_COUNT) << "\n";
    fs << "Method count: " << il2cpp_stats_get_value(IL2CPP_STAT_METHOD_COUNT) << "\n";
    fs << "Class static data size: " << il2cpp_stats_get_value(IL2CPP_STAT_CLASS_STATIC_DATA_SIZE) << "\n";
    fs << "Inflated method count: " << il2cpp_stats_get_value(IL2CPP_STAT_INFLATED_METHOD_COUNT) << "\n";
    fs << "Inflated type count: " << il2cpp_stats_get_value(IL2CPP_STAT_INFLATED_TYPE_COUNT) << "\n";
    fs << "Initialized class count: " << il2cpp_stats_get_value(IL2CPP_STAT_INITIALIZED_CLASS_COUNT) << "\n";
    fs << "Generic instance count: " << il2cpp_stats_get_value(IL2CPP_STAT_GENERIC_INSTANCE_COUNT) << "\n";
    fs << "Generic class count: " << il2cpp_stats_get_value(IL2CPP_STAT_GENERIC_CLASS_COUNT) << "\n";

    fs.close();


    return true;
}

uint64_t il2cpp_stats_get_value(Il2CppStat stat)
{
    switch (stat)
    {
        case IL2CPP_STAT_NEW_OBJECT_COUNT:
            return il2cpp_runtime_stats.new_object_count;

        case IL2CPP_STAT_INITIALIZED_CLASS_COUNT:
            return il2cpp_runtime_stats.initialized_class_count;

        /*case IL2CPP_STAT_GENERIC_VTABLE_COUNT:
            return il2cpp_runtime_stats.generic_vtable_count;

        case IL2CPP_STAT_USED_CLASS_COUNT:
            return il2cpp_runtime_stats.used_class_count;*/

        case IL2CPP_STAT_METHOD_COUNT:
            return il2cpp_runtime_stats.method_count;

        /*case IL2CPP_STAT_CLASS_VTABLE_SIZE:
            return il2cpp_runtime_stats.class_vtable_size;*/

        case IL2CPP_STAT_CLASS_STATIC_DATA_SIZE:
            return il2cpp_runtime_stats.class_static_data_size;

        case IL2CPP_STAT_GENERIC_INSTANCE_COUNT:
            return il2cpp_runtime_stats.generic_instance_count;

        case IL2CPP_STAT_GENERIC_CLASS_COUNT:
            return il2cpp_runtime_stats.generic_class_count;

        case IL2CPP_STAT_INFLATED_METHOD_COUNT:
            return il2cpp_runtime_stats.inflated_method_count;

        case IL2CPP_STAT_INFLATED_TYPE_COUNT:
            return il2cpp_runtime_stats.inflated_type_count;

            /*case IL2CPP_STAT_DELEGATE_CREATIONS:
                return il2cpp_runtime_stats.delegate_creations;

            case IL2CPP_STAT_MINOR_GC_COUNT:
                return il2cpp_runtime_stats.minor_gc_count;

            case IL2CPP_STAT_MAJOR_GC_COUNT:
                return il2cpp_runtime_stats.major_gc_count;

            case IL2CPP_STAT_MINOR_GC_TIME_USECS:
                return il2cpp_runtime_stats.minor_gc_time_usecs;

            case IL2CPP_STAT_MAJOR_GC_TIME_USECS:
                return il2cpp_runtime_stats.major_gc_time_usecs;*/
    }

    return 0;
}

// domain
Il2CppDomain* il2cpp_domain_get()
{
    return Domain::GetCurrent();
}

const Il2CppAssembly* il2cpp_domain_assembly_open(Il2CppDomain *domain, const char *name)
{
    return Assembly::Load(name);
}

const Il2CppAssembly** il2cpp_domain_get_assemblies(const Il2CppDomain* domain, size_t* size)
{
    il2cpp::vm::AssemblyVector* assemblies = Assembly::GetAllAssemblies();
    *size = assemblies->size();
    return &(*assemblies)[0];
}

// exception

void il2cpp_raise_exception(Il2CppException* exc)
{
    Exception::Raise(exc);
}

Il2CppException* il2cpp_exception_from_name_msg(const Il2CppImage* image, const char *name_space, const char *name, const char *msg)
{
    return Exception::FromNameMsg(image, name_space, name, msg);
}

Il2CppException* il2cpp_get_exception_argument_null(const char *arg)
{
    return Exception::GetArgumentNullException(arg);
}

void il2cpp_format_exception(const Il2CppException* ex, char* message, int message_size)
{
    strncpy(message, il2cpp::utils::Exception::FormatException(ex).c_str(), message_size);
}

void il2cpp_format_stack_trace(const Il2CppException* ex, char* output, int output_size)
{
    strncpy(output, il2cpp::utils::Exception::FormatStackTrace(ex).c_str(), output_size);
}

void il2cpp_unhandled_exception(Il2CppException* exc)
{
    Runtime::UnhandledException(exc);
}

void il2cpp_native_stack_trace(const Il2CppException * ex, uintptr_t** addresses, int* numFrames, char** imageUUID, char** imageName)
{
#if IL2CPP_ENABLE_NATIVE_INSTRUCTION_POINTER_EMISSION
    if (ex == NULL || ex->native_trace_ips == NULL)
    {
        *numFrames = 0;
        *addresses = NULL;
        *imageUUID = NULL;
        *imageName = NULL;
        return;
    }

    *numFrames = il2cpp_array_length(ex->native_trace_ips);

    if (*numFrames <= 0)
    {
        *addresses = NULL;
        *imageUUID = NULL;
        *imageName = NULL;
    }
    else
    {
        *addresses = static_cast<uintptr_t*>(il2cpp_alloc((*numFrames) * sizeof(uintptr_t)));
        for (int i = 0; i < *numFrames; i++)
        {
            uintptr_t ptrAddr = il2cpp_array_get(ex->native_trace_ips, uintptr_t, i);
            (*addresses)[i] = ptrAddr;
        }

        *imageUUID = il2cpp::os::Image::GetImageUUID();
        *imageName = il2cpp::os::Image::GetImageName();
    }
#endif
}

// field

const char* il2cpp_field_get_name(FieldInfo *field)
{
    return Field::GetName(field);
}

int il2cpp_field_get_flags(FieldInfo *field)
{
    return Field::GetFlags(field);
}

const FieldInfo* il2cpp_field_get_from_reflection(const Il2CppReflectionField * field)
{
    return Reflection::GetField(field);
}

Il2CppClass* il2cpp_field_get_parent(FieldInfo *field)
{
    return Field::GetParent(field);
}

Il2CppReflectionField* il2cpp_field_get_object(FieldInfo *field, Il2CppClass *refclass)
{
    return Reflection::GetFieldObject(refclass, field);
}

size_t il2cpp_field_get_offset(FieldInfo *field)
{
    return Field::GetOffset(field);
}

const Il2CppType* il2cpp_field_get_type(FieldInfo *field)
{
    return Field::GetType(field);
}

void il2cpp_field_get_value(Il2CppObject *obj, FieldInfo *field, void *value)
{
    return Field::GetValue(obj, field, value);
}

Il2CppObject* il2cpp_field_get_value_object(FieldInfo *field, Il2CppObject *obj)
{
    return Field::GetValueObject(field, obj);
}

bool il2cpp_field_has_attribute(FieldInfo *field, Il2CppClass *attr_class)
{
    return Field::HasAttribute(field, attr_class);
}

void il2cpp_field_set_value(Il2CppObject *obj, FieldInfo *field, void *value)
{
    Field::SetValue(obj, field, value);
}

void il2cpp_field_set_value_object(Il2CppObject* objectInstance, FieldInfo* field, Il2CppObject* value)
{
    Field::SetInstanceFieldValueObject(objectInstance, field, value);
}

void il2cpp_field_static_get_value(FieldInfo *field, void *value)
{
    Field::StaticGetValue(field, value);
}

void il2cpp_field_static_set_value(FieldInfo *field, void *value)
{
    Field::StaticSetValue(field, value);
}

bool il2cpp_field_is_literal(FieldInfo *field)
{
    return (field->type->attrs & FIELD_ATTRIBUTE_LITERAL) != 0;
}

// gc
void il2cpp_gc_collect(int maxGenerations)
{
    GarbageCollector::Collect(maxGenerations);
}

int32_t il2cpp_gc_collect_a_little()
{
    return GarbageCollector::CollectALittle();
}

void il2cpp_gc_start_incremental_collection()
{
    GarbageCollector::StartIncrementalCollection();
}

void il2cpp_gc_enable()
{
    GarbageCollector::Enable();
}

void il2cpp_gc_disable()
{
    GarbageCollector::Disable();
}

bool il2cpp_gc_is_disabled()
{
    return GarbageCollector::IsDisabled();
}

void il2cpp_gc_set_mode(Il2CppGCMode mode)
{
    GarbageCollector::SetMode(mode);
}

bool il2cpp_gc_is_incremental()
{
    return GarbageCollector::IsIncremental();
}

int64_t il2cpp_gc_get_max_time_slice_ns()
{
    return GarbageCollector::GetMaxTimeSliceNs();
}

void il2cpp_gc_set_max_time_slice_ns(int64_t maxTimeSlice)
{
    GarbageCollector::SetMaxTimeSliceNs(maxTimeSlice);
}

int64_t il2cpp_gc_get_used_size()
{
    return GarbageCollector::GetUsedHeapSize();
}

int64_t il2cpp_gc_get_heap_size()
{
    return GarbageCollector::GetAllocatedHeapSize();
}

void il2cpp_gc_foreach_heap(void(*func)(void* data, void* context), void* userData)
{
    MemoryInformation::IterationContext ctx;
    ctx.callback = func;
    ctx.userData = userData;
    il2cpp::gc::GarbageCollector::ForEachHeapSection(&ctx, MemoryInformation::ReportGcHeapSection);
}

void il2cpp_stop_gc_world()
{
    il2cpp::gc::GarbageCollector::StopWorld();
}

void il2cpp_start_gc_world()
{
    il2cpp::gc::GarbageCollector::StartWorld();
}

void* il2cpp_gc_alloc_fixed(size_t size)
{
    return il2cpp::gc::GarbageCollector::AllocateFixed(size, NULL);
}

void il2cpp_gc_free_fixed(void* address)
{
    il2cpp::gc::GarbageCollector::FreeFixed(address);
}

// gchandle

Il2CppGCHandle il2cpp_gchandle_new(Il2CppObject *obj, bool pinned)
{
    return GCHandle::New(obj, pinned);
}

Il2CppGCHandle il2cpp_gchandle_new_weakref(Il2CppObject *obj, bool track_resurrection)
{
    // Note that the call to Get will assert if an error occurred.
    return GCHandle::NewWeakref(obj, track_resurrection).Get();
}

Il2CppObject* il2cpp_gchandle_get_target(Il2CppGCHandle gchandle)
{
    return GCHandle::GetTarget(gchandle);
}

void il2cpp_gchandle_foreach_get_target(void(*func)(void*, void*), void* userData)
{
    MemoryInformation::IterationContext ctx;
    ctx.callback = func;
    ctx.userData = userData;
    il2cpp::gc::GCHandle::WalkStrongGCHandleTargets(MemoryInformation::ReportGcHandleTarget, &ctx);
}

void il2cpp_gc_wbarrier_set_field(Il2CppObject *obj, void **targetAddress, void *object)
{
    il2cpp::gc::WriteBarrier::GenericStore(targetAddress, object);
}

bool il2cpp_gc_has_strict_wbarriers()
{
#if IL2CPP_ENABLE_STRICT_WRITE_BARRIERS
    return true;
#else
    return false;
#endif
}

void il2cpp_gc_set_external_allocation_tracker(void(*func)(void*, size_t, int))
{
#if IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION
    il2cpp::gc::WriteBarrierValidation::SetExternalAllocationTracker(func);
#endif
}

void il2cpp_gc_set_external_wbarrier_tracker(void(*func)(void**))
{
#if IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION
    il2cpp::gc::WriteBarrierValidation::SetExternalWriteBarrierTracker(func);
#endif
}

void il2cpp_gchandle_free(Il2CppGCHandle gchandle)
{
    GCHandle::Free(gchandle);
}

// vm runtime info
uint32_t il2cpp_object_header_size()
{
    return static_cast<uint32_t>(sizeof(Il2CppObject));
}

uint32_t il2cpp_array_object_header_size()
{
    return static_cast<uint32_t>(kIl2CppSizeOfArray);
}

uint32_t il2cpp_offset_of_array_length_in_array_object_header()
{
    return kIl2CppOffsetOfArrayLength;
}

uint32_t il2cpp_offset_of_array_bounds_in_array_object_header()
{
    return kIl2CppOffsetOfArrayBounds;
}

uint32_t il2cpp_allocation_granularity()
{
    return static_cast<uint32_t>(2 * sizeof(void*));
}

// liveness

void* il2cpp_unity_liveness_allocate_struct(Il2CppClass* filter, int max_object_count, il2cpp_register_object_callback callback, void* userdata, il2cpp_liveness_reallocate_callback reallocate)
{
    return Liveness::AllocateStruct(filter, max_object_count, callback, userdata, reallocate);
}

void il2cpp_unity_liveness_calculation_from_root(Il2CppObject* root, void* state)
{
    Liveness::FromRoot(root, state);
}

void il2cpp_unity_liveness_calculation_from_statics(void* state)
{
    Liveness::FromStatics(state);
}

void il2cpp_unity_liveness_finalize(void* state)
{
    Liveness::Finalize(state);
}

void il2cpp_unity_liveness_free_struct(void* state)
{
    Liveness::FreeStruct(state);
}

// method

const Il2CppType* il2cpp_method_get_return_type(const MethodInfo* method)
{
    return Method::GetReturnType(method);
}

const MethodInfo* il2cpp_method_get_from_reflection(const Il2CppReflectionMethod *method)
{
    return Reflection::GetMethod(method);
}

Il2CppReflectionMethod* il2cpp_method_get_object(const MethodInfo *method, Il2CppClass *refclass)
{
    return Reflection::GetMethodObject(method, refclass);
}

const char* il2cpp_method_get_name(const MethodInfo *method)
{
    return Method::GetName(method);
}

bool il2cpp_method_is_generic(const MethodInfo *method)
{
    return Method::IsGeneric(method);
}

bool il2cpp_method_is_inflated(const MethodInfo *method)
{
    return Method::IsInflated(method);
}

bool il2cpp_method_is_instance(const MethodInfo *method)
{
    return Method::IsInstance(method);
}

uint32_t il2cpp_method_get_param_count(const MethodInfo *method)
{
    return Method::GetParamCount(method);
}

const Il2CppType* il2cpp_method_get_param(const MethodInfo *method, uint32_t index)
{
    return Method::GetParam(method, index);
}

Il2CppClass* il2cpp_method_get_class(const MethodInfo *method)
{
    return Method::GetClass(method);
}

bool il2cpp_method_has_attribute(const MethodInfo *method, Il2CppClass *attr_class)
{
    return Method::HasAttribute(method, attr_class);
}

Il2CppClass* il2cpp_method_get_declaring_type(const MethodInfo* method)
{
    return Method::GetDeclaringType(method);
}

uint32_t il2cpp_method_get_flags(const MethodInfo *method, uint32_t *iflags)
{
    if (iflags != 0)
        *iflags = Method::GetImplementationFlags(method);

    return Method::GetFlags(method);
}

uint32_t il2cpp_method_get_token(const MethodInfo *method)
{
    return Method::GetToken(method);
}

const char *il2cpp_method_get_param_name(const MethodInfo *method, uint32_t index)
{
    return Method::GetParamName(method, index);
}

// profiler

#if IL2CPP_ENABLE_PROFILER

void il2cpp_profiler_install(Il2CppProfiler *prof, Il2CppProfileFunc shutdown_callback)
{
    Profiler::Install(prof, shutdown_callback);
}

void il2cpp_profiler_set_events(Il2CppProfileFlags events)
{
    Profiler::SetEvents(events);
}

void il2cpp_profiler_install_enter_leave(Il2CppProfileMethodFunc enter, Il2CppProfileMethodFunc fleave)
{
    Profiler::InstallEnterLeave(enter, fleave);
}

void il2cpp_profiler_install_allocation(Il2CppProfileAllocFunc callback)
{
    Profiler::InstallAllocation(callback);
}

void il2cpp_profiler_install_gc(Il2CppProfileGCFunc callback, Il2CppProfileGCResizeFunc heap_resize_callback)
{
    Profiler::InstallGC(callback, heap_resize_callback);
}

void il2cpp_profiler_install_fileio(Il2CppProfileFileIOFunc callback)
{
    Profiler::InstallFileIO(callback);
}

void il2cpp_profiler_install_thread(Il2CppProfileThreadFunc start, Il2CppProfileThreadFunc end)
{
    Profiler::InstallThread(start, end);
}

#endif

// property

const char* il2cpp_property_get_name(PropertyInfo *prop)
{
    return Property::GetName(prop);
}

const MethodInfo* il2cpp_property_get_get_method(PropertyInfo *prop)
{
    return Property::GetGetMethod(prop);
}

const MethodInfo* il2cpp_property_get_set_method(PropertyInfo *prop)
{
    return Property::GetSetMethod(prop);
}

Il2CppClass* il2cpp_property_get_parent(PropertyInfo *prop)
{
    return Property::GetParent(prop);
}

uint32_t il2cpp_property_get_flags(PropertyInfo *prop)
{
    return Property::GetFlags(prop);
}

// object

Il2CppClass* il2cpp_object_get_class(Il2CppObject* obj)
{
    return Object::GetClass(obj);
}

uint32_t il2cpp_object_get_size(Il2CppObject* obj)
{
    return Object::GetSize(obj);
}

const MethodInfo* il2cpp_object_get_virtual_method(Il2CppObject *obj, const MethodInfo *method)
{
    return Object::GetVirtualMethod(obj, method);
}

Il2CppObject* il2cpp_object_new(const Il2CppClass *klass)
{
    try
    {
        return Object::New(const_cast<Il2CppClass*>(klass));
    }
    catch (const Il2CppExceptionWrapper&)
    {
        // If a static constructor throws, that exception will occur here.
        // We don't want that to escape across the embedding API.
        return NULL;
    }
}

void* il2cpp_object_unbox(Il2CppObject* obj)
{
    return Object::Unbox(obj);
}

Il2CppObject* il2cpp_value_box(Il2CppClass *klass, void* data)
{
    return Object::Box(klass, data);
}

// monitor
void il2cpp_monitor_enter(Il2CppObject* obj)
{
    Monitor::Enter(obj);
}

bool il2cpp_monitor_try_enter(Il2CppObject* obj, uint32_t timeout)
{
    return Monitor::TryEnter(obj, timeout);
}

void il2cpp_monitor_exit(Il2CppObject* obj)
{
    Monitor::Exit(obj);
}

void il2cpp_monitor_pulse(Il2CppObject* obj)
{
    Monitor::Pulse(obj);
}

void il2cpp_monitor_pulse_all(Il2CppObject* obj)
{
    Monitor::PulseAll(obj);
}

void il2cpp_monitor_wait(Il2CppObject* obj)
{
    Monitor::Wait(obj);
}

bool il2cpp_monitor_try_wait(Il2CppObject* obj, uint32_t timeout)
{
    return Monitor::TryWait(obj, timeout);
}

// runtime

Il2CppObject* il2cpp_runtime_invoke_convert_args(const MethodInfo *method, void *obj, Il2CppObject **params, int paramCount, Il2CppException **exc)
{
    return Runtime::InvokeConvertArgs(method, obj, params, paramCount, exc);
}

Il2CppObject* il2cpp_runtime_invoke(const MethodInfo *method,
    void *obj, void **params, Il2CppException **exc)
{
    return Runtime::Invoke(method, obj, params, exc);
}

void il2cpp_runtime_class_init(Il2CppClass* klass)
{
    return Runtime::ClassInit(klass);
}

void il2cpp_runtime_object_init(Il2CppObject *obj)
{
    Runtime::ObjectInit(obj);
}

void il2cpp_runtime_object_init_exception(Il2CppObject *obj, Il2CppException **exc)
{
    Runtime::ObjectInitException(obj, exc);
}

void il2cpp_runtime_unhandled_exception_policy_set(Il2CppRuntimeUnhandledExceptionPolicy value)
{
    Runtime::SetUnhandledExceptionPolicy(value);
}

// string

int32_t il2cpp_string_length(Il2CppString* str)
{
    return il2cpp::utils::StringUtils::GetLength(str);
}

Il2CppChar* il2cpp_string_chars(Il2CppString* str)
{
    return il2cpp::utils::StringUtils::GetChars(str);
}

// Same as il2cpp_string_new_wrapper, because other normally takes a domain
Il2CppString* il2cpp_string_new(const char* str)
{
    return String::New(str);
}

Il2CppString* il2cpp_string_new_wrapper(const char* str)
{
    return String::NewWrapper(str);
}

Il2CppString* il2cpp_string_new_utf16(const Il2CppChar *text, int32_t len)
{
    return String::NewUtf16(text, len);
}

Il2CppString* il2cpp_string_new_len(const char* str, uint32_t length)
{
    return String::NewLen(str, length);
}

Il2CppString* il2cpp_string_intern(Il2CppString* str)
{
    return String::Intern(str);
}

Il2CppString* il2cpp_string_is_interned(Il2CppString* str)
{
    return String::IsInterned(str);
}

// thread

Il2CppThread *il2cpp_thread_current()
{
    return Thread::Current();
}

Il2CppThread *il2cpp_thread_attach(Il2CppDomain *domain)
{
    return Thread::Attach(domain);
}

void il2cpp_thread_detach(Il2CppThread *thread)
{
    Thread::Detach(thread);
}

bool il2cpp_is_vm_thread(Il2CppThread *thread)
{
    return Thread::IsVmThread(thread);
}

// stacktrace

void il2cpp_current_thread_walk_frame_stack(Il2CppFrameWalkFunc func, void* user_data)
{
    StackTrace::WalkFrameStack(func, user_data);
}

void il2cpp_thread_walk_frame_stack(Il2CppThread *thread, Il2CppFrameWalkFunc func, void *user_data)
{
    return StackTrace::WalkThreadFrameStack(thread, func, user_data);
}

bool il2cpp_current_thread_get_top_frame(Il2CppStackFrameInfo* frame)
{
    IL2CPP_ASSERT(frame);
    return StackTrace::GetTopStackFrame(*frame);
}

bool il2cpp_thread_get_top_frame(Il2CppThread* thread, Il2CppStackFrameInfo* frame)
{
    IL2CPP_ASSERT(frame);
    return StackTrace::GetThreadTopStackFrame(thread, *frame);
}

bool il2cpp_current_thread_get_frame_at(int32_t offset, Il2CppStackFrameInfo* frame)
{
    IL2CPP_ASSERT(frame);
    return StackTrace::GetStackFrameAt(offset, *frame);
}

bool il2cpp_thread_get_frame_at(Il2CppThread* thread, int32_t offset, Il2CppStackFrameInfo* frame)
{
    IL2CPP_ASSERT(frame);
    return StackTrace::GetThreadStackFrameAt(thread, offset, *frame);
}

int32_t il2cpp_current_thread_get_stack_depth()
{
    return static_cast<int32_t>(StackTrace::GetStackDepth());
}

int32_t il2cpp_thread_get_stack_depth(Il2CppThread *thread)
{
    return StackTrace::GetThreadStackDepth(thread);
}

void il2cpp_set_default_thread_affinity(int64_t affinity_mask)
{
    Thread::SetDefaultAffinityMask(affinity_mask);
}

void il2cpp_override_stack_backtrace(Il2CppBacktraceFunc stackBacktraceFunc)
{
    il2cpp::os::StackTrace::OverrideStackBacktrace(stackBacktraceFunc);
}

// type

Il2CppObject* il2cpp_type_get_object(const Il2CppType *type)
{
    return (Il2CppObject*)Reflection::GetTypeObject(type);
}

int il2cpp_type_get_type(const Il2CppType *type)
{
    return Type::GetType(type);
}

Il2CppClass* il2cpp_type_get_class_or_element_class(const Il2CppType *type)
{
    return Type::GetClassOrElementClass(type);
}

char* il2cpp_type_get_name(const Il2CppType *type)
{
    std::string name = Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_IL);
    char* buffer = static_cast<char*>(il2cpp_alloc(name.length() + 1));
    memcpy(buffer, name.c_str(), name.length() + 1);

    return buffer;
}

char* il2cpp_type_get_assembly_qualified_name(const Il2CppType * type)
{
    std::string name = Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);
    char* buffer = static_cast<char*>(il2cpp_alloc(name.length() + 1));
    memcpy(buffer, name.c_str(), name.length() + 1);

    return buffer;
}

char* il2cpp_type_get_reflection_name(const Il2CppType *type)
{
    std::string name = Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_REFLECTION_QUALIFIED);
    char* buffer = static_cast<char*>(il2cpp_alloc(name.length() + 1));
    memcpy(buffer, name.c_str(), name.length() + 1);

    return buffer;
}

bool il2cpp_type_is_byref(const Il2CppType *type)
{
    return type->byref;
}

uint32_t il2cpp_type_get_attrs(const Il2CppType *type)
{
    return type->attrs;
}

bool il2cpp_type_equals(const Il2CppType* type, const Il2CppType *otherType)
{
    return Type::IsEqualToType(type, otherType);
}

bool il2cpp_type_is_static(const Il2CppType *type)
{
    return (type->attrs & FIELD_ATTRIBUTE_STATIC) != 0;
}

bool il2cpp_type_is_pointer_type(const Il2CppType *type)
{
    return type->type == IL2CPP_TYPE_PTR;
}

// image

const Il2CppAssembly* il2cpp_image_get_assembly(const Il2CppImage *image)
{
    return Image::GetAssembly(image);
}

const char* il2cpp_image_get_name(const Il2CppImage *image)
{
    return Image::GetName(image);
}

const char* il2cpp_image_get_filename(const Il2CppImage *image)
{
    return Image::GetFileName(image);
}

const MethodInfo* il2cpp_image_get_entry_point(const Il2CppImage *image)
{
    return Image::GetEntryPoint(image);
}

size_t il2cpp_image_get_class_count(const Il2CppImage * image)
{
    return Image::GetNumTypes(image);
}

const Il2CppClass* il2cpp_image_get_class(const Il2CppImage * image, size_t index)
{
    return Image::GetType(image, static_cast<AssemblyTypeIndex>(index));
}

Il2CppManagedMemorySnapshot* il2cpp_capture_memory_snapshot()
{
    return MemoryInformation::CaptureManagedMemorySnapshot();
}

void il2cpp_free_captured_memory_snapshot(Il2CppManagedMemorySnapshot* snapshot)
{
    MemoryInformation::FreeCapturedManagedMemorySnapshot(snapshot);
}

void il2cpp_set_find_plugin_callback(Il2CppSetFindPlugInCallback method)
{
    il2cpp::vm::PlatformInvoke::SetFindPluginCallback(method);
}

// Logging

void il2cpp_register_log_callback(Il2CppLogCallback method)
{
    il2cpp::utils::Logging::SetLogCallback(method);
}

// Debugger
void il2cpp_debugger_set_agent_options(const char* options)
{
#if IL2CPP_MONO_DEBUGGER
    il2cpp::utils::Debugger::SetAgentOptions(options);
#endif
}

bool il2cpp_is_debugger_attached()
{
    return il2cpp::utils::Debugger::GetIsDebuggerAttached();
}

void il2cpp_register_debugger_agent_transport(Il2CppDebuggerTransport * debuggerTransport)
{
#if IL2CPP_MONO_DEBUGGER
    il2cpp::utils::Debugger::RegisterTransport(debuggerTransport);
#endif
}

void il2cpp_debug_foreach_method(void(*func)(const MethodInfo* method, Il2CppMethodDebugInfo* methodDebugInfo, void* userData), void* userData)
{
#if IL2CPP_ENABLE_NATIVE_STACKTRACES
    return il2cpp::utils::NativeSymbol::GetAllManagedMethodsWithDebugInfo(func, userData);
#endif
}

bool il2cpp_debug_get_method_info(const MethodInfo* method, Il2CppMethodDebugInfo* methodDebugInfo)
{
#if IL2CPP_ENABLE_NATIVE_STACKTRACES
    return il2cpp::utils::NativeSymbol::GetMethodDebugInfo(method, methodDebugInfo);
#else
    return false;
#endif
}

void il2cpp_unity_install_unitytls_interface(const void* unitytlsInterfaceStruct)
{
    il2cpp::vm::Runtime::SetUnityTlsInterface(unitytlsInterfaceStruct);
}

// Custom Attributes
Il2CppCustomAttrInfo* il2cpp_custom_attrs_from_class(Il2CppClass *klass)
{
    return (Il2CppCustomAttrInfo*)(MetadataCache::GetCustomAttributeTypeToken(klass->image, klass->token));
}

Il2CppCustomAttrInfo* il2cpp_custom_attrs_from_method(const MethodInfo * method)
{
    return (Il2CppCustomAttrInfo*)(MetadataCache::GetCustomAttributeTypeToken(method->klass->image, method->token));
}

Il2CppCustomAttrInfo* il2cpp_custom_attrs_from_field(const FieldInfo * field)
{
    return (Il2CppCustomAttrInfo*)(MetadataCache::GetCustomAttributeTypeToken(field->parent->image, field->token));
}

bool il2cpp_custom_attrs_has_attr(Il2CppCustomAttrInfo *ainfo, Il2CppClass *attr_klass)
{
    return Reflection::HasAttribute(reinterpret_cast<Il2CppMetadataCustomAttributeHandle>(ainfo), attr_klass);
}

Il2CppObject* il2cpp_custom_attrs_get_attr(Il2CppCustomAttrInfo *ainfo, Il2CppClass *attr_klass)
{
    return Reflection::GetCustomAttribute(reinterpret_cast<Il2CppMetadataCustomAttributeHandle>(ainfo), attr_klass);
}

Il2CppArray*  il2cpp_custom_attrs_construct(Il2CppCustomAttrInfo *ainfo)
{
    return Reflection::ConstructCustomAttributes(reinterpret_cast<Il2CppMetadataCustomAttributeHandle>(ainfo));
}

void il2cpp_custom_attrs_free(Il2CppCustomAttrInfo *ainfo)
{
    // nothing to free, we cache everything
}

void il2cpp_type_get_name_chunked(const Il2CppType * type, void(*chunkReportFunc)(void* data, void* userData), void* userData)
{
    Type::GetNameChunkedRecurse(type, IL2CPP_TYPE_NAME_FORMAT_IL, chunkReportFunc, userData);
}

void il2cpp_class_set_userdata(Il2CppClass* klass, void* userdata)
{
    klass->unity_user_data = userdata;
}

int il2cpp_class_get_userdata_offset()
{
    return offsetof(struct Il2CppClass, unity_user_data);
}

void il2cpp_class_for_each(void(*klassReportFunc)(Il2CppClass* klass, void* userData), void* userData)
{
    MemoryInformation::ReportIL2CppClasses(klassReportFunc, userData);
}

// Android
void il2cpp_unity_set_android_network_up_state_func(Il2CppAndroidUpStateFunc func)
{
    AndroidRuntime::SetNetworkUpStateFunc(func);
}


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-api.cpp---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-benchmark-support.cpp---------------


#if IL2CPP_GOOGLE_BENCHMARK

#include "il2cpp-config.h"
#include "utils/StringUtils.h"
#include <benchmark/benchmark.h>

void il2cpp_benchmark_initialize(int argc, const Il2CppChar* const* argv)
{
    std::vector<std::string> args(argc);
    for (int i = 0; i < argc; ++i)
        args[i] = il2cpp::utils::StringUtils::Utf16ToUtf8(argv[i], -1);

    std::vector<const char*> cargs(argc);
    for (int i = 0; i < argc; ++i)
        cargs[i] = args[i].c_str();

    benchmark::Initialize(&argc, const_cast<char**>(&cargs[0]));
}

void il2cpp_benchmark_initialize(int argc, const char* const* argv)
{
    benchmark::Initialize(&argc, const_cast<char**>(argv));
}

#endif


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-benchmark-support.cpp---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-mono-api.cpp---------------


// This file implements the Mono embedding API that the debugger code requires.
// It should not include any Mono headers.

#include "il2cpp-config.h"

#include "il2cpp-api.h"
#include "il2cpp-mono-api.h"

#include "il2cpp-class-internals.h"

#include "gc/GCHandle.h"
#include "gc/WriteBarrier.h"

#include "metadata/FieldLayout.h"
#include "metadata/GenericMetadata.h"

#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/GenericContainer.h"
#include "vm/Image.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Property.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Thread.h"
#include "vm/ThreadPoolMs.h"
#include "vm/Type.h"

#include "vm-utils/Debugger.h"

#include "utils/Il2CppHashMap.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"

#include <cstring>
#include <limits>

// These types must match the layout of types defined in Mono headers

struct Il2CppGPtrArray
{
    void** pdata;
    uint32_t len;
};

struct Il2CppGPtrArrayPriv
{
    void** pdata;
    uint32_t len;
    uint32_t size;
};

struct Il2CppMonoError
{
    unsigned short error_code;
    unsigned short flags;

    void *hidden_1[12];
};

struct Il2CppMonoMethodSignature
{
    Il2CppType *ret;
    uint16_t param_count;
    int16_t sentinalpos_unused;
    uint32_t generic_param_count        : 16;
    uint32_t call_convention_unused     : 6;
    uint32_t hasthis                    : 1;
    uint32_t explicit_this_unused       : 1;
    uint32_t pinvoke_unused             : 1;
    uint32_t is_inflated_unused         : 1;
    uint32_t has_type_parameters_unused : 1;
    Il2CppType* params[IL2CPP_ZERO_LEN_ARRAY];
};

struct Il2CppMonoMethodHeader
{
    const unsigned char* code_unused;
    uint32_t code_size;
    uint16_t max_stack_unused   : 15;
    uint32_t is_transient_unsued : 1;
    uint32_t num_clauses_unused : 15;
    uint32_t init_locals_unused : 1;
    uint16_t      num_locals;
    void* clauses_unused; // Actually a MonoExceptionClause in Mono,but we don't use it
    void* volatile_args_unused; // Actually MonoBitSet
    void* volatile_locals_unused;// Actually MonoBitSet
    Il2CppType* locals[IL2CPP_ZERO_LEN_ARRAY];
};

struct Il2CppMonoDebugCodeBlock
{
    int32_t parent;
    int32_t type;
    int32_t start_offset;
    int32_t end_offset;
};

struct Il2CppMonoDebugLocalVar
{
    char *name;
    int32_t index;
    Il2CppMonoDebugCodeBlock *block;
};

struct Il2CppMonoDebugLocalsInfo
{
    int32_t num_locals;
    Il2CppMonoDebugLocalVar *locals;
    int32_t num_blocks;
    Il2CppMonoDebugCodeBlock *code_blocks;
};

struct Il2CppMonoDebugLineNumberEntry
{
    uint32_t il_offset;
    uint32_t native_offset;
};

struct Il2CppMonoDebugVarInfo
{
    uint32_t index;
    uint32_t offset;
    uint32_t size;
    uint32_t begin_scope;
    uint32_t end_scope;
    Il2CppType *type;
};

struct Il2CppMonoDebugMethodJitInfo
{
    const uint8_t *code_start;
    uint32_t code_size;
    uint32_t prologue_end;
    uint32_t epilogue_begin;
    const uint8_t *wrapper_addr;
    uint32_t num_line_numbers;
    Il2CppMonoDebugLineNumberEntry *line_numbers;
    uint32_t has_var_info;
    uint32_t num_params;
    Il2CppMonoDebugVarInfo *this_var;
    Il2CppMonoDebugVarInfo *params;
    uint32_t num_locals;
    Il2CppMonoDebugVarInfo *locals;
    Il2CppMonoDebugVarInfo *gsharedvt_info_var;
    Il2CppMonoDebugVarInfo *gsharedvt_locals_var;
};

enum
{
    BFLAGS_IgnoreCase = 1,
    BFLAGS_DeclaredOnly = 2,
    BFLAGS_Instance = 4,
    BFLAGS_Static = 8,
    BFLAGS_Public = 0x10,
    BFLAGS_NonPublic = 0x20,
    BFLAGS_FlattenHierarchy = 0x40,
    BFLAGS_InvokeMethod = 0x100,
    BFLAGS_CreateInstance = 0x200,
    BFLAGS_GetField = 0x400,
    BFLAGS_SetField = 0x800,
    BFLAGS_GetProperty = 0x1000,
    BFLAGS_SetProperty = 0x2000,
    BFLAGS_ExactBinding = 0x10000,
    BFLAGS_SuppressChangeType = 0x20000,
    BFLAGS_OptionalParamBinding = 0x40000
};

struct Il2CppMonoTypeNameParse
{
    char *name_space_unused;
    char *name_unused;
    Il2CppAssemblyName assembly;
    void *il2cppTypeNameParseInfo; // really GList *modifiers, but IL2CPP re-uses this field
    void *type_arguments_unused;
    void *nested_unused;
};

struct Il2CppMonoJitExceptionInfo
{
    uint32_t  flags;
    int32_t   exvar_offset;
    void* try_start;
    void* try_end;
    void* handler_start;
    /*
     * For LLVM compiled code, this is the index of the il clause
     * associated with this handler.
     */
    int clause_index;
    uint32_t try_offset;
    uint32_t try_len;
    uint32_t handler_offset;
    uint32_t handler_len;
    union
    {
        MonoClass *catch_class;
        void* filter;
        void* handler_end;
    } data;
};

struct Il2CppMonoJitInfo
{
    /* NOTE: These first two elements (method and
       next_jit_code_hash) must be in the same order and at the
       same offset as in RuntimeMethod, because of the jit_code_hash
       internal hash table in MonoDomain. */
    union
    {
        MonoMethod *method;
        MonoImage *image;
        void* aot_info;
        void* tramp_info;
    } d;
    union
    {
        void *next_jit_code_hash;
        void *next_tombstone;
    } n;
    void*    code_start;
    uint32_t     unwind_info;
    int         code_size;
    uint32_t     num_clauses : 15;
    /* Whenever the code is domain neutral or 'shared' */
    int32_t    domain_neutral : 1;
    int32_t    has_generic_jit_info : 1;
    int32_t    has_try_block_holes : 1;
    int32_t    has_arch_eh_info : 1;
    int32_t    has_thunk_info : 1;
    int32_t    has_unwind_info : 1;
    int32_t    from_aot : 1;
    int32_t    from_llvm : 1;
    int32_t    dbg_attrs_inited : 1;
    int32_t    dbg_hidden : 1;
    /* Whenever this jit info was loaded in async context */
    int32_t    async : 1;
    int32_t    dbg_step_through : 1;
    int32_t    dbg_non_user_code : 1;
    /*
     * Whenever this jit info refers to a trampoline.
     * d.tramp_info contains additional data in this case.
     */
    int32_t    is_trampoline : 1;
    /* Whenever this jit info refers to an interpreter method */
    int32_t    is_interp : 1;

    /* FIXME: Embed this after the structure later*/
    void*    gc_info; /* Currently only used by SGen */

    Il2CppMonoJitExceptionInfo clauses[IL2CPP_ZERO_LEN_ARRAY];
    /* There is an optional MonoGenericJitInfo after the clauses */
    /* There is an optional MonoTryBlockHoleTableJitInfo after MonoGenericJitInfo clauses*/
    /* There is an optional MonoArchEHJitInfo after MonoTryBlockHoleTableJitInfo */
    /* There is an optional MonoThunkJitInfo after MonoArchEHJitInfo */
};

// End of mirrored types

static void initialize_il2cpp_mono_method_signature(Il2CppMonoMethodSignature* signature, MethodInfo* method)
{
    signature->hasthis = il2cpp::vm::Method::IsInstance(method);
    signature->ret = (Il2CppType*)il2cpp::vm::Method::GetReturnType(method);

    signature->generic_param_count = 0;

    if (method->is_generic)
    {
        signature->generic_param_count = il2cpp::vm::Method::GetGenericParamCount(method);
    }
    else if (method->is_inflated)
    {
        if (method->genericMethod->context.method_inst)
            signature->generic_param_count += method->genericMethod->context.method_inst->type_argc;

        if (method->genericMethod->context.class_inst)
            signature->generic_param_count += method->genericMethod->context.class_inst->type_argc;
    }
    signature->param_count = il2cpp::vm::Method::GetParamCount(method);
    for (int i = 0; i < signature->param_count; ++i)
        signature->params[i] = (Il2CppType*)il2cpp::vm::Method::GetParam(method, i);
}

// We need to allocate the Il2CppMonoMethodSignature struct with C-style allocators because it is
// a mirror of _MonoMethodSignature, which end in a zero-length array. So wrap it in this C++
// struct that we can insert into a hash map and get proper memory management.
struct Il2CppMonoMethodSignatureWrapper
{
    Il2CppMonoMethodSignatureWrapper(MethodInfo* method)
    {
        // We need the size of Il2CppMonoMethodSignature plus one pointer for each parameter of the method.
        size_t methodSignatureSize =  sizeof(Il2CppMonoMethodSignature) + (sizeof(Il2CppType*) * il2cpp::vm::Method::GetParamCount(method));
        signature = (Il2CppMonoMethodSignature*)IL2CPP_CALLOC(1, methodSignatureSize);

        initialize_il2cpp_mono_method_signature(signature, method);
    }

    ~Il2CppMonoMethodSignatureWrapper()
    {
        IL2CPP_FREE(signature);
    }

    Il2CppMonoMethodSignature* signature;
};

typedef Il2CppHashMap<MethodInfo*, Il2CppMonoMethodSignatureWrapper*, il2cpp::utils::PointerHash<MethodInfo> > MethodSignatureMap;
static MethodSignatureMap* method_signatures;

static void error_init(MonoError* error)
{
    if (error != NULL)
    {
        auto il2CppError = (Il2CppMonoError*)error;
        il2CppError->error_code = 0;
        il2CppError->flags = 0;
    }
}

uint32_t mono_image_get_entry_point(MonoImage *image)
{
    const MethodInfo* entryPoint = il2cpp::vm::Image::GetEntryPoint((Il2CppImage*)image);
    return entryPoint == NULL ? 0 : entryPoint->token;
}

const char* mono_image_get_filename(MonoImage *image)
{
    return il2cpp_image_get_filename((Il2CppImage *)image);
}

const char* mono_image_get_guid(MonoImage *image)
{
    return "00000000-0000-0000-0000-000000000000"; //IL2CPP doesn't have image GUIDs
}

int32_t mono_image_is_dynamic(MonoImage *image)
{
    return false;
}

MonoAssembly* mono_image_get_assembly(MonoImage *image)
{
    return (MonoAssembly*)il2cpp_image_get_assembly((Il2CppImage *)image);
}

const char* mono_image_get_name(MonoImage *image)
{
    return il2cpp_image_get_name((Il2CppImage *)image);
}

MonoDomain* mono_get_root_domain(void)
{
    return (MonoDomain*)il2cpp::vm::Domain::GetCurrent();
}

MonoDomain* mono_domain_get(void)
{
    return mono_get_root_domain();
}

int32_t mono_domain_set_fast(MonoDomain *domain, int32_t force)
{
    IL2CPP_ASSERT(domain == mono_get_root_domain());
    return true;
}

void mono_domain_foreach(MonoDomainFunc func, void* user_data)
{
    func((MonoDomain*)mono_get_root_domain(), user_data);
}

void mono_domain_lock(MonoDomain* domain)
{
}

void mono_domain_unlock(MonoDomain* domain)
{
}

const MonoAssembly* mono_domain_get_corlib(MonoDomain *domain)
{
    return (MonoAssembly*)il2cpp::vm::Image::GetAssembly((Il2CppImage*)il2cpp_defaults.corlib);
}

MonoAssembly* mono_domain_get_assemblies_iter(MonoAppDomain *domain, void** iter)
{
    if (!iter)
        return NULL;

    il2cpp::vm::AssemblyVector* assemblies = il2cpp::vm::Assembly::GetAllAssemblies();

    if (!*iter)
    {
        il2cpp::vm::AssemblyVector::iterator *pIter = new il2cpp::vm::AssemblyVector::iterator();
        *pIter = assemblies->begin();
        *iter = pIter;
        return (MonoAssembly*)**pIter;
    }

    il2cpp::vm::AssemblyVector::iterator *pIter = (il2cpp::vm::AssemblyVector::iterator*)*iter;
    (*pIter)++;
    if (*pIter != assemblies->end())
    {
        return (MonoAssembly*)(**pIter);
    }
    else
    {
        delete pIter;
        *iter = NULL;
    }

    return NULL;
}

MonoClass* mono_type_get_class(MonoType *type)
{
    return (MonoClass*)il2cpp::vm::Type::GetClass((Il2CppType*)type);
}

MonoGenericClass* m_type_get_generic_class(MonoType* type)
{
    return (MonoGenericClass*)((Il2CppType*)type)->data.generic_class;
}

int32_t mono_type_is_struct(MonoType *type)
{
    return il2cpp::vm::Type::IsStruct((Il2CppType*)type);
}

int32_t mono_type_is_reference(MonoType *type)
{
    return type && il2cpp::vm::Type::IsReference((Il2CppType*)type);
}

int32_t mono_type_generic_inst_is_valuetype(MonoType *monoType)
{
    static const int kBitIsValueType = 1;
    Il2CppType *type = (Il2CppType*)monoType;
    Il2CppMetadataTypeHandle handle = il2cpp::vm::MetadataCache::GetTypeHandleFromType(type->data.generic_class->type);
    return il2cpp::vm::MetadataCache::TypeIsValueType(handle);
}

char* mono_type_full_name(MonoType* type)
{
    std::string name = il2cpp::vm::Type::GetName((Il2CppType*)type, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
    return il2cpp::utils::StringUtils::StringDuplicate(name.c_str());
}

char* mono_type_get_name_full(MonoType* type, MonoTypeNameFormat format)
{
    std::string name = il2cpp::vm::Type::GetName((Il2CppType*)type, (Il2CppTypeNameFormat)format);
    return il2cpp::utils::StringUtils::StringDuplicate(name.c_str());
}

void mono_string_free(const char* str)
{
    il2cpp::utils::StringUtils::StringDelete(str);
}

MonoReflectionType* mono_type_get_object_checked(MonoDomain* domain, MonoType* type, MonoError* error)
{
    error_init(error);
    return (MonoReflectionType*)il2cpp::vm::Reflection::GetTypeObject((const Il2CppType*)type);
}

int mono_type_get_type(MonoType* type)
{
    return il2cpp_type_get_type((const Il2CppType*)type);
}

int32_t mono_type_is_byref(MonoType* type)
{
    return il2cpp_type_is_byref((const Il2CppType*)type);
}

uint32_t mono_type_get_attrs(MonoType* type)
{
    return il2cpp_type_get_attrs((const Il2CppType*)type);
}

MonoVTable* mono_class_vtable_checked(MonoDomain *domain, MonoClass *klass, MonoError* error)
{
    return (MonoVTable*)((Il2CppClass*)klass)->vtable;
}

int32_t mono_class_instance_size(MonoClass *klass)
{
    il2cpp::vm::Class::Init((Il2CppClass*)klass);
    return il2cpp_class_instance_size((Il2CppClass*)klass);
}

int32_t mono_class_value_size(MonoClass *klass, uint32_t *align)
{
    return il2cpp::vm::Class::GetValueSize((Il2CppClass*)klass, align);
}

int32_t mono_class_is_assignable_from_internal(MonoClass *klass, MonoClass *oklass)
{
    return il2cpp::vm::Class::IsAssignableFrom((Il2CppClass*)klass, (Il2CppClass*)oklass);
}

MonoClass* mono_class_from_mono_type_internal(MonoType *type)
{
    return (MonoClass*)il2cpp::vm::Class::FromIl2CppType((Il2CppType*)type);
}

uint32_t mono_class_get_flags(MonoClass * klass)
{
    return il2cpp_class_get_flags((Il2CppClass*)klass);
}

int mono_class_num_fields(MonoClass *klass)
{
    return (int)il2cpp::vm::Class::GetNumFields((Il2CppClass*)klass);
}

int mono_class_num_methods(MonoClass *klass)
{
    return (int)il2cpp::vm::Class::GetNumMethods((Il2CppClass*)klass);
}

int mono_class_num_properties(MonoClass *klass)
{
    return (int)il2cpp::vm::Class::GetNumProperties((Il2CppClass*)klass);
}

MonoClassField* mono_class_get_fields_internal(MonoClass* klass, void* *iter)
{
    return (MonoClassField*)il2cpp::vm::Class::GetFields((Il2CppClass*)klass, iter);
}

MonoMethod* mono_class_get_methods(MonoClass* klass, void* *iter)
{
    return (MonoMethod*)il2cpp::vm::Class::GetMethods((Il2CppClass*)klass, iter);
}

MonoProperty* mono_class_get_properties(MonoClass* klass, void* *iter)
{
    return (MonoProperty*)il2cpp::vm::Class::GetProperties((Il2CppClass*)klass, iter);
}

MonoClass* mono_class_get_nested_types(MonoClass *monoClass, void* *iter)
{
    Il2CppClass *klass = (Il2CppClass*)monoClass;
    if (klass->generic_class)
        return NULL;

    return (MonoClass*)il2cpp::vm::Class::GetNestedTypes(klass, iter);
}

void mono_class_setup_methods(MonoClass* klass)
{
    il2cpp::vm::Class::SetupMethods((Il2CppClass*)klass);
}

void mono_class_setup_vtable(MonoClass* klass)
{
    il2cpp::vm::Class::Init((Il2CppClass*)klass);
}

static int32_t method_nonpublic(MethodInfo* method, int32_t start_klass)
{
    switch (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK)
    {
        case METHOD_ATTRIBUTE_ASSEM:
            return (start_klass || il2cpp_defaults.generic_ilist_class);
        case METHOD_ATTRIBUTE_PRIVATE:
            return start_klass;
        case METHOD_ATTRIBUTE_PUBLIC:
            return false;
        default:
            return true;
    }
}

static Il2CppGPtrArray* il2cpp_g_ptr_array_new()
{
    Il2CppGPtrArrayPriv* array = (Il2CppGPtrArrayPriv*)IL2CPP_CALLOC(1, sizeof(Il2CppGPtrArrayPriv));

    array->pdata = NULL;
    array->len = 0;
    array->size = 0;

    return (Il2CppGPtrArray *)array;
}

static void il2cpp_g_ptr_array_grow(Il2CppGPtrArrayPriv* array, uint32_t length)
{
    uint32_t new_length = array->len + length;

    IL2CPP_ASSERT(array != NULL);

    if (new_length <= array->size)
        return;

    array->size = 1;

    while (array->size < new_length)
        array->size <<= 1;

    array->size = std::max(array->size, 16U);
    array->pdata = (void**)IL2CPP_REALLOC(array->pdata, array->size * sizeof(void*));
}

static void il2cpp_g_ptr_array_add(Il2CppGPtrArray* array, void* data)
{
    IL2CPP_ASSERT(array != NULL);
    il2cpp_g_ptr_array_grow((Il2CppGPtrArrayPriv *)array, 1);
    array->pdata[array->len++] = data;
}

GPtrArray* il2cpp_g_ptr_array_free(GPtrArray *_array, bool free_seg)
{
    Il2CppGPtrArray* array = (Il2CppGPtrArray*)_array;
    void *data = NULL;

    IL2CPP_ASSERT(array);

    if (free_seg)
    {
        IL2CPP_FREE(array->pdata);
    }
    else
    {
        data = array->pdata;
    }

    IL2CPP_FREE(array);

    return (GPtrArray*)data;
}

static int32_t il2cpp_g_ascii_strcasecmp(const char *s1, const char *s2)
{
    const char *sp1 = s1;
    const char *sp2 = s2;

    if (s1 == NULL)
        return 0;
    if (s2 == NULL)
        return 0;

    while (*sp1 != '\0')
    {
        char c1 = tolower(*sp1++);
        char c2 = tolower(*sp2++);

        if (c1 != c2)
            return c1 - c2;
    }

    return (*sp1) - (*sp2);
}

GPtrArray* mono_class_get_methods_by_name(MonoClass* il2cppMonoKlass, const char* name, uint32_t bflags, uint32_t ignore_case, int32_t allow_ctors, MonoError* error)
{
#if IL2CPP_MONO_DEBUGGER
    Il2CppGPtrArray *array;
    Il2CppClass *klass = (Il2CppClass*)il2cppMonoKlass;
    Il2CppClass *startklass;
    MethodInfo *method;
    void* iter;
    int match;
    int (*compare_func) (const char *s1, const char *s2) = NULL;

    array = il2cpp_g_ptr_array_new();
    startklass = klass;
    error_init(error);

    if (name != NULL)
        compare_func = (ignore_case) ? il2cpp_g_ascii_strcasecmp : strcmp;

handle_parent:
    mono_class_setup_methods((MonoClass*)klass);
    mono_class_setup_vtable((MonoClass*)klass);

    iter = NULL;
    while ((method = (MethodInfo*)mono_class_get_methods((MonoClass*)klass, &iter)))
    {
        match = 0;

        if (!allow_ctors && method->name[0] == '.' && (strcmp(method->name, ".ctor") == 0 || strcmp(method->name, ".cctor") == 0))
            continue;
        if ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
        {
            if (bflags & BFLAGS_Public)
                match++;
        }
        else if ((bflags & BFLAGS_NonPublic) && method_nonpublic(method, (klass == startklass)))
        {
            match++;
        }
        if (!match)
            continue;
        match = 0;
        if (method->flags & METHOD_ATTRIBUTE_STATIC)
        {
            if (bflags & BFLAGS_Static)
                if ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))
                    match++;
        }
        else
        {
            if (bflags & BFLAGS_Instance)
                match++;
        }

        if (!match)
            continue;

        if (name != NULL)
        {
            if (compare_func(name, method->name))
                continue;
        }

        match = 0;
        il2cpp_g_ptr_array_add(array, method);
    }

    if (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))
        goto handle_parent;

    return (GPtrArray*)array;
#else
    return NULL;
#endif
}

MonoMethod* mono_class_get_method_from_name_checked(MonoClass * klass, const char* name, int argsCount, int flags, MonoError* error)
{
    return (MonoMethod*)il2cpp_class_get_method_from_name((Il2CppClass*)klass, name, argsCount);
}

int32_t mono_class_is_abstract(MonoClass * klass)
{
    return il2cpp_class_is_abstract((Il2CppClass*)klass);
}

int32_t mono_class_field_is_special_static(MonoClassField* field)
{
    return il2cpp::vm::Field::IsNormalStatic((FieldInfo*)field) ? 0 : 1;
}

MonoGenericContext* mono_class_get_context(MonoClass* klass)
{
    return (MonoGenericContext*)&((Il2CppClass*)klass)->generic_class->context;
}

MonoMethod* mono_class_inflate_generic_method_full_checked(MonoMethod* method, MonoClass* klass_hint, MonoGenericContext* context, MonoError* error)
{
    error_init(error);
    return (MonoMethod*)il2cpp::metadata::GenericMetadata::Inflate((MethodInfo*)method, (Il2CppGenericContext*)context);
}

MonoMethod* mono_class_inflate_generic_method_checked(MonoMethod* method, MonoGenericContext* context, MonoError* error)
{
    error_init(error);
    return (MonoMethod*)il2cpp::metadata::GenericMetadata::Inflate((MethodInfo*)method, (Il2CppGenericContext*)context);
}

int32_t mono_class_is_nullable(MonoClass* klass)
{
    return il2cpp::vm::Class::IsNullable((Il2CppClass*)klass);
}

MonoGenericContainer* mono_class_get_generic_container(MonoClass* klass)
{
    return (MonoGenericContainer*)il2cpp::vm::Class::GetGenericContainer((Il2CppClass*)klass);
}

void mono_class_setup_interfaces(MonoClass* klass, MonoError* error)
{
    error_init(error);
    il2cpp::vm::Class::SetupInterfaces((Il2CppClass*)klass);
}

int32_t mono_class_is_valuetype(MonoClass* klass)
{
    return il2cpp_class_is_valuetype((Il2CppClass*)klass);
}

MonoClass* mono_class_from_generic_parameter_internal(MonoGenericParam* param)
{
    return (MonoClass*)il2cpp::vm::Class::FromGenericParameter((Il2CppMetadataGenericParameterHandle)param);
}

MonoGenericClass* mono_class_get_generic_class(MonoClass* monoClass)
{
    Il2CppClass *klass = (Il2CppClass*)monoClass;
    return (MonoGenericClass*)klass->generic_class;
}

MonoClass* mono_class_try_load_from_name(MonoImage* image, const char* namespaze, const char* name)
{
    return (MonoClass*)il2cpp_class_from_name((const Il2CppImage*)image, namespaze, name);
}

int32_t mono_class_is_gtd(MonoClass* klass)
{
    return il2cpp_class_is_generic((Il2CppClass*)klass);
}

int32_t mono_class_is_ginst(MonoClass* klass)
{
    return il2cpp_class_is_inflated((Il2CppClass*)klass);
}

const char* mono_class_get_namespace(MonoClass * klass)
{
    return il2cpp_class_get_namespace((Il2CppClass*)klass);
}

const char* mono_class_get_name(MonoClass * klass)
{
    return il2cpp_class_get_name((Il2CppClass*)klass);
}

MonoClass* mono_class_get_parent(MonoClass * klass)
{
    return (MonoClass*)il2cpp_class_get_parent((Il2CppClass*)klass);
}

MonoType* mono_class_get_type(MonoClass * klass)
{
    return (MonoType*)il2cpp_class_get_type((Il2CppClass*)klass);
}

uint32_t mono_class_get_type_token(MonoClass * klass)
{
    return il2cpp_class_get_type_token((Il2CppClass*)klass);
}

MonoType* mono_class_get_byref_type(MonoClass *klass)
{
    return (MonoType*)il2cpp::vm::Class::GetByrefType((Il2CppClass*)klass);
}

MonoImage* mono_class_get_image(MonoClass * klass)
{
    return (MonoImage*)il2cpp_class_get_image((Il2CppClass*)klass);
}

MonoClass* mono_class_get_interfaces(MonoClass * klass, void* *iter)
{
    return (MonoClass*)il2cpp_class_get_interfaces((Il2CppClass*)klass, iter);
}

int32_t mono_class_is_interface(MonoClass * klass)
{
    return il2cpp_class_is_interface((Il2CppClass*)klass);
}

int mono_class_get_rank(MonoClass * klass)
{
    return il2cpp_class_get_rank((Il2CppClass*)klass);
}

MonoClass* mono_class_get_element_class(MonoClass * klass)
{
    return (MonoClass*)il2cpp_class_get_element_class((Il2CppClass*)klass);
}

int32_t mono_class_is_enum(MonoClass * klass)
{
    return il2cpp_class_is_enum((Il2CppClass*)klass);
}

MonoMethodSignature* mono_method_signature_internal(MonoMethod *m)
{
    MethodInfo* method = (MethodInfo*)m;

    if (method_signatures == NULL)
        method_signatures = new MethodSignatureMap();

    auto entry = method_signatures->find(method);
    if (entry != method_signatures->end())
        return (MonoMethodSignature*)entry->second->signature;

    Il2CppMonoMethodSignatureWrapper* wrapper = new Il2CppMonoMethodSignatureWrapper(method);
    method_signatures->add(method, wrapper);

    return (MonoMethodSignature*)wrapper->signature;
}

void mono_free_method_signatures()
{
    delete method_signatures;
    method_signatures = NULL;
}

MonoDebugLocalsInfo* mono_debug_lookup_locals(MonoMethod *method)
{
#if IL2CPP_MONO_DEBUGGER
    uint32_t executionContextInfoCount;
    const Il2CppMethodExecutionContextInfo * executionContextInfo;
    const Il2CppMethodHeaderInfo *headerInfo;
    const Il2CppMethodScope *scopes;
    il2cpp::utils::Debugger::GetMethodExecutionContextInfo((const MethodInfo*)method, &executionContextInfoCount, &executionContextInfo, &headerInfo, &scopes);

    Il2CppMonoDebugLocalsInfo* locals = (Il2CppMonoDebugLocalsInfo*)IL2CPP_CALLOC(1, sizeof(Il2CppMonoDebugLocalsInfo));
    locals->num_locals = executionContextInfoCount;

    locals->locals = (Il2CppMonoDebugLocalVar*)IL2CPP_CALLOC(executionContextInfoCount, sizeof(Il2CppMonoDebugLocalVar));
    for (int i = 0; i < locals->num_locals; ++i)
    {
        locals->locals[i].name = (char*)il2cpp::utils::Debugger::GetLocalName((const MethodInfo*)method, executionContextInfo[i].nameIndex);
        locals->locals[i].index = i;

        /* hack we should point to blocks allocated below? */
        locals->locals[i].block = (Il2CppMonoDebugCodeBlock*)IL2CPP_CALLOC(1, sizeof(Il2CppMonoDebugCodeBlock));
        const Il2CppMethodScope* scope = il2cpp::utils::Debugger::GetLocalScope((const MethodInfo*)method, executionContextInfo[i].scopeIndex);
        locals->locals[i].block->start_offset = scope->startOffset;
        locals->locals[i].block->end_offset = scope->endOffset;
    }

    locals->num_blocks = headerInfo->numScopes;
    locals->code_blocks = (Il2CppMonoDebugCodeBlock*)IL2CPP_CALLOC(headerInfo->numScopes, sizeof(Il2CppMonoDebugCodeBlock));

    for (int i = 0; i < headerInfo->numScopes; ++i)
    {
        locals->code_blocks[i].start_offset = scopes[i].startOffset;
        locals->code_blocks[i].end_offset = scopes[i].endOffset;
    }

    return (MonoDebugLocalsInfo*)locals;
#else
    return NULL;
#endif
}

void mono_debug_free_locals(MonoDebugLocalsInfo *info)
{
#if IL2CPP_MONO_DEBUGGER
    Il2CppMonoDebugLocalsInfo* locals = (Il2CppMonoDebugLocalsInfo*)info;
    for (int i = 0; i < locals->num_locals; ++i)
    {
        IL2CPP_FREE(locals->locals[i].block);
    }
    IL2CPP_FREE(locals->locals);
    IL2CPP_FREE(locals->code_blocks);
    IL2CPP_FREE(locals);
#endif
}

MonoDebugMethodJitInfo* mono_debug_find_method(MonoMethod *method, MonoDomain *domain)
{
#if IL2CPP_MONO_DEBUGGER
    Il2CppMonoDebugMethodJitInfo* jit = (Il2CppMonoDebugMethodJitInfo*)IL2CPP_CALLOC(1, sizeof(Il2CppMonoDebugMethodJitInfo));
    Il2CppMonoDebugLocalsInfo* locals_info = (Il2CppMonoDebugLocalsInfo*)mono_debug_lookup_locals(method);
    jit->num_locals = locals_info->num_locals;

    Il2CppMonoMethodSignature* sig = (Il2CppMonoMethodSignature*)mono_method_signature_internal(method);
    jit->num_params = sig->param_count;

    return (MonoDebugMethodJitInfo*)jit;
#else
    return NULL;
#endif
}

void mono_method_get_param_names(MonoMethod *m, const char **names)
{
    MethodInfo* method = (MethodInfo*)m;
    uint32_t numberOfParameters = il2cpp::vm::Method::GetParamCount(method);
    for (uint32_t i = 0; i < numberOfParameters; ++i)
        names[i] = il2cpp::vm::Method::GetParamName(method, i);
}

MonoGenericContext* mono_method_get_context(MonoMethod* monoMethod)
{
    MethodInfo* method = (MethodInfo*)monoMethod;

    if (!method->is_inflated || method->is_generic)
        return NULL;

    return (MonoGenericContext*)&((MethodInfo*)method)->genericMethod->context;
}

MonoMethodHeader* mono_method_get_header_checked(MonoMethod *method, MonoError *error)
{
#if IL2CPP_MONO_DEBUGGER
    if (error)
        error_init(error);

    uint32_t executionContextInfoCount;
    const Il2CppMethodExecutionContextInfo *executionContextInfo;
    const Il2CppMethodHeaderInfo *headerInfo;
    const Il2CppMethodScope *scopes;
    MonoGenericContext* context = mono_method_get_context(method);

    il2cpp::utils::Debugger::GetMethodExecutionContextInfo((const MethodInfo*)method, &executionContextInfoCount, &executionContextInfo, &headerInfo, &scopes);

    Il2CppMonoMethodHeader* header = (Il2CppMonoMethodHeader*)IL2CPP_CALLOC(1, sizeof(Il2CppMonoMethodHeader) + (executionContextInfoCount * sizeof(Il2CppType*)));
    header->code_size = headerInfo->code_size;
    header->num_locals = executionContextInfoCount;
    for (uint32_t i = 0; i < executionContextInfoCount; i++)
        header->locals[i] = (Il2CppType*)il2cpp::metadata::GenericMetadata::InflateIfNeeded(il2cpp::vm::MetadataCache::GetIl2CppTypeFromIndex(NULL, executionContextInfo[i].typeIndex), (const Il2CppGenericContext *)context, true);

    return (MonoMethodHeader*)header;
#else
    return NULL;
#endif
}

void mono_metadata_free_mh(MonoMethodHeader *mh)
{
    IL2CPP_FREE(mh);
}

char* mono_method_full_name(MonoMethod* method, int32_t signature)
{
    return il2cpp::utils::StringUtils::StringDuplicate(((MethodInfo*)method)->name);
}

MonoGenericContainer* mono_method_get_generic_container(MonoMethod* monoMethod)
{
    MethodInfo * method = (MethodInfo*)monoMethod;

    if (method->is_inflated || !method->is_generic)
        return NULL;

    return (MonoGenericContainer*)method->genericContainerHandle;
}

void* mono_method_get_wrapper_data(MonoMethod* method, uint32_t id)
{
    IL2CPP_ASSERT(0 && "This method is not supported");
    return 0;
}

MonoMethod* mono_method_get_declaring_generic_method(MonoMethod* method)
{
    IL2CPP_ASSERT(0 && "This method is not supported");
    return NULL;
}

const char* mono_method_get_name(MonoMethod *method)
{
    return il2cpp::vm::Method::GetName((const MethodInfo*)method);
}

MonoClass* mono_method_get_class(MonoMethod *method)
{
    return (MonoClass*)il2cpp::vm::Method::GetClass((const MethodInfo*)method);
}

uint32_t mono_method_get_flags(MonoMethod *method, uint32_t *iflags)
{
    if (iflags != 0)
        *iflags = il2cpp::vm::Method::GetImplementationFlags((const MethodInfo*)method);

    return il2cpp::vm::Method::GetFlags((const MethodInfo*)method);
}

uint32_t mono_method_get_token(MonoMethod *method)
{
    return il2cpp::vm::Method::GetToken((const MethodInfo*)method);
}

bool mono_method_is_generic(MonoMethod *method)
{
    return il2cpp::vm::Method::IsGeneric((const MethodInfo*)method);
}

bool mono_method_is_inflated(MonoMethod *method)
{
    return il2cpp::vm::Method::IsInflated((const MethodInfo*)method);
}

int32_t mono_array_element_size(MonoClass *monoClass)
{
    Il2CppClass *klass = (Il2CppClass*)monoClass;
    return klass->element_size;
}

char* mono_array_addr_with_size(MonoArray *array, int size, uintptr_t idx)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

uintptr_t mono_array_length(MonoArray *array)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

const char* mono_field_get_name(MonoClassField *field)
{
    return il2cpp::vm::Field::GetName((FieldInfo*)field);
}

void mono_field_set_value(MonoObject *obj, MonoClassField *field, void *value)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

void mono_field_static_set_value_internal(MonoVTable *vt, MonoClassField *field, void *value)
{
    il2cpp::vm::Field::StaticSetValue((FieldInfo*)field, value);
}

MonoObject* mono_field_get_value_object_checked(MonoDomain* domain, MonoClassField* field, MonoObject* obj, MonoError* error)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

MonoClass* mono_field_get_parent(MonoClassField *field)
{
    return (MonoClass*)il2cpp::vm::Field::GetParent((FieldInfo*)field);
}

uint32_t mono_field_get_offset(MonoClassField *field)
{
    return (uint32_t)il2cpp::vm::Field::GetOffset((FieldInfo*)field);
}

MonoType* mono_field_get_type(MonoClassField *field)
{
    return (MonoType*)il2cpp::vm::Field::GetType((FieldInfo*)field);
}

uint16_t* mono_string_chars(MonoString *monoStr)
{
    Il2CppString *str = (Il2CppString*)monoStr;
    return (uint16_t*)str->chars;
}

int mono_string_length(MonoString *monoStr)
{
    Il2CppString *str = (Il2CppString*)monoStr;
    return str->length;
}

MonoString* mono_string_new(MonoDomain *domain, const char *text)
{
    return (MonoString*)il2cpp::vm::String::New(text);
}

MonoString* mono_string_new_checked(MonoDomain *domain, const char *text, MonoError *merror)
{
    error_init(merror);
    return mono_string_new(domain, text);
}

char* mono_string_to_utf8_checked_internal(MonoString *string_obj, MonoError *error)
{
    error_init(error);
    Il2CppString *str = (Il2CppString*)string_obj;
    std::string s = il2cpp::utils::StringUtils::Utf16ToUtf8(str->chars, str->length);
    return il2cpp::utils::StringUtils::StringDuplicate(s.c_str());
}

int mono_object_hash_internal(MonoObject* obj)
{
    return (int)((intptr_t)obj >> 3);
}

void* mono_object_unbox_internal(MonoObject *monoObj)
{
    Il2CppObject *obj = (Il2CppObject*)monoObj;
    return il2cpp::vm::Object::Unbox(obj);
}

MonoMethod* mono_object_get_virtual_method_internal(MonoObject *obj, MonoMethod *method)
{
    return (MonoMethod*)il2cpp::vm::Object::GetVirtualMethod((Il2CppObject*)obj, (const MethodInfo*)method);
}

MonoObject* mono_object_new_checked(MonoDomain* domain, MonoClass* klass, MonoError* error)
{
    error_init(error);
    return (MonoObject*)il2cpp::vm::Object::New((Il2CppClass*)klass);
}

MonoType* mono_object_get_type(MonoObject* object)
{
    return (MonoType*)&(((Il2CppObject*)object)->klass->byval_arg);
}

MonoMethod* mono_get_method_checked(MonoImage* image, uint32_t token, MonoClass* klass, MonoGenericContext* context, MonoError* error)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

void* mono_gchandle_new_weakref_internal(MonoObject *obj, int32_t track_resurrection)
{
    auto weakRef = il2cpp::gc::GCHandle::NewWeakref((Il2CppObject*)obj, track_resurrection == 0 ? false : true);
    il2cpp::vm::Exception::RaiseIfError(weakRef.GetError());
    return (void*)weakRef.Get();
}

MonoObject* mono_gchandle_get_target_internal(void* gchandle)
{
    return (MonoObject*)il2cpp::gc::GCHandle::GetTarget((Il2CppGCHandle)gchandle);
}

void mono_gchandle_free_internal(void* gchandle)
{
    il2cpp::gc::GCHandle::Free((Il2CppGCHandle)gchandle);
}

MonoThread* mono_thread_current()
{
    return (MonoThread*)il2cpp::vm::Thread::Current();
}

MonoThread* mono_thread_get_main()
{
    return (MonoThread*)il2cpp::vm::Thread::Main();
}

MonoThread* mono_thread_attach(MonoDomain* domain)
{
    return (MonoThread*)il2cpp::vm::Thread::Attach((Il2CppDomain*)domain);
}

void mono_thread_detach(MonoThread* thread)
{
    il2cpp::vm::Thread::Detach((Il2CppThread*)thread);
}

MonoInternalThread* mono_thread_internal_current()
{
    Il2CppThread* currentThread = (Il2CppThread*)mono_thread_current();
    if (currentThread == NULL)
        return NULL;
    return (MonoInternalThread*)currentThread->internal_thread;
}

int32_t mono_thread_internal_is_current(MonoInternalThread* thread)
{
    MonoInternalThread* currentThread = mono_thread_internal_current();
    if (currentThread == NULL)
        return false;
    return currentThread == thread;
}

int32_t mono_thread_internal_abort(MonoInternalThread* thread, int32_t appdomain_unload)
{
    return il2cpp::vm::Thread::RequestAbort((Il2CppInternalThread*)thread);
}

void mono_thread_internal_reset_abort(MonoInternalThread* thread)
{
    il2cpp::vm::Thread::ResetAbort((Il2CppInternalThread*)thread);
}

char* mono_thread_get_name_utf8(MonoThread* this_obj)
{
    std::string name = il2cpp::vm::Thread::GetName(((Il2CppThread*)this_obj)->GetInternalThread());
    if (name.empty())
        return NULL;

    return il2cpp::utils::StringUtils::StringDuplicate(name.c_str());
}

void mono_thread_set_name_internal(MonoInternalThread* this_obj, MonoString* name, int32_t permanent, int32_t reset, MonoError* error)
{
    il2cpp::vm::Thread::SetName((Il2CppInternalThread*)this_obj, (Il2CppString*)name);
    error_init(error);
}

#if IL2CPP_COMPILER_MSVC
void mono_thread_set_name(MonoInternalThread* this_obj, const char* name8, size_t name8_length, const uint16_t* name16, int32_t flags, MonoError *error)
#else
void mono_thread_set_name(MonoInternalThread* this_obj, const char* name8, size_t name8_length, const uint16_t* name16, MonoSetThreadNameFlags flags, MonoError *error)
#endif
{
    il2cpp::vm::Thread::SetName((Il2CppInternalThread*)this_obj, il2cpp::vm::String::New(name8));
    error_init(error);
}

void mono_thread_suspend_all_other_threads()
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

int32_t mono_thread_state_init_from_current(MonoThreadUnwindState* ctx)
{
    return 0;
}

int32_t mono_thread_state_init_from_monoctx(MonoThreadUnwindState* ctx, MonoContext* mctx)
{
    return 0;
}

const char* mono_property_get_name(MonoProperty *prop)
{
    return il2cpp::vm::Property::GetName((PropertyInfo*)prop);
}

MonoMethod* mono_property_get_get_method(MonoProperty *prop)
{
    return (MonoMethod*)il2cpp::vm::Property::GetGetMethod((PropertyInfo*)prop);
}

MonoMethod* mono_property_get_set_method(MonoProperty *prop)
{
    return (MonoMethod*)il2cpp::vm::Property::GetSetMethod((PropertyInfo*)prop);
}

MonoClass* mono_property_get_parent(MonoProperty *prop)
{
    return (MonoClass*)il2cpp::vm::Property::GetParent((PropertyInfo*)prop);
}

void mono_loader_lock()
{
#if IL2CPP_MONO_DEBUGGER
    il2cpp::utils::Debugger::AcquireLoaderLock();
#else
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
#endif
}

void mono_loader_unlock()
{
#if IL2CPP_MONO_DEBUGGER
    il2cpp::utils::Debugger::ReleaseLoaderLock();
#else
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
#endif
}

void mono_loader_lock_track_ownership(int32_t track)
{
    // This method intentionally does nothing.
}

int32_t mono_loader_lock_is_owned_by_self()
{
#if IL2CPP_MONO_DEBUGGER
    return il2cpp::utils::Debugger::LoaderLockIsOwnedByThisThread();
#else
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return false;
#endif
}

void mono_gc_wbarrier_generic_store_internal(void volatile* ptr, MonoObject* value)
{
    il2cpp::gc::WriteBarrier::GenericStore((Il2CppObject**)ptr, (Il2CppObject*)value);
}

void mono_gc_base_init()
{
    // This method intentionally does nothing.
}

#if IL2CPP_COMPILER_MSVC
int mono_gc_register_root(char* start, size_t size, MonoGCDescriptor descr, int32_t source, void* key, const char* msg)
#else
int mono_gc_register_root(char* start, size_t size, MonoGCDescriptor descr, MonoGCRootSource source, void* key, const char* msg)
#endif
{
    il2cpp::gc::GarbageCollector::RegisterRoot(start, size);
    return 1;
}

void mono_gc_deregister_root(char* addr)
{
    il2cpp::gc::GarbageCollector::UnregisterRoot(addr);
}

void* mono_gc_make_root_descr_all_refs(int numbits)
{
    return NULL;
}

#if IL2CPP_COMPILER_MSVC
int mono_gc_register_root_wbarrier(char *start, size_t size, MonoGCDescriptor descr, int32_t source, void *key, const char *msg)
#else
int mono_gc_register_root_wbarrier(char *start, size_t size, MonoGCDescriptor descr, MonoGCRootSource source, void *key, const char *msg)
#endif
{
    il2cpp::gc::GarbageCollector::RegisterRoot(start, size);
    return 1;
}

MonoGCDescriptor mono_gc_make_vector_descr()
{
    return 0;
}

MonoInterpCallbacks* mini_get_interp_callbacks()
{
#if IL2CPP_MONO_DEBUGGER
    return (MonoInterpCallbacks*)il2cpp::utils::Debugger::GetInterpCallbacks();
#else
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
#endif
}

void* mono_gc_invoke_with_gc_lock(MonoGCLockedCallbackFunc func, void *data)
{
    return il2cpp::gc::GarbageCollector::CallWithAllocLockHeld(func, data);
}

int32_t mono_gc_is_moving()
{
    return false;
}

int mono_reflection_parse_type_checked(char *name, MonoTypeNameParse *monoInfo, MonoError *error)
{
#if !IL2CPP_MONO_DEBUGGER
    IL2CPP_ASSERT(0 && "This is not a complete implementation. It should only be called from the debugger.");
#endif
    error_init(error);
    il2cpp::vm::TypeNameParseInfo *pInfo = new il2cpp::vm::TypeNameParseInfo();
    std::string nameStr = name;
    std::replace(nameStr.begin(), nameStr.end(), '/', '+');
    il2cpp::vm::TypeNameParser parser(nameStr, *pInfo, false);
    Il2CppMonoTypeNameParse* info = (Il2CppMonoTypeNameParse*)monoInfo;
    info->assembly.name = NULL;
    info->il2cppTypeNameParseInfo = pInfo;
    return parser.Parse();
}

void mono_reflection_free_type_info(MonoTypeNameParse *info)
{
    delete (il2cpp::vm::TypeNameParseInfo*)((Il2CppMonoTypeNameParse*)info)->il2cppTypeNameParseInfo;
}

MonoType* mono_reflection_get_type_checked(MonoAssemblyLoadContext *alc, MonoImage* rootimage, MonoImage* image, MonoTypeNameParse* info, int32_t ignorecase, int32_t search_mscorlib, int32_t* type_resolve, MonoError* error)
{
    error_init(error);

    Il2CppClass *klass = il2cpp::vm::Image::FromTypeNameParseInfo((Il2CppImage*)image, *((il2cpp::vm::TypeNameParseInfo*)((Il2CppMonoTypeNameParse*)info)->il2cppTypeNameParseInfo), ignorecase);
    if (!klass)
        return NULL;

    return (MonoType*)il2cpp::vm::Class::GetType(klass);
}

void mono_runtime_quit()
{
    il2cpp::vm::Runtime::Shutdown();
}

int32_t mono_runtime_is_shutting_down()
{
    return il2cpp::vm::Runtime::IsShuttingDown() ? true : false;
}

MonoObject* mono_runtime_try_invoke(MonoMethod* method, void* obj, void** params, MonoObject** exc, MonoError* error)
{
    error_init(error);

    return (MonoObject*)il2cpp::vm::Runtime::Invoke((MethodInfo*)method, obj, params, (Il2CppException**)exc);
}

MonoObject* mono_runtime_invoke_checked(MonoMethod* method, void* obj, void** params, MonoError* error)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

int32_t mono_runtime_try_shutdown()
{
    return true;
}

void mono_arch_setup_resume_sighandler_ctx(MonoContext* ctx, void* func)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

void mono_arch_set_breakpoint(MonoJitInfo* ji, uint8_t* ip)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

void mono_arch_clear_breakpoint(MonoJitInfo* ji, uint8_t* ip)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

void mono_arch_start_single_stepping()
{
}

void mono_arch_stop_single_stepping()
{
}

void mono_arch_skip_breakpoint(MonoContext* ctx, MonoJitInfo* ji)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

void mono_arch_skip_single_step(MonoContext* ctx)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

intptr_t mono_arch_context_get_int_reg(MonoContext* ctx, int reg)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

void mono_arch_context_set_int_reg(MonoContext* ctx, int reg, intptr_t val)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

MonoJitInfo* mono_jit_info_table_find(MonoDomain* domain, void* addr)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

MonoMethod* mono_jit_info_get_method(MonoJitInfo* ji)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

MonoJitInfo* mono_jit_info_table_find_internal(MonoDomain* domain, void* addr, int32_t try_aot, int32_t allow_trampolines)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

int32_t mono_debug_il_offset_from_address(MonoMethod* method, MonoDomain* domain, uint32_t native_offset)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

void mono_set_is_debugger_attached(int32_t attached)
{
#if IL2CPP_MONO_DEBUGGER
    il2cpp::utils::Debugger::SetIsDebuggerAttached(attached == 1);
#endif
}

uint32_t mono_aligned_addr_hash(const void* ptr)
{
    return ((uint32_t)(intptr_t)(ptr)) >> 3;
}

MonoGenericInst* mono_metadata_get_generic_inst(int type_argc, MonoType** type_argv)
{
    return (MonoGenericInst*)il2cpp::vm::MetadataCache::GetGenericInst((Il2CppType**)type_argv, type_argc);
}

void* mono_ldtoken_checked(MonoImage* image, uint32_t token, MonoClass** handle_class, MonoGenericContext* context, MonoError* error)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

MonoThreadInfo* mono_stack_mark_record_size(MonoThreadInfo* info, HandleStackMark* stackmark, const char* func_name)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

void mono_nullable_init(uint8_t* buf, MonoObject* value, MonoClass* klass)
{
    il2cpp::vm::Object::NullableInit(buf, (Il2CppObject*)value, (Il2CppClass*)klass);
}

MonoObject* mono_value_box_checked(MonoDomain* domain, MonoClass* klass, void* value, MonoError* error)
{
    error_init(error);
    return (MonoObject*)il2cpp::vm::Object::Box((Il2CppClass*)klass, value);
}

char* mono_get_runtime_build_info()
{
    return il2cpp::utils::StringUtils::StringDuplicate("0.0 (IL2CPP)");
}

MonoMethod* mono_marshal_method_from_wrapper(MonoMethod* wrapper)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

void* mono_jit_find_compiled_method_with_jit_info(MonoDomain* domain, MonoMethod* method, MonoJitInfo** ji)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

MonoLMF** mono_get_lmf_addr()
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

void mono_set_lmf(MonoLMF* lmf)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

void* il2cpp_mono_aot_get_method_checked(MonoDomain* domain, MonoMethod* method, MonoError* error)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

MonoJitInfo* mini_jit_info_table_find(MonoDomain* domain, char* addr, MonoDomain** out_domain)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

void mono_restore_context(MonoContext* ctx)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
}

int32_t mono_error_ok(MonoError *error)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

MonoString* mono_ldstr_checked(MonoDomain* domain, MonoImage* image, uint32_t idx, MonoError* error)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return NULL;
}

int32_t mono_find_prev_seq_point_for_native_offset(MonoDomain *domain, MonoMethod *method, int32_t native_offset, MonoSeqPointInfo **info, SeqPoint* seq_point)
{
    IL2CPP_ASSERT(0 && "This method is not yet implemented");
    return 0;
}

int32_t mono_environment_exitcode_get()
{
    return il2cpp::vm::Runtime::GetExitCode();
}

void mono_environment_exitcode_set(int32_t value)
{
    il2cpp::vm::Runtime::SetExitCode(value);
}

void mono_threadpool_suspend()
{
    il2cpp::vm::ThreadPoolMs::Suspend();
}

void mono_threadpool_resume()
{
    il2cpp::vm::ThreadPoolMs::Resume();
}

MonoImage* mono_assembly_get_image_internal(MonoAssembly* assembly)
{
    return (MonoImage*)il2cpp::vm::Assembly::GetImage((Il2CppAssembly*)assembly);
}

int32_t mono_verifier_is_method_valid_generic_instantiation(MonoMethod* method)
{
    if (!method)
        return 0;

    if (!((MethodInfo*)method)->is_generic && ((MethodInfo*)method)->is_inflated && ((MethodInfo*)method)->methodPointer)
        return 1;

    return 0;
}

void mono_network_init()
{
}

MonoMethod* jinfo_get_method(MonoJitInfo *ji)
{
    return (MonoMethod*)((Il2CppMonoJitInfo*)ji)->d.method;
}

void mono_error_cleanup(MonoError *oerror)
{
}

MonoGenericContext* mono_generic_class_get_context(MonoGenericClass *gclass)
{
    return (MonoGenericContext*)il2cpp::vm::GenericClass::GetContext((Il2CppGenericClass*)gclass);
}

MonoClass* mono_get_string_class()
{
    return (MonoClass*)il2cpp_defaults.string_class;
}

int32_t mono_type_is_generic_parameter(MonoType *type)
{
    auto il2cppType = (Il2CppType*)type;
    return !il2cppType->byref && (il2cppType->type == IL2CPP_TYPE_VAR || il2cppType->type == IL2CPP_TYPE_MVAR);
}

int mono_type_size(MonoType *t, int* align)
{
    auto sizeAndAlignment = il2cpp::metadata::FieldLayout::GetTypeSizeAndAlignment((Il2CppType*)t);
    *align = sizeAndAlignment.alignment;

    // The Mono API requires an int return value, so assert if the value does not fit in an int.
    IL2CPP_ASSERT(sizeAndAlignment.size <= std::numeric_limits<uint32_t>::max());
    return (int)sizeAndAlignment.size;
}

int32_t mono_metadata_generic_class_is_valuetype(MonoGenericClass *gclass)
{
    return il2cpp::vm::GenericClass::IsValueType((Il2CppGenericClass*)gclass);
}

int32_t mono_domain_is_unloading(MonoDomain *domain)
{
    // Domains never unload in IL2CPP
    return 0;
}

MonoClass* mono_get_byte_class()
{
    return (MonoClass*)il2cpp_defaults.byte_class;
}

int32_t mono_debug_image_has_debug_info(MonoImage *image)
{
    // For IL2CPP assume we never have debug info for a given image
    return 0;
}

char* mono_debug_image_get_sourcelink(MonoImage *image)
{
    // IL2CPP does not support sourcelink
    return NULL;
}

MonoAssemblyLoadContext* mono_domain_default_alc(MonoDomain *domain)
{
    // IL2CPP does not support ALCs yet
    return NULL;
}

int mono_class_interface_offset_with_variance(MonoClass *klass, MonoClass *itf, int32_t *non_exact_match)
{
    IL2CPP_ASSERT(0 && "Not Implemented yet");
    return 0;
}

int32_t mono_class_has_parent(MonoClass *klass, MonoClass *parent)
{
    return il2cpp::vm::Class::HasParent((Il2CppClass*)klass, (Il2CppClass*)parent);
}

MonoClass* mono_class_get_checked(MonoImage *image, uint32_t type_token, MonoError *error)
{
    IL2CPP_ASSERT(0 && "Not Implemented yet");
    return NULL;
}

void* mono_vtype_get_field_addr(void* vtype, MonoClassField *field)
{
    return ((char*)vtype) + ((FieldInfo*)field)->offset - sizeof(Il2CppObject);
}

MonoClass* mono_class_create_array(MonoClass *element_class, uint32_t rank)
{
    return (MonoClass*)il2cpp::vm::Class::GetArrayClass((Il2CppClass*)element_class, rank);
}

MonoArray* mono_array_new_full_checked(MonoDomain *domain, MonoClass *array_class, uintptr_t *lengths, intptr_t *lower_bounds, MonoError *error)
{
    return (MonoArray*)il2cpp::vm::Array::NewFull((Il2CppClass*)array_class, (il2cpp_array_size_t*)lengths, (il2cpp_array_size_t*)lower_bounds);
}

int32_t mono_gc_is_finalizer_internal_thread(MonoInternalThread *thread)
{
    return il2cpp::gc::GarbageCollector::IsFinalizerInternalThread((Il2CppInternalThread*)thread);
}

char* mono_debugger_state_str()
{
    return NULL;
}

MonoType* mono_get_void_type()
{
    return (MonoType*)il2cpp::vm::Class::GetType(il2cpp_defaults.void_class);
}

MonoType* mono_get_object_type()
{
    return (MonoType*)il2cpp::vm::Class::GetType(il2cpp_defaults.object_class);
}

MonoCustomAttrInfo* mono_custom_attrs_from_assembly_checked(MonoAssembly *assembly, int32_t ignore_missing, MonoError *error)
{
    return (MonoCustomAttrInfo*)il2cpp::vm::MetadataCache::GetCustomAttributeTypeToken(((Il2CppAssembly*)assembly)->image, ((Il2CppAssembly*)assembly)->token);
}

MonoCustomAttrInfo* mono_custom_attrs_from_class_checked(MonoClass *klass, MonoError *error)
{
    return (MonoCustomAttrInfo*)il2cpp::vm::MetadataCache::GetCustomAttributeTypeToken(((Il2CppClass*)klass)->image, ((Il2CppClass*)klass)->token);
}

MonoCustomAttrInfo* mono_custom_attrs_from_method_checked(MonoMethod *method, MonoError *error)
{
    return (MonoCustomAttrInfo*)il2cpp::vm::MetadataCache::GetCustomAttributeTypeToken(((MethodInfo*)method)->klass->image, ((MethodInfo*)method)->token);
}

MonoCustomAttrInfo* mono_custom_attrs_from_property_checked(MonoClass *klass, MonoProperty *property, MonoError *error)
{
    return (MonoCustomAttrInfo*)il2cpp::vm::MetadataCache::GetCustomAttributeTypeToken(((Il2CppClass*)klass)->image, ((PropertyInfo*)property)->token);
}

MonoCustomAttrInfo* mono_custom_attrs_from_field_checked(MonoClass *klass, MonoClassField *field, MonoError *error)
{
    return (MonoCustomAttrInfo*)il2cpp::vm::MetadataCache::GetCustomAttributeTypeToken(((Il2CppClass*)klass)->image, ((FieldInfo*)field)->token);
}


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-mono-api.cpp---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-runtime-stats.cpp---------------


#include "il2cpp-runtime-stats.h"

Il2CppRuntimeStats il2cpp_runtime_stats = {{ 0 }};


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\il2cpp-runtime-stats.cpp---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\UnityAdsStubs.cpp---------------


#if defined(__ANDROID__)

#include <cstddef>

#define DONTSTRIP __attribute__((used))
#define EXPORT __attribute__((visibility("default")))

extern "C"
{
    typedef void (*UnityAdsReadyCallback)(const char * placementId);
    typedef void (*UnityAdsDidErrorCallback)(long rawError, const char * message);
    typedef void (*UnityAdsDidStartCallback)(const char * placementId);
    typedef void (*UnityAdsDidFinishCallback)(const char * placementId, long rawFinishState);

    EXPORT DONTSTRIP void UnityAdsEngineInitialize(const char * gameId, bool testMode) {}
    EXPORT DONTSTRIP void UnityAdsEngineShow(const char * placementId) {}
    EXPORT DONTSTRIP bool UnityAdsEngineGetDebugMode() { return false; }
    EXPORT DONTSTRIP void UnityAdsEngineSetDebugMode(bool debugMode) {}
    EXPORT DONTSTRIP bool UnityAdsEngineIsSupported() { return false; }
    EXPORT DONTSTRIP bool UnityAdsEngineIsReady(const char * placementId) { return false; }
    EXPORT DONTSTRIP long UnityAdsEngineGetPlacementState(const char * placementId) { return -1; }
    EXPORT DONTSTRIP const char * UnityAdsEngineGetVersion() { return NULL; }
    EXPORT DONTSTRIP bool UnityAdsEngineIsInitialized() { return false; }
    EXPORT DONTSTRIP void UnityAdsEngineSetMetaData(const char * category, const char * data) {}
    EXPORT DONTSTRIP void UnityAdsEngineSetReadyCallback(UnityAdsReadyCallback callback) {}
    EXPORT DONTSTRIP void UnityAdsEngineSetDidErrorCallback(UnityAdsDidErrorCallback callback) {}
    EXPORT DONTSTRIP void UnityAdsEngineSetDidStartCallback(UnityAdsDidStartCallback callback) {}
    EXPORT DONTSTRIP void UnityAdsEngineSetDidFinishCallback(UnityAdsDidFinishCallback callback) {}
}

#endif


#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\UnityAdsStubs.cpp---------------


#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\codegen\il2cpp-codegen.cpp---------------
.
.
#include <string>
#include <stdarg.h>

#include "il2cpp-config.h"
#include "il2cpp-codegen.h"

#include "utils/Exception.h"

#include "os/Atomic.h"
#include "metadata/GenericMethod.h"
#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "vm/Array.h"
#include "vm/CCW.h"
#include "vm/COM.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/InternalCalls.h"
#include "vm/LastError.h"
#include "vm/MarshalAlloc.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/PlatformInvoke.h"
#include "vm/Profiler.h"
#include "vm/RCW.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/StackTrace.h"
#include "vm/String.h"
#include "vm/Thread.h"
#include "vm/ThreadPoolMs.h"
#include "vm/Type.h"
#include "vm/WindowsRuntime.h"
#include "vm-utils/VmThreadUtils.h"
#include "utils/Runtime.h"

#if IL2CPP_ENABLE_WRITE_BARRIERS
void Il2CppCodeGenWriteBarrier(void** targetAddress, void* object)
{
    il2cpp::gc::GarbageCollector::SetWriteBarrier(targetAddress);
}

#endif

// This function exists to help with generation of callstacks for exceptions
// on iOS and MacOS x64 with clang 6.0 (newer versions of clang don't have this
// problem on x64). There we call the backtrace function, which does not play nicely
// with NORETURN, since the compiler eliminates the method prologue code setting up
// the address of the return frame (which makes sense). So on iOS we need to make
// the NORETURN define do nothing, then we use this dummy method which has the
// attribute for clang on iOS defined to prevent clang compiler errors for
// method that end by throwing a managed exception.
REAL_NORETURN IL2CPP_NO_INLINE void il2cpp_codegen_no_return()
{
    IL2CPP_UNREACHABLE;
}

REAL_NORETURN void il2cpp_codegen_abort()
{
    il2cpp::utils::Runtime::Abort();
    il2cpp_codegen_no_return();
}

#if IL2CPP_ENABLE_WRITE_BARRIERS
void Il2CppCodeGenWriteBarrierForType(const Il2CppType* type, void** targetAddress, void* object)
{
#if IL2CPP_ENABLE_STRICT_WRITE_BARRIERS
    if (il2cpp::vm::Type::IsPointerType(type))
        return;

    if (il2cpp::vm::Type::IsStruct(type))
    {
        Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);

        FieldInfo* field;
        void* iter = NULL;
        while ((field = il2cpp::vm::Class::GetFields(klass, &iter)))
        {
            if (il2cpp::vm::Field::GetFlags(field) & FIELD_ATTRIBUTE_STATIC)
                continue;

            void* fieldTargetAddress = il2cpp::vm::Field::GetInstanceFieldDataPointer((void*)targetAddress, field);
            Il2CppCodeGenWriteBarrierForType(field->type, (void**)fieldTargetAddress, NULL);
        }
    }
    else
    {
        il2cpp::gc::GarbageCollector::SetWriteBarrier(targetAddress);
    }
#else
    il2cpp::gc::GarbageCollector::SetWriteBarrier(targetAddress);
#endif
}

void Il2CppCodeGenWriteBarrierForClass(Il2CppClass* klass, void** targetAddress, void* object)
{
#if IL2CPP_ENABLE_STRICT_WRITE_BARRIERS
    Il2CppCodeGenWriteBarrierForType(il2cpp::vm::Class::GetType(klass), targetAddress, object);
#else
    il2cpp::gc::GarbageCollector::SetWriteBarrier(targetAddress);
#endif
}

#endif // IL2CPP_ENABLE_WRITE_BARRIERS


void* il2cpp_codegen_atomic_compare_exchange_pointer(void** dest, void* exchange, void* comparand)
{
    return il2cpp::os::Atomic::CompareExchangePointer(dest, exchange, comparand);
}

void il2cpp_codegen_marshal_store_last_error()
{
    il2cpp::vm::LastError::StoreLastError();
}

Il2CppAsyncResult* il2cpp_codegen_delegate_begin_invoke(RuntimeDelegate* delegate, void** params, RuntimeDelegate* asyncCallback, RuntimeObject* state)
{
    return il2cpp::vm::ThreadPoolMs::DelegateBeginInvoke(delegate, params, asyncCallback, state);
}

RuntimeObject* il2cpp_codegen_delegate_end_invoke(Il2CppAsyncResult* asyncResult, void **out_args)
{
    return il2cpp::vm::ThreadPoolMs::DelegateEndInvoke(asyncResult, out_args);
}

void il2cpp_codegen_set_closed_delegate_invoke(RuntimeObject* delegate, RuntimeObject* target, void* methodPtr)
{
    IL2CPP_ASSERT(delegate->klass->parent == il2cpp_defaults.multicastdelegate_class);
    il2cpp::vm::Type::SetClosedDelegateInvokeMethod((RuntimeDelegate*)delegate, target, (Il2CppMethodPointer)methodPtr);
}

Il2CppMethodPointer il2cpp_codegen_resolve_icall(const char* name)
{
    Il2CppMethodPointer method = il2cpp::vm::InternalCalls::Resolve(name);
    if (!method)
    {
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetMissingMethodException(name));
    }
    return method;
}

Type_t* il2cpp_codegen_type_get_object(const RuntimeType* type)
{
    return (Type_t*)il2cpp::vm::Reflection::GetTypeObject(type);
}

MethodBase_t* il2cpp_codegen_get_method_object_internal(const RuntimeMethod* method, RuntimeClass* refclass)
{
    return (MethodBase_t*)il2cpp::vm::Reflection::GetMethodObject(method, method->klass);
}

Assembly_t* il2cpp_codegen_get_executing_assembly(const RuntimeMethod* method)
{
    return (Assembly_t*)il2cpp::vm::Reflection::GetAssemblyObject(method->klass->image->assembly);
}

void il2cpp_codegen_register(const Il2CppCodeRegistration* const codeRegistration, const Il2CppMetadataRegistration* const metadataRegistration, const Il2CppCodeGenOptions* const codeGenOptions)
{
    il2cpp::vm::MetadataCache::Register(codeRegistration, metadataRegistration, codeGenOptions);
}

extern MetadataInitializerCleanupFunc g_ClearMethodMetadataInitializedFlags;
void il2cpp_codegen_register_metadata_initialized_cleanup(MetadataInitializerCleanupFunc cleanup)
{
    g_ClearMethodMetadataInitializedFlags = cleanup;
}

void il2cpp_codegen_initialize_runtime_metadata(uintptr_t* metadataPointer)
{
    il2cpp::vm::MetadataCache::InitializeRuntimeMetadata(metadataPointer);

    // We don't need a memory barrier here, InitializeRuntimeMetadata already has one
    // What we need is a barrier before setting s_Il2CppMethodInitialized = true in the generated code
    // but adding that to every function increases code size, so instead we rely on this function
    // being called before s_Il2CppCodeRegistrationInitialized is set to true
    il2cpp::os::Atomic::FullMemoryBarrier();
}

void* il2cpp_codegen_initialize_runtime_metadata_inline(uintptr_t* metadataPointer)
{
    return il2cpp::vm::MetadataCache::InitializeRuntimeMetadata(metadataPointer);
}

const RuntimeClass* il2cpp_codegen_get_generic_type_definition(const RuntimeClass* klass)
{
    IL2CPP_ASSERT(klass->generic_class);
    return il2cpp::vm::Class::FromIl2CppType(klass->generic_class->type);
}

const RuntimeMethod* il2cpp_codegen_get_generic_method_definition(const RuntimeMethod* method)
{
    return il2cpp::vm::MetadataCache::GetGenericMethodDefinition(method);
}

const RuntimeMethod* il2cpp_codegen_get_generic_instance_method_from_method_definition(RuntimeClass* genericInstanceClass, const RuntimeMethod* methodDefinition)
{
    return il2cpp::vm::Class::GetGenericInstanceMethodFromDefintion(genericInstanceClass, methodDefinition);
}

void* il2cpp_codegen_get_thread_static_data(RuntimeClass* klass)
{
    return il2cpp::vm::Thread::GetThreadStaticData(klass->thread_static_fields_offset);
}

void il2cpp_codegen_assert_field_size(RuntimeField* field, size_t size)
{
    IL2CPP_ASSERT(size == il2cpp_codegen_sizeof(InitializedTypeInfo(il2cpp::vm::Class::FromIl2CppType(field->type))));
}

void* il2cpp_codegen_get_instance_field_data_pointer(void* instance, RuntimeField* field)
{
    return il2cpp::vm::Field::GetInstanceFieldDataPointer(instance, field);
}

void il2cpp_codegen_write_instance_field_data(void* instance, RuntimeField* field, void* data, uint32_t size)
{
    il2cpp_codegen_assert_field_size(field, size);
    IL2CPP_ASSERT(il2cpp::vm::Field::IsInstance(field));

    void* fieldPointer = il2cpp_codegen_get_instance_field_data_pointer(instance, field);
    il2cpp_codegen_memcpy(fieldPointer, data, size);
    Il2CppCodeGenWriteBarrierForType(field->type, (void**)fieldPointer, NULL);
}

void* il2cpp_codegen_get_static_field_data_pointer(RuntimeField* field)
{
    IL2CPP_ASSERT(il2cpp::vm::Field::IsNormalStatic(field));

    return ((uint8_t*)field->parent->static_fields) + field->offset;
}

void il2cpp_codegen_write_static_field_data(RuntimeField* field, void* data, uint32_t size)
{
    il2cpp_codegen_assert_field_size(field, size);
    IL2CPP_ASSERT(il2cpp::vm::Field::IsNormalStatic(field));

    void* fieldPointer = il2cpp_codegen_get_static_field_data_pointer(field);
    il2cpp_codegen_memcpy(fieldPointer, data, size);
    Il2CppCodeGenWriteBarrierForType(field->type, (void**)fieldPointer, NULL);
}

void* il2cpp_codegen_get_thread_static_field_data_pointer(RuntimeField* field)
{
    IL2CPP_ASSERT(il2cpp::vm::Field::IsThreadStatic(field));

    int threadStaticFieldOffset = il2cpp::vm::MetadataCache::GetThreadLocalStaticOffsetForField(field);
    void* threadStaticData = il2cpp::vm::Thread::GetThreadStaticData(field->parent->thread_static_fields_offset);
    return static_cast<uint8_t*>(threadStaticData) + threadStaticFieldOffset;
}

void il2cpp_codegen_write_thread_static_field_data(RuntimeField* field, void* data, uint32_t size)
{
    il2cpp_codegen_assert_field_size(field, size);
    IL2CPP_ASSERT(il2cpp::vm::Field::IsThreadStatic(field));

    void* fieldPointer = il2cpp_codegen_get_thread_static_field_data_pointer(field);
    il2cpp_codegen_memcpy(fieldPointer, data, size);
    Il2CppCodeGenWriteBarrierForType(field->type, (void**)fieldPointer, NULL);
}

void il2cpp_codegen_memory_barrier()
{
    il2cpp::vm::Thread::FullMemoryBarrier();
}

void SetGenericValueImpl(RuntimeArray* thisPtr, int32_t pos, void* value)
{
    il2cpp_array_setrefwithsize(thisPtr, thisPtr->klass->element_size, pos, value);
}

RuntimeArray* SZArrayNew(RuntimeClass* arrayType, uint32_t length)
{
    return il2cpp::vm::Array::NewSpecific(arrayType, length);
}

RuntimeArray* GenArrayNew(RuntimeClass* arrayType, il2cpp_array_size_t* dimensions)
{
    return il2cpp::vm::Array::NewFull(arrayType, dimensions, NULL);
}

bool il2cpp_codegen_method_is_generic_instance_method(RuntimeMethod* method)
{
    return il2cpp::vm::Method::IsGenericInstanceMethod(method);
}

bool il2cpp_codegen_method_is_generic_instance(RuntimeClass* klass)
{
    return il2cpp::vm::Class::IsInflated(klass);
}

RuntimeClass* il2cpp_codegen_method_get_declaring_type(const RuntimeMethod* method)
{
    return il2cpp::vm::Method::GetClass(method);
}

bool MethodIsStatic(const RuntimeMethod* method)
{
    return !il2cpp::vm::Method::IsInstance(method);
}

bool MethodHasParameters(const RuntimeMethod* method)
{
    return il2cpp::vm::Method::GetParamCount(method) != 0;
}

NORETURN void il2cpp_codegen_raise_profile_exception(const RuntimeMethod* method)
{
    std::string methodName = il2cpp::vm::Method::GetFullName(method);
    il2cpp_codegen_raise_exception(il2cpp_codegen_get_not_supported_exception(methodName.c_str()));
}

const RuntimeMethod* il2cpp_codegen_get_generic_virtual_method_internal(const RuntimeMethod* vtableSlotMethod, const RuntimeMethod* genericVirtualMethod)
{
    return il2cpp::metadata::GenericMethod::GetGenericVirtualMethod(vtableSlotMethod, genericVirtualMethod);
}

void il2cpp_codegen_runtime_class_init(RuntimeClass* klass)
{
    il2cpp::vm::Runtime::ClassInit(klass);
}

void il2cpp_codegen_raise_execution_engine_exception(const RuntimeMethod* method)
{
    il2cpp::vm::Runtime::AlwaysRaiseExecutionEngineException(method);
}

void il2cpp_codegen_raise_execution_engine_exception_missing_virtual(const RuntimeMethod* method)
{
    il2cpp::vm::Runtime::AlwaysRaiseExecutionEngineExceptionOnVirtualCall(method);
}

RuntimeObject* IsInst(RuntimeObject *obj, RuntimeClass* targetType)
{
    return il2cpp::vm::Object::IsInst(obj, targetType);
}

RuntimeObject* Box(RuntimeClass* type, void* data)
{
    return il2cpp::vm::Object::Box(type, data);
}

void* Unbox_internal(Il2CppObject* obj)
{
    return il2cpp::vm::Object::Unbox(obj);
}

void UnBoxNullable_internal(RuntimeObject* obj, RuntimeClass* nullableClass, void* storage)
{
    il2cpp::vm::Object::UnboxNullable(obj, nullableClass, storage);
}

void* UnBox_Any(RuntimeObject* obj, RuntimeClass* expectedBoxedClass, void* unboxStorage)
{
    IL2CPP_ASSERT(unboxStorage != NULL);
    // We assume unboxStorage is on the stack, if not we'll need a write barrier
    IL2CPP_ASSERT_STACK_PTR(unboxStorage);

    if (il2cpp::vm::Class::IsValuetype(expectedBoxedClass))
    {
        if (il2cpp::vm::Class::IsNullable(expectedBoxedClass))
        {
            UnBoxNullable(obj, expectedBoxedClass, unboxStorage);
            return unboxStorage;
        }
        return UnBox(obj, expectedBoxedClass);
    }

    // Use unboxStorage to return a pointer to obj
    // This keeps the return value of UnBox_Any consistent; it always returns a pointer to the data we want
    // This saves a runtime check on the class type
    *((void**)unboxStorage) = Castclass(obj, expectedBoxedClass);
    return unboxStorage;
}

bool il2cpp_codegen_would_box_to_non_null(RuntimeClass* klass, void* objBuffer)
{
    if (il2cpp::vm::Class::IsValuetype(klass))
    {
        if (il2cpp::vm::Class::IsNullable(klass))
            return il2cpp::vm::Object::NullableHasValue(klass, objBuffer);
        return true;
    }

    return *(void**)objBuffer != NULL;
}

RuntimeObject* il2cpp_codegen_object_new(RuntimeClass *klass)
{
    return il2cpp::vm::Object::New(klass);
}

void* il2cpp_codegen_marshal_allocate(size_t size)
{
    return il2cpp::vm::MarshalAlloc::Allocate(size);
}

#if _DEBUG

void il2cpp_codegen_marshal_allocate_push_allocation_frame()
{
    il2cpp::vm::MarshalAlloc::PushAllocationFrame();
}

void il2cpp_codegen_marshal_allocate_pop_allocation_frame()
{
    il2cpp::vm::MarshalAlloc::PopAllocationFrame();
}

bool il2cpp_codegen_marshal_allocate_has_unfreed_allocations()
{
    return il2cpp::vm::MarshalAlloc::HasUnfreedAllocations();
}

void il2cpp_codegen_marshal_allocate_clear_all_tracked_allocations()
{
    il2cpp::vm::MarshalAlloc::ClearAllTrackedAllocations();
}

#endif

#if IL2CPP_ENABLE_PROFILER

void il2cpp_codegen_profiler_method_enter(const RuntimeMethod* method)
{
    il2cpp::vm::Profiler::MethodEnter(method);
}

void il2cpp_codegen_profiler_method_exit(const RuntimeMethod* method)
{
    il2cpp::vm::Profiler::MethodExit(method);
}

#endif

NORETURN void il2cpp_codegen_raise_exception(Exception_t *ex, MethodInfo* lastManagedFrame)
{
    RuntimeException* exc = (RuntimeException*)ex;
    IL2CPP_OBJECT_SETREF_NULL(exc, trace_ips);
    IL2CPP_OBJECT_SETREF_NULL(exc, stack_trace);
    il2cpp::vm::Exception::Raise(exc, lastManagedFrame);
}

NORETURN void il2cpp_codegen_rethrow_exception(Exception_t *ex)
{
    il2cpp::vm::Exception::Rethrow((RuntimeException*)ex);
}

NORETURN void il2cpp_codegen_raise_exception(il2cpp_hresult_t hresult, bool defaultToCOMException)
{
    il2cpp::vm::Exception::Raise(hresult, defaultToCOMException);
}

NORETURN void il2cpp_codegen_raise_out_of_memory_exception()
{
    il2cpp::vm::Exception::RaiseOutOfMemoryException();
}

NORETURN void il2cpp_codegen_raise_null_reference_exception()
{
    il2cpp::vm::Exception::RaiseNullReferenceException();
}

NORETURN void il2cpp_codegen_raise_divide_by_zero_exception()
{
    il2cpp::vm::Exception::RaiseDivideByZeroException();
}

NORETURN void il2cpp_codegen_raise_index_out_of_range_exception()
{
    il2cpp::vm::Exception::RaiseIndexOutOfRangeException();
}

NORETURN void il2cpp_codegen_raise_index_out_of_range_exception(const RuntimeMethod* method)
{
    IL2CPP_RAISE_MANAGED_EXCEPTION(il2cpp_codegen_get_overflow_exception(), method);
}

NORETURN void il2cpp_codegen_raise_invalid_unmanaged_callers_usage(const RuntimeMethod* method, const char* msg)
{
    std::string fullName = il2cpp::vm::Method::GetFullName(method);
    IL2CPP_RAISE_MANAGED_EXCEPTION(il2cpp::vm::Exception::GetExecutionEngineException((fullName + ": " +  msg).c_str()), method);
}

Exception_t* il2cpp_codegen_get_argument_exception(const char* param, const char* msg)
{
    return (Exception_t*)il2cpp::vm::Exception::GetArgumentException(param, msg);
}

Exception_t* il2cpp_codegen_get_argument_null_exception(const char* param)
{
    return (Exception_t*)il2cpp::vm::Exception::GetArgumentNullException(param);
}

Exception_t* il2cpp_codegen_get_overflow_exception()
{
    return (Exception_t*)il2cpp::vm::Exception::GetOverflowException("Arithmetic operation resulted in an overflow.");
}

Exception_t* il2cpp_codegen_get_not_supported_exception(const char* msg)
{
    return (Exception_t*)il2cpp::vm::Exception::GetNotSupportedException(msg);
}

Exception_t* il2cpp_codegen_get_array_type_mismatch_exception()
{
    return (Exception_t*)il2cpp::vm::Exception::GetArrayTypeMismatchException();
}

Exception_t* il2cpp_codegen_get_invalid_cast_exception(const char* msg)
{
    return (Exception_t*)il2cpp::vm::Exception::GetInvalidCastException(msg);
}

Exception_t* il2cpp_codegen_get_invalid_operation_exception(const char* msg)
{
    return (Exception_t*)il2cpp::vm::Exception::GetInvalidOperationException(msg);
}

Exception_t* il2cpp_codegen_get_marshal_directive_exception(const char* msg)
{
    return (Exception_t*)il2cpp::vm::Exception::GetMarshalDirectiveException(msg);
}

Exception_t* il2cpp_codegen_get_marshal_directive_exception(const char* msg, const RuntimeType* type)
{
    auto formattedMsg = il2cpp::utils::StringUtils::Printf(msg, il2cpp::vm::Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME).c_str());
    return (Exception_t*)il2cpp::vm::Exception::GetMarshalDirectiveException(formattedMsg.c_str());
}

// format string will require first instance as a field and second instance as a type or this will break
Exception_t* il2cpp_codegen_get_marshal_directive_exception(const char* msg, const RuntimeField *field, const RuntimeType* type)
{
    auto formattedMsg = il2cpp::utils::StringUtils::Printf(msg, il2cpp::vm::Field::GetName(field), il2cpp::vm::Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME).c_str());
    return (Exception_t*)il2cpp::vm::Exception::GetMarshalDirectiveException(formattedMsg.c_str());
}

Exception_t* il2cpp_codegen_get_missing_method_exception(const char* msg)
{
    return (Exception_t*)il2cpp::vm::Exception::GetMissingMethodException(msg);
}

Exception_t* il2cpp_codegen_get_maximum_nested_generics_exception()
{
    return (Exception_t*)il2cpp::vm::Exception::GetMaximumNestedGenericsException();
}

Exception_t* il2cpp_codegen_get_engine_execution_exception(const char* msg)
{
    return (Exception_t*)il2cpp::vm::Exception::GetExecutionEngineException(msg);
}

Exception_t* il2cpp_codegen_get_index_out_of_range_exception()
{
    return (Exception_t*)il2cpp::vm::Exception::GetIndexOutOfRangeException();
}

Exception_t* il2cpp_codegen_get_exception(il2cpp_hresult_t hresult, bool defaultToCOMException)
{
    return (Exception_t*)il2cpp::vm::Exception::Get(hresult, defaultToCOMException);
}

void il2cpp_codegen_store_exception_info(RuntimeException* ex, String_t* exceptionString)
{
    il2cpp::vm::Exception::StoreExceptionInfo(ex, reinterpret_cast<RuntimeString*>(exceptionString));
}

void il2cpp_codegen_com_marshal_variant(RuntimeObject* obj, Il2CppVariant* variant)
{
    il2cpp::vm::COM::MarshalVariant(obj, variant);
}

RuntimeObject* il2cpp_codegen_com_marshal_variant_result(const Il2CppVariant* variant)
{
    return il2cpp::vm::COM::MarshalVariantResult(variant);
}

void il2cpp_codegen_com_destroy_variant(Il2CppVariant* variant)
{
    il2cpp::vm::COM::DestroyVariant(variant);
}

Il2CppSafeArray* il2cpp_codegen_com_marshal_safe_array(Il2CppChar type, RuntimeArray* managedArray)
{
    return il2cpp::vm::COM::MarshalSafeArray(type, managedArray);
}

RuntimeArray* il2cpp_codegen_com_marshal_safe_array_result(Il2CppChar variantType, RuntimeClass* type, Il2CppSafeArray* safeArray)
{
    return il2cpp::vm::COM::MarshalSafeArrayResult(variantType, type, safeArray);
}

Il2CppSafeArray* il2cpp_codegen_com_marshal_safe_array_bstring(RuntimeArray* managedArray)
{
    return il2cpp::vm::COM::MarshalSafeArrayBString(managedArray);
}

RuntimeArray* il2cpp_codegen_com_marshal_safe_array_bstring_result(RuntimeClass* type, Il2CppSafeArray* safeArray)
{
    return il2cpp::vm::COM::MarshalSafeArrayBStringResult(type, safeArray);
}

void il2cpp_codegen_com_destroy_safe_array(Il2CppSafeArray* safeArray)
{
    il2cpp::vm::COM::DestroySafeArray(safeArray);
}

void il2cpp_codegen_com_create_instance(const Il2CppGuid& clsid, Il2CppIUnknown** identity)
{
    il2cpp::vm::COM::CreateInstance(clsid, identity);
}

il2cpp_hresult_t il2cpp_codegen_com_handle_invalid_iproperty_conversion(const char* fromType, const char* toType)
{
    return il2cpp::vm::CCW::HandleInvalidIPropertyConversion(fromType, toType);
}

il2cpp_hresult_t il2cpp_codegen_com_handle_invalid_iproperty_conversion(RuntimeObject* value, const char* fromType, const char* toType)
{
    return il2cpp::vm::CCW::HandleInvalidIPropertyConversion(value, fromType, toType);
}

il2cpp_hresult_t il2cpp_codegen_com_handle_invalid_ipropertyarray_conversion(const char* fromArrayType, const char* fromElementType, const char* toElementType, il2cpp_array_size_t index)
{
    return il2cpp::vm::CCW::HandleInvalidIPropertyArrayConversion(fromArrayType, fromElementType, toElementType, index);
}

il2cpp_hresult_t il2cpp_codegen_com_handle_invalid_ipropertyarray_conversion(RuntimeObject* value, const char* fromArrayType, const char* fromElementType, const char* toElementType, il2cpp_array_size_t index)
{
    return il2cpp::vm::CCW::HandleInvalidIPropertyArrayConversion(value, fromArrayType, fromElementType, toElementType, index);
}

Il2CppIUnknown* il2cpp_codegen_com_get_or_create_ccw_internal(RuntimeObject* obj, const Il2CppGuid& iid)
{
    return il2cpp::vm::CCW::GetOrCreate(obj, iid);
}

Il2CppObject* il2cpp_codegen_com_unpack_ccw(Il2CppIUnknown* obj)
{
    return il2cpp::vm::CCW::Unpack(obj);
}

void il2cpp_codegen_com_register_rcw(Il2CppComObject* rcw)
{
    il2cpp::vm::RCW::Register(rcw);
}

RuntimeObject* il2cpp_codegen_com_get_or_create_rcw_from_iunknown_internal(Il2CppIUnknown* unknown, RuntimeClass* fallbackClass)
{
    return il2cpp::vm::RCW::GetOrCreateFromIUnknown(unknown, fallbackClass);
}

RuntimeObject* il2cpp_codegen_com_get_or_create_rcw_from_iinspectable_internal(Il2CppIInspectable* unknown, RuntimeClass* fallbackClass)
{
    return il2cpp::vm::RCW::GetOrCreateFromIInspectable(unknown, fallbackClass);
}

RuntimeObject* il2cpp_codegen_com_get_or_create_rcw_for_sealed_class_internal(Il2CppIUnknown* unknown, RuntimeClass* objectClass)
{
    return il2cpp::vm::RCW::GetOrCreateForSealedClass(unknown, objectClass);
}

Il2CppIUnknown* il2cpp_codegen_com_query_interface_internal(Il2CppComObject* rcw, const Il2CppGuid& guid)
{
    return il2cpp::vm::RCW::QueryInterfaceNoAddRef<true>(rcw, guid);
}

Il2CppIUnknown* il2cpp_codegen_com_query_interface_no_throw_internal(Il2CppComObject* rcw, const Il2CppGuid& guid)
{
    return il2cpp::vm::RCW::QueryInterfaceNoAddRef<false>(rcw, guid);
}

void il2cpp_codegen_com_cache_queried_interface(Il2CppComObject* rcw, const Il2CppGuid& iid, Il2CppIUnknown* queriedInterface)
{
    if (il2cpp::vm::RCW::CacheQueriedInterface(rcw, iid, queriedInterface))
        queriedInterface->AddRef();
}

void il2cpp_codegen_il2cpp_com_object_cleanup(Il2CppComObject* rcw)
{
    il2cpp::vm::RCW::Cleanup(rcw);
}

String_t* il2cpp_codegen_string_new_wrapper(const char* str)
{
    return (String_t*)il2cpp::vm::String::NewWrapper(str);
}

String_t* il2cpp_codegen_string_new_utf16(const il2cpp::utils::StringView<Il2CppChar>& str)
{
    return (String_t*)il2cpp::vm::String::NewUtf16(str.Str(), static_cast<int32_t>(str.Length()));
}

RuntimeString* il2cpp_codegen_type_append_assembly_name_if_necessary(RuntimeString* typeName, const RuntimeMethod* callingMethod)
{
    return il2cpp::vm::Type::AppendAssemblyNameIfNecessary(typeName, callingMethod);
}

Type_t* il2cpp_codegen_get_type(String_t* typeName, const RuntimeMethod* getTypeMethod, const RuntimeMethod* callingMethod)
{
    RuntimeString* assemblyQualifiedTypeName = il2cpp_codegen_type_append_assembly_name_if_necessary((RuntimeString*)typeName, callingMethod);

    // Try to find the type using a hint about about calling assembly. If it is not found, fall back to calling GetType without the hint.
    Il2CppException* exc = NULL;
    void* params[] = {assemblyQualifiedTypeName};
    Type_t* type = (Type_t*)il2cpp::vm::Runtime::Invoke(getTypeMethod, NULL, params, &exc);
    if (exc)
        il2cpp::vm::Exception::Raise(exc);
    if (type == NULL)
    {
        params[0] = typeName;
        type = (Type_t*)il2cpp::vm::Runtime::Invoke(getTypeMethod, NULL, params, &exc);
        if (exc)
            il2cpp::vm::Exception::Raise(exc);
    }
    return type;
}

Type_t* il2cpp_codegen_get_type(String_t* typeName, bool throwOnError, const RuntimeMethod* getTypeMethod, const RuntimeMethod* callingMethod)
{
    typedef Type_t* (*getTypeFuncType)(String_t*, bool);
    RuntimeString* assemblyQualifiedTypeName = il2cpp_codegen_type_append_assembly_name_if_necessary((RuntimeString*)typeName, callingMethod);

    // Try to find the type using a hint about about calling assembly. If it is not found, fall back to calling GetType without the hint.
    Il2CppException* exc = NULL;
    void* params[] = {assemblyQualifiedTypeName, &throwOnError};
    Type_t* type = (Type_t*)il2cpp::vm::Runtime::Invoke(getTypeMethod, NULL, params, &exc);
    if (exc)
        il2cpp::vm::Exception::Raise(exc);

    if (type == NULL)
    {
        params[0] = typeName;
        type = (Type_t*)il2cpp::vm::Runtime::Invoke(getTypeMethod, NULL, params, &exc);
        if (exc)
            il2cpp::vm::Exception::Raise(exc);
    }
    return type;
}

Type_t* il2cpp_codegen_get_type(String_t* typeName, bool throwOnError, bool ignoreCase, const RuntimeMethod* getTypeMethod , const RuntimeMethod* callingMethod)
{
    typedef Type_t* (*getTypeFuncType)(String_t*, bool, bool);
    RuntimeString* assemblyQualifiedTypeName = il2cpp_codegen_type_append_assembly_name_if_necessary((RuntimeString*)typeName, callingMethod);
    // Try to find the type using a hint about about calling assembly. If it is not found, fall back to calling GetType without the hint.

    Il2CppException* exc = NULL;
    void* params[] = {assemblyQualifiedTypeName, &throwOnError, &ignoreCase};
    Type_t* type = (Type_t*)il2cpp::vm::Runtime::Invoke(getTypeMethod, NULL, params, &exc);
    if (exc)
        il2cpp::vm::Exception::Raise(exc);

    if (type == NULL)
    {
        params[0] = typeName;
        type = (Type_t*)il2cpp::vm::Runtime::Invoke(getTypeMethod, NULL, params, &exc);
        if (exc)
            il2cpp::vm::Exception::Raise(exc);
    }
    return type;
}

NORETURN void RaiseInvalidCastException(RuntimeObject* obj, RuntimeClass* targetType)
{
    std::string exceptionMessage = il2cpp::utils::Exception::FormatInvalidCastException(obj->klass->element_class, targetType);
    Exception_t* exception = il2cpp_codegen_get_invalid_cast_exception(exceptionMessage.c_str());
    il2cpp_codegen_raise_exception(exception);
}

bool il2cpp_codegen_method_is_interface_method(RuntimeMethod* method)
{
    return il2cpp::vm::Class::IsInterface(il2cpp_codegen_method_get_declaring_type(method));
}

bool il2cpp_codegen_class_is_assignable_from(RuntimeClass *klass, RuntimeClass *oklass)
{
    return il2cpp::vm::Class::IsAssignableFrom(klass, oklass);
}

bool il2cpp_codegen_class_is_nullable(RuntimeClass* type)
{
    return il2cpp::vm::Class::IsNullable(type);
}

RuntimeClass* il2cpp_codegen_get_generic_argument(RuntimeClass* klass, uint32_t argNum)
{
    const Il2CppGenericInst* classInst = il2cpp_codegen_get_generic_class_inst(klass);
    IL2CPP_ASSERT(argNum < classInst->type_argc);
    return il2cpp::vm::Class::FromIl2CppType(classInst->type_argv[argNum]);
}

RuntimeClass* il2cpp_codegen_inflate_generic_class(RuntimeClass* genericClassDefinition, const Il2CppGenericInst* genericInst)
{
    return il2cpp::vm::Class::GetInflatedGenericInstanceClass(genericClassDefinition, genericInst);
}

RuntimeClass* il2cpp_codegen_inflate_generic_class(RuntimeClass* genericClassDefinition, const RuntimeType* p1, /*const RuntimeType*, const RuntimeType* */ ...)
{
    IL2CPP_ASSERT(genericClassDefinition->is_generic);

    const uint32_t genericParameterCount = il2cpp::vm::MetadataCache::GetGenericContainerCount(genericClassDefinition->genericContainerHandle);

    const RuntimeType** types = (const RuntimeType**)alloca(sizeof(RuntimeType*) * genericParameterCount);
    types[0] = p1;

    if (genericParameterCount > 1)
    {
        va_list genericArguments;
        va_start(genericArguments, p1);

        for (uint32_t i = 1; i < genericParameterCount; i++)
            types[i] = va_arg(genericArguments, const RuntimeType*);

        va_end(genericArguments);
    }

    return il2cpp::vm::Class::GetInflatedGenericInstanceClass(genericClassDefinition, il2cpp::vm::MetadataCache::GetGenericInst(types, genericParameterCount));
}

int32_t il2cpp_codgen_class_get_instance_size(RuntimeClass* klass)
{
    return il2cpp::vm::Class::GetInstanceSize(klass);
}

RuntimeClass* il2cpp_codegen_class_from_type_internal(const RuntimeType* type)
{
    return il2cpp::vm::Class::FromIl2CppType(type);
}

char* il2cpp_codegen_marshal_string(String_t* string)
{
    return il2cpp::vm::PlatformInvoke::MarshalCSharpStringToCppString((RuntimeString*)string);
}

void il2cpp_codegen_marshal_string_fixed(String_t* string, char* buffer, int numberOfCharacters)
{
    return il2cpp::vm::PlatformInvoke::MarshalCSharpStringToCppStringFixed((RuntimeString*)string, buffer, numberOfCharacters);
}

Il2CppChar* il2cpp_codegen_marshal_wstring(String_t* string)
{
    return il2cpp::vm::PlatformInvoke::MarshalCSharpStringToCppWString((RuntimeString*)string);
}

void il2cpp_codegen_marshal_wstring_fixed(String_t* string, Il2CppChar* buffer, int numberOfCharacters)
{
    return il2cpp::vm::PlatformInvoke::MarshalCSharpStringToCppWStringFixed((RuntimeString*)string, buffer, numberOfCharacters);
}

Il2CppChar* il2cpp_codegen_marshal_bstring(String_t* string)
{
    return il2cpp::vm::PlatformInvoke::MarshalCSharpStringToCppBString((RuntimeString*)string);
}

String_t* il2cpp_codegen_marshal_string_result(const char* value)
{
    return (String_t*)il2cpp::vm::PlatformInvoke::MarshalCppStringToCSharpStringResult(value);
}

String_t* il2cpp_codegen_marshal_wstring_result(const Il2CppChar* value)
{
    return (String_t*)il2cpp::vm::PlatformInvoke::MarshalCppWStringToCSharpStringResult(value);
}

String_t* il2cpp_codegen_marshal_bstring_result(const Il2CppChar* value)
{
    return (String_t*)il2cpp::vm::PlatformInvoke::MarshalCppBStringToCSharpStringResult(value);
}

void il2cpp_codegen_marshal_free_bstring(Il2CppChar* value)
{
    il2cpp::vm::PlatformInvoke::MarshalFreeBString(value);
}

char* il2cpp_codegen_marshal_empty_string_builder(StringBuilder_t* stringBuilder)
{
    return il2cpp::vm::PlatformInvoke::MarshalEmptyStringBuilder((RuntimeStringBuilder*)stringBuilder);
}

char* il2cpp_codegen_marshal_string_builder(StringBuilder_t* stringBuilder)
{
    return il2cpp::vm::PlatformInvoke::MarshalStringBuilder((RuntimeStringBuilder*)stringBuilder);
}

Il2CppChar* il2cpp_codegen_marshal_empty_wstring_builder(StringBuilder_t* stringBuilder)
{
    return il2cpp::vm::PlatformInvoke::MarshalEmptyWStringBuilder((RuntimeStringBuilder*)stringBuilder);
}

Il2CppChar* il2cpp_codegen_marshal_wstring_builder(StringBuilder_t* stringBuilder)
{
    return il2cpp::vm::PlatformInvoke::MarshalWStringBuilder((RuntimeStringBuilder*)stringBuilder);
}

void il2cpp_codegen_marshal_string_builder_result(StringBuilder_t* stringBuilder, char* buffer)
{
    il2cpp::vm::PlatformInvoke::MarshalStringBuilderResult((RuntimeStringBuilder*)stringBuilder, buffer);
}

void il2cpp_codegen_marshal_wstring_builder_result(StringBuilder_t* stringBuilder, Il2CppChar* buffer)
{
    il2cpp::vm::PlatformInvoke::MarshalWStringBuilderResult((RuntimeStringBuilder*)stringBuilder, buffer);
}

void il2cpp_codegen_marshal_free(void* ptr)
{
    il2cpp::vm::PlatformInvoke::MarshalFree(ptr);
}

Il2CppMethodPointer il2cpp_codegen_marshal_delegate(MulticastDelegate_t* d)
{
    return (Il2CppMethodPointer)il2cpp::vm::PlatformInvoke::MarshalDelegate((RuntimeDelegate*)d);
}

Il2CppDelegate* il2cpp_codegen_marshal_function_ptr_to_delegate_internal(void* functionPtr, Il2CppClass* delegateType)
{
    return il2cpp::vm::PlatformInvoke::MarshalFunctionPointerToDelegate(functionPtr, delegateType);
}

bool il2cpp_codegen_is_marshalled_delegate(MulticastDelegate_t* d)
{
    return il2cpp::vm::PlatformInvoke::IsFakeDelegateMethodMarshaledFromNativeCode((const RuntimeDelegate*)d);
}

Il2CppMethodPointer il2cpp_codegen_resolve(const PInvokeArguments& pinvokeArgs)
{
    return il2cpp::vm::PlatformInvoke::Resolve(pinvokeArgs);
}

Il2CppHString il2cpp_codegen_create_hstring(String_t* str)
{
    return il2cpp::vm::WindowsRuntime::CreateHString(reinterpret_cast<RuntimeString*>(str));
}

String_t* il2cpp_codegen_marshal_hstring_result(Il2CppHString hstring)
{
    return reinterpret_cast<String_t*>(il2cpp::vm::WindowsRuntime::HStringToManagedString(hstring));
}

void il2cpp_codegen_marshal_free_hstring(Il2CppHString hstring)
{
    il2cpp::vm::WindowsRuntime::DeleteHString(hstring);
}

void il2cpp_codegen_marshal_type_to_native(Type_t* type, Il2CppWindowsRuntimeTypeName& nativeType)
{
    return il2cpp::vm::WindowsRuntime::MarshalTypeToNative(type != NULL ? reinterpret_cast<Il2CppReflectionType*>(type)->type : NULL, nativeType);
}

const Il2CppType* il2cpp_codegen_marshal_type_from_native_internal(Il2CppWindowsRuntimeTypeName& nativeType)
{
    return il2cpp::vm::WindowsRuntime::MarshalTypeFromNative(nativeType);
}

void il2cpp_codegen_delete_native_type(Il2CppWindowsRuntimeTypeName& nativeType)
{
    return il2cpp::vm::WindowsRuntime::DeleteNativeType(nativeType);
}

Il2CppIActivationFactory* il2cpp_codegen_windows_runtime_get_activation_factory(const il2cpp::utils::StringView<Il2CppNativeChar>& runtimeClassName)
{
    return il2cpp::vm::WindowsRuntime::GetActivationFactory(runtimeClassName);
}

void il2cpp_codegen_stacktrace_push_frame(Il2CppStackFrameInfo& frame)
{
    il2cpp::vm::StackTrace::PushFrame(frame);
}

void il2cpp_codegen_stacktrace_pop_frame()
{
    il2cpp::vm::StackTrace::PopFrame();
}

void il2cpp_codegen_array_unsafe_mov(RuntimeClass * destClass, void* dest, RuntimeClass * srcClass, void* src)
{
    // A runtime implementation of System.Array::UnsafeMov

    IL2CPP_ASSERT(destClass);
    IL2CPP_ASSERT(dest);
    IL2CPP_ASSERT(srcClass);
    IL2CPP_ASSERT(src);

    uint32_t destSize = il2cpp_codegen_sizeof(destClass);
    uint32_t srcSize = il2cpp_codegen_sizeof(srcClass);

    // If the types are the same size we can just memcpy them
    // otherwise we need to "move" them using the correct casting rules for primitive types
    if (destSize == srcSize)
    {
        il2cpp_codegen_memcpy(dest, src, destSize);
        return;
    }

    const Il2CppType* destType = il2cpp::vm::Class::IsEnum(destClass) ? il2cpp::vm::Class::GetEnumBaseType(destClass) : &destClass->byval_arg;
    const Il2CppType* srcType = il2cpp::vm::Class::IsEnum(srcClass) ? il2cpp::vm::Class::GetEnumBaseType(srcClass) : &srcClass->byval_arg;

    switch (destType->type)
    {
        case IL2CPP_TYPE_BOOLEAN:
            il2cpp_codegen_array_unsafe_mov_primitive<bool>(destType, (bool*)dest, srcType, src);
            break;
        case IL2CPP_TYPE_I1:
            il2cpp_codegen_array_unsafe_mov_primitive<int8_t>(destType, (int8_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_U1:
            il2cpp_codegen_array_unsafe_mov_primitive<uint8_t>(destType, (uint8_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_I2:
            il2cpp_codegen_array_unsafe_mov_primitive<int16_t>(destType, (int16_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_CHAR:
        case IL2CPP_TYPE_U2:
            il2cpp_codegen_array_unsafe_mov_primitive<uint16_t>(destType, (uint16_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_I4:
            il2cpp_codegen_array_unsafe_mov_primitive<int32_t>(destType, (int32_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_U4:
            il2cpp_codegen_array_unsafe_mov_primitive<uint32_t>(destType, (uint32_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_I8:
            il2cpp_codegen_array_unsafe_mov_primitive<int64_t>(destType, (int64_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_U8:
            il2cpp_codegen_array_unsafe_mov_primitive<uint64_t>(destType, (uint64_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_I:
            il2cpp_codegen_array_unsafe_mov_primitive<intptr_t>(destType, (intptr_t *)dest, srcType, src);
            break;
        case IL2CPP_TYPE_U:
            il2cpp_codegen_array_unsafe_mov_primitive<uintptr_t>(destType, (uintptr_t *)dest, srcType, src);
            break;
        default:
            il2cpp_codegen_array_unsafe_mov_type_exception(destType, srcType);
    }
}

NORETURN void il2cpp_codegen_array_unsafe_mov_type_exception(const RuntimeType * destType, const RuntimeType* srcType)
{
    // No other primitive types are supported by Array::UnsafeMov (floating point types are not supported)
    // Or we're trying to assign structs of different sizes

    IL2CPP_ASSERT(false);

    std::string msg;
    msg += "Unsupported call to ";
    msg += il2cpp::vm::Class::GetName(il2cpp::vm::Class::FromIl2CppType(destType));
    msg += " System.Array::UnsafeMov(";
    msg += il2cpp::vm::Class::GetName(il2cpp::vm::Class::FromIl2CppType(srcType));
    msg += ");";
    il2cpp_codegen_raise_exception(il2cpp_codegen_get_not_supported_exception(msg.c_str()));
}

void il2cpp_codegen_runtime_constrained_call(RuntimeClass* type, const RuntimeMethod* constrainedMethod, void* boxBuffer, void* objBuffer, void** args, void* retVal)
{
    // Reference types use a virtual method call
    if (!type->byval_arg.valuetype)
    {
        RuntimeObject* refObj = *(RuntimeObject**)objBuffer;
        NullCheck(refObj);
        const MethodInfo* virtualMethod = il2cpp::vm::Object::GetVirtualMethod(refObj, constrainedMethod);
        virtualMethod->invoker_method(virtualMethod->virtualMethodPointer, virtualMethod, refObj, args, retVal);
    }
    // For value types, the constrained RGCTX does our lookup for us
    else if (type == constrainedMethod->klass)
    {
        il2cpp_codegen_runtime_class_init_inline(type);
        // If the value type overrode the method, do a direct call wiht the pointer to the struct
        constrainedMethod->invoker_method(constrainedMethod->methodPointer, constrainedMethod, objBuffer, args, retVal);
    }
    else if (il2cpp::vm::Class::IsInterface(constrainedMethod->klass))
    {
        // We are invoking a default interface method on a struct
        // We need to box to call the interface method, and the boxing is observable
        IL2CPP_ASSERT(type->byval_arg.valuetype);

        RuntimeObject* boxed = il2cpp::vm::Object::Box(type, objBuffer);
        constrainedMethod->invoker_method(constrainedMethod->methodPointer, constrainedMethod, boxed, args, retVal);
    }
    else
    {
        IL2CPP_ASSERT(constrainedMethod->klass == il2cpp_defaults.object_class || constrainedMethod->klass == il2cpp_defaults.value_type_class || constrainedMethod->klass == il2cpp_defaults.enum_class);

        // The value type did not override the method, so we're making a call to a method declared on
        // System.Object, System.ValueType, or System.Enum so we need to box, but fake boxing should work
        // because these methods will not mutate "this" and we can assume that they do not store the "this" pointer past the call
        if (il2cpp::vm::Class::IsNullable(type))
        {
            if (!il2cpp::vm::Object::NullableHasValue(type, objBuffer))
                il2cpp_codegen_raise_null_reference_exception();
            type = il2cpp::vm::Class::GetNullableArgument(type);
        }

        Il2CppFakeBoxBuffer* boxed = new(boxBuffer) Il2CppFakeBoxBuffer(type, objBuffer);
        constrainedMethod->invoker_method(constrainedMethod->methodPointer, constrainedMethod, boxed, args, retVal);
    }
}

void* il2cpp_codegen_runtime_box_constrained_this(RuntimeClass* type, const RuntimeMethod* constrainedMethod, void* obj)
{
    // We are calling a method defined on the type, no need to box
    IL2CPP_ASSERT(il2cpp::vm::Class::IsValuetype(type));
    if (type == constrainedMethod->klass)
        return obj;

    // We are calling a default interface method with a value type, we have to box
    IL2CPP_ASSERT(il2cpp::vm::Class::IsInterface(constrainedMethod->klass));
    return il2cpp::vm::Object::Box(type, obj);
}

bool il2cpp_codegen_is_reference_or_contains_references(const RuntimeMethod* method)
{
    IL2CPP_ASSERT(il2cpp::vm::Method::IsGenericInstance(method));
    const Il2CppGenericContext* context = il2cpp::metadata::GenericMethod::GetContext(method->genericMethod);

    IL2CPP_ASSERT(context->method_inst);
    IL2CPP_ASSERT(context->method_inst->type_argc == 1);
    IL2CPP_ASSERT(!il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(context->method_inst->type_argv[0], &il2cpp_defaults.il2cpp_fully_shared_type->byval_arg));

    const Il2CppType* type = context->method_inst->type_argv[0];

    if (!type->valuetype)
        return true;

    Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(type);
    il2cpp::vm::ClassInlines::InitFromCodegen(klass);
    return klass->has_references;
}

bool il2cpp_codegen_is_unmanaged(const RuntimeMethod* method)
{
    return !il2cpp_codegen_is_reference_or_contains_references(method);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\codegen\il2cpp-codegen.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\debugger\il2cpp-api-debugger.cpp---------------
.
.
#if defined(RUNTIME_IL2CPP) && !defined(IL2CPP_MONO_DEBUGGER_DISABLED)

// This file implements an extension to the IL2CPP embedding API that the debugger code requires.
// It should not include any Mono headers.

#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-mono-api.h"
#include "il2cpp-api-debugger.h"

#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "metadata/CustomAttributeDataReader.h"
#include "metadata/FieldLayout.h"
#include "metadata/GenericMetadata.h"
#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/AssemblyName.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/GenericContainer.h"
#include "vm/GlobalMetadata.h"
#include "vm/Image.h"
#include "vm/MetadataCache.h"
#include "vm/Object.h"
#include "vm/Property.h"
#include "vm/Reflection.h"
#include "vm-utils/Debugger.h"

#include <algorithm>

struct Il2CppMonoError
{
    unsigned short error_code;
    unsigned short flags;

    void *hidden_1[12];
};

static void error_init(MonoError* error)
{
    auto il2CppError = (Il2CppMonoError*)error;
    il2CppError->error_code = 0;
    il2CppError->flags = 0;
}

extern "C" {
    void* il2cpp_domain_get_agent_info(MonoAppDomain* domain)
    {
        return ((Il2CppDomain*)domain)->agent_info;
    }

    void il2cpp_domain_set_agent_info(MonoAppDomain* domain, void* agentInfo)
    {
        il2cpp::gc::WriteBarrier::GenericStore(&((Il2CppDomain*)domain)->agent_info, agentInfo);
    }

    const char* il2cpp_domain_get_friendly_name(MonoAppDomain* domain)
    {
        return ((Il2CppDomain*)domain)->friendly_name;
    }

    void il2cpp_start_debugger_thread()
    {
#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::StartDebuggerThread();
#endif
    }

    const char* il2cpp_domain_get_name(MonoDomain* domain)
    {
        return ((Il2CppDomain*)domain)->friendly_name;
    }

    Il2CppSequencePoint* il2cpp_get_method_sequence_points(MonoMethod* method, void* *iter)
    {
#if IL2CPP_MONO_DEBUGGER
        if (method == NULL)
            return il2cpp::utils::Debugger::GetAllSequencePoints(iter);
        else
            return (Il2CppSequencePoint*)il2cpp::utils::Debugger::GetSequencePoints((const MethodInfo*)method, iter);
#else
        return NULL;
#endif
    }

    Il2CppCatchPoint* il2cpp_get_method_catch_points(MonoMethod* method, void* *iter)
    {
#if IL2CPP_MONO_DEBUGGER
        return (Il2CppCatchPoint*)il2cpp::utils::Debugger::GetCatchPoints((const MethodInfo*)method, iter);
#else
        return NULL;
#endif
    }

    Il2CppSequencePoint* il2cpp_get_seq_point_from_catch_point(Il2CppCatchPoint *cp)
    {
#if IL2CPP_MONO_DEBUGGER
        return (Il2CppSequencePoint*)il2cpp::utils::Debugger::GetSequencePoint(NULL, cp);
#else
        return NULL;
#endif
    }

    int32_t il2cpp_mono_methods_match(MonoMethod* left, MonoMethod* right)
    {
        MethodInfo* leftMethod = (MethodInfo*)left;
        MethodInfo* rightMethod = (MethodInfo*)right;

        if (rightMethod == leftMethod)
            return 1;
        if (rightMethod == NULL || leftMethod == NULL)
            return 0;
        if (leftMethod->methodMetadataHandle == rightMethod->methodMetadataHandle)
            return 1;

        return 0;
    }

    MonoClass* il2cpp_defaults_object_class()
    {
        return (MonoClass*)il2cpp_defaults.object_class;
    }

    const char* il2cpp_image_name(MonoImage *monoImage)
    {
        Il2CppImage *image = (Il2CppImage*)monoImage;
        return image->name;
    }

    uint8_t* il2cpp_field_get_address(MonoObject *obj, MonoClassField *monoField)
    {
        FieldInfo *field = (FieldInfo*)monoField;
        return (uint8_t*)obj + field->offset;
    }

    MonoClass* il2cpp_defaults_exception_class()
    {
        return (MonoClass*)il2cpp_defaults.exception_class;
    }

    MonoImage* il2cpp_defaults_corlib_image()
    {
        return (MonoImage*)il2cpp_defaults.corlib;
    }

    MonoClass* il2cpp_defaults_runtimetype_class()
    {
        return (MonoClass*)il2cpp_defaults.runtimetype_class;
    }

    bool il2cpp_method_is_string_ctor(const MonoMethod * method)
    {
        MethodInfo* methodInfo = (MethodInfo*)method;
        return methodInfo->klass == il2cpp_defaults.string_class && !strcmp(methodInfo->name, ".ctor");
    }

    MonoClass* il2cpp_defaults_void_class()
    {
        return (MonoClass*)il2cpp_defaults.void_class;
    }

    MonoMethod* il2cpp_get_interface_method(MonoClass* klass, MonoClass* itf, int slot)
    {
        const VirtualInvokeData* data = il2cpp::vm::ClassInlines::GetInterfaceInvokeDataFromVTable((Il2CppClass*)klass, (Il2CppClass*)itf, slot);
        if (!data)
            return NULL;

        return (MonoMethod*)data->method;
    }

    struct TypeIterState
    {
        il2cpp::vm::AssemblyVector* assemblies;
        il2cpp::vm::AssemblyVector::iterator assembly;
        Il2CppImage* image;
        il2cpp::vm::TypeVector types;
        il2cpp::vm::TypeVector::iterator type;
    };

    MonoClass* il2cpp_iterate_loaded_classes(void* *iter)
    {
        if (!iter)
            return NULL;

        if (!*iter)
        {
            TypeIterState *state = new TypeIterState();
            state->assemblies = il2cpp::vm::Assembly::GetAllAssemblies();
            state->assembly = state->assemblies->begin();
            state->image = il2cpp::vm::Assembly::GetImage(*state->assembly);
            il2cpp::vm::Image::GetTypes(state->image, false, &state->types);
            state->type = state->types.begin();
            *iter = state;
            return (MonoClass*)*state->type;
        }

        TypeIterState *state = (TypeIterState*)*iter;

        state->type++;
        if (state->type == state->types.end())
        {
            state->assembly++;
            if (state->assembly == state->assemblies->end())
            {
                delete state;
                *iter = NULL;
                return NULL;
            }

            state->image = il2cpp::vm::Assembly::GetImage(*state->assembly);
            il2cpp::vm::Image::GetTypes(state->image, false, &state->types);
            state->type = state->types.begin();
        }

        return (MonoClass*)*state->type;
    }

    const char** il2cpp_get_source_files_for_type(MonoClass *klass, int *count)
    {
#if IL2CPP_MONO_DEBUGGER
        return il2cpp::utils::Debugger::GetTypeSourceFiles((Il2CppClass*)klass, *count);
#else
        return NULL;
#endif
    }

    MonoMethod* il2cpp_method_get_generic_definition(MonoMethodInflated *imethod)
    {
        MethodInfo *method = (MethodInfo*)imethod;

        if (!method->is_inflated || method->is_generic)
            return NULL;

        return (MonoMethod*)((MethodInfo*)imethod)->genericMethod->methodDefinition;
    }

    MonoGenericInst* il2cpp_method_get_generic_class_inst(MonoMethodInflated *imethod)
    {
        MethodInfo *method = (MethodInfo*)imethod;

        if (!method->is_inflated || method->is_generic)
            return NULL;

        return (MonoGenericInst*)method->genericMethod->context.class_inst;
    }

    MonoClass* il2cpp_generic_class_get_container_class(MonoGenericClass *gclass)
    {
        return (MonoClass*)il2cpp::vm::GenericClass::GetTypeDefinition((Il2CppGenericClass*)gclass);
    }

    Il2CppSequencePoint* il2cpp_get_sequence_point(MonoImage* image, int id)
    {
#if IL2CPP_MONO_DEBUGGER
        return il2cpp::utils::Debugger::GetSequencePoint((const Il2CppImage*)image, id);
#else
        return NULL;
#endif
    }

    char* il2cpp_assembly_get_full_name(MonoAssembly *assembly)
    {
        std::string s = il2cpp::vm::AssemblyName::AssemblyNameToString(((Il2CppAssembly*)assembly)->aname);
        return il2cpp::utils::StringUtils::StringDuplicate(s.c_str());
    }

    const MonoMethod* il2cpp_get_seq_point_method(Il2CppSequencePoint *seqPoint)
    {
#if IL2CPP_MONO_DEBUGGER
        return (const MonoMethod*)il2cpp::utils::Debugger::GetSequencePointMethod(NULL, seqPoint);
#else
        return NULL;
#endif
    }

    const MonoClass* il2cpp_get_class_from_index(int index)
    {
        if (index < 0)
            return NULL;

        return (const MonoClass*)il2cpp::vm::MetadataCache::GetTypeInfoFromTypeIndex(NULL, index);
    }

    const MonoType* il2cpp_type_inflate(MonoType* type, const MonoGenericContext* context)
    {
        return (MonoType*)il2cpp::metadata::GenericMetadata::InflateIfNeeded((Il2CppType*)type, (const Il2CppGenericContext*)context, true);
    }

    void il2cpp_debugger_get_method_execution_context_and_header_info(const MonoMethod* method, uint32_t* executionContextInfoCount, const Il2CppMethodExecutionContextInfo **executionContextInfo, const Il2CppMethodHeaderInfo **headerInfo, const Il2CppMethodScope **scopes)
    {
#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::GetMethodExecutionContextInfo((const MethodInfo*)method, executionContextInfoCount, executionContextInfo, headerInfo, scopes);
#endif
    }

    Il2CppThreadUnwindState* il2cpp_debugger_get_thread_context()
    {
#if IL2CPP_MONO_DEBUGGER
        return il2cpp::utils::Debugger::GetThreadStatePointer();
#else
        return NULL;
#endif
    }

    Il2CppSequencePointSourceFile* il2cpp_debug_get_source_file(MonoImage* image, int index)
    {
        return ((Il2CppImage*)image)->codeGenModule->debuggerMetadata->sequencePointSourceFiles + index;
    }

    MonoMethod* il2cpp_get_generic_method_definition(MonoMethod* method)
    {
        return (MonoMethod*)((MethodInfo*)method)->genericMethod->methodDefinition;
    }

    bool il2cpp_class_is_initialized(MonoClass* klass)
    {
        return ((Il2CppClass*)klass)->initialized_and_no_error;
    }

    int il2cpp_generic_inst_get_argc(MonoGenericInst* inst)
    {
        return ((Il2CppGenericInst*)inst)->type_argc;
    }

    MonoType* il2cpp_generic_inst_get_argv(MonoGenericInst* inst, int index)
    {
        return (MonoType*)((Il2CppGenericInst*)inst)->type_argv[index];
    }

    MonoObject* il2cpp_assembly_get_object(MonoDomain* domain, MonoAssembly* assembly, MonoError* error)
    {
        return (MonoObject*)il2cpp::vm::Reflection::GetAssemblyObject((const Il2CppAssembly *)assembly);
    }

    const MonoType* il2cpp_get_type_from_index(int index)
    {
        return (const MonoType*)il2cpp::vm::MetadataCache::GetIl2CppTypeFromIndex(NULL, index);
    }

    void il2cpp_thread_info_safe_suspend_and_run(size_t /*Really MonoNativeThreadId*/ id, int32_t interrupt_kernel, MonoSuspendThreadCallback callback, void* user_data)
    {
        callback(NULL, user_data);
    }

    MonoGenericParam* il2cpp_generic_container_get_param(MonoGenericContainer *gc, int i)
    {
        return (MonoGenericParam*)il2cpp::vm::GenericContainer::GetGenericParameter((Il2CppMetadataGenericContainerHandle)gc, i);
    }

    void il2cpp_field_static_get_value_checked(MonoVTable* vt, MonoClassField* field, void* value, MonoError* error)
    {
        error_init(error);
        il2cpp::vm::Field::StaticGetValue((FieldInfo*)field, value);
    }

    void il2cpp_field_static_get_value_for_thread(MonoInternalThread* thread, MonoVTable* vt, MonoClassField* field, void* value, MonoError* error)
    {
        error_init(error);
        il2cpp::vm::Field::StaticGetValueForThread((FieldInfo*)field, value, (Il2CppInternalThread*)thread);
    }

    static bool IsFixedBufferAttribute(const MethodInfo* ctor)
    {
        const Il2CppClass* klass = ctor->klass;

        return strcmp(klass->name, "FixedBufferAttribute") == 0 &&
            strcmp(klass->namespaze, "System.Runtime.CompilerServices") == 0;
    }

    static bool IsInt32Type(Il2CppClass* klass)
    {
        return klass == il2cpp_defaults.int32_class;
    }

    struct FixedBufferAttributeConstructorVisitor : public il2cpp::metadata::CustomAttributeReaderVisitor
    {
        FixedBufferAttributeConstructorVisitor() : FixedArraySize(1) {}

        int32_t FixedArraySize;
        virtual void VisitCtor(const MethodInfo* ctor, il2cpp::metadata::CustomAttributeArgument args[], uint32_t argumentCount)
        {
            if (argumentCount == 2 && IsInt32Type(args[1].klass))
                FixedArraySize = *(int32_t*)&args[1].data;
        }
    };

    int32_t il2cpp_field_get_fixed_array_size(MonoClassField* field)
    {
        FieldInfo* il2cppField = (FieldInfo*)field;

        Il2CppMetadataCustomAttributeHandle attributeHandle = il2cpp::vm::MetadataCache::GetCustomAttributeTypeToken(il2cppField->parent->image, il2cppField->token);
        if (attributeHandle == NULL)
            return 1;

        auto reader = il2cpp::vm::GlobalMetadata::GetCustomAttributeDataReader(attributeHandle);

        Il2CppException* exc = NULL;
        il2cpp::metadata::CustomAttributeDataIterator iter = reader.GetDataIterator(IsFixedBufferAttribute);
        FixedBufferAttributeConstructorVisitor visitor;
        // Assume there is only one fixed buffer attribute - we will use the first one.
        if (reader.VisitCustomAttributeData(&iter, &visitor, &exc))
        {
            if (exc == NULL)
                return visitor.FixedArraySize;
        }

        return 1;
    }

    class DebuggerCustomAttributeVisitor : public il2cpp::metadata::CustomAttributeReaderVisitor
    {
    public:
        DebuggerCustomAttributeVisitor(Il2CppCustomAttributeDataList* attrs) : m_propertyIndexOffset(0), m_currentAttributeIndex(-1), m_attrs(attrs) {}

        virtual void MoveNext(const MethodInfo* ctor)
        {
            ++m_currentAttributeIndex;
            m_propertyIndexOffset = 0;
            IL2CPP_ASSERT(m_currentAttributeIndex < m_attrs->numberOfAttributes);
            m_attributeData = m_attrs->attributeData + m_currentAttributeIndex;
        }

        virtual void VisitArgumentSizes(uint32_t argumentCount, uint32_t fieldCount, uint32_t propertyCount)
        {
            m_attributeData->typedArgs = argumentCount == 0 ? nullptr : il2cpp::vm::Array::New(il2cpp_defaults.object_class, argumentCount);
            il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)&m_attributeData->typedArgs);

            int32_t numberOfNamedArguments = fieldCount + propertyCount;
            m_attributeData->namedArgs = numberOfNamedArguments == 0 ? nullptr : il2cpp::vm::Array::New(il2cpp_defaults.object_class, numberOfNamedArguments);
            il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)&m_attributeData->namedArgs);

            m_propertyIndexOffset = fieldCount;
            m_attributeData->argInfo = numberOfNamedArguments == 0 ? nullptr : (Il2CppCattrNamedArg*)IL2CPP_CALLOC(numberOfNamedArguments, sizeof(Il2CppCattrNamedArg));
        }

        virtual void VisitArgument(const il2cpp::metadata::CustomAttributeArgument& argument, uint32_t index)
        {
            AddArgumentValueToArray(m_attributeData->typedArgs, argument, index);
        }

        virtual void VisitCtor(const MethodInfo* ctor, il2cpp::metadata::CustomAttributeArgument args[], uint32_t argumentCount)
        {
            m_attributeData->ctor = ctor;
        }

        virtual void VisitField(const il2cpp::metadata::CustomAttributeFieldArgument& field, uint32_t index)
        {
            AddArgumentValueToArray(m_attributeData->namedArgs, field.arg, index);
            m_attributeData->argInfo[index].type = field.field->type;
            m_attributeData->argInfo[index].field = field.field;
        }

        virtual void VisitProperty(const il2cpp::metadata::CustomAttributePropertyArgument& prop, uint32_t index)
        {
            AddArgumentValueToArray(m_attributeData->namedArgs, prop.arg, index + m_propertyIndexOffset);
            m_attributeData->argInfo[index + m_propertyIndexOffset].type = il2cpp::vm::Property::GetType(prop.prop);
            m_attributeData->argInfo[index + m_propertyIndexOffset].prop = prop.prop;
        }

    private:
        int32_t m_propertyIndexOffset;
        int32_t m_currentAttributeIndex;
        Il2CppCustomAttributeData* m_attributeData;
        Il2CppCustomAttributeDataList* m_attrs;

        static void AddArgumentValueToArray(Il2CppArray* array, const il2cpp::metadata::CustomAttributeArgument arg, uint32_t index)
        {
            Il2CppObject* argumentValue = il2cpp::vm::Class::IsValuetype(arg.klass) ? il2cpp::vm::Object::Box(arg.klass, (void*)&arg.data) : reinterpret_cast<Il2CppObject*>(arg.data.obj);
            il2cpp_array_setref(array, index, argumentValue);
        }
    };

    static void free_custom_attribute_data(Il2CppCustomAttributeData* attr)
    {
        if (attr->argInfo != NULL)
            IL2CPP_FREE(attr->argInfo);
    }

    static Il2CppCustomAttributeDataList EmptyDataList = { 0 };

    void il2cpp_free_custom_attribute_data_list(Il2CppCustomAttributeDataList* attrs)
    {
        if (attrs == &EmptyDataList)
            return;

        for (int32_t i = 0; i < attrs->numberOfAttributes; ++i)
            free_custom_attribute_data(attrs->attributeData + i);

        il2cpp::gc::GarbageCollector::FreeFixed(attrs);
    }

    const Il2CppCustomAttributeDataList* il2cpp_get_custom_attribute_data_list(MonoClass* attr_klass, MonoCustomAttrInfo* cinfo, MonoImage* image)
    {
        // Get a reader to access the attribute data.
        auto reader = il2cpp::vm::GlobalMetadata::GetCustomAttributeDataReader((Il2CppMetadataCustomAttributeHandle)cinfo);

        auto filter = [attr_klass](const MethodInfo* ctor)
            {
                return attr_klass == NULL || il2cpp::vm::Class::HasParent(ctor->klass, (Il2CppClass*)attr_klass);
            };

        uint32_t count = reader.GetCount(filter);

        if (count == 0)
            return &EmptyDataList;

        // Allocate a structure to hold the data for all attributes.
        Il2CppCustomAttributeDataList* attrs = (Il2CppCustomAttributeDataList*)il2cpp::gc::GarbageCollector::AllocateFixed(sizeof(Il2CppCustomAttributeDataList) + (count * sizeof(Il2CppCustomAttributeData)), NULL);
        attrs->numberOfAttributes = count;

        uint32_t createdAttributes = 0;
        il2cpp::metadata::CustomAttributeDataIterator iter = reader.GetDataIterator(filter);
        Il2CppException* exc = NULL;
        DebuggerCustomAttributeVisitor visitor(attrs);
        while (reader.VisitCustomAttributeData(&iter, &visitor, &exc))
        {
            createdAttributes++;
        }

        // If an error occurred, we don't have a great way to communicate what it is. Just return NULL and let the client handle
        // it in a general way.
        if (exc != NULL)
        {
            // Reset the number of created attributes, so we only free that many
            attrs->numberOfAttributes = createdAttributes;
            il2cpp_free_custom_attribute_data_list(attrs);
            return NULL;
        }

        return attrs;
    }

    MonoType* il2cpp_class_get_byval_arg(MonoClass* klass)
    {
        return (MonoType*)&((Il2CppClass*)klass)->byval_arg;
    }
}

#endif // RUNTIME_IL2CPP
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\debugger\il2cpp-api-debugger.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\BoehmGC.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_GC_BOEHM

#include <stdint.h>
#include "gc_wrapper.h"
#include "GarbageCollector.h"
#include "WriteBarrier.h"
#include "WriteBarrierValidation.h"
#include "os/Mutex.h"
#include "vm/Array.h"
#include "vm/Domain.h"
#include "vm/Profiler.h"
#include "utils/Il2CppHashMap.h"
#include "utils/HashUtils.h"
#include "il2cpp-object-internals.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

static bool s_GCInitialized = false;

#if IL2CPP_ENABLE_DEFERRED_GC
static bool s_PendingGC = false;
#endif

static void on_gc_event(GC_EventType eventType);
#if IL2CPP_ENABLE_PROFILER
using il2cpp::vm::Profiler;
static void on_heap_resize(GC_word newSize);
#endif

static GC_push_other_roots_proc default_push_other_roots;
typedef Il2CppHashMap<char*, char*, il2cpp::utils::PassThroughHash<char*> > RootMap;
static RootMap s_Roots;
static void push_other_roots(void);

typedef struct ephemeron_node ephemeron_node;
static ephemeron_node* ephemeron_list;

static void
clear_ephemerons(void);

static GC_ms_entry*
push_ephemerons(GC_ms_entry* mark_stack_ptr, GC_ms_entry* mark_stack_limit);

static unsigned push_roots_proc_index;

static GC_ms_entry*
push_roots(GC_word* addr, GC_ms_entry* mark_stack_ptr, GC_ms_entry* mark_stack_limit, GC_word env);

#if !IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION
#define ELEMENT_CHUNK_SIZE 256
#define VECTOR_PROC_INDEX 6

#define BYTES_PER_WORD (sizeof(GC_word))

#include <gc_vector.h>

GC_ms_entry* GC_gcj_vector_proc(GC_word* addr, GC_ms_entry* mark_stack_ptr,
    GC_ms_entry* mark_stack_limit, GC_word env)
{
    Il2CppArraySize* a = NULL;
    if (env)
    {
        IL2CPP_ASSERT(env == 1);

        a = (Il2CppArraySize*)GC_base(addr);
    }
    else
    {
        IL2CPP_ASSERT(addr == GC_base(addr));

        a = (Il2CppArraySize*)addr;
    }

    if (!a->max_length)
        return mark_stack_ptr;

    il2cpp_array_size_t length = a->max_length;
    Il2CppClass* array_type = a->vtable->klass;
    Il2CppClass* element_type = array_type->element_class;
    GC_descr element_desc = (GC_descr)element_type->gc_desc;

    IL2CPP_ASSERT((element_desc & GC_DS_TAGS) == GC_DS_BITMAP);
    IL2CPP_ASSERT(element_type->byval_arg.valuetype);

    int words_per_element = array_type->element_size / BYTES_PER_WORD;
    GC_word* actual_start = (GC_word*)a->vector;

    /* start at first element or resume from last iteration */
    GC_word* start = env ? addr : actual_start;
    /* end at last element or max chunk size */
    GC_word* actual_end = actual_start + length * words_per_element;

    return GC_gcj_vector_mark_proc(mark_stack_ptr, mark_stack_limit, element_desc, start, actual_end, words_per_element);
}

#endif // !IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION

void
il2cpp::gc::GarbageCollector::Initialize()
{
    if (s_GCInitialized)
        return;

#if IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION
    il2cpp::gc::WriteBarrierValidation::Setup();
#endif
    // This tells the GC that we are not scanning dynamic library data segments and that
    // the GC tracked data structures need ot be manually pushed and marked.
    // Call this before GC_INIT since the initialization logic uses this value.
    GC_set_no_dls(1);

#if !IL2CPP_DEVELOPMENT
    // Turn off GC logging and warnings for non-development builds
    GC_set_warn_proc(GC_ignore_warn_proc);
#endif

#if IL2CPP_ENABLE_WRITE_BARRIERS
    GC_enable_incremental();
#if IL2CPP_INCREMENTAL_TIME_SLICE
    GC_set_time_limit(IL2CPP_INCREMENTAL_TIME_SLICE);
#endif
#endif

    push_roots_proc_index = GC_new_proc(push_roots);
    default_push_other_roots = GC_get_push_other_roots();
    GC_set_push_other_roots(push_other_roots);
    GC_set_mark_stack_empty(push_ephemerons);

    GC_set_on_collection_event(&on_gc_event);
#if IL2CPP_ENABLE_PROFILER
    GC_set_on_heap_resize(&on_heap_resize);
#endif

    GC_INIT();
    // Always manually trigger finalizers. This is done by the notifier callback registered
    // below on the majority of platforms. On the Web platform we trigger finalizers if needed
    // in CollectALittle which is called at top of each frame.
    GC_set_finalize_on_demand(1);
#if defined(GC_THREADS)
    GC_set_finalizer_notifier(&il2cpp::gc::GarbageCollector::NotifyFinalizers);
    // We need to call this if we want to manually register threads, i.e. GC_register_my_thread
    #if !IL2CPP_TARGET_JAVASCRIPT
    GC_allow_register_threads();
    #endif
#endif
#ifdef GC_GCJ_SUPPORT
    GC_init_gcj_malloc(0, NULL);
#endif

#if !IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION
    GC_init_gcj_vector(VECTOR_PROC_INDEX, (void*)GC_gcj_vector_proc);
#endif
    s_GCInitialized = true;
}

void il2cpp::gc::GarbageCollector::UninitializeGC()
{
#if IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION
    il2cpp::gc::WriteBarrierValidation::Run();
#endif
    GC_deinit();
#if IL2CPP_ENABLE_RELOAD
    s_GCInitialized = false;
    default_push_other_roots = NULL;
    s_Roots.clear();
#endif
}

int32_t
il2cpp::gc::GarbageCollector::GetCollectionCount(int32_t generation)
{
    return (int32_t)GC_get_gc_no();
}

int32_t
il2cpp::gc::GarbageCollector::GetMaxGeneration()
{
    return 0;
}

void
il2cpp::gc::GarbageCollector::Collect(int maxGeneration)
{
#if IL2CPP_ENABLE_DEFERRED_GC
    if (GC_is_disabled())
        s_PendingGC = true;
#endif
    GC_gcollect();
}

int32_t
il2cpp::gc::GarbageCollector::CollectALittle()
{
#if IL2CPP_ENABLE_DEFERRED_GC
    // This should only be called from Unity at the top of stack
    // with the GC enabled.

    IL2CPP_ASSERT(!GC_is_disabled());
    int32_t ret = 0;
    if (s_PendingGC)
    {
        s_PendingGC = false;
        GC_gcollect();
        ret = 0; // no more work to do
    }
    else
    {
        ret = GC_collect_a_little();
    }

    // Disable the GC to run finalizers, as they may allocate and interact with managed memory.
    GC_disable();
    // this checks and only runs finalizers if there is work to do
    GarbageCollector::WaitForPendingFinalizers();
    GC_enable();
    return ret;
#else
    return GC_collect_a_little();
#endif
}

void
il2cpp::gc::GarbageCollector::StartIncrementalCollection()
{
    GC_start_incremental_collection();
}

#if IL2CPP_ENABLE_WRITE_BARRIERS
void
il2cpp::gc::GarbageCollector::SetWriteBarrier(void **ptr)
{
    GC_END_STUBBORN_CHANGE(ptr);
}

#endif

int64_t
il2cpp::gc::GarbageCollector::GetUsedHeapSize(void)
{
    return GC_get_heap_size() - GC_get_free_bytes();
}

int64_t
il2cpp::gc::GarbageCollector::GetAllocatedHeapSize(void)
{
    return GC_get_heap_size();
}

void
il2cpp::gc::GarbageCollector::Disable()
{
    GC_disable();
}

void
il2cpp::gc::GarbageCollector::Enable()
{
    GC_enable();
}

bool
il2cpp::gc::GarbageCollector::IsDisabled()
{
    return GC_is_disabled();
}

static baselib::ReentrantLock s_GCSetModeLock;
static Il2CppGCMode s_CurrentGCMode = IL2CPP_GC_MODE_ENABLED;

void
il2cpp::gc::GarbageCollector::SetMode(Il2CppGCMode mode)
{
    os::FastAutoLock lock(&s_GCSetModeLock);
    switch (mode)
    {
        case IL2CPP_GC_MODE_ENABLED:
            if (s_CurrentGCMode == IL2CPP_GC_MODE_DISABLED)
                GC_enable();
            GC_set_disable_automatic_collection(false);
            break;

        case IL2CPP_GC_MODE_DISABLED:
            if (s_CurrentGCMode != IL2CPP_GC_MODE_DISABLED)
                GC_disable();
            break;

        case IL2CPP_GC_MODE_MANUAL:
            if (s_CurrentGCMode == IL2CPP_GC_MODE_DISABLED)
                GC_enable();
            GC_set_disable_automatic_collection(true);
            break;
    }

    s_CurrentGCMode = mode;
}

void
il2cpp::gc::GarbageCollector::RegisterThread()
{
#if defined(GC_THREADS) && !IL2CPP_TARGET_JAVASCRIPT
    struct GC_stack_base sb;
    int res;

    res = GC_get_stack_base(&sb);
    if (res != GC_SUCCESS)
    {
        /* Can't determine the register stack bounds */
        IL2CPP_ASSERT(false && "GC_get_stack_base () failed, aborting.");
        /* Abort we can't scan the stack, so we can't use the GC */
        abort();
    }
    res = GC_register_my_thread(&sb);
    if ((res != GC_SUCCESS) && (res != GC_DUPLICATE))
    {
        IL2CPP_ASSERT(false && "GC_register_my_thread () failed.");
        /* Abort we can't use the GC on this thread, so we can't run managed code */
        abort();
    }
#endif
}

bool
il2cpp::gc::GarbageCollector::UnregisterThread()
{
#if defined(GC_THREADS) && !IL2CPP_TARGET_JAVASCRIPT
    int res;

    res = GC_unregister_my_thread();
    if (res != GC_SUCCESS)
        IL2CPP_ASSERT(false && "GC_unregister_my_thread () failed.");

    return res == GC_SUCCESS;
#else
    return true;
#endif
}

il2cpp::gc::GarbageCollector::FinalizerCallback il2cpp::gc::GarbageCollector::RegisterFinalizerWithCallback(Il2CppObject* obj, FinalizerCallback callback)
{
    FinalizerCallback oldCallback;
    void* oldData;
    GC_REGISTER_FINALIZER_NO_ORDER((char*)obj, callback, NULL, &oldCallback, &oldData);
    IL2CPP_ASSERT(oldData == NULL);
    return oldCallback;
}

void
il2cpp::gc::GarbageCollector::AddWeakLink(void **link_addr, Il2CppObject *obj, bool track)
{
    /* libgc requires that we use HIDE_POINTER... */
    *link_addr = (void*)GC_HIDE_POINTER(obj);
    // need this since our strings are not real objects
    if (GC_is_heap_ptr(obj))
        GC_GENERAL_REGISTER_DISAPPEARING_LINK(link_addr, obj);
}

void
il2cpp::gc::GarbageCollector::RemoveWeakLink(void **link_addr)
{
    Il2CppObject*  obj = GarbageCollector::GetWeakLink(link_addr);
    if (GC_is_heap_ptr(obj))
        GC_unregister_disappearing_link(link_addr);
    *link_addr = NULL;
}

static void*
RevealLink(void* link_addr)
{
    void **link_a = (void**)link_addr;
    return GC_REVEAL_POINTER(*link_a);
}

Il2CppObject*
il2cpp::gc::GarbageCollector::GetWeakLink(void **link_addr)
{
    Il2CppObject *obj = (Il2CppObject*)GC_call_with_alloc_lock(RevealLink, link_addr);
    if (obj == (Il2CppObject*)-1)
        return NULL;
    return obj;
}

void*
il2cpp::gc::GarbageCollector::MakeDescriptorForObject(size_t *bitmap, int numbits)
{
#ifdef GC_GCJ_SUPPORT

    /* It seems there are issues when the bitmap doesn't fit: play it safe */
#define MAX_GC_DESCR_BITS   (IL2CPP_SIZEOF_VOID_P * 8 - GC_DS_TAG_BITS)

    if (numbits >= MAX_GC_DESCR_BITS)
        return GC_NO_DESCRIPTOR;
    else
    {
        GC_descr desc = GC_make_descriptor((GC_bitmap)bitmap, numbits);
        // we should always have a GC_DS_BITMAP descriptor, as we:
        // 1) Always want a precise marker.
        // 2) Can never be GC_DS_LENGTH since we always have an object header
        //    at the beginning of the allocation.
        IL2CPP_ASSERT((desc & GC_DS_TAGS) == GC_DS_BITMAP || (desc & GC_DS_TAGS) == (GC_descr)GC_NO_DESCRIPTOR);
        return (void*)desc;
    }
#else
    return 0;
#endif
}

void* il2cpp::gc::GarbageCollector::MakeEmptyDescriptor()
{
    return GC_NO_DESCRIPTOR;
}

void* il2cpp::gc::GarbageCollector::MakeDescriptorForString()
{
    return GC_NO_DESCRIPTOR;
}

void* il2cpp::gc::GarbageCollector::MakeDescriptorForArray()
{
    return GC_NO_DESCRIPTOR;
}

void il2cpp::gc::GarbageCollector::StopWorld()
{
    GC_stop_world_external();
}

void il2cpp::gc::GarbageCollector::StartWorld()
{
    GC_start_world_external();
}

void*
il2cpp::gc::GarbageCollector::AllocateFixed(size_t size, void *descr)
{
    // Note that we changed the implementation from mono.
    // In our case, we expect that
    // a) This memory will never be moved
    // b) This memory will be scanned for references
    // c) This memory will remain 'alive' until explicitly freed
    // GC_MALLOC_UNCOLLECTABLE fulfills all these requirements
    // It does not accept a descriptor, but there was only one
    // or two places in mono that pass a descriptor to this routine
    // and we can or will support those use cases in a different manner.
    IL2CPP_ASSERT(!descr);

    return GC_MALLOC_UNCOLLECTABLE(size);
}

void
il2cpp::gc::GarbageCollector::FreeFixed(void* addr)
{
    GC_FREE(addr);
}

int32_t
il2cpp::gc::GarbageCollector::InvokeFinalizers()
{
    return (int32_t)GC_invoke_finalizers();
}

bool
il2cpp::gc::GarbageCollector::HasPendingFinalizers()
{
    return GC_should_invoke_finalizers() != 0;
}

int64_t
il2cpp::gc::GarbageCollector::GetMaxTimeSliceNs()
{
    return GC_get_time_limit_ns();
}

void
il2cpp::gc::GarbageCollector::SetMaxTimeSliceNs(int64_t maxTimeSlice)
{
    GC_set_time_limit_ns(maxTimeSlice);
}

bool
il2cpp::gc::GarbageCollector::IsIncremental()
{
    return GC_is_incremental_mode();
}

void on_gc_event(GC_EventType eventType)
{
    if (eventType == GC_EVENT_RECLAIM_START)
    {
        clear_ephemerons();
    }
#if IL2CPP_ENABLE_PROFILER
    Profiler::GCEvent((Il2CppGCEvent)eventType);
#endif
}

#if IL2CPP_ENABLE_PROFILER

void on_heap_resize(GC_word newSize)
{
    Profiler::GCHeapResize((int64_t)newSize);
}

#endif // IL2CPP_ENABLE_PROFILER

typedef struct
{
    void* user_data;
    il2cpp::gc::GarbageCollector::HeapSectionCallback callback;
} HeapSectionExecutionContext;

static void HeapSectionAdaptor(void* userData, GC_PTR chunk_start, GC_PTR chunk_end, GC_heap_section_type type)
{
    HeapSectionExecutionContext* ctx = (HeapSectionExecutionContext*)userData;
    ctx->callback(ctx->user_data, chunk_start, chunk_end);
}

void il2cpp::gc::GarbageCollector::ForEachHeapSection(void* user_data, HeapSectionCallback callback)
{
    HeapSectionExecutionContext ctx {user_data, callback};
    GC_foreach_heap_section(&ctx, HeapSectionAdaptor);
}

static void HeapSectionCountIncrementer(void* userData, GC_PTR start, GC_PTR end, GC_heap_section_type type)
{
    size_t* countPtr = (size_t*)userData;
    (*countPtr)++;
}

size_t il2cpp::gc::GarbageCollector::GetSectionCount()
{
    size_t counter = 0;
    GC_foreach_heap_section(&counter, HeapSectionCountIncrementer);
    return counter;
}

void* il2cpp::gc::GarbageCollector::CallWithAllocLockHeld(GCCallWithAllocLockCallback callback, void* user_data)
{
    return GC_call_with_alloc_lock(callback, user_data);
}

typedef struct
{
    char *start;
    char *end;
} RootData;


static void*
register_root(void* arg)
{
    RootData* root_data = (RootData*)arg;
    s_Roots.insert(std::make_pair(root_data->start, root_data->end));
    return NULL;
}

void il2cpp::gc::GarbageCollector::RegisterRoot(char *start, size_t size)
{
    RootData root_data;
    root_data.start = start;
    /* Boehm root processing requires one byte past end of region to be scanned */
    root_data.end = start + size + 1;
    CallWithAllocLockHeld(register_root, &root_data);
}

static void*
deregister_root(void* arg)
{
    s_Roots.erase((char*)arg);
    return NULL;
}

void il2cpp::gc::GarbageCollector::UnregisterRoot(char* start)
{
    GC_call_with_alloc_lock(deregister_root, start);
}

static GC_ms_entry*
push_roots(GC_word* addr, GC_ms_entry* mark_stack_ptr, GC_ms_entry* mark_stack_limit, GC_word env)
{
    auto size = s_Roots.size();

    GC_word capacity = (GC_word)(mark_stack_limit - mark_stack_ptr) - 1;
    GC_word start_index = (GC_word)(intptr_t)addr;
    GC_word remaining = size - start_index;
    GC_word skip = start_index;

    /* if we have more items than capacity, push remaining immediately. This allows pushed
     * items to be processed on top of stack before we process remainder. If we push remainder
     * at top, we have no mark stack space.
     */
    if (remaining > capacity)
    {
        capacity--;
        mark_stack_ptr = GC_custom_push_proc(GC_MAKE_PROC(push_roots_proc_index, (start_index + capacity)), (void*)(start_index + capacity), mark_stack_ptr, mark_stack_limit);
    }

    for (RootMap::const_iterator iter = s_Roots.begin(); iter != s_Roots.end() && capacity > 0; ++iter)
    {
        if (skip)
        {
            skip--;
            continue;
        }

        mark_stack_ptr = GC_custom_push_range(iter->first, iter->second, mark_stack_ptr, mark_stack_limit);

        capacity--;
    }
    return mark_stack_ptr;
}

static void
push_other_roots(void)
{
    if (push_roots_proc_index)
        GC_push_proc(GC_MAKE_PROC(push_roots_proc_index, 0), NULL);

    GC_push_all(&ephemeron_list, &ephemeron_list + 1);
    if (default_push_other_roots)
        default_push_other_roots();
}

struct ephemeron_node
{
    ephemeron_node* next;
    void* ephemeron_array_weak_link;
};


static void*
ephemeron_array_add(void* arg)
{
    ephemeron_node* item = (ephemeron_node*)arg;
    ephemeron_node* current = ephemeron_list;
    il2cpp::gc::WriteBarrier::GenericStore(&item->next, current);
    ephemeron_list = item;

    return NULL;
}

struct Ephemeron
{
    Il2CppObject* key;
    Il2CppObject* value;
};

static void
clear_ephemerons(void)
{
    ephemeron_node* prev_node = NULL;
    ephemeron_node* current_node = NULL;

    /* iterate all registered Ephemeron[] */
    for (current_node = ephemeron_list; current_node; current_node = current_node->next)
    {
        Ephemeron* current_ephemeron, * array_end;
        Il2CppObject* tombstone = NULL;
        /* reveal weak link value*/
        Il2CppArray* array = (Il2CppArray*)GC_REVEAL_POINTER(current_node->ephemeron_array_weak_link);

        /* remove unmarked (non-reachable) arrays from the list */
        if (!GC_is_marked(array))
        {
            if (prev_node == NULL)
                il2cpp::gc::WriteBarrier::GenericStore(&ephemeron_list, current_node->next);
            else
                il2cpp::gc::WriteBarrier::GenericStore(&prev_node->next, current_node->next);
            continue;
        }

        prev_node = current_node;

        current_ephemeron = il2cpp_array_addr(array, Ephemeron, 0);
        array_end = current_ephemeron + array->max_length;
        tombstone = il2cpp::vm::Domain::GetCurrent()->ephemeron_tombstone;

        for (; current_ephemeron < array_end; ++current_ephemeron)
        {
            /* skip a null or tombstone (empty) key */
            if (!current_ephemeron->key || current_ephemeron->key == tombstone)
                continue;

            /* If the key is not marked, then set it to the tombstone and the value to NULL. */
            if (!GC_is_marked(current_ephemeron->key))
            {
                il2cpp::gc::WriteBarrier::GenericStore(&current_ephemeron->key, tombstone);
                current_ephemeron->value = NULL;
            }
        }
    }
}

static GC_ms_entry*
push_ephemerons(GC_ms_entry* mark_stack_ptr, GC_ms_entry* mark_stack_limit)
{
    ephemeron_node* prev_node = NULL;
    ephemeron_node* current_node = NULL;

    /* iterate all registered Ephemeron[] */
    for (current_node = ephemeron_list; current_node; current_node = current_node->next)
    {
        Ephemeron* current_ephemeron, * array_end;
        Il2CppObject* tombstone = NULL;
        /* reveal weak link value*/
        Il2CppArray* array = (Il2CppArray*)GC_REVEAL_POINTER(current_node->ephemeron_array_weak_link);

        /* unreferenced array */
        if (!GC_is_marked(array))
        {
            continue;
        }

        prev_node = current_node;

        current_ephemeron = il2cpp_array_addr(array, Ephemeron, 0);
        array_end = current_ephemeron + array->max_length;
        tombstone = il2cpp::vm::Domain::GetCurrent()->ephemeron_tombstone;

        for (; current_ephemeron < array_end; ++current_ephemeron)
        {
            /* skip a null or tombstone (empty) key */
            if (!current_ephemeron->key || current_ephemeron->key == tombstone)
                continue;

            /* If the key is not marked, then don't mark value. */
            if (!GC_is_marked(current_ephemeron->key))
                continue;

            if (current_ephemeron->value)
            {
                mark_stack_ptr = GC_mark_and_push((void*)current_ephemeron->value, mark_stack_ptr, mark_stack_limit, (void**)&current_ephemeron->value);
            }
        }
    }

    return mark_stack_ptr;
}

bool il2cpp::gc::GarbageCollector::EphemeronArrayAdd(Il2CppObject* obj)
{
    ephemeron_node* item = (ephemeron_node*)GC_MALLOC(sizeof(ephemeron_node));
    memset(item, 0, sizeof(ephemeron_node));

    AddWeakLink(&item->ephemeron_array_weak_link, obj, false);

    GC_call_with_alloc_lock(ephemeron_array_add, item);
    return true;
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\BoehmGC.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\GarbageCollector.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "GarbageCollector.h"
#include "os/Event.h"
#include "os/Mutex.h"
#include "os/Semaphore.h"
#include "os/Thread.h"
#include "utils/Il2CppHashMap.h"
#include "utils/HashUtils.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

#include "vm/CCW.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Exception.h"
#include "vm/RCW.h"
#include "vm/Runtime.h"
#include "vm/Thread.h"

using namespace il2cpp::os;
using namespace il2cpp::vm;

namespace il2cpp
{
namespace gc
{
// So COM Callable Wrapper can be created for any kind of managed object,
// whether it has finalizer or not. If it doesn't then it's an easy case:
// when creating the CCW, we just register our cleanup method to be the
// finalizer method. In case it does, then we need to be able to invoke
// both our CCW cleanup method, and the finalizer in question.
// We could chain them by registering CCW cleanup method over the finalizer
// method and storing the previous finalizer in CCW cache, but it would
// screw us over if for example the object is IDisposable and then it
// calls `GC.SuppressFinalize` from C# - instead of the finalizer getting
// unregistered, our CCW cleanup method gets unregistered, and we now have
// a dangling pointer to the managed heap in the CCW cache. Not pretty.
// Instead, we made GarbageCollector::RegisterFinalizer and GarbageCollector::SuppressFinalizer
// to be CCW cache aware. Now, any managed object goes into 1 of these categories:
//
// 1. Object has no finalizer and it is not in CCW cache. It gets garbage
//    collected and no cleanup is needed.
// 2. Object has a finalizer and it is not in CCW cache. GarbageCollector::RunFinalizer
//    gets registered with the GC for such object.
// 3. Object has no finalizer and it is in CCW cache. CleanupCCW is
//    registered with the GC for such object. Once it is called, it removes
//    the object from the CCW cache.
// 4. Object has a finalizer and it is in CCW cache. CleanupCCW is
//    registered with the GC for such object. Once it is called, it removes
//    the object from the CCW cache and then calls its finalizer.
//
// To know whether we have case 3 or 4, we have the "hasFinalizer" field in
// the CachedCCW object.
//
// When GarbageCollector::RegisterFinalizer or GarbageCollector::SuppressFinalizer
// is called, we have managed objects fitting in two buckets:
//
// 1. Those that do not exist in CCW cache. Finalizer is normally registered with
//    the GC.
// 2. Those that are in the CCW cache. In such case, GC won't know about the call,
//    but instead we'll find the object in the CCW cache and RegisterFinalizer will
//    set "hasFinalizer" field to true, while SuppressFinalizer will set it to false
//
// Any methods that interact with s_CCWCache have to lock s_CCWCacheMutex.
    struct CachedCCW
    {
        Il2CppIManagedObjectHolder* managedObjectHolder;
        bool hasFinalizer;
    };

    typedef Il2CppHashMap<Il2CppObject*, CachedCCW, utils::PointerHash<Il2CppObject> > CCWCache;

    static baselib::ReentrantLock s_CCWCacheMutex;
    static CCWCache s_CCWCache;

#if IL2CPP_SUPPORT_THREADS

    struct GarbageCollectorContext
    {
        GarbageCollectorContext() :
            m_StopFinalizer(false),
            m_FinalizerThread(nullptr),
            m_FinalizerThreadObject(nullptr),
            m_FinalizerSemaphore(0, 32767),
            m_FinalizersThreadStartedEvent(),
            m_FinalizersCompletedEvent(true, false)
        {
        }

        bool m_StopFinalizer;
        il2cpp::os::Thread* m_FinalizerThread;
        Il2CppThread* m_FinalizerThreadObject;
        Semaphore m_FinalizerSemaphore;
        Event m_FinalizersThreadStartedEvent;
        Event m_FinalizersCompletedEvent;
    };

    GarbageCollectorContext* s_GarbageCollectorContext = nullptr;

    static void FinalizerThread(void* arg)
    {
        s_GarbageCollectorContext->m_FinalizerThreadObject = il2cpp::vm::Thread::Attach(Domain::GetCurrent());
        s_GarbageCollectorContext->m_FinalizerThread->SetName("GC Finalizer");

        s_GarbageCollectorContext->m_FinalizersThreadStartedEvent.Set();

        while (!s_GarbageCollectorContext->m_StopFinalizer)
        {
            s_GarbageCollectorContext->m_FinalizerSemaphore.Wait();

            GarbageCollector::InvokeFinalizers();

            s_GarbageCollectorContext->m_FinalizersCompletedEvent.Set();
        }

        il2cpp::vm::Thread::Detach(s_GarbageCollectorContext->m_FinalizerThreadObject);
    }

    bool GarbageCollector::IsFinalizerThread(Il2CppThread *thread)
    {
        return s_GarbageCollectorContext->m_FinalizerThreadObject == thread;
    }

    bool GarbageCollector::IsFinalizerInternalThread(Il2CppInternalThread *thread)
    {
        return s_GarbageCollectorContext->m_FinalizerThreadObject->GetInternalThread() == thread;
    }

#else

    bool GarbageCollector::IsFinalizerThread(Il2CppThread *thread)
    {
        return false;
    }

    bool GarbageCollector::IsFinalizerInternalThread(Il2CppInternalThread *thread)
    {
        return false;
    }

#endif

    void GarbageCollector::InitializeFinalizer()
    {
        GarbageCollector::InvokeFinalizers();
#if IL2CPP_SUPPORT_THREADS
        s_GarbageCollectorContext = new GarbageCollectorContext();

        s_GarbageCollectorContext->m_FinalizerThread = new il2cpp::os::Thread;
        s_GarbageCollectorContext->m_FinalizerThread->Run(&FinalizerThread, NULL);
        s_GarbageCollectorContext->m_FinalizersThreadStartedEvent.Wait();
#endif
    }

    void GarbageCollector::UninitializeFinalizers()
    {
#if IL2CPP_SUPPORT_THREADS
        s_GarbageCollectorContext->m_StopFinalizer = true;
        NotifyFinalizers();
        s_GarbageCollectorContext->m_FinalizerThread->Join();
        delete s_GarbageCollectorContext->m_FinalizerThread;
        s_GarbageCollectorContext->m_FinalizerThread = NULL;
        s_GarbageCollectorContext->m_StopFinalizer = false;
        s_GarbageCollectorContext->m_FinalizerThreadObject = NULL;

        delete s_GarbageCollectorContext;
        s_GarbageCollectorContext = nullptr;
#endif
    }

    void GarbageCollector::NotifyFinalizers()
    {
#if IL2CPP_SUPPORT_THREADS
        s_GarbageCollectorContext->m_FinalizerSemaphore.Post(1, NULL);
#endif
    }

    void GarbageCollector::RunFinalizer(void *obj, void *data)
    {
        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(GarbageCollector::RunFinalizer, "Compare to mono implementation special cases");

        Il2CppException *exc = NULL;
        Il2CppObject *o;
        const MethodInfo* finalizer = NULL;

        o = (Il2CppObject*)obj;

        finalizer = Class::GetFinalizer(o->klass);

        Runtime::Invoke(finalizer, o, NULL, &exc);

        if (exc)
            Runtime::UnhandledException(exc);
    }

    void GarbageCollector::RegisterFinalizerForNewObject(Il2CppObject* obj)
    {
        // Fast path
        // No need to check CCW cache since it's guaranteed to not be in it for a new object
        RegisterFinalizerWithCallback(obj, &GarbageCollector::RunFinalizer);
    }

    void GarbageCollector::RegisterFinalizer(Il2CppObject* obj)
    {
        // Slow path
        // Check in CCW cache first
        os::FastAutoLock lock(&s_CCWCacheMutex);
        CCWCache::iterator it = s_CCWCache.find(obj);

        if (it != s_CCWCache.end())
        {
            it->second.hasFinalizer = true;
        }
        else
        {
            RegisterFinalizerWithCallback(obj, &GarbageCollector::RunFinalizer);
        }
    }

    void GarbageCollector::SuppressFinalizer(Il2CppObject* obj)
    {
        // Slow path
        // Check in CCW cache first
        os::FastAutoLock lock(&s_CCWCacheMutex);
        CCWCache::iterator it = s_CCWCache.find(obj);

        if (it != s_CCWCache.end())
        {
            it->second.hasFinalizer = false;
        }
        else
        {
            RegisterFinalizerWithCallback(obj, NULL);
        }
    }

    void GarbageCollector::WaitForPendingFinalizers()
    {
        if (!GarbageCollector::HasPendingFinalizers())
            return;

#if IL2CPP_SUPPORT_THREADS
        /* Avoid deadlocks */
        if (vm::Thread::Current() == s_GarbageCollectorContext->m_FinalizerThreadObject)
            return;

        s_GarbageCollectorContext->m_FinalizersCompletedEvent.Reset();
        NotifyFinalizers();
        s_GarbageCollectorContext->m_FinalizersCompletedEvent.Wait();
#else
        GarbageCollector::InvokeFinalizers();
#endif
    }

    static void CleanupCCW(void* obj, void* data)
    {
        bool hasFinalizer;

        // We have to destroy CCW before invoking the finalizer, because we cannot know whether the finalizer will revive the object
        // In cases it does revive it, it's also possible for it to hit CCW cache, and in that case we'd want to create a new CCW object
        // rather than returning the one that we're about to destroy here
        {
            os::FastAutoLock lock(&s_CCWCacheMutex);
            CCWCache::iterator it = s_CCWCache.find(static_cast<Il2CppObject*>(obj));
            IL2CPP_ASSERT(it != s_CCWCache.end());

            Il2CppIManagedObjectHolder* managedObjectHolder = it->second.managedObjectHolder;
            hasFinalizer = it->second.hasFinalizer;
            s_CCWCache.erase(it);

            managedObjectHolder->Destroy();
        }

        if (hasFinalizer)
            GarbageCollector::RunFinalizer(obj, data);
    }

    // When creating COM Callable Wrappers for classes that project to other Windows Runtime classes
    // for instance, System.Uri to Windows.Foundation.Uri, we cannot actually create a wrapper against managed object
    // as the native side actually wants an instance of a real Windows.Foundation.Uri class. So do that, our createCCW
    // instead of creating a COM Callable Wrapper, will create an instance of that windows runtime class. In that case,
    // we do not (AND CANNOT!) put it into a CCW cache because it's not a CCW.
    static bool ShouldInsertIntoCCWCache(Il2CppObject* obj)
    {
        if (obj->klass == il2cpp_defaults.system_uri_class && il2cpp_defaults.windows_foundation_uri_class != NULL)
            return false;

        /* TODO - Add the rest of the class projections:
        System.Collections.Specialized.NotifyCollectionChangedEventArgs <-> Windows.UI.Xaml.Interop.NotifyCollectionChangedEventArgs
        System.ComponentModel.PropertyChangedEventArgs <-> Windows.UI.Xaml.Data.PropertyChangedEventArgs
        */

        return true;
    }

    Il2CppIUnknown* GarbageCollector::GetOrCreateCCW(Il2CppObject* obj, const Il2CppGuid& iid)
    {
        if (obj == NULL)
            return NULL;

        // check for rcw object. COM interface can be extracted from it and there's no need to create ccw
        if (obj->klass->is_import_or_windows_runtime)
        {
            Il2CppIUnknown* result = RCW::QueryInterfaceNoAddRef<true>(static_cast<Il2CppComObject*>(obj), iid);
            result->AddRef();
            return result;
        }

        os::FastAutoLock lock(&s_CCWCacheMutex);
        CCWCache::iterator it = s_CCWCache.find(obj);
        Il2CppIUnknown* comCallableWrapper;

        if (it == s_CCWCache.end())
        {
            comCallableWrapper = CCW::CreateCCW(obj);

            if (ShouldInsertIntoCCWCache(obj))
            {
#if IL2CPP_DEBUG
                // Assert that CCW::CreateCCW actually returns upcasted Il2CppIManagedObjectHolder
                Il2CppIManagedObjectHolder* managedObjectHolder = NULL;
                comCallableWrapper->QueryInterface(Il2CppIManagedObjectHolder::IID, reinterpret_cast<void**>(&managedObjectHolder));
                IL2CPP_ASSERT(static_cast<void*>(comCallableWrapper) == static_cast<void*>(managedObjectHolder));
                managedObjectHolder->Release();
#endif
                CachedCCW ccw =
                {
                    static_cast<Il2CppIManagedObjectHolder*>(comCallableWrapper),
                    RegisterFinalizerWithCallback(obj, &CleanupCCW) != NULL
                };

                s_CCWCache.insert(std::make_pair(obj, ccw));
            }
        }
        else
        {
            comCallableWrapper = it->second.managedObjectHolder;
        }

        Il2CppIUnknown* result;
        il2cpp_hresult_t hr = comCallableWrapper->QueryInterface(iid, reinterpret_cast<void**>(&result));
        vm::Exception::RaiseIfFailed(hr, true);
        return result;
    }

    int32_t GarbageCollector::GetGeneration(void* addr)
    {
        return 0;
    }

    void GarbageCollector::AddMemoryPressure(int64_t value)
    {
    }

#if IL2CPP_ENABLE_WRITE_BARRIERS
    void il2cpp::gc::GarbageCollector::SetWriteBarrier(void **ptr, size_t size)
    {
#if IL2CPP_ENABLE_STRICT_WRITE_BARRIERS
        for (size_t i = 0; i < size / sizeof(void**); i++)
            SetWriteBarrier(ptr + i);
#else
        SetWriteBarrier(ptr);
#endif
    }

#endif

    void il2cpp::gc::GarbageCollector::SetSkipThread(bool skip)
    {
    }
} // namespace gc
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\GarbageCollector.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\GCHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/GCHandle.h"
#include "il2cpp-object-internals.h"
#include "GarbageCollector.h"
#include "os/Mutex.h"
#include "utils/Memory.h"
#include <memory>

namespace il2cpp
{
namespace gc
{
#if IL2CPP_SIZEOF_VOID_P == 4
#define HANDLE_COUNT 992
#define HANDLE_DATA_ALIGNMENT 4096
#else
#define HANDLE_COUNT 992
#define HANDLE_DATA_ALIGNMENT 8192
#endif

    typedef struct HandleData HandleData;
    struct HandleData
    {
        HandleData *next; //immutable
        HandleData *next_free; // next free
        uint32_t   *bitmap;
        uint32_t   in_use;
        uint32_t   size;
        uint8_t    type;
        uint32_t   slot_hint : 24; /* starting slot for search in bitmap */
        void*      entries[HANDLE_COUNT];
    };


    static HandleData* gc_handles[HANDLE_PINNED + 1];
    static HandleData* gc_handles_free[HANDLE_PINNED + 1];

    inline bool HandleTypeIsWeak(GCHandleType type)
    {
        return type == GCHandleType::HANDLE_WEAK || type == GCHandleType::HANDLE_WEAK_TRACK;
    }

#define BITMAP_SIZE (sizeof (*((HandleData *)NULL)->bitmap) * CHAR_BIT)

    static bool
    slot_occupied(HandleData* handles, uint32_t slot)
    {
        return handles->bitmap[slot / BITMAP_SIZE] & (1 << (slot % BITMAP_SIZE));
    }

    static void
    vacate_slot(HandleData* handles, uint32_t slot)
    {
        handles->in_use--;
        handles->bitmap[slot / BITMAP_SIZE] &= ~(1 << (slot % BITMAP_SIZE));

        if (handles->in_use == (handles->size - 1))
        {
            uint8_t type = handles->type;
            HandleData* first = gc_handles_free[type];
            handles->next_free = first;
            gc_handles_free[type] = handles;
        }
    }

    static void
    occupy_slot(HandleData* handles, uint32_t slot)
    {
        handles->in_use++;
        handles->bitmap[slot / BITMAP_SIZE] |= 1 << (slot % BITMAP_SIZE);

        if (handles->in_use == handles->size)
        {
            uint8_t type = handles->type;
            IL2CPP_ASSERT(handles == gc_handles_free[type]);
            gc_handles_free[type] = gc_handles_free[type]->next_free;
        }
    }

    static int
    find_first_unset(uint32_t bitmap)
    {
        int i;
        for (i = 0; i < 32; ++i)
        {
            if (!(bitmap & (1 << i)))
                return i;
        }
        return -1;
    }

    static HandleData*
    handle_data_alloc_entries(int type)
    {
        IL2CPP_ASSERT(sizeof(HandleData) < HANDLE_DATA_ALIGNMENT);
        IL2CPP_ASSERT(HANDLE_COUNT % BITMAP_SIZE == 0);
        HandleData* handles = (HandleData*)utils::Memory::AlignedMalloc(sizeof(HandleData), HANDLE_DATA_ALIGNMENT);
        memset(handles, 0, sizeof(HandleData));
        handles->type = type;
        handles->size = HANDLE_COUNT;
        if (!HandleTypeIsWeak((GCHandleType)handles->type))
        {
            GarbageCollector::RegisterRoot((char*)&handles->entries[0], HANDLE_COUNT * sizeof(void*));
        }
        handles->bitmap = (uint32_t*)utils::Memory::Calloc(sizeof(char), handles->size / CHAR_BIT);

        return handles;
    }

    static int32_t
    handle_data_next_unset(HandleData* handles)
    {
        uint32_t slot;
        for (slot = handles->slot_hint; slot < handles->size / BITMAP_SIZE; ++slot)
        {
            if (handles->bitmap[slot] == 0xffffffff)
                continue;
            handles->slot_hint = slot;
            return find_first_unset(handles->bitmap[slot]);
        }
        return -1;
    }

    static int32_t
    handle_data_first_unset(HandleData* handles)
    {
        uint32_t slot;
        for (slot = 0; slot < handles->slot_hint; ++slot)
        {
            if (handles->bitmap[slot] == 0xffffffff)
                continue;
            handles->slot_hint = slot;
            return find_first_unset(handles->bitmap[slot]);
        }
        return -1;
    }

    static int32_t
    handle_data_find_slot(HandleData* handles)
    {
        int32_t slot = 0;
        int32_t i = handle_data_next_unset(handles);
        if (i == -1 && handles->slot_hint != 0)
            i = handle_data_first_unset(handles);

        IL2CPP_ASSERT(i != -1);

        slot = handles->slot_hint * BITMAP_SIZE + i;
        return slot;
    }

    static Il2CppGCHandle
    handle_tag_weak(Il2CppGCHandle handle)
    {
        return (Il2CppGCHandle)((uintptr_t)handle | (uintptr_t)1);
    }

    static Il2CppGCHandle
    handle_untag_weak(Il2CppGCHandle handle)
    {
        return (Il2CppGCHandle)((uintptr_t)handle & ~(uintptr_t)1);
    }

    static uintptr_t AlignDownTo(uintptr_t size, uintptr_t align)
    {
        return size & ~(align - 1);
    }

    static HandleData*
    get_handle_data_from_handle(Il2CppGCHandle handle)
    {
        HandleData* handles = (HandleData*)AlignDownTo((uintptr_t)handle, HANDLE_DATA_ALIGNMENT);
        return handles;
    }

    static HandleData*
    handle_lookup(Il2CppGCHandle handle, uint32_t* slot)
    {
        HandleData* handles = get_handle_data_from_handle(handle);
        if (slot)
            *slot = (uint32_t)(ptrdiff_t)((void**)handle_untag_weak(handle) - &handles->entries[0]);
        return handles;
    }

    static baselib::ReentrantLock g_HandlesMutex;

#define lock_handles(handles) g_HandlesMutex.Acquire ()
#define unlock_handles(handles) g_HandlesMutex.Release ()

    static Il2CppGCHandle
    alloc_handle(GCHandleType type, Il2CppObject *obj, bool track)
    {
        int32_t slot = 0;
        Il2CppGCHandle res = 0;
        HandleData* handles = gc_handles[type];
        lock_handles(handles);
        handles = gc_handles_free[type];
        if (!handles)
        {
            handles = handle_data_alloc_entries(type);
            handles->next = gc_handles[type];
            gc_handles[type] = handles;

            handles->next_free = gc_handles_free[type];
            gc_handles_free[type] = handles;
        }
        slot = handle_data_find_slot(handles);
        occupy_slot(handles, slot);

        handles->entries[slot] = NULL;
        if (handles->type <= HANDLE_WEAK_TRACK)
        {
            if (obj)
                GarbageCollector::AddWeakLink(&(handles->entries[slot]), obj, track);
        }
        else
        {
            handles->entries[slot] = obj;
            GarbageCollector::SetWriteBarrier(handles->entries + slot);
        }

        //mono_perfcounters->gc_num_handles++;
        unlock_handles(handles);

        res = (Il2CppGCHandle) & handles->entries[slot];
        if (HandleTypeIsWeak((GCHandleType)handles->type))
        {
            /*
             * Use lowest bit as an optimization to indicate weak GC handle.
             * This allows client code to simply dereference strong GCHandle
             * when the bit is not set.
            */
            res = handle_tag_weak(res);
        }
        return res;
    }

    Il2CppGCHandle GCHandle::New(Il2CppObject *obj, bool pinned)
    {
        return alloc_handle(pinned ? HANDLE_PINNED : HANDLE_NORMAL, obj, false);
    }

    utils::Expected<Il2CppGCHandle> GCHandle::NewWeakref(Il2CppObject *obj, bool track_resurrection)
    {
        Il2CppGCHandle handle = alloc_handle(track_resurrection ? HANDLE_WEAK_TRACK : HANDLE_WEAK, obj, track_resurrection);

#ifndef HAVE_SGEN_GC
        if (track_resurrection)
            return utils::Il2CppError(utils::NotSupported, "IL2CPP does not support resurrection for weak references. Pass the trackResurrection with a value of false.");
#endif

        return (Il2CppGCHandle)handle;
    }

    GCHandleType GCHandle::GetHandleType(Il2CppGCHandle gchandle)
    {
        HandleData* handles = handle_lookup(gchandle, NULL);
        return (GCHandleType)handles->type;
    }

    Il2CppObject* GCHandle::GetTarget(Il2CppGCHandle gchandle)
    {
        uint32_t slot = 0;
        HandleData* handles = handle_lookup(gchandle, &slot);
        Il2CppObject *obj = NULL;

        if (handles->type >= HANDLE_TYPE_MAX)
            return NULL;

        lock_handles(handles);
        if (slot < handles->size && slot_occupied(handles, slot))
        {
            if (handles->type <= HANDLE_WEAK_TRACK)
            {
                obj = GarbageCollector::GetWeakLink(&handles->entries[slot]);
            }
            else
            {
                obj = (Il2CppObject*)handles->entries[slot];
            }
        }
        else
        {
            /* print a warning? */
        }
        unlock_handles(handles);
        /*g_print ("get target of entry %d of type %d: %p\n", slot, handles->type, obj);*/
        return obj;
    }

    static void
    il2cpp_gchandle_set_target(Il2CppGCHandle gchandle, Il2CppObject *obj)
    {
        uint32_t slot = 0;
        HandleData* handles = handle_lookup(gchandle, &slot);
        Il2CppObject *old_obj = NULL;


        IL2CPP_ASSERT(handles->type < HANDLE_TYPE_MAX);
        lock_handles(handles);
        if (slot < handles->size && slot_occupied(handles, slot))
        {
            if (handles->type <= HANDLE_WEAK_TRACK)
            {
                old_obj = (Il2CppObject*)handles->entries[slot];
                if (handles->entries[slot])
                    GarbageCollector::RemoveWeakLink(&handles->entries[slot]);
                if (obj)
                    GarbageCollector::AddWeakLink(&handles->entries[slot], obj, handles->type == HANDLE_WEAK_TRACK);
            }
            else
            {
                handles->entries[slot] = obj;
            }
        }
        else
        {
            /* print a warning? */
        }
        unlock_handles(handles);
    }

    void GCHandle::Free(Il2CppGCHandle gchandle)
    {
        if (!gchandle)
            return;

        uint32_t slot = 0;
        HandleData* handles = handle_lookup(gchandle, &slot);
        if (handles->type >= HANDLE_TYPE_MAX)
            return;

        lock_handles(handles);
        if (slot < handles->size && slot_occupied(handles, slot))
        {
            if (HandleTypeIsWeak((GCHandleType)handles->type))
            {
                if (handles->entries[slot])
                    GarbageCollector::RemoveWeakLink(&handles->entries[slot] /*, handles->type == HANDLE_WEAK_TRACK*/);
            }
            else
            {
                handles->entries[slot] = NULL;
            }
            vacate_slot(handles, slot);
        }
        else
        {
            /* print a warning? */
        }

        unlock_handles(handles);
    }

    utils::Expected<Il2CppGCHandle> GCHandle::GetTargetHandle(Il2CppObject * obj, Il2CppGCHandle handle, int32_t type)
    {
        if (type == -1)
        {
            il2cpp_gchandle_set_target(handle, obj);
            /* the handle doesn't change */
            return handle;
        }
        switch (type)
        {
            case HANDLE_WEAK:
                return NewWeakref(obj, false);
            case HANDLE_WEAK_TRACK:
                return NewWeakref(obj, true);
            case HANDLE_NORMAL:
                return New(obj, false);
            case HANDLE_PINNED:
                return New(obj, true);
            default:
                IL2CPP_ASSERT(0);
        }
        return 0;
    }

    void GCHandle::WalkStrongGCHandleTargets(WalkGCHandleTargetsCallback callback, void* context)
    {
        lock_handles(handles);
        const GCHandleType types[] = { HANDLE_NORMAL, HANDLE_PINNED };

        for (int gcHandleTypeIndex = 0; gcHandleTypeIndex < 2; gcHandleTypeIndex++)
        {
            const HandleData* handles = gc_handles[types[gcHandleTypeIndex]];

            while (handles != NULL)
            {
                for (uint32_t i = 0; i < handles->size; i++)
                {
                    if (handles->entries[i] != NULL)
                        callback(static_cast<Il2CppObject*>(handles->entries[i]), context);
                }

                handles = handles->next;
            }
        }
        unlock_handles(handles);
    }
} /* gc */
} /* il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\GCHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\NullGC.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_GC_NULL
struct Il2CppObject;

#include <stdlib.h>
#include "il2cpp-api.h"
#include "GarbageCollector.h"
#include "utils/Memory.h"

void
il2cpp::gc::GarbageCollector::Initialize()
{
}

void il2cpp::gc::GarbageCollector::UninitializeGC()
{
}

void*
il2cpp::gc::GarbageCollector::AllocateFixed(size_t size, void *descr)
{
    return IL2CPP_MALLOC_ZERO(size);
}

void*
il2cpp::gc::GarbageCollector::MakeDescriptorForObject(size_t *bitmap, int numbits)
{
    return NULL;
}

void* il2cpp::gc::GarbageCollector::MakeEmptyDescriptor()
{
    return NULL;
}

void* il2cpp::gc::GarbageCollector::MakeDescriptorForString()
{
    return NULL;
}

void* il2cpp::gc::GarbageCollector::MakeDescriptorForArray()
{
    return NULL;
}

void il2cpp::gc::GarbageCollector::StopWorld()
{
    IL2CPP_NOT_IMPLEMENTED(il2cpp::gc::GarbageCollector::StopWorld);
}

void il2cpp::gc::GarbageCollector::StartWorld()
{
    IL2CPP_NOT_IMPLEMENTED(il2cpp::gc::GarbageCollector::StartWorld);
}

void
il2cpp::gc::GarbageCollector::RemoveWeakLink(void **link_addr)
{
    *link_addr = NULL;
}

Il2CppObject*
il2cpp::gc::GarbageCollector::GetWeakLink(void **link_addr)
{
    return (Il2CppObject*)*link_addr;
}

void
il2cpp::gc::GarbageCollector::AddWeakLink(void **link_addr, Il2CppObject *obj, bool track)
{
    *link_addr = obj;
}

void
il2cpp::gc::GarbageCollector::RegisterThread()
{
}

bool
il2cpp::gc::GarbageCollector::UnregisterThread()
{
    return true;
}

il2cpp::gc::GarbageCollector::FinalizerCallback il2cpp::gc::GarbageCollector::RegisterFinalizerWithCallback(Il2CppObject* obj, FinalizerCallback callback)
{
    return NULL;
}

void
il2cpp::gc::GarbageCollector::FreeFixed(void* addr)
{
    IL2CPP_FREE(addr);
}

int32_t
il2cpp::gc::GarbageCollector::InvokeFinalizers()
{
    return 0;
}

bool
il2cpp::gc::GarbageCollector::HasPendingFinalizers()
{
    return false;
}

void
il2cpp::gc::GarbageCollector::Collect(int maxGeneration)
{
}

int32_t
il2cpp::gc::GarbageCollector::CollectALittle()
{
    return 0;
}

void
il2cpp::gc::GarbageCollector::StartIncrementalCollection()
{
}

void
il2cpp::gc::GarbageCollector::Enable()
{
}

void
il2cpp::gc::GarbageCollector::Disable()
{
}

void
il2cpp::gc::GarbageCollector::SetMode(Il2CppGCMode mode)
{
}

bool
il2cpp::gc::GarbageCollector::IsDisabled()
{
    return true;
}

int64_t
il2cpp::gc::GarbageCollector::GetUsedHeapSize(void)
{
    return 0;
}

int64_t
il2cpp::gc::GarbageCollector::GetAllocatedHeapSize(void)
{
    return 0;
}

int32_t
il2cpp::gc::GarbageCollector::GetMaxGeneration()
{
    return 0;
}

int32_t
il2cpp::gc::GarbageCollector::GetCollectionCount(int32_t generation)
{
    return 0;
}

void il2cpp::gc::GarbageCollector::ForEachHeapSection(void* user_data, HeapSectionCallback callback)
{
}

size_t il2cpp::gc::GarbageCollector::GetSectionCount()
{
    return 0;
}

void* il2cpp::gc::GarbageCollector::CallWithAllocLockHeld(GCCallWithAllocLockCallback callback, void* user_data)
{
    return callback(user_data);
}

int64_t
il2cpp::gc::GarbageCollector::GetMaxTimeSliceNs()
{
    return 0;
}

void
il2cpp::gc::GarbageCollector::SetMaxTimeSliceNs(int64_t maxTimeSlice)
{
}

bool
il2cpp::gc::GarbageCollector::IsIncremental()
{
    return false;
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\NullGC.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\WriteBarrier.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/WriteBarrier.h"
#include "gc/GarbageCollector.h"

namespace il2cpp
{
namespace gc
{
    void WriteBarrier::GenericStore(void** ptr, void* value)
    {
        *ptr = value;
        GarbageCollector::SetWriteBarrier((void**)ptr);
    }
} /* gc */
} /* il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\WriteBarrier.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\WriteBarrierValidation.cpp---------------
.
.
#if IL2CPP_ENABLE_WRITE_BARRIER_VALIDATION

#include "gc_wrapper.h"
#include "il2cpp-config.h"
#include "il2cpp-api.h"
#include "gc/WriteBarrierValidation.h"
#include "gc/GarbageCollector.h"
#include "os/Mutex.h"
#include "vm/StackTrace.h"
#include <algorithm>
#include <functional>
#include <map>
#include <string>

// On systems which have the posix backtrace API, you can turn on this define to get native stack traces.
// This can make it easier to debug issues with missing barriers.
#define HAS_POSIX_BACKTRACE IL2CPP_TARGET_OSX
#define HAS_WINDOWS_BACKTRACE IL2CPP_TARGET_WINDOWS

#if HAS_POSIX_BACKTRACE
#include <execinfo.h>
#endif

#if HAS_WINDOWS_BACKTRACE
#include <windows.h>
#endif

using namespace il2cpp::os;
using namespace il2cpp::vm;

#if !IL2CPP_GC_BOEHM
#error "Write Barrier Validation is specific to Boehm GC"
#endif

namespace il2cpp
{
namespace gc
{
    enum AllocationKind
    {
        kPtrFree = 0,
        kNormal = 1,
        kUncollectable = 2,
        kObject = 3
    };

    struct AllocationInfo
    {
        size_t size;
        StackFrames stacktrace;
#if HAS_POSIX_BACKTRACE || HAS_WINDOWS_BACKTRACE
        void *backtraceFrames[128];
        int frameCount;
#endif
        AllocationKind kind;
    };

    static std::map<void*, AllocationInfo, std::greater<void*> > g_Allocations;
    static std::map<void**, void*> g_References;
    static void* g_MinHeap = (void*)0xffffffffffffffffULL;
    static void* g_MaxHeap = 0;
    static WriteBarrierValidation::ExternalAllocationTrackerFunction g_ExternalAllocationTrackerFunction = NULL;
    static WriteBarrierValidation::ExternalWriteBarrierTrackerFunction g_ExternalWriteBarrierTrackerFunction = NULL;
    static baselib::ReentrantLock s_AllocationMutex;
    static baselib::ReentrantLock s_WriteBarrierMutex;

    extern "C" void* GC_malloc_kind(size_t size, int k);

#if HAS_POSIX_BACKTRACE
    std::string GetStackPosix(const AllocationInfo &info)
    {
        std::string result;
        char **frameStrings = backtrace_symbols(&info.backtraceFrames[0], info.frameCount);
        int frameCount = std::min(info.frameCount, 32);
        if (frameStrings != NULL)
        {
            for (int x = 0; x < frameCount; x++)
            {
                result += frameStrings[x];
                result += "\n";
            }
            free(frameStrings);
        }
        return result;
    }

#endif

    void* GC_malloc_wrapper(size_t size, AllocationKind kind)
    {
        void* ptr = (char*)GC_malloc_kind(size, kind);
        memset(ptr, 0, size);

        if (g_ExternalAllocationTrackerFunction != NULL)
            g_ExternalAllocationTrackerFunction(ptr, size, kind);
        else
        {
            const StackFrames *trace = StackTrace::GetStackFrames();

            os::FastAutoLock lock(&s_AllocationMutex);

            AllocationInfo& allocation = g_Allocations[ptr];
            allocation.size = size;
            allocation.kind = kind;
            if (trace != NULL)
                allocation.stacktrace = *trace;
#if HAS_POSIX_BACKTRACE
            allocation.frameCount = backtrace(&allocation.backtraceFrames[0], 128);
#endif
#if HAS_WINDOWS_BACKTRACE
            allocation.frameCount = CaptureStackBackTrace(0, 128, &allocation.backtraceFrames[0], NULL);
#endif

            g_MinHeap = std::min(g_MinHeap, ptr);
            g_MaxHeap = std::max(g_MaxHeap, (void*)((char*)ptr + size));
        }

        return ptr;
    }

    extern "C" void GC_dirty_inner(void **ptr)
    {
        if (g_ExternalWriteBarrierTrackerFunction)
            g_ExternalWriteBarrierTrackerFunction(ptr);
        else
        {
            os::FastAutoLock lock(&s_WriteBarrierMutex);
            g_References[ptr] = *ptr;
        }
    }

    extern "C" void GC_free(void *ptr)
    {
    }

    extern "C" void* GC_malloc(size_t size)
    {
        return GC_malloc_wrapper(size, kNormal);
    }

    extern "C" void* GC_gcj_malloc(size_t size, void * ptr_to_struct_containing_descr)
    {
        void ** ptr = (void**)GC_malloc_wrapper(size, kObject);
        *ptr = ptr_to_struct_containing_descr;
        return ptr;
    }

    extern "C" void* GC_CALL GC_gcj_vector_malloc(size_t size, void * ptr_to_struct_containing_descr)
    {
        void ** ptr = (void**)GC_malloc_wrapper(size, kObject);
        *ptr = ptr_to_struct_containing_descr;
        return ptr;
    }

    extern "C" void* GC_malloc_uncollectable(size_t size)
    {
        return GC_malloc_wrapper(size, kUncollectable);
    }

    extern "C" void* GC_malloc_atomic(size_t size)
    {
        return GC_malloc_wrapper(size, kPtrFree);
    }

    static std::string ObjectName(void* object, AllocationKind kind)
    {
        if (kind != kObject)
        {
            switch (kind)
            {
                case kPtrFree: return "Kind: kPtrFree";
                case kNormal: return "Kind: kNormal";
                case kUncollectable: return "Kind: kUncollectable";
                default: return "?";
            }
        }

        Il2CppClass* klass = il2cpp_object_get_class((Il2CppObject*)(object));

        if (klass == NULL)
            return "";

        std::string name = il2cpp_class_get_name(klass);
        Il2CppClass* parent = il2cpp_class_get_declaring_type(klass);
        while (parent != NULL)
        {
            klass = parent;
            parent = il2cpp_class_get_declaring_type(klass);
            name = std::string(il2cpp_class_get_name(klass)) + "/" + name;
        }

        return std::string(il2cpp_class_get_namespace(klass)) + "::" + name;
    }

    static std::string GetReadableStackTrace(const StackFrames &stackTrace)
    {
        std::string str;
        for (StackFrames::const_iterator i = stackTrace.begin(); i != stackTrace.end(); i++)
        {
            Il2CppClass* parent = il2cpp_method_get_declaring_type(i->method);
            str += il2cpp_class_get_namespace(parent);
            str += '.';
            str += il2cpp_class_get_name(parent);
            str += ':';
            str += il2cpp_method_get_name(i->method);
            str += '\n';
        }
        return str;
    }

    static std::string LogError(std::pair<void*, AllocationInfo> const & object, void** reference, void *refObject)
    {
        std::string msg;
        char chbuf[1024];
        snprintf(chbuf, 1024, "In object %p (%s) with size %zx at offset %zx, allocated at \n%s\n", object.first, ObjectName(object.first, object.second.kind).c_str(), object.second.size, (size_t)((char*)reference - (char*)object.first),
#if HAS_POSIX_BACKTRACE
            GetStackPosix(object.second).c_str()
#else
            GetReadableStackTrace(object.second.stacktrace).c_str()
#endif
        );
        msg += chbuf;
        snprintf(chbuf, 1024, "Points to object %p of type (%s)\n", refObject, ObjectName(refObject, kPtrFree).c_str());
        msg += chbuf;
        return msg;
    }

    // Boehm internal constants
    #define GC_DS_TAG_BITS 2
    #define GC_DS_TAGS   ((1 << GC_DS_TAG_BITS) - 1)
    #define GC_DS_LENGTH 0  /* The entire word is a length in bytes that    */
    /* must be a multiple of 4.                     */
    #define GC_DS_BITMAP 1  /* 30 (62) bits are a bitmap describing pointer */

    #ifndef MARK_DESCR_OFFSET
    #  define MARK_DESCR_OFFSET sizeof(void*)
    #endif

    void WriteBarrierValidation::SetExternalAllocationTracker(ExternalAllocationTrackerFunction func)
    {
        g_ExternalAllocationTrackerFunction = func;
    }

    void WriteBarrierValidation::SetExternalWriteBarrierTracker(ExternalWriteBarrierTrackerFunction func)
    {
        g_ExternalWriteBarrierTrackerFunction = func;
    }

    /* Taken from https://randomascii.wordpress.com/2012/02/14/64-bit-made-easy/

    Copyright 2012 Bruce Dawson. All Rights Reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    void ReserveBottomMemory()
    {
#if defined(_WIN64)
        static bool s_initialized = false;
        if (s_initialized)
            return;
        s_initialized = true;

        // Start by reserving large blocks of address space, and then
        // gradually reduce the size in order to capture all of the
        // fragments. Technically we should continue down to 64 KB but
        // stopping at 1 MB is sufficient to keep most allocators out.

        const size_t LOW_MEM_LINE = 0x1000000000LL; // Modified to reserve bottom 64 GB
        size_t totalReservation = 0;
        size_t numVAllocs = 0;
        size_t numHeapAllocs = 0;
        size_t oneMB = 1024 * 1024;
        size_t sixtyFourKB = 64 * 1024; // Modified to continue down to 64 KB as our GC allocates chunks in 256 KB
        for (size_t size = 256 * oneMB; size >= sixtyFourKB; size /= 2)
        {
            for (;;)
            {
                void* p = VirtualAlloc(0, size, MEM_RESERVE, PAGE_NOACCESS);
                if (!p)
                    break;

                if ((size_t)p >= LOW_MEM_LINE)
                {
                    // We don't need this memory, so release it completely.
                    VirtualFree(p, 0, MEM_RELEASE);
                    break;
                }

                totalReservation += size;
                ++numVAllocs;
            }
        }

        // Now repeat the same process but making heap allocations, to use up
        // the already reserved heap blocks that are below the 4 GB line.
        HANDLE heap = GetProcessHeap();
        for (size_t blockSize = 64 * 1024; blockSize >= 16; blockSize /= 2)
        {
            for (;;)
            {
                void* p = HeapAlloc(heap, 0, blockSize);
                if (!p)
                    break;

                if ((size_t)p >= LOW_MEM_LINE)
                {
                    // We don't need this memory, so release it completely.
                    HeapFree(heap, 0, p);
                    break;
                }

                totalReservation += blockSize;
                ++numHeapAllocs;
            }
        }

        // Perversely enough the CRT doesn't use the process heap. Consume up
        // the memory the CRT heap has already reserved.
        for (size_t blockSize = 64 * 1024; blockSize >= 16; blockSize /= 2)
        {
            for (;;)
            {
                void* p = malloc(blockSize);
                if (!p)
                    break;

                if ((size_t)p >= LOW_MEM_LINE)
                {
                    // We don't need this memory, so release it completely.
                    free(p);
                    break;
                }

                totalReservation += blockSize;
                ++numHeapAllocs;
            }
        }

        // Print diagnostics showing how many allocations we had to make in
        // order to reserve all of low memory, typically less than 200.
        char buffer[1000];
        sprintf_s(buffer, "Reserved %1.3f MB (%d vallocs,"
            "%d heap allocs) of low-memory.\n",
            totalReservation / (1024 * 1024.0),
            (int)numVAllocs, (int)numHeapAllocs);
        OutputDebugStringA(buffer);
#endif
    }

    void WriteBarrierValidation::Setup()
    {
        // Reserve bottom 64 GB of memory to force GC into high addresses
        // This prevents hashes colliding with heap addresses and causing false detections.
        ReserveBottomMemory();

        GarbageCollector::Disable();
    }

    void WriteBarrierValidation::Run()
    {
        if (g_ExternalAllocationTrackerFunction != NULL)
            return;
        std::string msg;
        msg = "<TestResult Name='WriteBarrierValidation'>\n<![CDATA[\n";
        size_t errors = 0;
        for (std::map<void*, AllocationInfo>::iterator i = g_Allocations.begin(); i != g_Allocations.end(); i++)
        {
            if (i->second.kind == kPtrFree)
                continue;

            intptr_t desc = (intptr_t)GC_NO_DESCRIPTOR;
            if (i->second.kind == kObject)
            {
                desc = *(intptr_t*)(((char*)(*(void**)i->first)) + MARK_DESCR_OFFSET);
                if ((desc & GC_DS_TAGS) != GC_DS_BITMAP)
                    desc = (intptr_t)GC_NO_DESCRIPTOR;
            }

            for (void** ptr = ((void**)i->first) + 2; ptr < (void**)((char*)i->first + i->second.size); ptr++)
            {
                if (desc != (intptr_t)GC_NO_DESCRIPTOR)
                {
                    // if we have a GC descriptor bitmap, check if this address can be a pointer, skip otherwise.
                    size_t ptr_index = ptr - (void**)i->first;
                    if (((desc >> (sizeof(void*) * 8 - ptr_index - 1)) & 1) == 0)
                        continue;
                }

                void* ref = *ptr;
                if (ref < g_MinHeap || ref >= g_MaxHeap)
                    continue;

                std::map<void*, AllocationInfo>::iterator j = g_Allocations.lower_bound(ref);
                if (j != g_Allocations.end() && j != i && j->second.kind != kUncollectable)
                {
                    if (j->first <= ref && (void*)((char*)j->first + j->second.size) > ref)
                    {
                        std::map<void**, void*>::iterator trackedRef = g_References.find(ptr);
                        if (trackedRef == g_References.end())
                        {
                            char chbuf[1024];
                            snprintf(chbuf, 1024, "\n%p looks like a reference to %p, but was not found in tracked references\n", ptr, ref);
                            msg += chbuf;
                            errors++;
                            msg += LogError(*i, ptr, j->first);
                        }
                        else if (trackedRef->second != ref)
                        {
                            char chbuf[1024];
                            snprintf(chbuf, 1024, "\n%p does not match tracked value (%p!=%p).\n", ptr, trackedRef->second, ref);
                            msg += chbuf;
                            errors++;
                            msg += LogError(*i, ptr, j->first);
                        }
                    }
                }
            }
        }
        msg += "]]>\n</TestResult>\n";
        if (errors > 0)
            printf("%s", msg.c_str());
    }
} /* gc */
} /* il2cpp */

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\gc\WriteBarrierValidation.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Interop.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Interop.h"
#include <stdio.h>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
    // int ves_icall_Interop_Sys_DoubleToString(double value, char *format, char *buffer, int bufferLength)
    int32_t Interop::Sys::DoubleToString(double value, char* format, char* buffer, int32_t bufferLength)
    {
#if IL2CPP_TARGET_ARMV7
        /* workaround for faulty vcmp.f64 implementation on some 32bit ARM CPUs */
        int64_t bits = *(int64_t *)&value;
        if (bits == 0x1)   /* 4.9406564584124654E-324 */
        {
            IL2CPP_ASSERT(!strcmp(format, "%.40e"));
            return snprintf(buffer, bufferLength, "%s", "4.9406564584124654417656879286822137236506e-324");
        }
        else if (bits == 0x4)     /* 2E-323 */
        {
            IL2CPP_ASSERT(!strcmp(format, "%.40e"));
            return snprintf(buffer, bufferLength, "%s", "1.9762625833649861767062751714728854894602e-323");
        }
#endif

        return ::snprintf(buffer, bufferLength, format, value);
    }
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Interop.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Microsoft.Win32\NativeMethods.cpp---------------
.
.
#include "il2cpp-config.h"
#include "NativeMethods.h"

#include "os/Process.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Microsoft
{
namespace Win32
{
    int32_t NativeMethods::GetCurrentProcessId()
    {
        return os::Process::GetCurrentProcessId();
    }
} // namespace Win32
} // namespace Microsoft
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Microsoft.Win32\NativeMethods.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\Runtime.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Runtime.h"
#include <vm/String.h>
#include <vm/Exception.h>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Mono
{
    int32_t Runtime::CheckCrashReportLog_internal(intptr_t directory, bool clear)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::CheckCrashReportLog_internal);
        IL2CPP_UNREACHABLE;
        return 0;
    }

    Il2CppString* Runtime::DumpStateSingle_internal(uint64_t* portable_hash, uint64_t* unportable_hash)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::DumpStateSingle_internal);
        IL2CPP_UNREACHABLE;
        return 0;
    }

    Il2CppString* Runtime::DumpStateTotal_internal(uint64_t* portable_hash, uint64_t* unportable_hash)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::DumpStateTotal_internal);
        IL2CPP_UNREACHABLE;
        return 0;
    }

    Il2CppString* Runtime::ExceptionToState_internal(Il2CppException* exc, uint64_t* portable_hash, uint64_t* unportable_hash)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::ExceptionToState_internal);
        IL2CPP_UNREACHABLE;
        return 0;
    }

    Il2CppString* Runtime::GetDisplayName()
    {
        return il2cpp::vm::String::New("Unity IL2CPP (" __DATE__ " " __TIME__ ")");
    }

    Il2CppString* Runtime::GetNativeStackTrace(Il2CppException* exception)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::GetNativeStackTrace);
        IL2CPP_UNREACHABLE;
        return NULL;
    }

    void Runtime::AnnotateMicrosoftTelemetry_internal(intptr_t key, intptr_t val)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::AnnotateMicrosoftTelemetry_internal);
        IL2CPP_UNREACHABLE;
    }

    void Runtime::EnableCrashReportLog_internal(intptr_t directory)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::EnableCrashReportLog_internal);
        IL2CPP_UNREACHABLE;
    }

    void Runtime::mono_runtime_cleanup_handlers()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::mono_runtime_cleanup_handlers);
        IL2CPP_UNREACHABLE;
    }

    void Runtime::mono_runtime_install_handlers()
    {
        NOT_SUPPORTED_IL2CPP(Runtime::mono_runtime_install_handlers, "This method appears to never be called.");
    }

    void Runtime::RegisterReportingForAllNativeLibs_internal()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::RegisterReportingForAllNativeLibs_internal);
        IL2CPP_UNREACHABLE;
    }

    void Runtime::RegisterReportingForNativeLib_internal(intptr_t modulePathSuffix, intptr_t moduleName)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Runtime::RegisterReportingForNativeLib_internal);
        IL2CPP_UNREACHABLE;
    }
} /* namespace Mono */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\Runtime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\RuntimeClassHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "RuntimeClassHandle.h"
#include "vm/Class.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Mono
{
    intptr_t RuntimeClassHandle::GetTypeFromClass(Il2CppClass* klass)
    {
        return reinterpret_cast<intptr_t>(il2cpp::vm::Class::GetType(klass));
    }
} // namespace Mono
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\RuntimeClassHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\RuntimeGPtrArrayHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include "mono-structs.h"
#include "RuntimeGPtrArrayHandle.h"
#include "utils/Memory.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Mono
{
    void RuntimeGPtrArrayHandle::GPtrArrayFree(void* value)
    {
        IL2CPP_ASSERT(value != NULL);
        free_gptr_array((MonoGPtrArray*)value);
    }
} // namespace Mono
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\RuntimeGPtrArrayHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\RuntimeMarshal.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeMarshal.h"
#include "mono-structs.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Mono
{
    void RuntimeMarshal::FreeAssemblyName(Il2CppMonoAssemblyName* name, bool freeStruct)
    {
        IL2CPP_FREE(const_cast<char*>(name->name));
        IL2CPP_FREE(const_cast<char*>(name->culture));
        if (freeStruct)
            IL2CPP_FREE(name);
    }
} // namespace Mono
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\RuntimeMarshal.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\SafeStringMarshal.cpp---------------
.
.
#include "il2cpp-config.h"
#include "SafeStringMarshal.h"
#include "utils/StringUtils.h"
#include "utils/Memory.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Mono
{
    intptr_t SafeStringMarshal::StringToUtf8_icall(Il2CppString *volatile* str)
    {
        std::string strobj = il2cpp::utils::StringUtils::Utf16ToUtf8((*str)->chars, (*str)->length);
        char* cstr = il2cpp::utils::StringUtils::StringDuplicate(strobj.c_str());
        return reinterpret_cast<intptr_t>(cstr);
    }

    void SafeStringMarshal::GFree(intptr_t ptr)
    {
        IL2CPP_FREE((char*)ptr);
    }
} // namespace Mono
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono\SafeStringMarshal.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono.Security.Cryptography\KeyPairPersistence.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/Mono.Security.Cryptography/KeyPairPersistence.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Mono
{
namespace Security
{
namespace Cryptography
{
    bool KeyPairPersistence::_CanSecure(Il2CppChar* root)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(KeyPairPersistence::_CanSecure);
        return false;
    }

    bool KeyPairPersistence::_IsMachineProtected(Il2CppChar* path)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(KeyPairPersistence::_IsMachineProtected);
        return false;
    }

    bool KeyPairPersistence::_IsUserProtected(Il2CppChar* path)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(KeyPairPersistence::_IsUserProtected);
        return false;
    }

    bool KeyPairPersistence::_ProtectMachine(Il2CppChar* path)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(KeyPairPersistence::_ProtectMachine);
        return false;
    }

    bool KeyPairPersistence::_ProtectUser(Il2CppChar* path)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(KeyPairPersistence::_ProtectUser);
        return false;
    }
} /* namespace Cryptography */
} /* namespace Security */
} /* namespace Mono */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono.Security.Cryptography\KeyPairPersistence.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono.Unity\UnityTls.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/Mono.Unity/UnityTls.h"
#include "vm/Runtime.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace Mono
{
namespace Unity
{
    const void* UnityTls::GetUnityTlsInterface()
    {
        return il2cpp::vm::Runtime::GetUnityTlsInterface();
    }
}
}
}
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\Mono.Unity\UnityTls.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\AppDomain.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System/AppDomain.h"

#include "gc/Allocator.h"
#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "os/Mutex.h"
#include "utils/StringUtils.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Exception.h"
#include "vm/Image.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Thread.h"
#include "vm/Type.h"

#include "il2cpp-tabledefs.h"
#include "il2cpp-string-types.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-api.h"

#include <map>
#include <string>
#include <vector>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    Il2CppObject* AppDomain::createDomain(Il2CppString* friendlyName, Il2CppObject* info)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::createDomain, "IL2CPP only supports one app domain, others cannot be created.");
        return NULL;
    }

    Il2CppAppDomain* AppDomain::getCurDomain()
    {
        Il2CppDomain *add = vm::Domain::GetCurrent();

        if (add->domain)
            return add->domain;

        add->domain = (Il2CppAppDomain*)il2cpp::vm::Object::New(il2cpp_defaults.appdomain_class);
        return add->domain;
    }

    Il2CppAppDomain* AppDomain::getRootDomain()
    {
        return vm::Domain::GetRoot()->domain;
    }

    Il2CppObject* AppDomain::InternalSetDomain(Il2CppObject* context)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalSetDomain, "This icall is only used in the System.Runtime.Remoting namespace.");

        return 0;
    }

    Il2CppObject* AppDomain::InternalSetDomainByID(int32_t domain_id)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalSetDomainByID, "This icall is only used in the System.Runtime.Remoting namespace.");

        return 0;
    }

    Il2CppAppDomainSetup* AppDomain::getSetup(Il2CppAppDomain* domain)
    {
        IL2CPP_ASSERT(domain != NULL);
        IL2CPP_ASSERT(domain->data != NULL);

        return domain->data->setup;
    }

    bool AppDomain::InternalIsFinalizingForUnload(int32_t domain_id)
    {
        return false;
    }

    int32_t AppDomain::ExecuteAssembly(Il2CppObject* thisPtr, Il2CppObject* a, Il2CppArray* args)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::ExecuteAssembly, "This icall is not supported by il2cpp.");

        return 0;
    }

    baselib::ReentrantLock s_DomainDataMutex;
    typedef std::vector<std::pair<UTF16String, Il2CppObject*>, il2cpp::gc::Allocator<std::pair<UTF16String, Il2CppObject*> > > DomainDataStorage;
    DomainDataStorage* s_DomainData;

    static inline void InitializeDomainData()
    {
        void* memory = utils::Memory::Malloc(sizeof(DomainDataStorage));
        s_DomainData = new(memory) DomainDataStorage;
    }

    Il2CppObject* AppDomain::GetData(Il2CppAppDomain* self, Il2CppString* name)
    {
        os::FastAutoLock lock(&s_DomainDataMutex);

        if (s_DomainData == NULL)
            InitializeDomainData();

        for (DomainDataStorage::iterator it = s_DomainData->begin(); it != s_DomainData->end(); it++)
        {
            if (it->first.compare(name->chars) == 0)
                return it->second;
        }

        return NULL;
    }

    void AppDomain::SetData(Il2CppAppDomain* self, Il2CppString* name, Il2CppObject* data)
    {
        os::FastAutoLock lock(&s_DomainDataMutex);

        if (s_DomainData == NULL)
            InitializeDomainData();

        for (DomainDataStorage::iterator it = s_DomainData->begin(); it != s_DomainData->end(); it++)
        {
            if (it->first.compare(0, it->first.size(), name->chars, name->length) == 0)
            {
                gc::WriteBarrier::GenericStore(&it->second, data);
                return;
            }
        }

        s_DomainData->push_back(std::make_pair(UTF16String(name->chars, name->length), data));
        gc::GarbageCollector::SetWriteBarrier((void**)&s_DomainData->back().second);
    }

    Il2CppReflectionAssembly* AppDomain::LoadAssembly(Il2CppAppDomain* thisPtr, Il2CppString* assemblyRef, Il2CppObject* securityEvidence, bool refOnly, int32_t* stackMark)
    {
        il2cpp::vm::TypeNameParseInfo info;
        std::string name = il2cpp::utils::StringUtils::Utf16ToUtf8(assemblyRef->chars);
        il2cpp::vm::TypeNameParser parser(name, info, false);

        if (!parser.ParseAssembly())
            return NULL;

        //assemblyRef might have been a fullname like System, CultureInfo=bla, Version=4.0, PublicKeyToken=23423423423423
        //we ignore all that info except the name. (mono ignores the keytoken, and I'm quite sure it also ignores the version).
        //il2cpp does not pack multiple assemblies with the same name, and even if that one is not the exact one that is asked for,
        //it's more useful to return it than not to. (like cases where you want to Deserialize a BinaryFormatter blob that was serialized
        //on 4.0)
        const Il2CppAssembly* assembly = vm::Assembly::GetLoadedAssembly(info.assembly_name().name.c_str());

        if (assembly != NULL)
            return vm::Reflection::GetAssemblyObject(assembly);

        return NULL;
    }

    Il2CppObject* AppDomain::LoadAssemblyRaw(Il2CppObject* thisPtr, Il2CppArray* rawAssembly, Il2CppArray* rawSymbolStore, Il2CppObject* securityEvidence, bool refonly)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::LoadAssemblyRaw, "This icall is not supported by il2cpp.");

        return 0;
    }

    Il2CppArray* AppDomain::GetAssemblies(Il2CppObject* thisPtr, bool refOnly)
    {
        vm::AssemblyVector* assemblies = vm::Assembly::GetAllAssemblies();

        int c = 0;
        Il2CppArray *res = vm::Array::New(il2cpp_defaults.assembly_class, (il2cpp_array_size_t)assemblies->size());
        for (vm::AssemblyVector::const_iterator assembly = assemblies->begin(); assembly != assemblies->end(); ++assembly)
            il2cpp_array_setref(res, c++, vm::Reflection::GetAssemblyObject(*assembly));

        return res;
    }

    Il2CppAppContext* AppDomain::InternalGetContext()
    {
        return vm::Domain::ContextGet();
    }

    Il2CppAppContext* AppDomain::InternalGetDefaultContext()
    {
        return vm::Domain::ContextGet();
    }

    Il2CppObject* AppDomain::InternalSetContext(Il2CppObject* context)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalSetContext, "This icall is only used in the System.Runtime.Remoting namespace.");

        return 0;
    }

    Il2CppString* AppDomain::getFriendlyName(Il2CppAppDomain* thisPtr)
    {
        return il2cpp_string_new(thisPtr->data->friendly_name);
    }

    Il2CppString* AppDomain::InternalGetProcessGuid(Il2CppString* newguid)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalGetProcessGuid, "This icall is only used in System.Runtime.Remoting.RemotingConfiguraiton.ProcessId.");

        return NULL;
    }

    void AppDomain::DoUnhandledException(Il2CppObject* thisPtr, Il2CppException* e)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(AppDomain::DoUnhandledException);
        IL2CPP_UNREACHABLE;
    }

    void AppDomain::InternalPopDomainRef()
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalPopDomainRef, "This icall is only used in the System.Runtime.Remoting namespace.");
    }

    void AppDomain::InternalPushDomainRef(Il2CppObject* domain)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalPushDomainRef, "This icall is only used in the System.Runtime.Remoting namespace.");
    }

    void AppDomain::InternalPushDomainRefByID(int32_t domain_id)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalPushDomainRefByID, "This icall is only used in the System.Runtime.Remoting namespace.");
    }

    void AppDomain::InternalUnload(int32_t domain_id)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::InternalUnload, "This icall is not supported by il2cpp.");
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\AppDomain.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\ArgIterator.cpp---------------
.
.
#include "il2cpp-config.h"
#include "ArgIterator.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    intptr_t ArgIterator::IntGetNextArgType(mscorlib_System_ArgIterator* thisPtr)
    {
        NOT_SUPPORTED_IL2CPP(ArgIterator::IntGetNextArgType, "ArgIterator is not supported. Do not use __argList, use params instead.");
        return intptr_t();
    }

    void ArgIterator::IntGetNextArg(mscorlib_System_ArgIterator* thisPtr, void* res)
    {
        NOT_SUPPORTED_IL2CPP(ArgIterator::IntGetNextArg, "ArgIterator is not supported. Do not use __argList, use params instead.");
    }

    void ArgIterator::IntGetNextArgWithType(mscorlib_System_ArgIterator* thisPtr, void* res, intptr_t rth)
    {
        NOT_SUPPORTED_IL2CPP(ArgIterator::IntGetNextArgWithType, "ArgIterator is not supported. Do not use __argList, use params instead.");
    }

    void ArgIterator::Setup(mscorlib_System_ArgIterator* thisPtr, intptr_t argsp, intptr_t start)
    {
        NOT_SUPPORTED_IL2CPP(ArgIterator::Setup, "ArgIterator is not supported. Do not use __argList, use params instead.");
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\ArgIterator.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Array.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "gc/GarbageCollector.h"
#include "icalls/mscorlib/System/Array.h"
#include "utils/Exception.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Type.h"

#include <vector>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    static std::string FormatCreateInstanceException(const Il2CppType* type)
    {
        std::string typeName = vm::Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_IL);

        std::string message;
        message += "Unable to create an array of type '";
        message += typeName;
        message += "'. IL2CPP needs to know about the array type at compile time, so please define a private static field like this:\n\nprivate static ";
        message += typeName;
        message += "[] _unused;\n\nin any MonoBehaviour class, and this exception should go away.";

        return message;
    }

    Il2CppArray* Array::CreateInstanceImpl(Il2CppReflectionType* elementType, Il2CppArray* lengths, Il2CppArray* bounds)
    {
        int32_t* i32lengths = NULL;
        int32_t* i32bounds = NULL;
        il2cpp_array_size_t* arraySizeLengths = NULL;
        il2cpp_array_size_t* arraySizeBounds = NULL;

        if (lengths != NULL)
            i32lengths = (int32_t*)il2cpp_array_addr(lengths, int32_t, 0);

        if (bounds != NULL)
            i32bounds = (int32_t*)il2cpp_array_addr(bounds, int32_t, 0);

        int32_t boundsCount = bounds != NULL ? il2cpp::vm::Array::GetLength(bounds) : 0;

        Il2CppClass* arrayType = il2cpp::vm::Class::GetBoundedArrayClass(
            il2cpp::vm::Class::FromIl2CppType(elementType->type),
            il2cpp::vm::Array::GetLength(lengths),
            boundsCount > 2 || (boundsCount == 1 && i32bounds[0] != 0)
        );

        if (arrayType == NULL)
            vm::Exception::Raise(vm::Exception::GetInvalidOperationException(FormatCreateInstanceException(elementType->type).c_str()));

        //Convert the lengths and bounds of the array into il2cpp_array_size_t
        if (lengths)
        {
            arraySizeLengths = (il2cpp_array_size_t*)alloca(lengths->max_length * sizeof(il2cpp_array_size_t));
            for (il2cpp_array_size_t i = 0; i < lengths->max_length; i++)
            {
                arraySizeLengths[i] = i32lengths[i];
            }
        }

        if (bounds)
        {
            arraySizeBounds = (il2cpp_array_size_t*)alloca(bounds->max_length * sizeof(il2cpp_array_size_t));
            for (il2cpp_array_size_t i = 0; i < bounds->max_length; i++)
            {
                arraySizeBounds[i] = i32bounds[i];
            }
        }

        return (Il2CppArray*)il2cpp::vm::Array::NewFull(arrayType, arraySizeLengths, arraySizeBounds);
    }

    bool Array::FastCopy(Il2CppArray* source, int32_t source_idx, Il2CppArray* dest, int32_t dest_idx, int32_t length)
    {
        int element_size;
        Il2CppClass *src_class;
        Il2CppClass *dest_class;
        int i;

        if (source->klass->rank != dest->klass->rank)
            return false;

        if (source->bounds || dest->bounds)
            return false;

        // Our max array length is il2cpp_array_size_t, which is currently int32_t,
        // so Array::GetLength will never return more than 2^31 - 1
        // Therefore, casting sum to uint32_t is safe even if it overflows - it if does,
        // the comparison will succeed and this function will return false
        if ((static_cast<uint32_t>(dest_idx + length) > il2cpp::vm::Array::GetLength(dest)) ||
            (static_cast<uint32_t>(source_idx + length) > il2cpp::vm::Array::GetLength(source)))
            return false;

        src_class = source->klass->element_class;
        dest_class = dest->klass->element_class;

        // object[] -> valuetype[]
        if (src_class == il2cpp_defaults.object_class && dest_class->byval_arg.valuetype)
        {
            for (i = source_idx; i < source_idx + length; ++i)
            {
                Il2CppObject *elem = il2cpp_array_get(source, Il2CppObject*, i);
                if (elem && !vm::Object::IsInst(elem, dest_class))
                    return false;
            }

            element_size = il2cpp_array_element_size(dest->klass);
            void *baseAddr = il2cpp_array_addr_with_size(dest, element_size, dest_idx);

            size_t byte_len = (size_t)length * element_size;
            memset(baseAddr, 0, byte_len);

            for (i = 0; i < length; ++i)
            {
                Il2CppObject *elem = il2cpp_array_get(source, Il2CppObject*, source_idx + (size_t)i);

                if (!elem)
                    vm::Exception::Raise(vm::Exception::GetInvalidCastException("At least one element in the source array could not be cast down to the destination array type."));

                memcpy(il2cpp_array_addr_with_size(dest, element_size, dest_idx + (size_t)i), vm::Object::Unbox(elem), element_size);
            }
            gc::GarbageCollector::SetWriteBarrier((void**)baseAddr, byte_len);

            return true;
        }

        if (src_class != dest_class)
        {
            if (vm::Class::IsValuetype(dest_class) || vm::Class::IsEnum(dest_class) || vm::Class::IsValuetype(src_class) || vm::Class::IsEnum(src_class))
                return false;

            // object[] -> reftype[]
            if (vm::Class::IsSubclassOf(dest_class, src_class, false))
            {
                for (i = source_idx; i < source_idx + length; ++i)
                {
                    Il2CppObject *elem = il2cpp_array_get(source, Il2CppObject*, i);
                    if (elem && !vm::Object::IsInst(elem, dest_class))
                        vm::Exception::Raise(vm::Exception::GetInvalidCastException("At least one element in the source array could not be cast down to the destination array type."));
                }
            }
            else if (!vm::Class::IsSubclassOf(src_class, dest_class, false))
                return false;

            // derivedtype[] -> basetype[]
            IL2CPP_ASSERT(vm::Type::IsReference(&src_class->byval_arg));
            IL2CPP_ASSERT(vm::Type::IsReference(&dest_class->byval_arg));
        }

        element_size = il2cpp_array_element_size(dest->klass);

        IL2CPP_ASSERT(element_size == il2cpp_array_element_size(source->klass));

        size_t byte_len = (size_t)length * element_size;

        memmove(
            il2cpp_array_addr_with_size(dest, element_size, dest_idx),
            il2cpp_array_addr_with_size(source, element_size, source_idx),
            byte_len);

        gc::GarbageCollector::SetWriteBarrier((void**)il2cpp_array_addr_with_size(dest, element_size, dest_idx), byte_len);

        return true;
    }

    int32_t Array::GetLength(Il2CppArray* thisPtr, int32_t dimension)
    {
        int32_t rank = thisPtr->klass->rank;
        il2cpp_array_size_t length;

        if ((dimension < 0) || (dimension >= rank))
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetIndexOutOfRangeException());

        if (thisPtr->bounds == NULL)
            length = thisPtr->max_length;
        else
            length = thisPtr->bounds[dimension].length;

#ifdef IL2CPP_BIG_ARRAYS
        if (length > G_MAXINT32)
            mono_raise_exception(mono_get_exception_overflow());
#endif
        return ARRAY_LENGTH_AS_INT32(length);
    }

    int32_t Array::GetLowerBound(Il2CppArray* thisPtr, int32_t dimension)
    {
        int32_t rank = thisPtr->klass->rank;

        if ((dimension < 0) || (dimension >= rank))
            vm::Exception::Raise(vm::Exception::GetIndexOutOfRangeException());

        if (thisPtr->bounds == NULL)
            return false;

        return thisPtr->bounds[dimension].lower_bound;
    }

    int32_t Array::GetRank(Il2CppArray* arr)
    {
        return arr->klass->rank;
    }

    Il2CppObject* Array::GetValue(Il2CppArray* thisPtr, Il2CppArray* indices)
    {
        Il2CppClass *ac, *ic;
        Il2CppArray *ao, *io;
        int32_t i, *ind;
        il2cpp_array_size_t pos;

        IL2CPP_CHECK_ARG_NULL(indices);

        io = (Il2CppArray*)indices;
        ic = (Il2CppClass*)io->klass;

        ao = (Il2CppArray*)thisPtr;
        ac = (Il2CppClass*)ao->klass;

        IL2CPP_ASSERT(ic->rank == 1);
        if (io->bounds != NULL || io->max_length !=  ac->rank)
            vm::Exception::Raise(vm::Exception::GetArgumentException(NULL, NULL));

        ind = (int32_t*)il2cpp::vm::Array::GetFirstElementAddress(io);

        if (ao->bounds == NULL)
        {
            if (*ind < 0 || *ind >= ARRAY_LENGTH_AS_INT32(ao->max_length))
                vm::Exception::Raise(vm::Exception::GetIndexOutOfRangeException());

            return GetValueImpl(thisPtr, *ind);
        }

        for (i = 0; i < ac->rank; i++)
            if ((ind[i] < ao->bounds[i].lower_bound) ||
                (ind[i] >= ARRAY_LENGTH_AS_INT32(ao->bounds[i].length) + ao->bounds[i].lower_bound))
                vm::Exception::Raise(vm::Exception::GetIndexOutOfRangeException());

        pos = vm::Array::IndexFromIndices(ao, ind);

        return GetValueImpl(thisPtr, ARRAY_LENGTH_AS_INT32(pos));
    }

    Il2CppObject* Array::GetValueImpl(Il2CppArray* thisPtr, int32_t pos)
    {
        Il2CppClass* typeInfo = thisPtr->klass;
        void **ea;

        ea = (void**)il2cpp_array_addr_with_size(thisPtr, pos, typeInfo->element_size);

        if (typeInfo->element_class->byval_arg.valuetype)
            return il2cpp::vm::Object::Box(typeInfo->element_class, ea);

        return (Il2CppObject*)*ea;
    }

    void Array::ClearInternal(Il2CppArray* arr, int32_t index, int32_t count)
    {
        int sz = il2cpp_array_element_size(arr->klass);
        memset(il2cpp_array_addr_with_size(arr, sz, index), 0, count * sz);
    }

    void Array::SetValue(Il2CppArray* thisPtr, Il2CppObject* value, Il2CppArray* indices)
    {
        Il2CppClass *ac, *ic;
        int32_t i, *ind;
        il2cpp_array_size_t pos;

        IL2CPP_CHECK_ARG_NULL(indices);

        ic = indices->klass;
        ac = thisPtr->klass;

        IL2CPP_ASSERT(ic->rank == 1);
        if (indices->bounds != NULL || indices->max_length != ac->rank)
            vm::Exception::Raise(vm::Exception::GetArgumentException(NULL, NULL));

        ind = (int32_t*)il2cpp::vm::Array::GetFirstElementAddress(indices);

        if (thisPtr->bounds == NULL)
        {
            if (*ind < 0 || *ind >= ARRAY_LENGTH_AS_INT32(thisPtr->max_length))
                vm::Exception::Raise(vm::Exception::GetIndexOutOfRangeException());

            SetValueImpl(thisPtr, value, *ind);
            return;
        }

        for (i = 0; i < ac->rank; i++)
            if ((ind[i] < thisPtr->bounds[i].lower_bound) ||
                (ind[i] >= (il2cpp_array_lower_bound_t)thisPtr->bounds[i].length + thisPtr->bounds[i].lower_bound))
                vm::Exception::Raise(vm::Exception::GetIndexOutOfRangeException());

        pos = vm::Array::IndexFromIndices(thisPtr, ind);

        SetValueImpl(thisPtr, value, ARRAY_LENGTH_AS_INT32(pos));
    }

    static void ThrowNoWidening()
    {
        vm::Exception::Raise(vm::Exception::GetArgumentException("value", "not a widening conversion"));
    }

    static void ThrowInvalidCast(const Il2CppClass* a, const Il2CppClass* b)
    {
        vm::Exception::Raise(vm::Exception::GetInvalidCastException(utils::Exception::FormatInvalidCastException(b, a).c_str()));
    }

    union WidenedValueUnion
    {
        int64_t i64;
        uint64_t u64;
        double r64;
    };

    WidenedValueUnion ExtractWidenedValue(Il2CppTypeEnum type, void* value)
    {
        WidenedValueUnion extractedValue = { 0 };
        switch (type)
        {
            case IL2CPP_TYPE_U1:
                extractedValue.u64 = *(uint8_t*)value;
                break;
            case IL2CPP_TYPE_CHAR:
                extractedValue.u64 = *(Il2CppChar*)value;
                break;
            case IL2CPP_TYPE_U2:
                extractedValue.u64 = *(uint16_t*)value;
                break;
            case IL2CPP_TYPE_U4:
                extractedValue.u64 = *(uint32_t*)value;
                break;
            case IL2CPP_TYPE_U8:
                extractedValue.u64 = *(uint64_t*)value;
                break;
            case IL2CPP_TYPE_I1:
                extractedValue.i64 = *(int8_t*)value;
                break;
            case IL2CPP_TYPE_I2:
                extractedValue.i64 = *(int16_t*)value;
                break;
            case IL2CPP_TYPE_I4:
                extractedValue.i64 = *(int32_t*)value;
                break;
            case IL2CPP_TYPE_I8:
                extractedValue.i64 = *(int64_t*)value;
                break;
            case IL2CPP_TYPE_R4:
                extractedValue.r64 = *(float*)value;
                break;
            case IL2CPP_TYPE_R8:
                extractedValue.r64 = *(double*)value;
                break;
            default:
                IL2CPP_ASSERT(0);
                break;
        }

        return extractedValue;
    }

    static void CheckWideningConversion(size_t elementSize, size_t valueSize, size_t extra = 0)
    {
        if (elementSize < valueSize + (extra))
            ThrowNoWidening();
    }

    template<typename T>
    static void AssignUnsigned(WidenedValueUnion value, void* elementAddress, Il2CppTypeEnum valueType, size_t elementSize, size_t valueSize)
    {
        switch (valueType)
        {
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_CHAR:
                CheckWideningConversion(elementSize, valueSize);
                *(T*)elementAddress = (T)value.u64;
                break;
            /* You can't assign a signed value to an unsigned array. */
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_I8:
            /* You can't assign a floating point number to an integer array. */
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_R8:
                ThrowNoWidening();
                break;
            default:
                IL2CPP_ASSERT(0);
                break;
        }
    }

    template<typename T>
    static void AssignSigned(WidenedValueUnion value, void* elementAddress, Il2CppTypeEnum valueType, size_t elementSize, size_t valueSize)
    {
        switch (valueType)
        {
            /* You can assign an unsigned value to a signed array if the array's
                element size is larger than the value size. */
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_CHAR:
                CheckWideningConversion(elementSize, valueSize, 1);
                *(T*)elementAddress = (T)value.u64;
                break;
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_I8:
                CheckWideningConversion(elementSize, valueSize);
                *(T*)elementAddress = (T)value.i64;
                break;
            /* You can't assign a floating point number to an integer array. */
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_R8:
                ThrowNoWidening();
                break;
            default:
                IL2CPP_ASSERT(0);
                break;
        }
    }

    template<typename T>
    static void AssignReal(WidenedValueUnion value, void* elementAddress, Il2CppTypeEnum valueType, size_t elementSize, size_t valueSize)
    {
        switch (valueType)
        {
            /* All integers fit into the floating point value range. No need to check size. */
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_CHAR:
                *(T*)elementAddress = (T)value.u64;
                break;
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_I8:
                *(T*)elementAddress = (T)value.i64;
                break;
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_R8:
                CheckWideningConversion(elementSize, valueSize);
                *(T*)elementAddress = (T)value.r64;
                break;
            default:
                IL2CPP_ASSERT(0);
                break;
        }
    }

    void Array::SetValueImpl(Il2CppArray* thisPtr, Il2CppObject* value, int32_t index)
    {
        Il2CppClass* typeInfo = thisPtr->klass;
        Il2CppClass* elementClass = vm::Class::GetElementClass(typeInfo);

        int elementSize = vm::Class::GetArrayElementSize(elementClass);
        void* elementAddress = il2cpp_array_addr_with_size(thisPtr, elementSize, index);

        if (vm::Class::IsNullable(elementClass))
        {
            vm::Object::NullableInit((uint8_t*)elementAddress, value, elementClass);
            return;
        }

        if (value == NULL)
        {
            memset(elementAddress, 0, elementSize);
            return;
        }

        if (!vm::Class::IsValuetype(elementClass))
        {
            if (!vm::Object::IsInst(value, elementClass))
                vm::Exception::Raise(vm::Exception::GetInvalidCastException(utils::Exception::FormatInvalidCastException(thisPtr->klass->element_class, value->klass).c_str()));
            il2cpp_array_setref(thisPtr, index, value);
            return;
        }

        if (vm::Object::IsInst(value, elementClass))
        {
            memcpy(elementAddress, vm::Object::Unbox(value), elementSize);
            gc::GarbageCollector::SetWriteBarrier((void**)elementAddress, elementSize);
            return;
        }

        Il2CppClass* valueClass = vm::Object::GetClass(value);

        if (!vm::Class::IsValuetype(valueClass))
            ThrowInvalidCast(elementClass, valueClass);

        int valueSize = vm::Class::GetInstanceSize(valueClass) - sizeof(Il2CppObject);

        Il2CppTypeEnum elementType = vm::Class::IsEnum(elementClass) ? vm::Class::GetEnumBaseType(elementClass)->type : elementClass->byval_arg.type;
        Il2CppTypeEnum valueType = vm::Class::IsEnum(valueClass) ? vm::Class::GetEnumBaseType(valueClass)->type : valueClass->byval_arg.type;

        if (elementType == IL2CPP_TYPE_BOOLEAN)
        {
            switch (valueType)
            {
                case IL2CPP_TYPE_BOOLEAN:
                    break;
                case IL2CPP_TYPE_CHAR:
                case IL2CPP_TYPE_U1:
                case IL2CPP_TYPE_U2:
                case IL2CPP_TYPE_U4:
                case IL2CPP_TYPE_U8:
                case IL2CPP_TYPE_I1:
                case IL2CPP_TYPE_I2:
                case IL2CPP_TYPE_I4:
                case IL2CPP_TYPE_I8:
                case IL2CPP_TYPE_R4:
                case IL2CPP_TYPE_R8:
                    ThrowNoWidening();
                default:
                    ThrowInvalidCast(elementClass, valueClass);
            }
        }

        WidenedValueUnion widenedValue = ExtractWidenedValue(valueType, vm::Object::Unbox(value));

        switch (elementType)
        {
            case IL2CPP_TYPE_U1:
                AssignUnsigned<uint8_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_CHAR:
                AssignUnsigned<Il2CppChar>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_U2:
                AssignUnsigned<uint16_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_U4:
                AssignUnsigned<uint32_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_U8:
                AssignUnsigned<uint64_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_I1:
                AssignSigned<int8_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_I2:
                AssignSigned<int16_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_I4:
                AssignSigned<int32_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_I8:
                AssignSigned<int64_t>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_R4:
                AssignReal<float>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            case IL2CPP_TYPE_R8:
                AssignReal<double>(widenedValue, elementAddress, valueType, elementSize, valueSize);
                break;
            default:
                ThrowInvalidCast(elementClass, valueClass);
                break;
        }
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Array.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Buffer.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "icalls/mscorlib/System/Buffer.h"
#include "il2cpp-class-internals.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"

using il2cpp::vm::Class;


namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    static bool IsPrimitive(const Il2CppType* type)
    {
        switch (type->type)
        {
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_BOOLEAN:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_CHAR:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_I:
            case IL2CPP_TYPE_U:
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_R8:
                return true;
            default:
                return false;
        }
    }

    static int32_t ArrayOfPrimitivesByteLength(Il2CppArray* value)
    {
        const Il2CppType* elementType = vm::Class::GetType(value->klass->element_class);
        if (IsPrimitive(elementType))
            return vm::Array::GetByteLength(value);
        return -1;
    }

    bool Buffer::InternalBlockCopy(Il2CppArray* src, int32_t srcOffsetBytes, Il2CppArray* dest, int32_t dstOffsetBytes, int32_t count)
    {
        IL2CPP_CHECK_ARG_NULL(src);
        IL2CPP_CHECK_ARG_NULL(dest);

        // Watch out for integer overflow and note that these array byte "lengths" can be -1 (to indicate a failure).
        int32_t srcLength = ArrayOfPrimitivesByteLength(src);
        int32_t dstLength = ArrayOfPrimitivesByteLength(dest);
        if ((srcOffsetBytes > (srcLength - count)) || (dstOffsetBytes > (dstLength - count)))
            return false;

        char* src_buf = ((char*)il2cpp_array_addr_with_size(src, Class::GetInstanceSize(src->klass->element_class), 0)) + srcOffsetBytes;
        char* dest_buf = ((char*)il2cpp_array_addr_with_size(dest, Class::GetInstanceSize(dest->klass->element_class), 0)) + dstOffsetBytes;

        if (src != dest)
            memcpy(dest_buf, src_buf, count);
        else
            memmove(dest_buf, src_buf, count); /* Source and dest are the same array */

        return true;
    }

    // This function should return -1 is the array element type is not a primitive type.
    // It is possible to compute the byte length for other element types, but the class
    // libraries assume this special behavior.
    int32_t Buffer::_ByteLength(Il2CppArray* array)
    {
        return ArrayOfPrimitivesByteLength(array);
    }

    void Buffer::InternalMemcpy(uint8_t* dest, uint8_t* src, int32_t count)
    {
        memcpy(dest, src, count);
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Buffer.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\CLRConfig.cpp---------------
.
.
#include "il2cpp-config.h"
#include "CLRConfig.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    bool CLRConfig::CheckThrowUnobservedTaskExceptions()
    {
        // TODO : Properly support this icall at some point.  This requires knowning that the ThrowUnobservedTaskExceptions=true flag was
        // set in the app.config and return true here if it was
        return false;
    }
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\CLRConfig.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\ConsoleDriver.cpp---------------
.
.
#include "il2cpp-config.h"

#include "gc/WriteBarrier.h"
#include "icalls/mscorlib/System/ConsoleDriver.h"
#include "il2cpp-class-internals.h"
#include "os/Console.h"
#include "os/File.h"
#include "vm/Array.h"
#include "vm/Exception.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
// Used in .NET 2.0 System.Console -> CStreamReader/CStreamWriter -> TermInfoDriver -> ConsoleDriver -> icalls

    bool ConsoleDriver::Isatty(intptr_t handle)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;
        auto result = os::File::Isatty(fileHandle);
        vm::Exception::RaiseIfError(result.GetError());
        return result.Get();
    }

    int32_t ConsoleDriver::InternalKeyAvailable(int32_t ms_timeout)
    {
        return il2cpp::os::Console::InternalKeyAvailable(ms_timeout);
    }

    bool ConsoleDriver::TtySetup(Il2CppString* keypadXmit, Il2CppString* teardown, Il2CppArray** control_characters, int32_t** size)
    {
        const std::string keypadXmitString(keypadXmit ? il2cpp::utils::StringUtils::Utf16ToUtf8(keypadXmit->chars) : "");
        const std::string teardownString(teardown ? il2cpp::utils::StringUtils::Utf16ToUtf8(teardown->chars) : "");

        uint8_t controlChars[17];

        const bool ret = il2cpp::os::Console::TtySetup(keypadXmitString, teardownString, controlChars, size);

        gc::WriteBarrier::GenericStore(control_characters, vm::Array::New(il2cpp_defaults.byte_class, 17));

        if (ret)
            memcpy(il2cpp_array_addr(*control_characters, uint8_t, 0), controlChars, 17);

        return true;
    }

    bool ConsoleDriver::SetEcho(bool wantEcho)
    {
        return il2cpp::os::Console::SetEcho(wantEcho);
    }

    bool ConsoleDriver::SetBreak(bool wantBreak)
    {
        return il2cpp::os::Console::SetBreak(wantBreak);
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\ConsoleDriver.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\CurrentSystemTimeZone.cpp---------------
.
.
#include "il2cpp-config.h"
#include <string>
#include "gc/WriteBarrier.h"
#include "icalls/mscorlib/System/CurrentSystemTimeZone.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/Array.h"
#include "vm/Exception.h"
#include "vm/String.h"
#include "os/TimeZone.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    bool CurrentSystemTimeZone::GetTimeZoneData40(int year, Il2CppArray** data, Il2CppArray** names, bool* daylight_inverted)
    {
        int64_t dataTemp[4] = {0};
        std::string namesTemp[2];
        IL2CPP_CHECK_ARG_NULL(data);
        IL2CPP_CHECK_ARG_NULL(names);

        gc::WriteBarrier::GenericStore(data, vm::Array::New(il2cpp_defaults.int64_class, 4));
        gc::WriteBarrier::GenericStore(names, vm::Array::New(il2cpp_defaults.string_class, 2));
        if (!os::TimeZone::GetTimeZoneData(year, dataTemp, namesTemp, daylight_inverted))
            return false;

        for (int i = 0; i < 4; i++)
            il2cpp_array_set((*data), int64_t, i, dataTemp[i]);

        for (int i = 0; i < 2; i++)
            il2cpp_array_setref((*names), i, vm::String::New(namesTemp[i].c_str()));

        return true;
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\CurrentSystemTimeZone.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\DateTime.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System/DateTime.h"
#include "os/Time.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    int64_t DateTime::GetSystemTimeAsFileTime()
    {
        return os::Time::GetSystemTimeAsFileTime();
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\DateTime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Delegate.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "icalls/mscorlib/System/Delegate.h"
#include "gc/WriteBarrier.h"
#include "vm/Class.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/Type.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    Il2CppDelegate * Delegate::CreateDelegate_internal(Il2CppReflectionType *__type, Il2CppObject *target, Il2CppReflectionMethod *info, bool throwOnBindFailure)
    {
        Il2CppClass *delegate_class = il2cpp::vm::Class::FromIl2CppType(__type->type);
        const MethodInfo *method = info->method;

        IL2CPP_ASSERT(delegate_class->parent == il2cpp_defaults.multicastdelegate_class);

        //if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR) {
        //  if (!mono_security_core_clr_ensure_delegate_creation (method, throwOnBindFailure))
        //      return NULL;
        //}

        Il2CppObject* delegate = il2cpp::vm::Object::New(delegate_class);
        il2cpp::vm::Type::ConstructDelegate((Il2CppDelegate*)delegate, target, method);

        return (Il2CppDelegate*)delegate;
    }

    void Delegate::SetMulticastInvoke(Il2CppDelegate * delegate)
    {
    }

    Il2CppMulticastDelegate* Delegate::AllocDelegateLike_internal(Il2CppDelegate* d)
    {
        IL2CPP_ASSERT(d->object.klass->parent == il2cpp_defaults.multicastdelegate_class);

        Il2CppMulticastDelegate *ret = (Il2CppMulticastDelegate*)il2cpp::vm::Object::New(d->object.klass);

        IL2CPP_OBJECT_SETREF((&ret->delegate), invoke_impl_this, (Il2CppObject*)ret);

        // extra_arg stores the multicast_invoke_impl
        ret->delegate.invoke_impl = (Il2CppMethodPointer)d->extraArg;
        ret->delegate.extraArg = d->extraArg;

        return ret;
    }

    Il2CppReflectionMethod* Delegate::GetVirtualMethod_internal(Il2CppDelegate* _this)
    {
        const MethodInfo* resolvedMethod = _this->target != NULL ? il2cpp::vm::Object::GetVirtualMethod(_this->target, _this->method) : _this->method;
        return il2cpp::vm::Reflection::GetMethodObject(resolvedMethod, NULL);
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Delegate.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Enum.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "icalls/mscorlib/System/Enum.h"
#include "vm/Class.h"
#include "vm/Object.h"
#include "vm/Exception.h"
#include "vm/Reflection.h"
#include "vm/Enum.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    bool Enum::GetEnumValuesAndNames(Il2CppReflectionRuntimeType* enumType, Il2CppArray** values, Il2CppArray** names)
    {
        return vm::Enum::GetEnumValuesAndNames(vm::Class::FromIl2CppType(enumType->type.type), values, names);
    }

    bool Enum::InternalHasFlag(Il2CppObject* thisPtr, Il2CppObject* flags)
    {
        Il2CppClass* enumClass = vm::Class::FromIl2CppType(vm::Class::GetEnumBaseType(thisPtr->klass));
        int32_t size = vm::Class::GetValueSize(enumClass, NULL);
        uint64_t a_val = 0, b_val = 0;

        memcpy(&a_val, vm::Object::Unbox(thisPtr), size);
        memcpy(&b_val, vm::Object::Unbox(flags), size);

        return (a_val & b_val) == b_val;
    }

    int32_t Enum::get_hashcode(Il2CppObject* thisPtr)
    {
        void* data = (char*)thisPtr + sizeof(Il2CppObject);
        Il2CppClass *basetype = thisPtr->klass->element_class;
        IL2CPP_ASSERT(basetype);

        if (basetype == il2cpp_defaults.sbyte_class)
            return *((int8_t*)data);
        if (basetype == il2cpp_defaults.byte_class)
            return *((uint8_t*)data);
        if (basetype == il2cpp_defaults.char_class)
            return *((Il2CppChar*)data);
        if (basetype == il2cpp_defaults.uint16_class)
            return *((uint16_t*)data);
        if (basetype == il2cpp_defaults.int16_class)
            return *((uint16_t*)data);
        if (basetype == il2cpp_defaults.uint32_class)
            return *((uint32_t*)data);
        if (basetype == il2cpp_defaults.int32_class)
            return *((int32_t*)data);
        if (basetype == il2cpp_defaults.uint64_class || basetype == il2cpp_defaults.int64_class)
        {
            int64_t value = *((int64_t*)data);
            return (int32_t)(value & 0xffffffff) ^ (int32_t)(value >> 32);
        }

        IL2CPP_ASSERT(0 && "System_Enum_get_hashcode_icall");
        return 0;
    }

    int32_t Enum::InternalCompareTo(Il2CppObject* o1, Il2CppObject* o2)
    {
        const int retIncompatibleMethodTables = 2;  // indicates that the method tables did not match
        const int retInvalidEnumType = 3; // indicates that the enum was of an unknown/unsupported underlying type

        if (vm::Object::GetClass(o1) != vm::Object::GetClass(o2))
            return retIncompatibleMethodTables;

        void* tdata = (char*)o1 + sizeof(Il2CppObject);
        void* odata = (char*)o2 + sizeof(Il2CppObject);
        const Il2CppType* basetype = vm::Class::GetEnumBaseType(vm::Object::GetClass(o1));
        IL2CPP_ASSERT(basetype);

#define COMPARE_ENUM_VALUES(ENUM_TYPE) do { \
        ENUM_TYPE me = *((ENUM_TYPE*)tdata); \
        ENUM_TYPE other = *((ENUM_TYPE*)odata); \
        if (me == other) \
            return 0; \
        return me > other ? 1 : -1; \
    } while (0)

        switch (basetype->type)
        {
            case IL2CPP_TYPE_U1:
                COMPARE_ENUM_VALUES(uint8_t);
            case IL2CPP_TYPE_I1:
                COMPARE_ENUM_VALUES(int8_t);
            case IL2CPP_TYPE_CHAR:
                COMPARE_ENUM_VALUES(Il2CppChar);
            case IL2CPP_TYPE_U2:
                COMPARE_ENUM_VALUES(uint16_t);
            case IL2CPP_TYPE_I2:
                COMPARE_ENUM_VALUES(int16_t);
            case IL2CPP_TYPE_U4:
                COMPARE_ENUM_VALUES(uint32_t);
            case IL2CPP_TYPE_I4:
                COMPARE_ENUM_VALUES(int32_t);
            case IL2CPP_TYPE_U8:
                COMPARE_ENUM_VALUES(uint64_t);
            case IL2CPP_TYPE_I8:
                COMPARE_ENUM_VALUES(int64_t);
            case IL2CPP_TYPE_U:
                COMPARE_ENUM_VALUES(uintptr_t);
            case IL2CPP_TYPE_I:
                COMPARE_ENUM_VALUES(intptr_t);
            default:
                IL2CPP_ASSERT(false && "Implement type 0x%02x in Enum::InternalCompareTo");
                return retInvalidEnumType;
        }

#undef COMPARE_ENUM_VALUES
        return retInvalidEnumType;
    }

    Il2CppObject* Enum::get_value(Il2CppObject* thisPtr)
    {
        if (!thisPtr)
            return NULL;

        IL2CPP_ASSERT(thisPtr->klass->enumtype);

        Il2CppClass* enumClass = vm::Class::FromIl2CppType(vm::Class::GetEnumBaseType(thisPtr->klass));
        Il2CppObject* res = vm::Object::New(enumClass);
        void* dst = (char*)res + sizeof(Il2CppObject);
        void* src = (char*)thisPtr + sizeof(Il2CppObject);
        int32_t size = vm::Class::GetValueSize(enumClass, NULL);

        memcpy(dst, src, size);

        return res;
    }

    Il2CppObject* Enum::InternalBoxEnum(Il2CppReflectionRuntimeType* enumType, int64_t value)
    {
        return vm::Object::Box(vm::Class::FromIl2CppType(enumType->type.type), &value);
    }

    Il2CppReflectionRuntimeType* Enum::InternalGetUnderlyingType(Il2CppReflectionRuntimeType* enumType)
    {
        const Il2CppType* etype;

        etype = vm::Class::GetEnumBaseType(vm::Class::FromIl2CppType(enumType->type.type));
        if (!etype)
            /* MS throws this for typebuilders */
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentException("Type must be a type provided by the runtime.", "enumType"));

        return reinterpret_cast<Il2CppReflectionRuntimeType*>(il2cpp::vm::Reflection::GetTypeObject(etype));
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Enum.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Environment.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"

#include "icalls/mscorlib/System/Environment.h"

#include "os/CrashHelpers.h"
#include "os/Time.h"
#include "os/Environment.h"

#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Exception.h"

#include "utils/PathUtils.h"
#include "utils/StringUtils.h"
#include "utils/Environment.h"
#include "utils/Exception.h"
#include "utils/Logging.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    static bool socket_security_enabled = false;

    static Il2CppArray* ToIl2CppArray(const std::vector<std::string>& strings)
    {
        Il2CppClass* klass = il2cpp::vm::Class::GetArrayClass(il2cpp_defaults.string_class, 1);
        Il2CppArray* array = (Il2CppArray*)il2cpp::vm::Array::NewSpecific(klass, (il2cpp_array_size_t)strings.size());

        for (size_t i = 0, size = strings.size(); i < size; ++i)
            il2cpp_array_setref(array, i, il2cpp::vm::String::New(strings[i].c_str()));

        return array;
    }

    bool Environment::get_HasShutdownStarted()
    {
        return vm::Runtime::IsShuttingDown();
    }

    bool Environment::GetIs64BitOperatingSystem()
    {
        if (sizeof(void*) == 8)
            return true;
        auto result = il2cpp::os::Environment::Is64BitOs();
        vm::Exception::RaiseIfError(result.GetError());
        return result.Get();
    }

    int32_t Environment::get_ExitCode()
    {
        return vm::Runtime::GetExitCode();
    }

    int32_t Environment::get_ProcessorCount()
    {
        return il2cpp::os::Environment::GetProcessorCount();
    }

    int32_t Environment::get_TickCount()
    {
        return il2cpp::os::Time::GetTicksMillisecondsMonotonic();
    }

    int32_t Environment::GetPageSize()
    {
        return IL2CPP_PAGE_SIZE;
    }

    int32_t Environment::get_Platform()
    {
#if IL2CPP_TARGET_WINDOWS
        return 2;
#elif IL2CPP_TARGET_DARWIN
        // new Mono expects distinct platform value for OSX/iOS
        return 6;
#else
        return 4;
#endif
    }

    Il2CppString* Environment::get_bundled_machine_config()
    {
        return NULL;
    }

    Il2CppString* Environment::get_MachineName()
    {
        return il2cpp::vm::String::New(il2cpp::os::Environment::GetMachineName().c_str());
    }

    Il2CppString* Environment::get_UserName()
    {
        return il2cpp::vm::String::New(il2cpp::os::Environment::GetOsUserName().c_str());
    }

    Il2CppString* Environment::GetMachineConfigPath()
    {
        const char* frameworkVersion = vm::Runtime::GetFrameworkVersion();

        std::string path = utils::PathUtils::Combine(
            vm::Runtime::GetConfigDir(), utils::PathUtils::Combine(
                utils::StringView<char>("mono"), utils::PathUtils::Combine(
                    utils::StringView<char>(frameworkVersion, strlen(frameworkVersion)), utils::StringView<char>("machine.config"))));

        return vm::String::NewWrapper(path.c_str());
    }

    Il2CppString* Environment::GetNewLine()
    {
        return il2cpp::vm::String::NewUtf16(kIl2CppNewLine);
    }

    Il2CppString* Environment::GetOSVersionString()
    {
        return il2cpp::vm::String::New(il2cpp::os::Environment::GetOsVersionString().c_str());
    }

    Il2CppString* Environment::GetWindowsFolderPath(int32_t folder)
    {
        auto result = il2cpp::os::Environment::GetWindowsFolderPath(folder);
        vm::Exception::RaiseIfError(result.GetError());
        return il2cpp::vm::String::New(result.Get().c_str());
    }

    Il2CppString* Environment::internalGetEnvironmentVariable_native(intptr_t variablePtr)
    {
        const char* value = (char*)variablePtr;

        if (!value)
            return NULL;

        const std::string nameStr(value);
        const std::string variable(il2cpp::os::Environment::GetEnvironmentVariable(nameStr));

        return variable.empty() ? NULL : il2cpp::vm::String::New(variable.c_str());
    }

    Il2CppString* Environment::internalGetHome()
    {
        return il2cpp::vm::String::New(il2cpp::os::Environment::GetHomeDirectory().c_str());
    }

    Il2CppArray* Environment::GetCommandLineArgs()
    {
        Il2CppArray *res;
        int i;
        int num_main_args = utils::Environment::GetNumMainArgs();
        const std::vector<UTF16String>& mainArgs = utils::Environment::GetMainArgs();

        Il2CppClass *klass = il2cpp::vm::Class::GetArrayClass(il2cpp_defaults.string_class, 1);
        res = (Il2CppArray*)il2cpp::vm::Array::NewSpecific(klass, num_main_args);

        for (i = 0; i < num_main_args; ++i)
            il2cpp_array_setref(res, i, il2cpp::vm::String::NewUtf16(mainArgs[i].c_str(), static_cast<int>(mainArgs[i].length())));

        return res;
    }

    Il2CppArray* Environment::GetEnvironmentVariableNames()
    {
        return ToIl2CppArray(il2cpp::os::Environment::GetEnvironmentVariableNames());
    }

    Il2CppArray* Environment::GetLogicalDrivesInternal()
    {
        return ToIl2CppArray(il2cpp::os::Environment::GetLogicalDrives());
    }

    void Environment::Exit(int32_t exitCode)
    {
        set_ExitCode(exitCode);
        il2cpp::vm::Runtime::Shutdown();
        il2cpp::os::Environment::Exit(exitCode);
    }

    void Environment::FailFast(Il2CppString* message, Il2CppException* exception, Il2CppString* errorSource)
    {
        bool messageWritten = false;
        if (message != NULL)
        {
            std::string messageUtf8 = il2cpp::utils::StringUtils::Utf16ToUtf8(message->chars, message->length);
            if (!messageUtf8.empty())
            {
                il2cpp::utils::Logging::Write(messageUtf8.c_str());
                messageWritten = true;
            }
        }

        if (!messageWritten)
            il2cpp::utils::Logging::Write("Managed code called FailFast without specifying a reason.");

        if (exception != NULL)
        {
            std::string exceptionMessage = utils::Exception::FormatException(exception);
            il2cpp::utils::Logging::Write(exceptionMessage.c_str());
        }

        il2cpp::os::CrashHelpers::Crash();
    }

    void Environment::InternalSetEnvironmentVariable(Il2CppChar* variable, int32_t variable_length, Il2CppChar* value, int32_t value_length)
    {
        const std::string variableStr(utils::StringUtils::Utf16ToUtf8(variable));

        const bool clearValue = value == NULL || value_length == 0 || utils::StringUtils::GetChars(0) == 0;

        const std::string valueStr = clearValue ? std::string() : utils::StringUtils::Utf16ToUtf8(value);

        il2cpp::os::Environment::SetEnvironmentVariable(variableStr, valueStr);
    }

    void Environment::set_ExitCode(int32_t value)
    {
        vm::Runtime::SetExitCode(value);
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Environment.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Exception.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Exception.h"
#include "vm/Runtime.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    void Exception::ReportUnhandledException(Il2CppException* exception)
    {
        vm::Runtime::UnhandledException(exception);
    }
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Exception.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\GC.cpp---------------
.
.
#include "il2cpp-config.h"

#include "il2cpp-class-internals.h"
#include "icalls/mscorlib/System/GC.h"
#include "gc/GarbageCollector.h"
#include "vm/Domain.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Array.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    int32_t GC::GetCollectionCount(int32_t generation)
    {
        return il2cpp::gc::GarbageCollector::GetCollectionCount(generation);
    }

    int32_t GC::GetGeneration(Il2CppObject* obj)
    {
        return il2cpp::gc::GarbageCollector::GetGeneration(obj);
    }

    int32_t GC::GetMaxGeneration()
    {
        return il2cpp::gc::GarbageCollector::GetMaxGeneration();
    }

    int64_t GC::GetAllocatedBytesForCurrentThread()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(GC::GetAllocatedBytesForCurrentThread);
        IL2CPP_UNREACHABLE;
        return 0;
    }

    int64_t GC::GetTotalMemory(bool forceFullCollection)
    {
        if (forceFullCollection)
            il2cpp::gc::GarbageCollector::Collect(il2cpp::gc::GarbageCollector::GetMaxGeneration());

        return il2cpp::gc::GarbageCollector::GetUsedHeapSize();
    }

    Il2CppObject* GC::get_ephemeron_tombstone()
    {
        return il2cpp::vm::Domain::GetCurrent()->ephemeron_tombstone;
    }

    void GC::_ReRegisterForFinalize(Il2CppObject* obj)
    {
        if (obj == NULL)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentNullException("obj"));

        il2cpp::gc::GarbageCollector::RegisterFinalizer(obj);
    }

    void GC::_SuppressFinalize(Il2CppObject* obj)
    {
        if (obj == NULL)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentNullException("obj"));

        il2cpp::gc::GarbageCollector::SuppressFinalizer(obj);
    }

    void GC::InternalCollect(int32_t generation)
    {
        il2cpp::gc::GarbageCollector::Collect(generation);
    }

    void GC::RecordPressure(int64_t bytesAllocated)
    {
        il2cpp::gc::GarbageCollector::AddMemoryPressure(bytesAllocated);
    }

    void GC::register_ephemeron_array(Il2CppArray* array)
    {
        il2cpp::gc::GarbageCollector::EphemeronArrayAdd((Il2CppObject*)array);
    }

    void GC::WaitForPendingFinalizers()
    {
        il2cpp::gc::GarbageCollector::WaitForPendingFinalizers();
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\GC.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\MonoCustomAttrs.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "icalls/mscorlib/System/MonoCustomAttrs.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "gc/GarbageCollector.h"
#include "metadata/CustomAttributeDataReader.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/Exception.h"
#include "vm/MetadataCache.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    Il2CppArray * MonoCustomAttrs::GetCustomAttributesInternal(Il2CppObject* obj, Il2CppReflectionType* type, bool pseudoAttrs)
    {
        IL2CPP_ASSERT(pseudoAttrs == false && "System_MonoCustomAttrs_GetCustomAttributesInternal_icall with pseudoAttrs == true has not been implemented yet");

        Il2CppClass* attributeClass = type != NULL ? vm::Class::FromIl2CppType(type->type) : NULL;

        Il2CppArray *result = il2cpp::vm::Reflection::GetCustomAttrsInfo(obj, attributeClass);

        if (!result)
            return il2cpp::vm::Array::New(il2cpp_defaults.attribute_class, 0);

        return result;
    }

    bool MonoCustomAttrs::IsDefinedInternal(Il2CppObject *obj, Il2CppReflectionType *attr_type)
    {
        return il2cpp::vm::Reflection::HasAttribute(obj, vm::Class::FromIl2CppType(attr_type->type));
    }

    static Il2CppObject* CreateCustomAttributeData(const Il2CppAssembly* assembly, const il2cpp::metadata::LazyCustomAttributeData& data)
    {
        static const MethodInfo* customAttributeDataConstructor;
        if (!customAttributeDataConstructor)
        {
            customAttributeDataConstructor = vm::Class::GetMethodFromName(il2cpp_defaults.customattribute_data_class, ".ctor", 4);
            if (customAttributeDataConstructor == NULL)
                IL2CPP_NOT_IMPLEMENTED_ICALL(MonoCustomAttrs::GetCustomAttributesDataInternal);
        }

        Il2CppObject* customAttributeData = vm::Object::New(il2cpp_defaults.customattribute_data_class);
        void* params[] =
        {
            vm::Reflection::GetMethodObject(data.ctor, data.ctor->klass),
            vm::Reflection::GetAssemblyObject(assembly),
            (void*)&data.dataStart,
            (void*)&data.dataLength
        };
        vm::Runtime::Invoke(customAttributeDataConstructor, customAttributeData, params, NULL);
        return customAttributeData;
    }

    Il2CppArray* MonoCustomAttrs::GetCustomAttributesDataInternal(Il2CppObject* obj)
    {
        metadata::CustomAttributeDataReader reader = il2cpp::vm::Reflection::GetCustomAttrsDataReader(obj);

        uint32_t count = reader.GetCount();

        Il2CppArray* result = il2cpp::vm::Array::New(il2cpp_defaults.customattribute_data_class, reader.GetCount());

        if (count == 0)
            return result;

        uint32_t i = 0;

        bool hasError = false;
        il2cpp::metadata::LazyCustomAttributeData data;
        Il2CppException* exc = NULL;
        il2cpp::metadata::CustomAttributeDataIterator iter = reader.GetDataIterator();
        while (reader.ReadLazyCustomAttributeData(&data, &iter, &exc))
        {
            IL2CPP_ASSERT(i < reader.GetCount());
            Il2CppObject* attributeData = CreateCustomAttributeData(obj->klass->image->assembly, data);
            il2cpp_array_setref(result, i, attributeData);
            i++;
        }

        if (exc != NULL)
            vm::Exception::Raise(exc);

        return result;
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\MonoCustomAttrs.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Number.cpp---------------
.
.
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Number.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\NumberFormatter.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System/NumberFormatter.h"
#include "il2cpp-number-formatter.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    void NumberFormatter::GetFormatterTables(uint64_t * * mantissas,
        int32_t * * exponents,
        int16_t * * digitLowerTable,
        int16_t * * digitUpperTable,
        int64_t * * tenPowersList,
        int32_t * * decHexDigits)
    {
        *mantissas = (uint64_t*)Formatter_MantissaBitsTable;
        *exponents = (int32_t*)Formatter_TensExponentTable;
        *digitLowerTable = (int16_t*)Formatter_DigitLowerTable;
        *digitUpperTable = (int16_t*)Formatter_DigitUpperTable;
        *tenPowersList = (int64_t*)Formatter_TenPowersList;
        *decHexDigits = (int32_t*)Formatter_DecHexDigits;
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\NumberFormatter.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Object.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "icalls/mscorlib/System/Object.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    int32_t Object::InternalGetHashCode(Il2CppObject* obj)
    {
        return il2cpp::vm::Object::GetHash(obj);
    }

    Il2CppObject* Object::MemberwiseClone(Il2CppObject* obj)
    {
        return il2cpp::vm::Object::Clone(obj);
    }

    Il2CppReflectionType* Object::GetType(Il2CppObject* obj)
    {
        return il2cpp::vm::Reflection::GetTypeObject(&obj->klass->byval_arg);
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Object.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeFieldHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeFieldHandle.h"

#include "icalls/mscorlib/System.Reflection/RuntimeFieldInfo.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/Type.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    Il2CppObject* RuntimeFieldHandle::GetValueDirect(Il2CppObject* field, Il2CppReflectionRuntimeType* fieldType, void* pTypedRef, Il2CppReflectionRuntimeType* contextType)
    {
        NOT_SUPPORTED_IL2CPP(RuntimeFieldHandle::GetValueDirect, "This icall is not supported by il2cpp.");
        return NULL;
    }

    void RuntimeFieldHandle::SetValueDirect(Il2CppReflectionField* field, Il2CppObject* fieldType, Il2CppTypedRef* typedRef, Il2CppObject* value, Il2CppObject* contextType)
    {
        IL2CPP_ASSERT(field);
        IL2CPP_ASSERT(typedRef);
        IL2CPP_ASSERT(value);

        FieldInfo* f = field->field;
        if (!vm::Type::IsStruct(&f->parent->byval_arg))
        {
            std::string errorMessage = "The type ";
            errorMessage += vm::Type::GetName(&f->parent->byval_arg, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
            errorMessage += " is not struct";
            vm::Exception::Raise(vm::Exception::GetNotSupportedException(errorMessage.c_str()));
            return;
        }

        if (vm::Type::IsReference(f->type))
            vm::Field::SetValueRaw(f->type, (uint8_t*)typedRef->value + f->offset - sizeof(Il2CppObject), value, false);
        else
            vm::Field::SetValueRaw(f->type, (uint8_t*)typedRef->value + f->offset - sizeof(Il2CppObject), vm::Object::Unbox(value), false);
    }

    void RuntimeFieldHandle::SetValueInternal(Il2CppReflectionField* fi, Il2CppObject* obj, Il2CppObject* value)
    {
        // In mono's icall-def.h file, this maps to the same icall as MonoField.SetValueInternal
        // so our implementation will do the same
        Reflection::RuntimeFieldInfo::SetValueInternal(fi, obj, value);
    }
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeFieldHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeMethodHandle.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System/RuntimeMethodHandle.h"
#include "vm/Exception.h"
#include "vm/Method.h"
#include "vm/Runtime.h"
#include "vm/MetadataCache.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    intptr_t RuntimeMethodHandle::GetFunctionPointer(intptr_t m)
    {
        MethodInfo* method = reinterpret_cast<MethodInfo*>(m);
        if (method->is_unmanaged_callers_only)
            return reinterpret_cast<intptr_t>(il2cpp::vm::MetadataCache::GetReversePInvokeWrapper(method->klass->image, method));
        return reinterpret_cast<intptr_t>(method);
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeMethodHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeType.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-runtime-metadata.h"
#include "il2cpp-api.h"
#include "il2cpp-tabledefs.h"
#include "mono-structs.h"

#include "RuntimeType.h"
#include "RuntimeTypeHandle.h"
#include "Type.h"
#include "metadata/GenericMetadata.h"
#include "utils/Functional.h"
#include "utils/Il2CppHashSet.h"
#include "utils/StringUtils.h"
#include "utils/dynamic_array.h"
#include "vm-utils/VmStringUtils.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Type.h"

#include <vector>
#include <set>

typedef int32_t BindingFlags;

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    struct Il2CppEventInfoHash
    {
        size_t operator()(const EventInfo* eventInfo) const
        {
            return il2cpp::utils::StringUtils::Hash(eventInfo->name);
        }
    };

    struct Il2CppEventInfoCompare
    {
        bool operator()(const EventInfo* event1, const EventInfo* event2) const
        {
            // You can't overload events
            return strcmp(event1->name, event2->name) == 0;
        }
    };

    typedef Il2CppHashMap<const EventInfo*, Il2CppClass*, Il2CppEventInfoHash, Il2CppEventInfoCompare> EventMap;

    struct PropertyPair
    {
        const PropertyInfo *property;
        Il2CppClass* originalType;

        PropertyPair(const PropertyInfo *property, Il2CppClass* originalType) : property(property), originalType(originalType)
        {
        }
    };

    typedef std::vector<PropertyPair> PropertyPairVector;

    static bool PropertyEqual(const PropertyInfo* prop1, const PropertyInfo* prop2)
    {
        // Name check is not enough, property can be overloaded
        if (strcmp(prop1->name, prop2->name) != 0)
            return false;

        return vm::Method::IsSameOverloadSignature(prop1, prop2);
    }

    static bool PropertyPairVectorContains(const PropertyPairVector& properties, const PropertyInfo* property)
    {
        for (PropertyPairVector::const_iterator it = properties.begin(), end = properties.end(); it != end; ++it)
            if (PropertyEqual(it->property, property))
                return true;

        return false;
    }

    int32_t RuntimeType::GetGenericParameterPosition(Il2CppReflectionRuntimeType* type)
    {
        if (RuntimeTypeHandle::IsGenericVariable(type))
            return vm::Type::GetGenericParameterInfo(type->type.type).num;
        return -1;
    }

    static inline bool IsPublic(const FieldInfo* field)
    {
        return (field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PUBLIC;
    }

    static inline bool IsPrivate(const FieldInfo* field)
    {
        return (field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PRIVATE;
    }

    static inline bool IsStatic(const FieldInfo* field)
    {
        return (field->type->attrs & FIELD_ATTRIBUTE_STATIC) != 0;
    }

    static inline bool IsPublic(const PropertyInfo* property)
    {
        if (property->get != NULL && (property->get->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
            return true;

        if (property->set != NULL && (property->set->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
            return true;

        return false;
    }

    static inline bool IsPrivate(const PropertyInfo* property)
    {
        if (property->get != NULL && (property->get->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) != METHOD_ATTRIBUTE_PRIVATE)
            return false;

        if (property->set != NULL && (property->set->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) != METHOD_ATTRIBUTE_PRIVATE)
            return false;

        return true;
    }

    static inline bool IsStatic(const PropertyInfo* property)
    {
        if (property->get != NULL)
            return (property->get->flags & METHOD_ATTRIBUTE_STATIC) != 0;

        if (property->set != NULL)
            return (property->set->flags & METHOD_ATTRIBUTE_STATIC) != 0;

        return false;
    }

    static inline bool IsPublic(const MethodInfo* method)
    {
        return (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC;
    }

    static inline bool IsPrivate(const MethodInfo* method)
    {
        return (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PRIVATE;
    }

    static inline bool IsStatic(const MethodInfo* method)
    {
        return (method->flags & METHOD_ATTRIBUTE_STATIC) != 0;
    }

    // From MSDN: An event is considered public to reflection if it has at least one method or accessor that is public.
    static inline bool IsPublic(const EventInfo* event)
    {
        if (event->add != NULL && (event->add->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
            return true;

        if (event->remove != NULL && (event->remove->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
            return true;

        if (event->raise != NULL && (event->raise->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
            return true;

        return false;
    }

    static inline bool IsPrivate(const EventInfo* event)
    {
        if (event->add != NULL && (event->add->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) != METHOD_ATTRIBUTE_PRIVATE)
            return false;

        if (event->remove != NULL && (event->remove->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) != METHOD_ATTRIBUTE_PRIVATE)
            return false;

        if (event->raise != NULL && (event->raise->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) != METHOD_ATTRIBUTE_PRIVATE)
            return false;

        return true;
    }

    static inline bool IsStatic(const EventInfo* event)
    {
        if (event->add != NULL)
            return (event->add->flags & METHOD_ATTRIBUTE_STATIC) != 0;

        if (event->remove != NULL)
            return (event->remove->flags & METHOD_ATTRIBUTE_STATIC) != 0;

        if (event->raise != NULL)
            return (event->raise->flags & METHOD_ATTRIBUTE_STATIC) != 0;

        return false;
    }

    template<typename MemberInfo, typename NameFilter>
    static bool CheckMemberMatch(const MemberInfo* member, const Il2CppClass* type, const Il2CppClass* originalType, int32_t bindingFlags, const NameFilter& nameFilter)
    {
        uint32_t accessBindingFlag = IsPublic(member) ? BFLAGS_Public : BFLAGS_NonPublic;

        if ((bindingFlags & accessBindingFlag) == 0)
            return false;

        if (type != originalType && IsPrivate(member)) // Private members are not part of derived class
            return false;

        if (IsStatic(member))
        {
            if ((bindingFlags & BFLAGS_Static) == 0)
                return false;

            if ((bindingFlags & BFLAGS_FlattenHierarchy) == 0 && type != originalType)
                return false;
        }
        else if ((bindingFlags & BFLAGS_Instance) == 0)
        {
            return false;
        }

        if (!nameFilter(member->name))
            return false;

        return true;
    }

    template<typename NameFilter>
    static inline void CollectTypeEvents(Il2CppClass* type, Il2CppClass* const originalType, int32_t bindingFlags, EventMap& events, const NameFilter& nameFilter)
    {
        void* iter = NULL;
        while (const EventInfo* event = vm::Class::GetEvents(type, &iter))
        {
            if (CheckMemberMatch(event, type, originalType, bindingFlags, nameFilter))
            {
                if (events.find(event) != events.end())
                    continue;

                events[event] = originalType;
            }
        }
    }

    static inline bool ValidBindingFlagsForGetMember(uint32_t bindingFlags)
    {
        return (bindingFlags & BFLAGS_Static) != 0 || (bindingFlags & BFLAGS_Instance) != 0;
    }

    template<typename NameFilter>
    static inline Il2CppArray* GetEventsImpl(Il2CppReflectionType* type, int listType, Il2CppReflectionType* reflectedType, const NameFilter& nameFilter)
    {
        if (type->type->byref)
            return vm::Array::New(il2cpp_defaults.event_info_class, 0);

        EventMap events;
        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(type->type);

        CollectTypeEvents(typeInfo, typeInfo, BFLAGS_MatchAll, events, nameFilter);

        Il2CppClass* const originalType = typeInfo;
        typeInfo = vm::Class::GetParent(typeInfo);

        while (typeInfo != NULL)
        {
            CollectTypeEvents(typeInfo, originalType, BFLAGS_MatchAll, events, nameFilter);
            typeInfo = vm::Class::GetParent(typeInfo);
        }

        int i = 0;
        Il2CppArray* result = vm::Array::NewCached(il2cpp_defaults.event_info_class, (il2cpp_array_size_t)events.size());

        for (EventMap::const_iterator iter = events.begin(); iter != events.end(); iter++)
        {
            il2cpp_array_setref(result, i, vm::Reflection::GetEventObject(iter->second, iter->first.key));
            i++;
        }

        return result;
    }

    static Il2CppArray* GetEventsByName(Il2CppReflectionType* _this, Il2CppString* name, int listType, Il2CppReflectionType* reflectedType)
    {
        if (name == NULL)
            return GetEventsImpl(_this, listType, reflectedType, utils::functional::TrueFilter());

        if (listType == MLISTTYPE_CaseInsensitive)
        {
            return GetEventsImpl(_this, listType, reflectedType, utils::functional::Filter<std::string, utils::VmStringUtils::CaseInsensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
        }

        return GetEventsImpl(_this, listType, reflectedType, utils::functional::Filter<std::string, utils::VmStringUtils::CaseSensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
    }

    intptr_t RuntimeType::GetConstructors_native(Il2CppReflectionRuntimeType* thisPtr, int32_t bindingAttr)
    {
        if (thisPtr->type.type->byref)
        {
            return reinterpret_cast<intptr_t>(empty_gptr_array());
        }

        VoidPtrArray res_array;
        res_array.reserve(4);

        Il2CppClass* startklass, * klass;
        const MethodInfo* method;
        int match;
        void* iter = NULL;

        klass = startklass = vm::Class::FromIl2CppType(thisPtr->type.type);

        iter = NULL;
        while ((method = vm::Class::GetMethods(klass, &iter)))
        {
            match = 0;
            if (strcmp(method->name, ".ctor") && strcmp(method->name, ".cctor"))
                continue;
            if ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
            {
                if (bindingAttr & BFLAGS_Public)
                    match++;
            }
            else
            {
                if (bindingAttr & BFLAGS_NonPublic)
                    match++;
            }
            if (!match)
                continue;
            match = 0;
            if (method->flags & METHOD_ATTRIBUTE_STATIC)
            {
                if (bindingAttr & BFLAGS_Static)
                    if ((bindingAttr & BFLAGS_FlattenHierarchy) || (klass == startklass))
                        match++;
            }
            else
            {
                if (bindingAttr & BFLAGS_Instance)
                    match++;
            }

            if (!match)
                continue;

            res_array.push_back((void*)method);
        }

        return reinterpret_cast<intptr_t>(void_ptr_array_to_gptr_array(res_array));
    }

    intptr_t RuntimeType::GetEvents_native(Il2CppReflectionRuntimeType* thisPtr, intptr_t name, int32_t listType)
    {
        Il2CppReflectionMonoEvent *event;
        VoidPtrArray res_array;

        if (thisPtr->type.type->byref)
        {
            return reinterpret_cast<intptr_t>(empty_gptr_array());
        }

        res_array.reserve(4);

        const char *utf8_name = reinterpret_cast<const char*>(name);
        Il2CppString* nameStr = utf8_name == NULL ? NULL : il2cpp::vm::String::New(utf8_name);
        Il2CppArray* events = GetEventsByName(&thisPtr->type, nameStr, listType, &thisPtr->type);

        for (unsigned int i = 0; i < il2cpp::vm::Array::GetLength(events); i++)
        {
            event = il2cpp_array_get(events, Il2CppReflectionMonoEvent*, i);
            res_array.push_back((EventInfo*)event->eventInfo);
        }

        return reinterpret_cast<intptr_t>(void_ptr_array_to_gptr_array(res_array));
    }

    template<typename NameFilter>
    static inline void CollectTypeFields(Il2CppClass* type, const Il2CppClass* const originalType, int32_t bindingFlags, std::vector<FieldInfo*>& fields, const NameFilter& nameFilter)
    {
        void* iterator = NULL;
        FieldInfo* field = NULL;
        while ((field = vm::Class::GetFields(type, &iterator)) != NULL)
        {
            if (CheckMemberMatch(field, type, originalType, bindingFlags, nameFilter))
                fields.push_back(field);
        }
    }

    template<typename NameFilter>
    static inline Il2CppArray* GetFieldsImpl(Il2CppReflectionType* _this, int bindingFlags, Il2CppReflectionType* reflectedType, const NameFilter& nameFilter)
    {
        if (reflectedType->type->byref || !ValidBindingFlagsForGetMember(bindingFlags))
            return vm::Array::New(il2cpp_defaults.field_info_class, 0);

        std::vector<FieldInfo*> fields;
        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(reflectedType->type);
        Il2CppClass* const originalType = typeInfo;

        CollectTypeFields(typeInfo, typeInfo, bindingFlags, fields, nameFilter);

        if ((bindingFlags & BFLAGS_DeclaredOnly) == 0)
        {
            typeInfo = typeInfo->parent;

            while (typeInfo != NULL)
            {
                CollectTypeFields(typeInfo, originalType, bindingFlags, fields, nameFilter);
                typeInfo = typeInfo->parent;
            }
        }

        size_t fieldCount = fields.size();
        Il2CppArray* result = vm::Array::NewCached(il2cpp_defaults.field_info_class, (il2cpp_array_size_t)fieldCount);

        for (size_t i = 0; i < fieldCount; i++)
        {
            il2cpp_array_setref(result, i, vm::Reflection::GetFieldObject(originalType, fields[i]));
        }

        return result;
    }

    static Il2CppArray* GetFieldsByName(Il2CppReflectionType* _this, Il2CppString* name, int bindingFlags, Il2CppReflectionType* reflectedType)
    {
        if (name == NULL)
            return GetFieldsImpl(_this, bindingFlags, reflectedType, utils::functional::TrueFilter());

        if (bindingFlags & BFLAGS_IgnoreCase)
        {
            return GetFieldsImpl(_this, bindingFlags, reflectedType, utils::functional::Filter<std::string, utils::VmStringUtils::CaseInsensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
        }

        return GetFieldsImpl(_this, bindingFlags, reflectedType, utils::functional::Filter<std::string, utils::VmStringUtils::CaseSensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
    }

    intptr_t RuntimeType::GetFields_native(Il2CppReflectionRuntimeType* thisPtr, intptr_t name, int32_t bindingAttr, int32_t listType)
    {
        Il2CppReflectionField *field;

        VoidPtrArray res_array;

        if (thisPtr->type.type->byref)
        {
            return reinterpret_cast<intptr_t>(empty_gptr_array());
        }

        res_array.reserve(16);

        const char *utf8_name = reinterpret_cast<const char*>(name);
        Il2CppString* nameStr = utf8_name == NULL ? NULL : il2cpp::vm::String::New(utf8_name);
        Il2CppArray* fields = GetFieldsByName(&thisPtr->type, nameStr, bindingAttr, &thisPtr->type);

        for (unsigned int i = 0; i < il2cpp::vm::Array::GetLength(fields); i++)
        {
            field = il2cpp_array_get(fields, Il2CppReflectionField*, i);
            res_array.push_back(field->field);
        }

        return reinterpret_cast<intptr_t>(void_ptr_array_to_gptr_array(res_array));
    }

    template<typename NameFilter>
    void CollectTypeMethods(Il2CppClass* type, const Il2CppClass* originalType, uint32_t bindingFlags, const NameFilter& nameFilter, std::vector<const MethodInfo*>& methods, bool(&filledSlots)[65535])
    {
        void* iter = NULL;
        while (const MethodInfo* method = vm::Class::GetMethods(type, &iter))
        {
            if ((method->flags & METHOD_ATTRIBUTE_RT_SPECIAL_NAME) != 0 && (strcmp(method->name, ".ctor") == 0 || strcmp(method->name, ".cctor") == 0))
                continue;

            if (CheckMemberMatch(method, type, originalType, bindingFlags, nameFilter))
            {
                if ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) != 0)
                {
                    if (filledSlots[method->slot])
                        continue;

                    filledSlots[method->slot] = true;
                }

                methods.push_back(method);
            }
        }
    }

    template<typename NameFilter>
    static Il2CppArray* GetMethodsByNameImpl(const Il2CppType* type, uint32_t bindingFlags, const NameFilter& nameFilter)
    {
        std::vector<const MethodInfo*> methods;
        bool filledSlots[65535] = { 0 };

        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(type);
        Il2CppClass* const originalTypeInfo = typeInfo;

        CollectTypeMethods(typeInfo, typeInfo, bindingFlags, nameFilter, methods, filledSlots);

        if ((bindingFlags & BFLAGS_DeclaredOnly) == 0)
        {
            for (typeInfo = vm::Class::GetParent(typeInfo); typeInfo != NULL; typeInfo = vm::Class::GetParent(typeInfo))
            {
                CollectTypeMethods(typeInfo, originalTypeInfo, bindingFlags, nameFilter, methods, filledSlots);
            }
        }

        size_t methodCount = methods.size();
        Il2CppArray* result = vm::Array::NewCached(il2cpp_defaults.method_info_class, (il2cpp_array_size_t)methodCount);

        for (size_t i = 0; i < methodCount; i++)
        {
            Il2CppReflectionMethod* method = vm::Reflection::GetMethodObject(methods[i], originalTypeInfo);
            il2cpp_array_setref(result, i, method);
        }

        return result;
    }

    static Il2CppArray* GetMethodsByName(Il2CppReflectionType* _this, Il2CppString* name, int32_t bindingFlags, int listType, Il2CppReflectionType* type)
    {
        if (type->type->byref || !ValidBindingFlagsForGetMember(bindingFlags))
            return vm::Array::NewCached(il2cpp_defaults.property_info_class, 0);

        if (name != NULL)
        {
            if (bindingFlags & BFLAGS_IgnoreCase || listType == MLISTTYPE_CaseInsensitive)
            {
                return GetMethodsByNameImpl(type->type, bindingFlags, utils::functional::Filter<std::string, utils::VmStringUtils::CaseInsensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
            }

            return GetMethodsByNameImpl(type->type, bindingFlags, utils::functional::Filter<std::string, utils::VmStringUtils::CaseSensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
        }

        return GetMethodsByNameImpl(type->type, bindingFlags, utils::functional::TrueFilter());
    }

    intptr_t RuntimeType::GetMethodsByName_native(Il2CppReflectionRuntimeType* thisPtr, intptr_t namePtr, int32_t bindingAttr, int32_t listType)
    {
        VoidPtrArray res_array;
        Il2CppReflectionMethod *method;

        if (thisPtr->type.type->byref)
        {
            return reinterpret_cast<intptr_t>(empty_gptr_array());
        }

        const char *utf8_name = reinterpret_cast<const char*>(namePtr);
        Il2CppString* nameStr = utf8_name == NULL ? NULL : il2cpp::vm::String::New(utf8_name);
        Il2CppArray* methods = GetMethodsByName(&thisPtr->type, nameStr, bindingAttr, listType, &thisPtr->type);

        for (unsigned int i = 0; i < il2cpp::vm::Array::GetLength(methods); i++)
        {
            method = il2cpp_array_get(methods, Il2CppReflectionMethod*, i);
            res_array.push_back((MethodInfo*)method->method);
        }

        return reinterpret_cast<intptr_t>(void_ptr_array_to_gptr_array(res_array));
    }

    static inline bool CheckNestedTypeMatch(Il2CppClass* nestedType, BindingFlags bindingFlags)
    {
        uint32_t accessFlag = (nestedType->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK) == TYPE_ATTRIBUTE_NESTED_PUBLIC ? BFLAGS_Public : BFLAGS_NonPublic;
        return (accessFlag & bindingFlags) != 0;
    }

    template<typename NameFilter>
    static Il2CppArray* GetNestedTypesImpl(Il2CppReflectionType* type, int32_t bindingFlags, const NameFilter& nameFilter)
    {
        bool validBindingFlags = (bindingFlags & BFLAGS_NonPublic) != 0 || (bindingFlags & BFLAGS_Public) != 0;

        if (type->type->byref || !validBindingFlags)
            return vm::Array::New(il2cpp_defaults.monotype_class, 0);

        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(type->type);

        // nested types are always generic type definitions, even for inflated types. As such we only store/retrieve them on
        // type definitions and generic type definitions. If we are a generic instance, use our generic type definition instead.
        if (typeInfo->generic_class)
            typeInfo = vm::GenericClass::GetTypeDefinition(typeInfo->generic_class);

        std::vector<Il2CppClass*> nestedTypes;

        void* iter = NULL;
        while (Il2CppClass* nestedType = vm::Class::GetNestedTypes(typeInfo, &iter))
        {
            if (CheckNestedTypeMatch(nestedType, bindingFlags) && nameFilter(nestedType->name))
                nestedTypes.push_back(nestedType);
        }

        size_t nestedTypeCount = nestedTypes.size();
        Il2CppArray* result = vm::Array::New(il2cpp_defaults.monotype_class, (il2cpp_array_size_t)nestedTypeCount);

        for (size_t i = 0; i < nestedTypeCount; i++)
        {
            il2cpp_array_setref(result, i, vm::Reflection::GetTypeObject(&nestedTypes[i]->byval_arg));
        }

        return result;
    }

    static Il2CppArray* GetNestedTypesByName(Il2CppReflectionType* type, Il2CppString* name, int32_t bindingFlags)
    {
        if (name == NULL)
            return GetNestedTypesImpl(type, bindingFlags, utils::functional::TrueFilter());

        if (bindingFlags & BFLAGS_IgnoreCase)
            return GetNestedTypesImpl(type, bindingFlags, utils::functional::Filter<std::string, utils::VmStringUtils::CaseInsensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));

        return GetNestedTypesImpl(type, bindingFlags, utils::functional::Filter<std::string, utils::VmStringUtils::CaseSensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
    }

    intptr_t RuntimeType::GetNestedTypes_native(Il2CppReflectionRuntimeType* thisPtr, intptr_t name, int32_t bindingAttr, int32_t listType)
    {
        Il2CppReflectionType *nested;
        VoidPtrArray res_array;

        if (thisPtr->type.type->byref)
        {
            return reinterpret_cast<intptr_t>(empty_gptr_array());
        }

        const char *utf8_name = reinterpret_cast<const char*>(name);
        Il2CppString* nameStr = utf8_name == NULL ? NULL : il2cpp::vm::String::New(utf8_name);
        Il2CppArray* nestedTypes = GetNestedTypesByName(&thisPtr->type, nameStr, bindingAttr);

        for (unsigned int i = 0; i < il2cpp::vm::Array::GetLength(nestedTypes); i++)
        {
            nested = il2cpp_array_get(nestedTypes, Il2CppReflectionType*, i);
            res_array.push_back((Il2CppType*)nested->type);
        }

        return reinterpret_cast<intptr_t>(void_ptr_array_to_gptr_array(res_array));
    }

    template<typename NameFilter>
    static void CollectTypeProperties(Il2CppClass* type, uint32_t bindingFlags, const NameFilter& nameFilter, Il2CppClass* const originalType, PropertyPairVector& properties)
    {
        void* iter = NULL;
        while (const PropertyInfo* property = vm::Class::GetProperties(type, &iter))
        {
            if (CheckMemberMatch(property, type, originalType, bindingFlags, nameFilter))
            {
                if (PropertyPairVectorContains(properties, property))
                    continue;

                properties.push_back(PropertyPair(property, originalType));
            }
        }
    }

    template<typename NameFilter>
    static Il2CppArray* GetPropertiesByNameImpl(const Il2CppType* type, uint32_t bindingFlags, const NameFilter& nameFilter)
    {
        PropertyPairVector properties;
        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(type);
        Il2CppClass* const originalTypeInfo = typeInfo;

        properties.reserve(typeInfo->property_count);
        CollectTypeProperties(typeInfo, bindingFlags, nameFilter, originalTypeInfo, properties);

        if ((bindingFlags & BFLAGS_DeclaredOnly) == 0)
        {
            for (typeInfo = typeInfo->parent; typeInfo != NULL; typeInfo = typeInfo->parent)
            {
                CollectTypeProperties(typeInfo, bindingFlags, nameFilter, originalTypeInfo, properties);
            }
        }

        int i = 0;
        Il2CppArray* res = vm::Array::NewCached(il2cpp_defaults.property_info_class, (il2cpp_array_size_t)properties.size());

        for (PropertyPairVector::const_iterator iter = properties.begin(); iter != properties.end(); iter++)
        {
            il2cpp_array_setref(res, i, vm::Reflection::GetPropertyObject(iter->originalType, iter->property));
            i++;
        }

        return res;
    }

    static Il2CppArray* GetPropertiesByName(Il2CppReflectionType* _this, Il2CppString* name, uint32_t bindingFlags, bool ignoreCase, Il2CppReflectionType* type)
    {
        if (type->type->byref || !ValidBindingFlagsForGetMember(bindingFlags))
            return vm::Array::NewCached(il2cpp_defaults.property_info_class, 0);

        if (name != NULL)
        {
            if (ignoreCase)
            {
                return GetPropertiesByNameImpl(type->type, bindingFlags, utils::functional::Filter<std::string, utils::VmStringUtils::CaseInsensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
            }

            return GetPropertiesByNameImpl(type->type, bindingFlags, utils::functional::Filter<std::string, utils::VmStringUtils::CaseSensitiveComparer>(utils::StringUtils::Utf16ToUtf8(name->chars)));
        }

        return GetPropertiesByNameImpl(type->type, bindingFlags, utils::functional::TrueFilter());
    }

    intptr_t RuntimeType::GetPropertiesByName_native(Il2CppReflectionRuntimeType* thisPtr, intptr_t name, int32_t bindingAttr, int32_t listType)
    {
        Il2CppReflectionProperty *prop;
        VoidPtrArray res_array;

        if (thisPtr->type.type->byref)
        {
            return reinterpret_cast<intptr_t>(empty_gptr_array());
        }

        res_array.reserve(8);

        bool ignoreCase = listType == MLISTTYPE_CaseInsensitive;

        const char *utf8_name = reinterpret_cast<const char*>(name);
        Il2CppString* nameStr = utf8_name == NULL ? NULL : il2cpp::vm::String::New(utf8_name);
        Il2CppArray* properties = GetPropertiesByName(&thisPtr->type, nameStr, bindingAttr, ignoreCase, &thisPtr->type);

        for (unsigned int i = 0; i < il2cpp::vm::Array::GetLength(properties); i++)
        {
            prop = il2cpp_array_get(properties, Il2CppReflectionProperty*, i);
            res_array.push_back((PropertyInfo*)prop->property);
        }

        return reinterpret_cast<intptr_t>(void_ptr_array_to_gptr_array(res_array));
    }

    Il2CppObject* RuntimeType::CreateInstanceInternal(Il2CppReflectionType* type)
    {
        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(type->type);

        if (typeInfo == NULL || il2cpp::vm::Class::IsNullable(typeInfo))
            return NULL;

        il2cpp::vm::Class::Init(typeInfo);

        // You could think "hey, shouldn't we call the constructor here?" but we don't because this path is only hit for value
        // types, and they cannot have default constructors.  for reference types with constructors, the c# side of CreateInstance()
        // actually takes care of its own business by using reflection to create the object and invoke the constructor.
        return il2cpp_object_new(typeInfo);
    }

    Il2CppObject* RuntimeType::GetCorrespondingInflatedConstructor(Il2CppReflectionRuntimeType* thisPtr, Il2CppObject* generic)
    {
        NOT_SUPPORTED_IL2CPP(MonoType::GetCorrespondingInflatedConstructor, "This icall is only used by System.Reflection.Emit.TypeBuilder.");
        return 0;
    }

    Il2CppReflectionMethod* RuntimeType::get_DeclaringMethod(Il2CppReflectionRuntimeType* thisPtr)
    {
        const MethodInfo* declaringMethod = vm::Type::GetDeclaringMethod(thisPtr->type.type);
        return declaringMethod == NULL ? NULL : vm::Reflection::GetMethodObject(declaringMethod, NULL);
    }

    Il2CppObject* RuntimeType::GetCorrespondingInflatedMethod(Il2CppReflectionRuntimeType* thisPtr, Il2CppObject* generic)
    {
        NOT_SUPPORTED_IL2CPP(MonoType::GetCorrespondingInflatedMethod, "This icall is only used by System.Reflection.Emit.TypeBuilder.");
        return 0;
    }

    Il2CppString* RuntimeType::get_Name(Il2CppReflectionRuntimeType* _type)
    {
        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(_type->type.type);

        if (_type->type.type->byref)
        {
            std::string n = il2cpp::utils::StringUtils::Printf("%s&", typeInfo->name);
            return vm::String::New(n.c_str());
        }
        else
        {
            return il2cpp::vm::String::NewWrapper(typeInfo->name);
        }
    }

    Il2CppString* RuntimeType::get_Namespace(Il2CppReflectionRuntimeType* _type)
    {
        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(_type->type.type);

        while (Il2CppClass* declaringType = vm::Class::GetDeclaringType(typeInfo))
            typeInfo = declaringType;

        if (typeInfo->namespaze[0] == '\0')
            return NULL;
        else
            return il2cpp::vm::String::NewWrapper(typeInfo->namespaze);
    }

    Il2CppString* RuntimeType::getFullName(Il2CppReflectionRuntimeType* _type, bool full_name, bool assembly_qualified)
    {
        Il2CppTypeNameFormat format;

        if (full_name)
            format = assembly_qualified ?
                IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED :
                IL2CPP_TYPE_NAME_FORMAT_FULL_NAME;
        else
            format = IL2CPP_TYPE_NAME_FORMAT_REFLECTION;

        std::string name(vm::Type::GetName(_type->type.type, format));
        if (name.empty())
            return NULL;

        if (full_name && (_type->type.type->type == IL2CPP_TYPE_VAR || _type->type.type->type == IL2CPP_TYPE_MVAR))
        {
            return NULL;
        }

        return il2cpp::vm::String::NewWrapper(name.c_str());
    }

    Il2CppReflectionType* RuntimeType::get_DeclaringType(Il2CppReflectionRuntimeType* _this)
    {
        Il2CppClass* declaringClass = vm::Type::GetDeclaringType(_this->type.type);
        return declaringClass == NULL ? NULL : il2cpp::vm::Reflection::GetTypeObject(vm::Class::GetType(declaringClass));
    }

    void validate_make_array_type_inputs(Il2CppReflectionType* type, int32_t rank)
    {
        // Per MSDN: http://msdn.microsoft.com/en-us/library/w0ykk2sw(v=vs.110).aspx
        if (rank > 32)
        {
            std::string message;
            message = vm::Type::GetName(type->type, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME) + " with rank " + utils::StringUtils::Printf("%d", rank) + " has too many dimensions.";
            il2cpp_raise_exception(vm::Exception::GetTypeLoadException(message.c_str()));
        }

        if (type->type->byref)
        {
            std::string message;
            message = "Could not create array type '" + vm::Type::GetName(type->type, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME) + "'.";
            il2cpp_raise_exception(vm::Exception::GetTypeLoadException(message.c_str()));
        }

        const Il2CppClass* klass = vm::Class::FromIl2CppType(type->type);

        if ((strcmp(klass->namespaze, "System") == 0 && strcmp(klass->name, "TypedReference") == 0))
        {
            std::string message;
            message + "Could not create array type '" + klass->namespaze + "." + klass->name + "[]'.";
            il2cpp_raise_exception(vm::Exception::GetTypeLoadException(message.c_str()));
        }
    }

    Il2CppReflectionType* RuntimeType::make_array_type(Il2CppReflectionRuntimeType* _type, int32_t rank)
    {
        validate_make_array_type_inputs(&_type->type, rank);

        Il2CppClass* arrayClass;

        Il2CppClass* klass = il2cpp_class_from_il2cpp_type(_type->type.type);
        if (rank == 0) //single dimentional array
            arrayClass = il2cpp_array_class_get(klass, 1);
        else
            arrayClass = il2cpp_bounded_array_class_get(klass, rank, true);

        return arrayClass != NULL ? vm::Reflection::GetTypeObject(&arrayClass->byval_arg) : NULL;
    }

    Il2CppReflectionType* RuntimeType::make_byref_type(Il2CppReflectionRuntimeType* _type)
    {
        Il2CppClass* klass;

        klass = vm::Class::FromIl2CppType(_type->type.type);

        return il2cpp::vm::Reflection::GetTypeObject(&klass->this_arg);
    }

    static std::string FormatExceptionMessageForNonConstructableGenericType(const Il2CppType* type, const Il2CppType** genericArguments, int genericArgumentCount)
    {
        std::string message;
        message += "Failed to construct generic type '";
        message += il2cpp::vm::Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
        message += "' with generic arguments [";
        for (int i = 0; i < genericArgumentCount; i++)
        {
            if (i != 0)
                message += ", ";
            message += il2cpp::vm::Type::GetName(genericArguments[i], IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
        }
        message += "] at runtime.";

        return message;
    }

    Il2CppReflectionType * RuntimeType::MakeGenericType(Il2CppReflectionType* type, Il2CppArray* genericArgumentTypes)
    {
        const Il2CppType* genericTypeDefinitionType = type->type;
        Il2CppClass* genericTypeDefinitionClass = vm::Class::FromIl2CppType(genericTypeDefinitionType);
        IL2CPP_ASSERT(vm::Class::IsGeneric(genericTypeDefinitionClass));

        uint32_t arrayLength = vm::Array::GetLength(genericArgumentTypes);
        const Il2CppType** genericArguments = (const Il2CppType**)alloca(arrayLength * sizeof(Il2CppType*));

        for (uint32_t i = 0; i < arrayLength; i++)
        {
            Il2CppReflectionType* genericArgumentType = il2cpp_array_get(genericArgumentTypes, Il2CppReflectionType*, i);
            genericArguments[i] = genericArgumentType->type;
        }

        const Il2CppGenericInst* inst = vm::MetadataCache::GetGenericInst(genericArguments, arrayLength);
        Il2CppGenericClass* genericClass = metadata::GenericMetadata::GetGenericClass(genericTypeDefinitionClass, inst);
        Il2CppClass* genericInstanceTypeClass = vm::GenericClass::GetClass(genericClass);

        if (!genericInstanceTypeClass)
        {
            vm::Exception::Raise(vm::Exception::GetNotSupportedException(FormatExceptionMessageForNonConstructableGenericType(genericTypeDefinitionType, genericArguments, arrayLength).c_str()));
            return NULL;
        }

        return vm::Reflection::GetTypeObject(&genericInstanceTypeClass->byval_arg);
    }

    Il2CppReflectionType* RuntimeType::MakePointerType(Il2CppReflectionType* type)
    {
        Il2CppClass* pointerType = vm::Class::GetPtrClass(type->type);

        return vm::Reflection::GetTypeObject(&pointerType->byval_arg);
    }

    Il2CppArray* RuntimeType::GetGenericArgumentsInternal(Il2CppReflectionRuntimeType* _this, bool runtimeArray)
    {
        return vm::Type::GetGenericArgumentsInternal(&_this->type, runtimeArray);
    }

    Il2CppArray* RuntimeType::GetInterfaces(Il2CppReflectionRuntimeType* type)
    {
        Il2CppClass* klass = vm::Class::FromIl2CppType(type->type.type);
        typedef std::set<Il2CppClass*> InterfaceVector;
        InterfaceVector itfs;

        Il2CppClass* currentType = klass;
        while (currentType != NULL)
        {
            void* iter = NULL;
            while (Il2CppClass* itf = vm::Class::GetInterfaces(currentType, &iter))
                itfs.insert(itf);

            currentType = vm::Class::GetParent(currentType);
        }

        Il2CppArray* res = vm::Array::New(il2cpp_defaults.systemtype_class, (il2cpp_array_size_t)itfs.size());
        int i = 0;
        for (InterfaceVector::const_iterator iter = itfs.begin(); iter != itfs.end(); ++iter, ++i)
            il2cpp_array_setref(res, i, vm::Reflection::GetTypeObject(&(*iter)->byval_arg));

        return res;
    }

    /* System.TypeCode */
    typedef enum
    {
        TYPECODE_EMPTY,
        TYPECODE_OBJECT,
        TYPECODE_DBNULL,
        TYPECODE_BOOLEAN,
        TYPECODE_CHAR,
        TYPECODE_SBYTE,
        TYPECODE_BYTE,
        TYPECODE_INT16,
        TYPECODE_UINT16,
        TYPECODE_INT32,
        TYPECODE_UINT32,
        TYPECODE_INT64,
        TYPECODE_UINT64,
        TYPECODE_SINGLE,
        TYPECODE_DOUBLE,
        TYPECODE_DECIMAL,
        TYPECODE_DATETIME,
        TYPECODE_STRING = 18
    } TypeCode;

    int32_t RuntimeType::GetTypeCodeImplInternal(Il2CppReflectionType* type)
    {
        int t = type->type->type;

        if (type->type->byref)
            return TYPECODE_OBJECT;

    handle_enum:
        switch (t)
        {
            case IL2CPP_TYPE_VOID:
                return TYPECODE_OBJECT;
            case IL2CPP_TYPE_BOOLEAN:
                return TYPECODE_BOOLEAN;
            case IL2CPP_TYPE_U1:
                return TYPECODE_BYTE;
            case IL2CPP_TYPE_I1:
                return TYPECODE_SBYTE;
            case IL2CPP_TYPE_U2:
                return TYPECODE_UINT16;
            case IL2CPP_TYPE_I2:
                return TYPECODE_INT16;
            case IL2CPP_TYPE_CHAR:
                return TYPECODE_CHAR;
            case IL2CPP_TYPE_PTR:
            case IL2CPP_TYPE_U:
            case IL2CPP_TYPE_I:
                return TYPECODE_OBJECT;
            case IL2CPP_TYPE_U4:
                return TYPECODE_UINT32;
            case IL2CPP_TYPE_I4:
                return TYPECODE_INT32;
            case IL2CPP_TYPE_U8:
                return TYPECODE_UINT64;
            case IL2CPP_TYPE_I8:
                return TYPECODE_INT64;
            case IL2CPP_TYPE_R4:
                return TYPECODE_SINGLE;
            case IL2CPP_TYPE_R8:
                return TYPECODE_DOUBLE;
            case IL2CPP_TYPE_VALUETYPE:
            {
                if (vm::Type::IsEnum(type->type))
                {
                    t = vm::Class::GetEnumBaseType(vm::Type::GetClass(type->type))->type;
                    goto handle_enum;
                }
                else
                {
                    if (vm::Type::IsSystemDecimal(type->type))
                        return TYPECODE_DECIMAL;
                    else if (vm::Type::IsSystemDateTime(type->type))
                        return TYPECODE_DATETIME;
                }
                return TYPECODE_OBJECT;
            }
            case IL2CPP_TYPE_STRING:
                return TYPECODE_STRING;
            case IL2CPP_TYPE_SZARRAY:
            case IL2CPP_TYPE_ARRAY:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:
            case IL2CPP_TYPE_TYPEDBYREF:
                return TYPECODE_OBJECT;
            case IL2CPP_TYPE_CLASS:
            {
                if (vm::Type::IsSystemDBNull(type->type))
                    return TYPECODE_DBNULL;
            }
                return TYPECODE_OBJECT;
            case IL2CPP_TYPE_GENERICINST:
                return TYPECODE_OBJECT;
            default:
                abort();
        }
        return false;
    }

    void RuntimeType::GetInterfaceMapData(Il2CppReflectionType* type, Il2CppReflectionType* iface, Il2CppArray** targets, Il2CppArray** methods)
    {
        Il2CppClass* klass = il2cpp_class_from_il2cpp_type(type->type);
        Il2CppClass* iklass = il2cpp_class_from_il2cpp_type(iface->type);

        void* iter = NULL;

        int32_t numberOfMethods = (int32_t)vm::Class::GetNumMethods(iklass);
        int32_t numberOfVirtualMethods = 0;
        for (int i = 0; i < numberOfMethods; ++i)
        {
            const MethodInfo* method = il2cpp_class_get_methods(iklass, &iter);
            if (method->flags & METHOD_ATTRIBUTE_VIRTUAL)
                numberOfVirtualMethods++;
        }


        *targets = il2cpp_array_new(il2cpp_defaults.method_info_class, numberOfVirtualMethods);
        *methods = il2cpp_array_new(il2cpp_defaults.method_info_class, numberOfVirtualMethods);

        if (numberOfVirtualMethods == 0)
            return;

        vm::Class::Init(klass);
        const VirtualInvokeData* invokeDataStart;

        // So this part is tricky. GetInterfaceInvokeDataFromVTable takes an object pointer in order to support
        // COM peculiarities, like being able to return invoke data for an interface only if native side implements it
        // So here we create a fake object of the class we want to query and pass that to GetInterfaceInvokeDataFromVTable
        // It is safe because the only fields GetInterfaceInvokeDataFromVTable accesses are the klass and identity fields
        if (!klass->is_import_or_windows_runtime)
        {
            Il2CppObject fakeObject = {};
            fakeObject.klass = klass;
            invokeDataStart = &vm::ClassInlines::GetInterfaceInvokeDataFromVTable(&fakeObject, iklass, 0);
        }
        else
        {
            Il2CppComObject fakeComObject;
            memset(&fakeComObject, 0, sizeof(fakeComObject));
            fakeComObject.klass = klass;

            // This makes GetInterfaceInvokeDataFromVTable believe that the COM object is dead,
            // thus making it skip asking native side whether a particular interface is supported
            fakeComObject.identity = NULL;

            invokeDataStart = &vm::ClassInlines::GetInterfaceInvokeDataFromVTable(&fakeComObject, iklass, 0);
        }

        iter = NULL;
        int virtualMethodIndex = 0;
        for (int i = 0; i < numberOfMethods; ++i)
        {
            const MethodInfo* method = il2cpp_class_get_methods(iklass, &iter);
            if (method->flags & METHOD_ATTRIBUTE_VIRTUAL)
            {
                Il2CppReflectionMethod* member = il2cpp_method_get_object(method, iklass);
                il2cpp_array_setref(*methods, virtualMethodIndex, member);

                const MethodInfo* targetMethod = invokeDataStart[i].method;

                if (vm::Method::IsAmbiguousMethodInfo(targetMethod) || vm::Method::IsEntryPointNotFoundMethodInfo(targetMethod))
                {
                    // Method is an ambiguous default interface method (more than one DIM matched)
                    // Or there is no valid method in this slot
                    member = NULL;
                }
                else if (vm::Class::IsInterface(targetMethod->klass))
                {
                    // We found a default interface method
                    if (targetMethod->flags & METHOD_ATTRIBUTE_ABSTRACT)
                    {
                        // The method was re-abstracted
                        member = NULL;
                    }
                    else
                    {
                        // Normal DIM case
                        member = il2cpp_method_get_object(targetMethod, targetMethod->klass);
                    }
                }
                else
                {
                    // Normal interface implementation
                    member = il2cpp_method_get_object(targetMethod, klass);
                }
                il2cpp_array_setref(*targets, virtualMethodIndex, member);
                virtualMethodIndex++;
            }
        }
    }

    void RuntimeType::GetPacking(Il2CppReflectionType* type, int32_t* packing, int32_t* size)
    {
        const Il2CppType* runtimeType = vm::Type::IsGenericInstance(type->type) ? vm::Type::GetGenericTypeDefintion(type->type) : type->type;
        Il2CppMetadataTypeHandle handle = il2cpp::vm::MetadataCache::GetTypeHandleFromType(runtimeType);

        if (vm::MetadataCache::StructLayoutPackIsDefault(handle))
            *packing = 8;
        else
            *packing = vm::MetadataCache::StructLayoutPack(handle);

        if (vm::MetadataCache::StructLayoutSizeIsDefault(handle))
            *size = 0;
        else
            *size = vm::Class::FromIl2CppType(runtimeType)->native_size;
    }

    void RuntimeType::GetGUID(Il2CppReflectionType* type, Il2CppArray* guid_result)
    {
        IL2CPP_ASSERT(vm::Array::GetLength(guid_result) == sizeof(Il2CppGuid));
        if (type == NULL)
            return;

        Il2CppClass* klass = vm::Class::FromIl2CppType(type->type);

        if (klass->interopData != nullptr && klass->interopData->guid != nullptr)
        {
            uint8_t* guid = il2cpp_array_addr_with_size(guid_result, 1, 0);
            memcpy(guid, klass->interopData->guid, sizeof(Il2CppGuid));
        }
    }
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeType.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeTypeHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "mono-structs.h"

#include "RuntimeTypeHandle.h"
#include "Type.h"

#include "utils/StringUtils.h"
#include "vm/Class.h"
#include "vm/Image.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/GenericClass.h"
#include "il2cpp-api.h"

#define CHECK_IF_NULL(v)    \
    if ( (v) == NULL && throwOnError ) \
        vm::Exception::Raise (vm::Exception::GetTypeLoadException (info)); \
    if ( (v) == NULL ) \
        return NULL;

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    bool RuntimeTypeHandle::HasInstantiation(Il2CppReflectionRuntimeType* typeObject)
    {
        const Il2CppType* type = typeObject->type.type;

        if (type->byref)
            return false;

        Il2CppClass* klass = vm::Class::FromIl2CppType(type);

        return vm::Class::IsGeneric(klass) || vm::Class::IsInflated(klass);
    }

    bool RuntimeTypeHandle::HasReferences(Il2CppReflectionRuntimeType* type)
    {
        return vm::Class::FromIl2CppType(type->type.type)->has_references;
    }

    static bool is_generic_parameter(Il2CppType *type)
    {
        return !type->byref && (type->type == IL2CPP_TYPE_VAR || type->type == IL2CPP_TYPE_MVAR);
    }

    bool RuntimeTypeHandle::is_subclass_of(Il2CppType* childType, Il2CppType* baseType)
    {
        bool result = false;
        Il2CppClass *childClass;
        Il2CppClass *baseClass;

        childClass = vm::Class::FromIl2CppType(childType);
        baseClass = vm::Class::FromIl2CppType(baseType);

        if (childType->byref)
            return !baseType->byref && baseClass == il2cpp_defaults.object_class;

        if (baseType->byref)
            return false;

        /* .NET IsSubclassOf is not reflexive */
        if (childType == baseType)
            return false;

        if (is_generic_parameter(childType))
        {
            /* slow path: walk the type hierarchy looking at base types
             * until we see baseType.  If the current type is not a gparam,
             * break out of the loop and use is_subclass_of.
             */
            Il2CppClass *c = vm::Class::GenericParamGetBaseType(childClass);

            result = false;
            while (c != NULL)
            {
                if (c == baseClass)
                {
                    result = true;
                    break;
                }
                if (!is_generic_parameter(&c->byval_arg))
                {
                    result = vm::Class::IsSubclassOf(c, baseClass, false);
                    break;
                }
                else
                    c = vm::Class::GenericParamGetBaseType(c);
            }
        }
        else
        {
            result = vm::Class::IsSubclassOf(childClass, baseClass, false);
        }

        return result;
    }

    bool RuntimeTypeHandle::IsByRefLike(Il2CppReflectionRuntimeType* type)
    {
        Il2CppClass* klass = vm::Class::FromIl2CppType(type->type.type);
        return klass->is_byref_like;
    }

    bool RuntimeTypeHandle::IsComObject(Il2CppReflectionRuntimeType* type)
    {
        return false; // il2cpp does not support COM objects, so this is always false
    }

    bool RuntimeTypeHandle::IsGenericTypeDefinition(Il2CppReflectionRuntimeType* type)
    {
        Il2CppClass* klass;

        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(MonoType::get_IsGenericTypeDefinition, "Check for custom Type implementations");
        //if (!IS_MONOTYPE (type))
        //  return FALSE;

        if (type->type.type->byref)
            return false;

        klass = vm::Class::FromIl2CppType(type->type.type);

        return vm::Class::IsGeneric(klass);
    }

    bool RuntimeTypeHandle::IsGenericVariable(Il2CppReflectionRuntimeType* type)
    {
        return !type->type.type->byref && (type->type.type->type == IL2CPP_TYPE_VAR || type->type.type->type == IL2CPP_TYPE_MVAR);
    }

    bool RuntimeTypeHandle::IsInstanceOfType(Il2CppReflectionRuntimeType* type, Il2CppObject* obj)
    {
        Il2CppClass* klass = vm::Class::FromIl2CppType(type->type.type);
        return il2cpp::vm::Object::IsInst(obj, klass) != NULL;
    }

    bool RuntimeTypeHandle::type_is_assignable_from(Il2CppReflectionType* a, Il2CppReflectionType* b)
    {
        return vm::Class::IsAssignableFrom(a, b);
    }

    int32_t RuntimeTypeHandle::GetArrayRank(Il2CppReflectionRuntimeType* type)
    {
        if (type->type.type->type != IL2CPP_TYPE_ARRAY && type->type.type->type != IL2CPP_TYPE_SZARRAY)
            IL2CPP_ASSERT("Type must be an array type");

        Il2CppClass* klass = vm::Class::FromIl2CppType(type->type.type);
        return klass->rank;
    }

    int32_t RuntimeTypeHandle::GetMetadataToken(Il2CppReflectionRuntimeType* type)
    {
        return vm::Class::FromSystemType(&type->type)->token;
    }

    intptr_t RuntimeTypeHandle::GetGenericParameterInfo(Il2CppReflectionRuntimeType* type)
    {
        intptr_t retVal = 0;

        const Il2CppType *thisType = type->type.type;
        if ((thisType->type == IL2CPP_TYPE_VAR) || (thisType->type == IL2CPP_TYPE_MVAR))
        {
            Il2CppMetadataGenericParameterHandle param = il2cpp::vm::MetadataCache::GetGenericParameterFromType(thisType);
            if (param)
            {
                retVal = reinterpret_cast<intptr_t>(vm::Class::GetOrCreateMonoGenericParameterInfo(param));
            }
        }

        return retVal;
    }

    uint8_t RuntimeTypeHandle::GetCorElementType(Il2CppReflectionRuntimeType* ref_type)
    {
        const Il2CppType *type = ref_type->type.type;

        if (type->byref)
            return IL2CPP_TYPE_BYREF;
        else
            return (uint8_t)type->type;
    }

    Il2CppReflectionAssembly* RuntimeTypeHandle::GetAssembly(Il2CppReflectionRuntimeType* type)
    {
        return vm::Reflection::GetAssemblyObject(vm::Image::GetAssembly(vm::Class::GetImage(vm::Class::FromIl2CppType(type->type.type))));
    }

    Il2CppReflectionModule* RuntimeTypeHandle::GetModule(Il2CppReflectionRuntimeType* type)
    {
        return vm::Reflection::GetModuleObject(vm::Class::GetImage(vm::Class::FromIl2CppType(type->type.type)));
    }

    int32_t RuntimeTypeHandle::GetAttributes(Il2CppReflectionRuntimeType* type)
    {
        Il2CppClass* klass = vm::Class::FromSystemType(&type->type);

        return klass->flags;
    }

    Il2CppReflectionRuntimeType* RuntimeTypeHandle::GetBaseType(Il2CppReflectionRuntimeType* type)
    {
        Il2CppClass* klass = vm::Class::FromIl2CppType((&type->type)->type);

        Il2CppReflectionType* retVal = klass->parent ? il2cpp::vm::Reflection::GetTypeObject(&klass->parent->byval_arg) : NULL;
        return reinterpret_cast<Il2CppReflectionRuntimeType*>(retVal);
    }

    Il2CppReflectionRuntimeType* RuntimeTypeHandle::GetElementType(Il2CppReflectionRuntimeType* type)
    {
        Il2CppClass* klass;
        Il2CppReflectionType* retVal = NULL;

        klass = vm::Class::FromIl2CppType(type->type.type);

        // GetElementType should only return a type for:
        // Array Pointer PassedByRef
        if (type->type.type->byref)
            retVal = il2cpp::vm::Reflection::GetTypeObject(&klass->byval_arg);
        else if (klass->element_class && IL2CPP_CLASS_IS_ARRAY(klass))
            retVal = il2cpp::vm::Reflection::GetTypeObject(&klass->element_class->byval_arg);
        else if (klass->element_class && type->type.type->type == IL2CPP_TYPE_PTR)
            retVal = il2cpp::vm::Reflection::GetTypeObject(&klass->element_class->byval_arg);

        if (retVal)
            return reinterpret_cast<Il2CppReflectionRuntimeType*>(retVal);
        return NULL;
    }

    Il2CppReflectionType* RuntimeTypeHandle::internal_from_name(Il2CppString* name, int32_t* stackMark, Il2CppObject* callerAssembly, bool throwOnError, bool ignoreCase, bool reflectionOnly)
    {
        std::string str = utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(name));

        il2cpp::vm::TypeNameParseInfo info;
        il2cpp::vm::TypeNameParser parser(str, info, false);

        if (!parser.Parse())
        {
            if (throwOnError)
                vm::Exception::Raise(vm::Exception::GetArgumentException("typeName", "Invalid type name"));
            else
                return NULL;
        }

        vm::TypeSearchFlags searchFlags = vm::kTypeSearchFlagNone;

        if (throwOnError)
            searchFlags = static_cast<vm::TypeSearchFlags>(searchFlags | vm::kTypeSearchFlagThrowOnError);

        if (ignoreCase)
            searchFlags = static_cast<vm::TypeSearchFlags>(searchFlags | vm::kTypeSearchFlagIgnoreCase);

        const Il2CppType *type = vm::Class::il2cpp_type_from_type_info(info, searchFlags);

        CHECK_IF_NULL(type);

        return il2cpp::vm::Reflection::GetTypeObject(type);
    }

    Il2CppReflectionType* RuntimeTypeHandle::GetGenericTypeDefinition_impl(Il2CppReflectionRuntimeType* type)
    {
        Il2CppClass* klass;

        if (type->type.type->byref)
            return NULL;

        klass = vm::Class::FromIl2CppType(type->type.type);
        if (vm::Class::IsGeneric(klass))
            return &type->type;

        if (klass->generic_class)
        {
            Il2CppClass* generic_class = vm::GenericClass::GetTypeDefinition(klass->generic_class);
            return vm::Reflection::GetTypeObject(&generic_class->byval_arg);
        }

        return NULL;
    }
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\RuntimeTypeHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\String.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "il2cpp-api.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "icalls/mscorlib/System/String.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/String.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    Il2CppString* String::FastAllocateString(int32_t length)
    {
        return vm::String::NewSize(length);
    }

    Il2CppString* String::InternalIntern(Il2CppString* str)
    {
        return il2cpp_string_intern(str);
    }

    Il2CppString* String::InternalIsInterned(Il2CppString* str)
    {
        return il2cpp_string_is_interned(str);
    }

    void String::RedirectToCreateString()
    {
        NOT_SUPPORTED_IL2CPP(String::RedirectToCreateString, "All String constructors should be redirected to String.CreateString.");
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\String.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Type.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System/Type.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/Type.h"
#include <utils/StringUtils.h>
#include <metadata/GenericMetadata.h>

using il2cpp::metadata::GenericMetadata;
using il2cpp::utils::StringUtils;

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    Il2CppReflectionType* Type::internal_from_handle(intptr_t ptr)
    {
        return vm::Type::GetTypeFromHandle(ptr);
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\Type.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\TypedReference.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System/TypedReference.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Object.h"
#include "vm/Type.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    Il2CppObject* TypedReference::InternalToObject(Il2CppTypedRef* typedRef)
    {
        Il2CppObject* result = NULL;
        if (vm::Type::IsReference(typedRef->type))
        {
            Il2CppObject** obj = (Il2CppObject**)typedRef->value;
            return *obj;
        }

        result = vm::Object::Box(typedRef->klass, typedRef->value);
        return result;
    }

    void TypedReference::InternalMakeTypedReference(Il2CppTypedRef* res, Il2CppObject* target, Il2CppArray* fields, Il2CppReflectionRuntimeType* lastFieldType)
    {
        memset(res, 0, sizeof(Il2CppTypedRef));

        IL2CPP_ASSERT(fields);

        uint32_t fieldsArrayLength = vm::Array::GetLength(fields);

        Il2CppClass* klass = target->vtable->klass;

        uint8_t* value = NULL;
        const Il2CppType *ftype = NULL;
        for (uint32_t i = 0; i < fieldsArrayLength; ++i)
        {
            FieldInfo* f = il2cpp_array_get(fields, FieldInfo*, i);
            if (f == NULL)
            {
                vm::Exception::Raise(vm::Exception::GetArgumentNullException("field"));
                return;
            }

            if (i == 0)
                value = (uint8_t*)target + f->offset;
            else
                value += f->offset - sizeof(Il2CppObject);

            klass = vm::Class::FromIl2CppType(f->type);
            ftype = f->type;
        }

        res->type = ftype;
        res->klass = vm::Class::FromIl2CppType(ftype);
        res->value = value;
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\TypedReference.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\ValueType.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "icalls/mscorlib/System/ValueType.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "gc/WriteBarrier.h"
#include "utils/StringUtils.h"
#include "utils/HashUtils.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/String.h"

using il2cpp::gc::WriteBarrier;

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    bool ValueType::InternalEquals(Il2CppObject * thisPtr, Il2CppObject * that, Il2CppArray** fields)
    {
        Il2CppClass *klass;
        Il2CppObject **values = NULL;
        Il2CppObject *o;
        FieldInfo* field;
        void* iter;
        int count = 0;

        IL2CPP_CHECK_ARG_NULL(that);

        if (thisPtr->klass != that->klass)
            return false;

        klass = vm::Object::GetClass(thisPtr);

        if (klass->enumtype && vm::Class::GetEnumBaseType(klass) && vm::Class::GetEnumBaseType(klass)->type == IL2CPP_TYPE_I4)
            return (*(int32_t*)((uint8_t*)thisPtr + sizeof(Il2CppObject)) == *(int32_t*)((uint8_t*)that + sizeof(Il2CppObject)));

        /*
         * Do the comparison for fields of primitive type and return a result if
         * possible. Otherwise, return the remaining fields in an array to the
         * managed side. This way, we can avoid costly reflection operations in
         * managed code.
         */
        *fields = NULL;
        iter = NULL;
        while ((field = vm::Class::GetFields(klass, &iter)))
        {
            if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
                continue;
            if (vm::Field::IsDeleted(field))
                continue;
            /* FIXME: Add more types */

            switch (field->type->type)
            {
                case IL2CPP_TYPE_I1:
                case IL2CPP_TYPE_U1:
                case IL2CPP_TYPE_BOOLEAN:
                    if (*((uint8_t*)thisPtr + field->offset) != *((uint8_t*)that + field->offset))
                        return false;
                    break;
                case IL2CPP_TYPE_I2:
                case IL2CPP_TYPE_U2:
                case IL2CPP_TYPE_CHAR:
                    if (*(int16_t*)((uint8_t*)thisPtr + field->offset) != *(int16_t*)((uint8_t*)that + field->offset))
                        return false;
                    break;
                case IL2CPP_TYPE_I4:
                case IL2CPP_TYPE_U4:
                    if (*(int32_t*)((uint8_t*)thisPtr + field->offset) != *(int32_t*)((uint8_t*)that + field->offset))
                        return false;
                    break;
                case IL2CPP_TYPE_I8:
                case IL2CPP_TYPE_U8:
                    if (*(int64_t*)((uint8_t*)thisPtr + field->offset) != *(int64_t*)((uint8_t*)that + field->offset))
                        return false;
                    break;
                case IL2CPP_TYPE_R4:
                    if (*(float*)((uint8_t*)thisPtr + field->offset) != *(float*)((uint8_t*)that + field->offset))
                        return false;
                    break;
                case IL2CPP_TYPE_R8:
                    if (*(double*)((uint8_t*)thisPtr + field->offset) != *(double*)((uint8_t*)that + field->offset))
                        return false;
                    break;
                case IL2CPP_TYPE_PTR:
                    if (*(void**)((uint8_t*)thisPtr + field->offset) != *(void**)((uint8_t*)that + field->offset))
                        return false;
                    break;
                case IL2CPP_TYPE_STRING:
                    Il2CppString *s1, *s2;
                    uint32_t s1len, s2len;
                    s1 = *(Il2CppString**)((uint8_t*)thisPtr + field->offset);
                    s2 = *(Il2CppString**)((uint8_t*)that + field->offset);
                    if (s1 == s2)
                        break;
                    if ((s1 == NULL) || (s2 == NULL))
                        return false;
                    s1len = utils::StringUtils::GetLength(s1);
                    s2len = utils::StringUtils::GetLength(s2);
                    if (s1len != s2len)
                        return false;

                    if (memcmp(utils::StringUtils::GetChars(s1), utils::StringUtils::GetChars(s2), s1len * sizeof(Il2CppChar)) != 0)
                        return false;
                    break;
                default:
                    if (!values)
                        values = (Il2CppObject**)alloca(sizeof(Il2CppObject*) * (vm::Class::GetNumFields(klass) * 2));
                    o = vm::Field::GetValueObject(field, thisPtr);
                    values[count++] = o;
                    o = vm::Field::GetValueObject(field, that);
                    values[count++] = o;
            }

            if (klass->enumtype)
                /* enums only have one non-static field */
                break;
        }

        if (values)
        {
            int i;
            WriteBarrier::GenericStore(fields, vm::Array::New(il2cpp_defaults.object_class, count));
            for (i = 0; i < count; ++i)
                il2cpp_array_setref(*fields, i, values[i]);
            return false;
        }
        else
        {
            return true;
        }
    }

    int ValueType::InternalGetHashCode(Il2CppObject* obj, Il2CppArray** fields)
    {
        Il2CppObject **values = NULL;
        int count = 0;
        FieldInfo* field = NULL;
        void* iter = NULL;

        Il2CppClass* klass = vm::Object::GetClass(obj);
        int32_t result = (int32_t)il2cpp::utils::HashUtils::AlignedPointerHash(klass);

        if (vm::Class::GetNumFields(klass) == 0)
            return result;

        /*
         * Compute the starting value of the hashcode for fields of primitive
         * types, and return the remaining fields in an array to the managed side.
         * This way, we can avoid costly reflection operations in managed code.
         */
        iter = NULL;
        while ((field = vm::Class::GetFields(klass, &iter)))
        {
            if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
                continue;
            if (vm::Field::IsDeleted(field))
                continue;
            /* FIXME: Add more types */
            switch (field->type->type)
            {
                case IL2CPP_TYPE_I4:
                    result ^= *(int32_t*)((uint8_t*)obj + field->offset);
                    break;
                case IL2CPP_TYPE_STRING:
                {
                    Il2CppString *s;
                    s = *(Il2CppString**)((uint8_t*)obj + field->offset);
                    if (s != NULL)
                        result ^= vm::String::GetHash(s);
                    break;
                }
                case IL2CPP_TYPE_PTR:
                    result ^= il2cpp::utils::HashUtils::AlignedPointerHash(*(void**)((uint8_t*)obj + field->offset));
                    break;
                default:
                    if (!values)
                        values = (Il2CppObject**)alloca(sizeof(Il2CppObject*) * vm::Class::GetNumFields(klass));
                    Il2CppObject* o = vm::Field::GetValueObject(field, obj);
                    values[count++] = o;
            }
        }

        if (values)
        {
            int i;
            WriteBarrier::GenericStore(fields, vm::Array::New(il2cpp_defaults.object_class, count));
            for (i = 0; i < count; ++i)
                il2cpp_array_setref(*fields, i, values[i]);
        }
        else
        {
            *fields = NULL;
        }

        return result;
    }
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System\ValueType.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Diagnostics\Debugger.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Debugger.h"
#include "vm-utils/Debugger.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Diagnostics
{
    bool Debugger::IsAttached_internal()
    {
        return utils::Debugger::GetIsDebuggerAttached();
    }

    bool Debugger::IsLogging()
    {
#if IL2CPP_MONO_DEBUGGER
        return utils::Debugger::IsLoggingEnabled();
#else
        return false;
#endif
    }

    void Debugger::Log_icall(int32_t level, Il2CppString** category, Il2CppString** message)
    {
#if IL2CPP_MONO_DEBUGGER
        utils::Debugger::Log(level, *category, *message);
#endif
    }
} /* namespace Diagnostics */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Diagnostics\Debugger.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Diagnostics\StackFrame.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System.Diagnostics/StackFrame.h"
#include "vm/Reflection.h"
#include "vm/StackTrace.h"
#include "vm/String.h"
#include "il2cpp-class-internals.h"
#include "gc/GarbageCollector.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Diagnostics
{
    static bool IsCalledFromSystemDiagnosticsStackTrace(const vm::StackFrames& stack)
    {
        for (vm::StackFrames::const_iterator frame = stack.begin(); frame != stack.end(); ++frame)
            if (strcmp(frame->method->klass->namespaze, "System.Diagnostics") == 0 && strcmp(frame->method->klass->name, "StackTrace") == 0)
                return true;

        return false;
    }

    static bool FrameNeedsSkipped(const Il2CppStackFrameInfo& frame)
    {
        return strcmp(frame.method->klass->namespaze, "System.Diagnostics") == 0 &&
            (strcmp(frame.method->klass->name, "StackFrame") == 0 || strcmp(frame.method->klass->name, "StackTrace") == 0);
    }

    bool StackFrame::get_frame_info(
        int32_t skip,
        bool needFileInfo,
        Il2CppReflectionMethod ** method,
        int32_t* iloffset,
        int32_t* native_offset,
        Il2CppString** file,
        int32_t* line,
        int32_t* column)
    {
        const int kSkippedFramesFromMSCorlibStackFrameMethods = 2;
        const int kSkippedFramesFromMSCorlibStackTraceMethods = 2;

        const vm::StackFrames& stack = *vm::StackTrace::GetCachedStackFrames(skip);

        // Always ignore the skipped frames from System.Diagnostics.StackFrame, as we know we are always called from it.
        // These frames might be inlined or optimized away by the C++ compiler, so we will inspect the actual stack
        // frames later to see if we need to add skipped frames back in for System.Diagnostics.StackFrame.
        skip -= kSkippedFramesFromMSCorlibStackFrameMethods;


        // Sometimes ignore the skipped frames from System.Diagnostics.StackTrace, as we may or may not be called from it.
        // These frames might be inlined or optimized away by the C++ compiler, so we will inspect the actual stack
        // frames later to see if we need to add skipped frames back in for System.Diagnostics.StackTrace.
        if (IsCalledFromSystemDiagnosticsStackTrace(stack))
            skip -= kSkippedFramesFromMSCorlibStackTraceMethods;

        // Now look in the actual stack trace to see if anything we ignored above is really there. We don't know what the C++
        // compile will do with these frames, so we need to inspect each frame and check.
        for (vm::StackFrames::const_iterator frame = stack.begin(); frame != stack.end(); ++frame)
        {
            if (FrameNeedsSkipped(*frame))
                skip++;
        }

        // Finally, find the location in the stack we actually want to use by offsetting from the end of the stack the number of
        // frames we skipped, and offsetting it by one more to account for this icall itself.
        int64_t index = stack.size() - skip - 1;
        if (static_cast<uint64_t>(index) >= stack.size() || index < 0)
            return false;

        const Il2CppStackFrameInfo& info = stack[static_cast<size_t>(index)];

        *method = vm::Reflection::GetMethodObject(info.method, info.method->klass);
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)method);

        if (info.filePath != NULL && strlen(info.filePath) != 0)
        {
            *line = info.sourceCodeLineNumber;
            *iloffset = info.ilOffset;
            *file = il2cpp::vm::String::New(info.filePath);
            il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)file);
        }

        return true;
    }
} /* namespace Diagnostics */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Diagnostics\StackFrame.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Diagnostics\StackTrace.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "gc/WriteBarrier.h"
#include "vm/Array.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "icalls/mscorlib/System.Diagnostics/StackTrace.h"
#include "vm-utils/DebugSymbolReader.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Diagnostics
{
    static Il2CppArray* GetTraceInternal(Il2CppArray* trace_ips, int32_t skip, bool need_file_info)
    {
        /* Exception is not thrown yet */
        if (trace_ips == NULL)
            return vm::Array::New(il2cpp_defaults.stack_frame_class, 0);

        int len = vm::Array::GetLength(trace_ips);
        Il2CppArray* stackFrames = vm::Array::New(il2cpp_defaults.stack_frame_class, len > skip ? len - skip : 0);

        for (int i = skip; i < len; i++)
        {
            Il2CppStackFrame* stackFrame = NULL;

            if (utils::DebugSymbolReader::DebugSymbolsAvailable())
            {
                stackFrame = il2cpp_array_get(trace_ips, Il2CppStackFrame*, i);
            }
            else
            {
                stackFrame = (Il2CppStackFrame*)vm::Object::New(il2cpp_defaults.stack_frame_class);
                MethodInfo* method = il2cpp_array_get(trace_ips, MethodInfo*, i);

                IL2CPP_OBJECT_SETREF(stackFrame, method, vm::Reflection::GetMethodObject(method, NULL));
            }

            il2cpp_array_setref(stackFrames, i, stackFrame);
        }

        return stackFrames;
    }

    Il2CppArray* StackTrace::get_trace(Il2CppException *exc, int32_t skip, bool need_file_info)
    {
        // Exception.RestoreExceptionDispatchInfo() will clear trace_ips, so we need to ensure that we read it only once
        return GetTraceInternal(exc->trace_ips, skip, need_file_info);
    }
} /* namespace Diagnostics */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Diagnostics\StackTrace.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CalendarData.cpp---------------
.
.
#include <string>
#include <cstdlib>
#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "CalendarData.h"
#include "CultureInfoTables.h"
#include "gc/WriteBarrier.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/String.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Globalization
{
    static Il2CppArray* calendar_data_create_names_array_idx(const uint16_t* names, int len, const char* strings_array)
    {
        if (names == NULL)
            return NULL;

        Il2CppArray* ret = il2cpp_array_new_specific(il2cpp_array_class_get(il2cpp_defaults.string_class, 1), len);

        for (int i = 0; i < len; i++)
        {
            if (names[i] == 0)
                il2cpp_array_setref(ret, i, vm::String::Empty());
            else
                il2cpp_array_setref(ret, i, il2cpp_string_new(strings_array + names[i]));
        }

        return ret;
    }

    static Il2CppArray* calendar_data_create_names_array_idx_dynamic(const uint16_t* names, int max, const char* strings_array)
    {
        if (names == NULL)
            return NULL;

        int len = 0;
        for (int i = 0; i < max; i++)
        {
            if (names[i] == 0)
                break;
            len++;
        }

        return calendar_data_create_names_array_idx(names, len, strings_array);
    }

    static int culture_data_culture_name_locator(const void *a, const void *b)
    {
        const char* aa = (const char*)a;
        const CultureInfoNameEntry* bb = (const CultureInfoNameEntry*)b;
        int ret;

        ret = strcmp(aa, idx2string(bb->name));

        return ret;
    }

    bool CalendarData::fill_calendar_data(Il2CppCalendarData* _this, Il2CppString* localeName, int32_t datetimeIndex)
    {
        const DateTimeFormatEntry *dfe;
        const CultureInfoEntry *ci;

        std::string cultureName = il2cpp::utils::StringUtils::Utf16ToUtf8(localeName->chars);

        const CultureInfoNameEntry* ne = (const CultureInfoNameEntry*)bsearch(cultureName.c_str(), culture_name_entries, NUM_CULTURE_ENTRIES, sizeof(CultureInfoNameEntry), culture_data_culture_name_locator);

        if (ne == NULL)
        {
            return false;
        }

        ci = &culture_entries[ne->culture_entry_index];
        dfe = &datetime_format_entries[ci->datetime_format_index];

        IL2CPP_OBJECT_SETREF(_this, NativeName, il2cpp_string_new(idx2string(ci->nativename)));
        Il2CppArray *short_date_patterns = calendar_data_create_names_array_idx_dynamic(dfe->short_date_patterns, NUM_SHORT_DATE_PATTERNS, &patterns[0]);
        IL2CPP_OBJECT_SETREF(_this, ShortDatePatterns, short_date_patterns);
        Il2CppArray *year_month_patterns = calendar_data_create_names_array_idx_dynamic(dfe->year_month_patterns, NUM_YEAR_MONTH_PATTERNS, &patterns[0]);
        IL2CPP_OBJECT_SETREF(_this, YearMonthPatterns, year_month_patterns);
        Il2CppArray *long_date_patterns = calendar_data_create_names_array_idx_dynamic(dfe->long_date_patterns, NUM_LONG_DATE_PATTERNS, &patterns[0]);
        IL2CPP_OBJECT_SETREF(_this, LongDatePatterns, long_date_patterns);
        IL2CPP_OBJECT_SETREF(_this, MonthDayPattern, il2cpp_string_new(pattern2string(dfe->month_day_pattern)));
        Il2CppArray *day_names = calendar_data_create_names_array_idx(dfe->day_names, NUM_DAYS, &datetime_strings[0]);
        IL2CPP_OBJECT_SETREF(_this, DayNames, day_names);
        Il2CppArray *abbr_day_names = calendar_data_create_names_array_idx(dfe->abbreviated_day_names, NUM_DAYS, &datetime_strings[0]);
        IL2CPP_OBJECT_SETREF(_this, AbbreviatedDayNames, abbr_day_names);
        Il2CppArray *ss_day_names = calendar_data_create_names_array_idx(dfe->shortest_day_names, NUM_DAYS, &datetime_strings[0]);
        IL2CPP_OBJECT_SETREF(_this, SuperShortDayNames, ss_day_names);
        Il2CppArray *month_names = calendar_data_create_names_array_idx(dfe->month_names, NUM_MONTHS, &datetime_strings[0]);
        IL2CPP_OBJECT_SETREF(_this, MonthNames, month_names);
        Il2CppArray *abbr_mon_names = calendar_data_create_names_array_idx(dfe->abbreviated_month_names, NUM_MONTHS, &datetime_strings[0]);
        IL2CPP_OBJECT_SETREF(_this, AbbreviatedMonthNames, abbr_mon_names);
        Il2CppArray *gen_month_names = calendar_data_create_names_array_idx(dfe->month_genitive_names, NUM_MONTHS, &datetime_strings[0]);
        IL2CPP_OBJECT_SETREF(_this, GenitiveMonthNames, gen_month_names);
        Il2CppArray *gen_abbr_mon_names = calendar_data_create_names_array_idx(dfe->abbreviated_month_genitive_names, NUM_MONTHS, &datetime_strings[0]);
        IL2CPP_OBJECT_SETREF(_this, GenitiveAbbreviatedMonthNames, gen_abbr_mon_names);

        return true;
    }
} // namespace Globalization
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CalendarData.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CompareInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "icalls/mscorlib/System.Globalization/CompareInfo.h"
#include "icalls/mscorlib/System.Globalization/CompareOptions.h"
#include "vm/String.h"
#include "vm/Exception.h"
#include "vm/Array.h"
#include "utils/StringUtils.h"
#include "vm-utils/VmStringUtils.h"
#include <cwctype>
#include <wctype.h>
#include <algorithm>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Globalization
{
    static int string_invariant_compare_char(Il2CppChar c1, Il2CppChar c2, int options)
    {
        int result = 0;

        // Ordinal can not be mixed with other options, and must return the difference, not only -1, 0, 1.
        if (options & CompareOptions_Ordinal)
            return (int)(c1 - c2);

        if (options & CompareOptions_IgnoreCase)
        {
            result = towlower(c1) - towlower(c2);
        }
        else
        {
            /*
             * No options. Kana, symbol and spacing options don't
             * apply to the invariant culture.
             */

            /*
             * FIXME: here we must use the information from c1type and c2type
             * to find out the proper collation, even on the InvariantCulture, the
             * sorting is not done by computing the unicode values, but their
             * actual sort order.
             */
            result = (int)(c1 - c2);
        }

        return ((result < 0) ? -1 : (result > 0) ? 1 : 0);
    }

    int32_t CompareInfo::internal_compare_icall(Il2CppChar* str1, int32_t length1, Il2CppChar* str2, int32_t length2, int32_t options)
    {
        // Do a normal ascii string compare, as we only know the invariant locale if we dont have ICU.
        /* c translation of C# code from old string.cs.. :) */
        const int length = std::max(length1, length2);
        int charcmp;
        int pos = 0;

        for (pos = 0; pos != length; pos++)
        {
            if (pos >= length1 || pos >= length2)
                break;

            charcmp = string_invariant_compare_char(str1[pos], str2[pos],
                options);
            if (charcmp != 0)
                return (charcmp);
        }

        /* the lesser wins, so if we have looped until length we just
         * need to check the last char
         */
        if (pos == length)
            return (string_invariant_compare_char(str1[pos - 1], str2[pos - 1], options));

        /* Test if one of the strings has been compared to the end */
        if (pos >= length1)
        {
            if (pos >= length2)
                return (0);
            return (-1);
        }
        else if (pos >= length2)
            return (1);

        /* if not, check our last char only.. (can this happen?) */
        return (string_invariant_compare_char(str1[pos], str2[pos], options));
    }

    int32_t CompareInfo::internal_index_icall(Il2CppChar* source, int32_t sindex, int32_t count, Il2CppChar* value, int32_t value_length, bool first)
    {
        int pos, i;

        if (first)
        {
            count -= value_length;
            for (pos = sindex; pos <= sindex + count; pos++)
                for (i = 0; source[pos + i] == value[i];)
                    if (++i == value_length)
                        return (pos);

            return (-1);
        }
        else
        {
            for (pos = sindex - value_length + 1; pos > sindex - count; pos--)
                if (memcmp(source + pos, value, value_length * sizeof(Il2CppChar)) == 0)
                    return (pos);

            return (-1);
        }
    }
} /* namespace Globalization */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CompareInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CultureData.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "CultureData.h"
#include "il2cpp-api.h"
#include <icalls/mscorlib/System.Globalization/CultureInfoInternals.h>
#include <icalls/mscorlib/System.Globalization/CultureInfoTables.h>
#include "gc/WriteBarrier.h"
#include <vm/Array.h>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Globalization
{
    static Il2CppArray* culture_data_create_names_array_idx(const uint16_t* names, int max, const char* strings_array)
    {
        if (names == NULL)
            return NULL;

        int len = 0;
        for (int i = 0; i < max; i++)
        {
            if (names[i] == 0)
                break;
            len++;
        }

        Il2CppArray* ret = il2cpp_array_new_specific(il2cpp_array_class_get(il2cpp_defaults.string_class, 1), len);

        for (int i = 0; i < len; i++)
            il2cpp_array_setref(ret, i, il2cpp_string_new(strings_array + names[i]));

        return ret;
    }

    static Il2CppArray* culture_data_create_group_sizes_array(const int *gs, int ml)
    {
        int i, len = 0;

        for (i = 0; i < ml; i++)
        {
            if (gs[i] == -1)
                break;
            len++;
        }

        Il2CppArray* ret = il2cpp_array_new_specific(il2cpp_array_class_get(il2cpp_defaults.int32_class, 1), len);

        for (i = 0; i < len; i++)
            il2cpp_array_set(ret, int32_t, i, gs[i]);

        return ret;
    }

    const void* CultureData::fill_number_data(int32_t number_index, NumberFormatEntryManaged* managed)
    {
        IL2CPP_ASSERT(number_index >= 0 && number_index < IL2CPP_ARRAY_SIZE(number_format_entries));

        NumberFormatEntry const * const native = &number_format_entries[number_index];

        managed->currency_decimal_digits = native->currency_decimal_digits;
        managed->currency_decimal_separator = native->currency_decimal_separator;
        managed->currency_group_separator = native->currency_group_separator;
        managed->currency_group_sizes0 = native->currency_group_sizes[0];
        managed->currency_group_sizes1 = native->currency_group_sizes[1];
        managed->currency_negative_pattern = native->currency_negative_pattern;
        managed->currency_positive_pattern = native->currency_positive_pattern;
        managed->currency_symbol = native->currency_symbol;
        managed->nan_symbol = native->nan_symbol;
        managed->negative_infinity_symbol = native->negative_infinity_symbol;
        managed->negative_sign = native->negative_sign;
        managed->number_decimal_digits = native->number_decimal_digits;
        managed->number_decimal_separator = native->number_decimal_separator;
        managed->number_group_separator = native->number_group_separator;
        managed->number_group_sizes0 = native->number_group_sizes[0];
        managed->number_group_sizes1  = native->number_group_sizes[1];
        managed->number_negative_pattern = native->number_negative_pattern;
        managed->per_mille_symbol = native->per_mille_symbol;
        managed->percent_negative_pattern = native->percent_negative_pattern;
        managed->percent_positive_pattern = native->percent_positive_pattern;
        managed->percent_symbol = native->percent_symbol;
        managed->positive_infinity_symbol = native->positive_infinity_symbol;
        managed->positive_sign = native->positive_sign;

        return locale_strings;
    }

    void CultureData::fill_culture_data(Il2CppCultureData* _this, int32_t datetimeIndex)
    {
        const DateTimeFormatEntry *dfe;

        IL2CPP_ASSERT(datetimeIndex >= 0);

        dfe = &datetime_format_entries[datetimeIndex];
        IL2CPP_OBJECT_SETREF(_this, AMDesignator, il2cpp_string_new(idx2string(dfe->am_designator)));
        IL2CPP_OBJECT_SETREF(_this, PMDesignator, il2cpp_string_new(idx2string(dfe->pm_designator)));
        IL2CPP_OBJECT_SETREF(_this, TimeSeparator, il2cpp_string_new(idx2string(dfe->time_separator)));
        Il2CppArray *long_time_patterns = culture_data_create_names_array_idx(dfe->long_time_patterns, NUM_LONG_TIME_PATTERNS, &patterns[0]);
        IL2CPP_OBJECT_SETREF(_this, LongTimePatterns, long_time_patterns);
        Il2CppArray *short_time_patterns = culture_data_create_names_array_idx(dfe->short_time_patterns, NUM_SHORT_TIME_PATTERNS, &patterns[0]);
        IL2CPP_OBJECT_SETREF(_this, ShortTimePatterns, short_time_patterns);
        _this->FirstDayOfWeek = dfe->first_day_of_week;
        _this->CalendarWeekRule = dfe->calendar_week_rule;
    }
} // namespace Globalization
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CultureData.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CultureInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include <string>
#include <algorithm>
#include "il2cpp-api.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "gc/WriteBarrier.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/Exception.h"
#include "vm/String.h"
#include "os/Locale.h"
#include "icalls/mscorlib/System.Globalization/CultureInfo.h"
#include "CultureInfoInternals.h"
#include "CultureInfoTables.h"


/*
* The following methods is modified from the ICU source code. (http://oss.software.ibm.com/icu)
* Copyright (c) 1995-2003 International Business Machines Corporation and others
* All rights reserved.
*/
static std::string get_current_locale_name(void)
{
    char* locale;
    char* corrected = NULL;
    const char* p;

    std::string locale_str = il2cpp::os::Locale::GetLocale();

    if (locale_str.empty())
        return std::string();

    locale = il2cpp::utils::StringUtils::StringDuplicate(locale_str.c_str());

    if ((p = strchr(locale, '.')) != NULL)
    {
        /* assume new locale can't be larger than old one? */
        corrected = (char*)IL2CPP_MALLOC(strlen(locale));
        strncpy(corrected, locale, p - locale);
        corrected[p - locale] = 0;

        /* do not copy after the @ */
        if ((p = strchr(corrected, '@')) != NULL)
            corrected[p - corrected] = 0;
    }

    /* Note that we scan the *uncorrected* ID. */
    if ((p = strrchr(locale, '@')) != NULL)
    {
        /*
        * Mono we doesn't handle the '@' modifier because it does
        * not have any cultures that use it. Just trim it
        * off of the end of the name.
        */

        if (corrected == NULL)
        {
            corrected = (char*)IL2CPP_MALLOC(strlen(locale));
            strncpy(corrected, locale, p - locale);
            corrected[p - locale] = 0;
        }
    }

    if (corrected == NULL)
        corrected = locale;
    else
        IL2CPP_FREE(locale);

    char* c;
    if ((c = strchr(corrected, '_')) != NULL)
        *c = '-';

    std::string result(corrected);
    IL2CPP_FREE(corrected);

    std::transform(result.begin(), result.end(), result.begin(), ::tolower);

    return result;
}

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Globalization
{
    static Il2CppArray* culture_info_create_names_array_idx(const uint16_t* names, int max)
    {
        if (names == NULL)
            return NULL;

        int len = 0;
        for (int i = 0; i < max; i++)
        {
            if (names[i] == 0)
                break;
            len++;
        }

        Il2CppArray* ret = il2cpp_array_new_specific(il2cpp_array_class_get(il2cpp_defaults.string_class, 1), len);

        for (int i = 0; i < len; i++)
            il2cpp_array_setref(ret, i, il2cpp_string_new(dtidx2string(names[i])));

        return ret;
    }

    static bool construct_culture(Il2CppCultureInfo* cultureInfo, const CultureInfoEntry *ci)
    {
        cultureInfo->lcid = ci->lcid;
        IL2CPP_OBJECT_SETREF(cultureInfo, name, il2cpp_string_new(idx2string(ci->name)));
        IL2CPP_OBJECT_SETREF(cultureInfo, englishname, il2cpp_string_new(idx2string(ci->englishname)));
        IL2CPP_OBJECT_SETREF(cultureInfo, nativename, il2cpp_string_new(idx2string(ci->nativename)));
        IL2CPP_OBJECT_SETREF(cultureInfo, win3lang, il2cpp_string_new(idx2string(ci->win3lang)));
        IL2CPP_OBJECT_SETREF(cultureInfo, iso3lang, il2cpp_string_new(idx2string(ci->iso3lang)));
        IL2CPP_OBJECT_SETREF(cultureInfo, iso2lang, il2cpp_string_new(idx2string(ci->iso2lang)));

        // It's null for neutral cultures
        if (ci->territory > 0)
            IL2CPP_OBJECT_SETREF(cultureInfo, territory, il2cpp_string_new(idx2string(ci->territory)));
        cultureInfo->parent_lcid = ci->parent_lcid;
        cultureInfo->datetime_index = ci->datetime_format_index;
        cultureInfo->number_index = ci->number_format_index;
        cultureInfo->text_info_data = &ci->text_info;

        IL2CPP_OBJECT_SETREF(cultureInfo, native_calendar_names, culture_info_create_names_array_idx(ci->native_calendar_names, NUM_CALENDARS));
        cultureInfo->default_calendar_type = ci->calendar_type;

        return true;
    }

    static int culture_info_culture_name_locator(const void *a, const void *b)
    {
        const char* aa = (const char*)a;
        const CultureInfoNameEntry* bb = (const CultureInfoNameEntry*)b;
        int ret;

        ret = strcmp(aa, idx2string(bb->name));

        return ret;
    }

    static int culture_lcid_locator(const void *a, const void *b)
    {
        const CultureInfoEntry *aa = (const CultureInfoEntry*)a;
        const CultureInfoEntry *bb = (const CultureInfoEntry*)b;

        return (aa->lcid - bb->lcid);
    }

    static const CultureInfoEntry* culture_info_entry_from_lcid(int lcid)
    {
        CultureInfoEntry key;
        key.lcid = lcid;
        return (const CultureInfoEntry*)bsearch(&key, culture_entries, NUM_CULTURE_ENTRIES, sizeof(CultureInfoEntry), culture_lcid_locator);
    }
    bool CultureInfo::construct_internal_locale_from_lcid(Il2CppCultureInfo* cultureInfo, int lcid)
    {
        const CultureInfoEntry* ci = culture_info_entry_from_lcid(lcid);
        if (ci == NULL)
            return false;

        return construct_culture(cultureInfo, ci);
    }

    bool CultureInfo::construct_internal_locale_from_name(Il2CppCultureInfo* cultureInfo, Il2CppString* name)
    {
        std::string cultureName = il2cpp::utils::StringUtils::Utf16ToUtf8(name->chars);
        const CultureInfoNameEntry* ne = (const CultureInfoNameEntry*)bsearch(cultureName.c_str(), culture_name_entries, NUM_CULTURE_ENTRIES, sizeof(CultureInfoNameEntry), culture_info_culture_name_locator);

        if (ne == NULL)
            return false;

        return construct_culture(cultureInfo, &culture_entries[ne->culture_entry_index]);
    }

    static bool IsMatchingCultureInfoEntry(const CultureInfoEntry& entry, bool neutral, bool specific, bool installed)
    {
        const bool isNeutral = entry.territory == 0;
        return ((neutral && isNeutral) || (specific && !isNeutral));
    }

    Il2CppArray* CultureInfo::internal_get_cultures(bool neutral, bool specific, bool installed)
    {
        // Count culture infos that match.
        int numMatchingCultures = 0;
        for (int i = 0; i < NUM_CULTURE_ENTRIES; ++i)
        {
            const CultureInfoEntry& entry = culture_entries[i];
            if (IsMatchingCultureInfoEntry(entry, neutral, specific, installed))
                ++numMatchingCultures;
        }

        if (neutral)
            ++numMatchingCultures;

        // Allocate result array.
        Il2CppClass* cultureInfoClass = il2cpp_defaults.culture_info;
        Il2CppArray* array = il2cpp_array_new(cultureInfoClass, numMatchingCultures);

        int index = 0;

        // InvariantCulture is not in culture table. We reserve the first
        // array element for it.
        if (neutral)
            il2cpp_array_setref(array, index++, NULL);

        // Populate CultureInfo entries.
        for (int i = 0; i < NUM_CULTURE_ENTRIES; ++i)
        {
            const CultureInfoEntry& entry = culture_entries[i];
            if (!IsMatchingCultureInfoEntry(entry, neutral, specific, installed))
                continue;

            Il2CppCultureInfo* info = reinterpret_cast<Il2CppCultureInfo*>(il2cpp_object_new(cultureInfoClass));
            construct_culture(info, &entry);

            il2cpp_array_setref(array, index++, info);
        }

        return array;
    }

    Il2CppString* CultureInfo::get_current_locale_name()
    {
        return vm::String::New(::get_current_locale_name().c_str());
    }

    extern "C" void STDCALL InitializeUserPreferredCultureInfoInAppX(CultureInfoChangedCallback onCultureInfoChangedInAppX)
    {
#if IL2CPP_TARGET_WINRT
        il2cpp_hresult_t hr = os::Locale::InitializeUserPreferredCultureInfoInAppX(onCultureInfoChangedInAppX);
        if (IL2CPP_HR_FAILED(hr))
            vm::Exception::Raise(hr, false);
#endif
    }

    extern "C" void STDCALL SetUserPreferredCultureInfoInAppX(const Il2CppChar* name)
    {
#if IL2CPP_TARGET_WINRT
        il2cpp_hresult_t hr = os::Locale::SetUserPreferredCultureInfoInAppX(name);
        if (IL2CPP_HR_FAILED(hr))
            vm::Exception::Raise(hr, false);
#endif
    }
} /* namespace Globalization */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\CultureInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\RegionInfo.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System.Globalization/CultureInfoInternals.h"
#include "icalls/mscorlib/System.Globalization/CultureInfoTables.h"
#include "icalls/mscorlib/System.Globalization/RegionInfo.h"
#include "gc/WriteBarrier.h"
#include "utils/StringUtils.h"
#include "vm/String.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Globalization
{
    static bool ConstructRegion(Il2CppRegionInfo* regionInfo, const RegionInfoEntry* ri)
    {
        regionInfo->geo_id = ri->geo_id;
        IL2CPP_OBJECT_SETREF(regionInfo, iso2name, vm::String::New(idx2string(ri->iso2name)));
        IL2CPP_OBJECT_SETREF(regionInfo, iso3name, vm::String::New(idx2string(ri->iso3name)));
        IL2CPP_OBJECT_SETREF(regionInfo, win3name, vm::String::New(idx2string(ri->win3name)));
        IL2CPP_OBJECT_SETREF(regionInfo, english_name, vm::String::New(idx2string(ri->english_name)));
        IL2CPP_OBJECT_SETREF(regionInfo, native_name, vm::String::New(idx2string(ri->native_name)));
        IL2CPP_OBJECT_SETREF(regionInfo, currency_symbol, vm::String::New(idx2string(ri->currency_symbol)));
        IL2CPP_OBJECT_SETREF(regionInfo, iso_currency_symbol, vm::String::New(idx2string(ri->iso_currency_symbol)));
        IL2CPP_OBJECT_SETREF(regionInfo, currency_english_name, vm::String::New(idx2string(ri->currency_english_name)));
        IL2CPP_OBJECT_SETREF(regionInfo, currency_native_name, vm::String::New(idx2string(ri->currency_native_name)));

        return true;
    }

    static int RegionNameLocator(const void *a, const void *b)
    {
        const char* aa = (const char*)a;
        const RegionInfoNameEntry* bb = (const RegionInfoNameEntry*)b;

        return strcmp(aa, idx2string(bb->name));
    }

    bool RegionInfo::construct_internal_region_from_name(Il2CppRegionInfo* regionInfo, Il2CppString* name)
    {
        std::string n = utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(name));
        RegionInfoNameEntry* nameEntry = (RegionInfoNameEntry*)bsearch(n.c_str(), region_name_entries, NUM_REGION_ENTRIES,
            sizeof(RegionInfoNameEntry), RegionNameLocator);

        if (nameEntry == NULL)
            return false;

        return ConstructRegion(regionInfo, &region_entries[nameEntry->region_entry_index]);
    }
} /* namespace Globalization */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Globalization\RegionInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\BrokeredFileSystem.cpp---------------
.
.
#include "il2cpp-object-internals.h"
#include "gc/GarbageCollector.h"
#include "icalls/mscorlib/System.IO/BrokeredFileSystem.h"
#include "os/BrokeredFileSystem.h"
#include "os/Directory.h"
#include "os/ErrorCodes.h"
#include "vm/LastError.h"
#include "vm/String.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace IO
{
    bool BrokeredFileSystem::CreateDirectory(Il2CppString* path)
    {
        auto status = os::BrokeredFileSystem::CreateDirectoryW(path->chars);
        vm::LastError::SetLastError(status);
        if (status != os::kErrorCodeSuccess)
            return false;

        return true;
    }

    bool BrokeredFileSystem::RemoveDirectory(Il2CppString* path)
    {
        auto status = os::BrokeredFileSystem::RemoveDirectoryW(path->chars);
        vm::LastError::SetLastError(status);
        if (status != os::kErrorCodeSuccess)
            return false;

        return true;
    }

    bool BrokeredFileSystem::GetFileAttributes(Il2CppString* path, WIN32_FILE_ATTRBIUTE_DATA_MIRROR* data)
    {
        os::FileStat stat;
        int32_t error = 0;
        os::BrokeredFileSystem::GetFileStat(il2cpp::utils::StringUtils::Utf16ToUtf8(path->chars), path->chars, &stat, &error);
        data->attributes = stat.attributes;
        data->creation_time = stat.creation_time;
        data->last_access_time = stat.last_access_time;
        data->last_write_time = stat.last_write_time;
        data->length_high = (uint32_t)(stat.length >> 32);
        data->length_low = (uint32_t)stat.length;

        vm::LastError::SetLastError(error);
        if (error != os::kErrorCodeSuccess)
            return false;

        return true;
    }

    bool BrokeredFileSystem::SetAttributes(Il2CppString* path, int32_t attributes)
    {
        int error = os::kErrorCodeSuccess;
        auto result = os::BrokeredFileSystem::SetFileAttributesW(path->chars, (UnityPalFileAttributes)attributes, &error);
        vm::LastError::SetLastError(error);
        return result;
    }

    void* BrokeredFileSystem::OpenFile(Il2CppString* path, int32_t desiredAccess, int32_t shareMode, int32_t creationDisposition, int32_t flagsAndAttributes)
    {
        int error = os::kErrorCodeSuccess;
        auto result = os::File::Open(il2cpp::utils::StringUtils::Utf16ToUtf8(path->chars), creationDisposition, desiredAccess, shareMode, flagsAndAttributes, &error);
        vm::LastError::SetLastError(error);
        return result;
    }

    void BrokeredFileSystem::CopyFile(Il2CppString* sourcePath, Il2CppString* destinationPath, bool overwrite, int32_t* error)
    {
        *error = os::kErrorCodeSuccess;
        os::BrokeredFileSystem::CopyFileW(sourcePath->chars, destinationPath->chars, overwrite, error);
    }

    bool BrokeredFileSystem::MoveFile(Il2CppString* sourcePath, Il2CppString* destinationPath)
    {
        int error = os::kErrorCodeSuccess;
        auto result = os::BrokeredFileSystem::MoveFileW(sourcePath->chars, destinationPath->chars, &error);
        vm::LastError::SetLastError(error);
        return result;
    }

    bool BrokeredFileSystem::DeleteFile(Il2CppString* path)
    {
        int32_t status = os::BrokeredFileSystem::DeleteFileW(path->chars);
        vm::LastError::SetLastError(status);
        if (status != os::kErrorCodeSuccess)
            return false;
        return true;
    }

    void* BrokeredFileSystem::FindFirstFile(Il2CppString* searchPath, Il2CppString** resultFileName, uint32_t* fileAttributes)
    {
        DECLARE_IL2CPP_CHAR_PTR_AS_STRING_VIEW_OF_NATIVE_CHARS(searchPathNative, searchPath->chars);

        Il2CppNativeString resultFileNameNative;

        os::Directory::FindHandle* findHandle = new(utils::Memory::Malloc(sizeof(os::Directory::FindHandle))) os::Directory::FindHandle(searchPathNative);
        int error = os::BrokeredFileSystem::FindFirstFileW(findHandle, searchPathNative, &resultFileNameNative, (int32_t*)fileAttributes);
        vm::LastError::SetLastError(error);

        DECLARE_NATIVE_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(resultFileNameNativeUtf16, resultFileNameNative);
        *resultFileName = vm::String::NewUtf16(resultFileNameNativeUtf16);
        gc::GarbageCollector::SetWriteBarrier((void**)resultFileName);

        return findHandle;
    }

    bool BrokeredFileSystem::FindNextFile(void* handle, Il2CppString** resultFileName, uint32_t* fileAttributes)
    {
        Il2CppNativeString resultFileNameNative;
        auto status = os::BrokeredFileSystem::FindNextFileW((os::Directory::FindHandle*)handle, &resultFileNameNative, (int32_t*)fileAttributes);

        DECLARE_NATIVE_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(resultFileNameNativeUtf16, resultFileNameNative);
        *resultFileName = vm::String::NewUtf16(resultFileNameNativeUtf16);
        gc::GarbageCollector::SetWriteBarrier((void**)resultFileName);

        vm::LastError::SetLastError(status);
        if (status != os::kErrorCodeSuccess)
            return false;
        return true;
    }

    void BrokeredFileSystem::FindHandleClose(void* findHandle)
    {
        os::BrokeredFileSystem::FindClose(((os::Directory::FindHandle*)findHandle)->osHandle);
        utils::Memory::Free(findHandle);
    }
} /* namespace IO */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\BrokeredFileSystem.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\DriveInfo.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System.IO/DriveInfo.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace IO
{
    bool DriveInfo::GetDiskFreeSpaceInternal(Il2CppChar* pathName, int32_t pathName_length, uint64_t* freeBytesAvail, uint64_t* totalNumberOfBytes, uint64_t* totalNumberOfFreeBytes, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(DriveInfo::GetDiskFreeSpaceInternal, "This icall is not supported by il2cpp.");

        return false;
    }

    Il2CppString* DriveInfo::GetDriveFormatInternal(Il2CppChar* rootPathName, int32_t rootPathName_length)
    {
        NOT_SUPPORTED_IL2CPP(DriveInfo::GetDriveFormat, "This icall is not supported by il2cpp.");
        return NULL;
    }

    uint32_t DriveInfo::GetDriveTypeInternal(Il2CppChar* rootPathName, int32_t rootPathName_length)
    {
        NOT_SUPPORTED_IL2CPP(DriveInfo::GetDriveTypeInternal, "This icall is not supported by il2cpp.");

        return 0;
    }
} /* namespace IO */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\DriveInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\MonoIO.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "icalls/mscorlib/System.IO/MonoIO.h"
#include "os/Directory.h"
#include "os/ErrorCodes.h"
#include "os/File.h"
#include "utils/PathUtils.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Path.h"
#include "vm/Profiler.h"
#include "vm/String.h"
#include "vm/Exception.h"
#include "utils/dynamic_array.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace IO
{
    bool MonoIO::Cancel_internal(intptr_t handle, int32_t* error)
    {
        return il2cpp::os::File::Cancel((il2cpp::os::FileHandle*)handle);
    }

    bool MonoIO::Close(intptr_t handle, int32_t* error)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;

        return il2cpp::os::File::Close(fileHandle, error);
    }

    bool MonoIO::CopyFile(Il2CppChar* path, Il2CppChar* dest, bool overwrite, int32_t* error)
    {
        const std::string srcString(il2cpp::utils::StringUtils::Utf16ToUtf8(path));
        const std::string destString(il2cpp::utils::StringUtils::Utf16ToUtf8(dest));

        return il2cpp::os::File::CopyFile(srcString, destString, overwrite, error);
    }

    bool MonoIO::CreateDirectory(Il2CppChar* path, int32_t* error)
    {
        return il2cpp::os::Directory::Create(il2cpp::utils::StringUtils::Utf16ToUtf8(path), error);
    }

    bool MonoIO::CreatePipe(intptr_t* read_handle, intptr_t* write_handle, int32_t* error)
    {
        il2cpp::os::FileHandle** input = (il2cpp::os::FileHandle**)read_handle;
        il2cpp::os::FileHandle** output = (il2cpp::os::FileHandle**)write_handle;

        auto result = il2cpp::os::File::CreatePipe(input, output, error);
        vm::Exception::RaiseIfError(result.GetError());
        return result.Get();
    }

    bool MonoIO::DeleteFile(Il2CppChar* path, int32_t* error)
    {
        return il2cpp::os::File::DeleteFile(il2cpp::utils::StringUtils::Utf16ToUtf8(path), error);
    }

    bool MonoIO::DuplicateHandle(intptr_t source_process_handle, intptr_t source_handle, intptr_t target_process_handle, intptr_t* target_handle, int32_t access, int32_t inherit, int32_t options, int32_t* error)
    {
        il2cpp::os::FileHandle* spHandle = (il2cpp::os::FileHandle*)source_process_handle;
        il2cpp::os::FileHandle* sHandle = (il2cpp::os::FileHandle*)source_handle;
        il2cpp::os::FileHandle* tpHandle = (il2cpp::os::FileHandle*)target_process_handle;
        il2cpp::os::FileHandle** tHandle = (il2cpp::os::FileHandle**)target_handle;
        auto result = il2cpp::os::File::DuplicateHandle(spHandle, sHandle, tpHandle, tHandle, access, inherit, options, error);
        vm::Exception::RaiseIfError(result.GetError());
        return result.Get();
    }

    struct SMonoIOContext
    {
        utils::dynamic_array<os::Directory::FindHandle*> m_OpenFindHandles;
        baselib::ReentrantLock m_OpenFindHandlesMutex;
    };

    SMonoIOContext* s_MonoIOContext = nullptr;

    void MonoIO::AllocateStaticData()
    {
        s_MonoIOContext = new SMonoIOContext();
    }

    void MonoIO::FreeStaticData()
    {
        delete s_MonoIOContext;
        s_MonoIOContext = nullptr;
    }

    static int32_t CloseFindHandle(os::Directory::FindHandle* findHandle)
    {
        int32_t result = findHandle->CloseOSHandle();

        findHandle->~FindHandle();
        utils::Memory::Free(findHandle);

        return result;
    }

    bool MonoIO::FindCloseFile(intptr_t hnd)
    {
        auto possibleFindHandle = reinterpret_cast<os::Directory::FindHandle*>(hnd);

        // Manually managed the mutex here because we don't want to hold the lock during a call to
        // CloseOSFindHandleDirectly, as that call can be expensive.
        s_MonoIOContext->m_OpenFindHandlesMutex.Acquire();

        auto knownFindHandle = std::find(s_MonoIOContext->m_OpenFindHandles.begin(), s_MonoIOContext->m_OpenFindHandles.end(), possibleFindHandle);
        if (knownFindHandle == s_MonoIOContext->m_OpenFindHandles.end())
        {
            s_MonoIOContext->m_OpenFindHandlesMutex.Release();
            // We did not find the handle in the list of ones the VM allocated - assume it is
            // a directly allocated OS handle.
            return os::Directory::CloseOSFindHandleDirectly(hnd);
        }
        else
        {
            s_MonoIOContext->m_OpenFindHandles.erase(knownFindHandle);
            s_MonoIOContext->m_OpenFindHandlesMutex.Release();
            return CloseFindHandle(possibleFindHandle);
        }
    }

    bool MonoIO::FindNextFile(intptr_t hnd, Il2CppString** fileName, int32_t* fileAttr, int32_t* error)
    {
        Il2CppNativeString fileNameNative;
        os::Directory::FindHandle* findHandle = reinterpret_cast<os::Directory::FindHandle*>(hnd);

        while (fileNameNative.empty() || fileNameNative == IL2CPP_NATIVE_STRING(".") || fileNameNative == IL2CPP_NATIVE_STRING(".."))
        {
            os::ErrorCode findError = os::Directory::FindNextFile(findHandle, &fileNameNative, fileAttr);
            if (findError != os::kErrorCodeSuccess)
            {
                *error = findError;
                return false;
            }
        }

        DECLARE_NATIVE_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(fileNameNativeUtf16, fileNameNative);
        *fileName = vm::String::NewUtf16(fileNameNativeUtf16);
        gc::GarbageCollector::SetWriteBarrier((void**)fileName);
        return true;
    }

    bool MonoIO::Flush(intptr_t handle, int32_t* error)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::Flush(fileHandle, error);
    }

    bool MonoIO::GetFileStat(Il2CppChar* path, FileStat* stat, int32_t* error)
    {
        os::FileStat fileStat;

        const bool ret = il2cpp::os::File::GetFileStat(il2cpp::utils::StringUtils::Utf16ToUtf8(path), &fileStat, error);

        if (ret)
        {
            stat->attributes = fileStat.attributes;
            stat->length = fileStat.length;
            stat->creation_time = fileStat.creation_time;
            stat->last_access_time = fileStat.last_access_time;
            stat->last_write_time = fileStat.last_write_time;
        }

        return ret;
    }

    bool MonoIO::MoveFile(Il2CppChar* path, Il2CppChar* dest, int32_t* error)
    {
        const std::string srcString(il2cpp::utils::StringUtils::Utf16ToUtf8(path));
        const std::string destString(il2cpp::utils::StringUtils::Utf16ToUtf8(dest));

        return il2cpp::os::File::MoveFile(srcString, destString, error);
    }

    bool MonoIO::RemapPath(Il2CppString* path, Il2CppString** newPath)
    {
        *newPath = NULL;
        return false;
    }

    bool MonoIO::RemoveDirectory(Il2CppChar* path, int32_t* error)
    {
        return il2cpp::os::Directory::Remove(il2cpp::utils::StringUtils::Utf16ToUtf8(path), error);
    }

    bool MonoIO::ReplaceFile(Il2CppChar* sourceFileName, Il2CppChar* destinationFileName, Il2CppChar* destinationBackupFileName, bool ignoreMetadataErrors, int32_t* error)
    {
        const std::string srcString(il2cpp::utils::StringUtils::Utf16ToUtf8(sourceFileName));
        const std::string destString(il2cpp::utils::StringUtils::Utf16ToUtf8(destinationFileName));
        const std::string destBackupString(destinationBackupFileName ? il2cpp::utils::StringUtils::Utf16ToUtf8(destinationBackupFileName) : "");

        return il2cpp::os::File::ReplaceFile(srcString, destString, destBackupString, ignoreMetadataErrors, error);
    }

    bool MonoIO::SetCurrentDirectory(Il2CppChar* path, int32_t* error)
    {
        return il2cpp::os::Directory::SetCurrent(il2cpp::utils::StringUtils::Utf16ToUtf8(path), error);
    }

    bool MonoIO::SetFileAttributes(Il2CppChar* path, int32_t attrs, int32_t* error)
    {
        return il2cpp::os::File::SetFileAttributes(il2cpp::utils::StringUtils::Utf16ToUtf8(path), (UnityPalFileAttributes)attrs, error);
    }

    bool MonoIO::SetFileTime(intptr_t handle, int64_t creation_time, int64_t last_access_time, int64_t last_write_time, int32_t* error)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::SetFileTime(fileHandle, creation_time, last_access_time, last_write_time, error);
    }

    bool MonoIO::SetLength(intptr_t handle, int64_t length, int32_t* error)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::SetLength(fileHandle, length, error);
    }

    Il2CppChar MonoIO::get_AltDirectorySeparatorChar()
    {
        return '/'; /* slash, same as DirectorySeparatorChar */
    }

    Il2CppChar MonoIO::get_DirectorySeparatorChar()
    {
        return IL2CPP_DIR_SEPARATOR;
    }

    Il2CppChar MonoIO::get_PathSeparator()
    {
#if IL2CPP_TARGET_WINDOWS
        return ';'; /* semicolon */
#else
        return ':'; /* colon */
#endif
    }

    Il2CppChar MonoIO::get_VolumeSeparatorChar()
    {
#if IL2CPP_TARGET_WINDOWS
        return ':'; /* colon */
#else
        return '/'; /* forward slash */
#endif
    }

    int32_t MonoIO::Read(intptr_t handle, Il2CppArray* dest, int32_t dest_offset, int32_t count, int32_t* error)
    {
        IL2CPP_ASSERT(dest != NULL);

        *error = 0; // ERROR_SUCCESS

        if (((uint32_t)dest_offset + count) > il2cpp::vm::Array::GetLength(dest))
            return 0;

        il2cpp::os::FileHandle* h = (il2cpp::os::FileHandle*)handle;

        char *buffer = il2cpp_array_addr(dest, char, dest_offset); \

        int bytesRead = il2cpp::os::File::Read(h, buffer, count, error);

#if IL2CPP_ENABLE_PROFILER
        if (vm::Profiler::ProfileFileIO())
            vm::Profiler::FileIO(IL2CPP_PROFILE_FILEIO_READ, bytesRead);
#endif
        if (*error != 0)
            return -1;
        return bytesRead;
    }

    int32_t MonoIO::Write(intptr_t handle, Il2CppArray* src, int32_t src_offset, int32_t count, int32_t* error)
    {
        IL2CPP_ASSERT(src != NULL);

        *error = 0; // ERROR_SUCCESS

        if ((uint32_t)(src_offset + count) > il2cpp::vm::Array::GetLength(src))
            return 0;

        il2cpp::os::FileHandle* h = (il2cpp::os::FileHandle*)handle;
        char *buffer = il2cpp_array_addr(src, char, src_offset);

        int bytesWritten = il2cpp::os::File::Write(h, buffer, count, error);

#if IL2CPP_ENABLE_PROFILER
        if (vm::Profiler::ProfileFileIO())
            vm::Profiler::FileIO(IL2CPP_PROFILE_FILEIO_WRITE, bytesWritten);
#endif

        return bytesWritten;
    }

    int64_t MonoIO::GetLength(intptr_t handle, int32_t* error)
    {
        il2cpp::os::FileHandle* h = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::GetLength(h, error);
    }

    int64_t MonoIO::Seek(intptr_t handle, int64_t offset, int32_t origin, int32_t* error)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::Seek(fileHandle, offset, origin, error);
    }

    intptr_t MonoIO::FindFirstFile(Il2CppChar* pathWithPattern, Il2CppString** fileName, int32_t* fileAttr, int32_t* error)
    {
        DECLARE_IL2CPP_CHAR_PTR_AS_STRING_VIEW_OF_NATIVE_CHARS(pathWithPatternNative, pathWithPattern);
        os::Directory::FindHandle* findHandle = new(utils::Memory::Malloc(sizeof(os::Directory::FindHandle))) os::Directory::FindHandle(pathWithPatternNative);

        Il2CppNativeString fileNameNative;
        os::ErrorCode findError = os::Directory::FindFirstFile(findHandle, pathWithPatternNative, &fileNameNative, fileAttr);
        if (findError != os::kErrorCodeSuccess)
        {
            *error = findError;

            CloseFindHandle(findHandle);
            return 0;
        }

        while (fileNameNative.empty() || fileNameNative == IL2CPP_NATIVE_STRING(".") || fileNameNative == IL2CPP_NATIVE_STRING(".."))
        {
            os::ErrorCode findError = os::Directory::FindNextFile(findHandle, &fileNameNative, fileAttr);
            if (findError != os::kErrorCodeSuccess)
            {
                *error = findError;

                CloseFindHandle(findHandle);
                return 0;
            }
        }

        DECLARE_NATIVE_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(fileNameNativeUtf16, fileNameNative);
        *fileName = vm::String::NewUtf16(fileNameNativeUtf16);
        gc::GarbageCollector::SetWriteBarrier((void**)fileName);

        // Keep track of the handles we allocated, so we can tell later if this is an OS handle
        // or one we allocated.
        os::FastAutoLock lock(&s_MonoIOContext->m_OpenFindHandlesMutex);
        s_MonoIOContext->m_OpenFindHandles.push_back(findHandle);

        return reinterpret_cast<intptr_t>(findHandle);
    }

    intptr_t MonoIO::get_ConsoleError()
    {
        intptr_t ret;
        ret = (intptr_t)il2cpp::os::File::GetStdError();
        return ret;
    }

    intptr_t MonoIO::get_ConsoleInput()
    {
        intptr_t ret;
        ret = (intptr_t)il2cpp::os::File::GetStdInput();
        return ret;
    }

    intptr_t MonoIO::get_ConsoleOutput()
    {
        intptr_t ret;
        ret = (intptr_t)il2cpp::os::File::GetStdOutput();
        return ret;
    }

    intptr_t MonoIO::Open(Il2CppChar* filename, int32_t mode, int32_t access, int32_t share, int32_t options, int32_t* error)
    {
        intptr_t ret;
        ret = (intptr_t)il2cpp::os::File::Open(il2cpp::utils::StringUtils::Utf16ToUtf8(filename), mode, access, share, options, error);
        return ret;
    }

    int32_t MonoIO::GetFileAttributes(Il2CppChar* path, int32_t* error)
    {
        return il2cpp::os::File::GetFileAttributes(il2cpp::utils::StringUtils::Utf16ToUtf8(path), error);
    }

    int32_t MonoIO::GetFileType(intptr_t handle, int32_t* error)
    {
        il2cpp::os::FileHandle* h = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::GetFileType(h);
    }

    Il2CppString* MonoIO::GetCurrentDirectory(int32_t* error)
    {
        return vm::String::New(il2cpp::os::Directory::GetCurrent(error).c_str());
    }

    void MonoIO::DumpHandles()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(MonoIO::DumpHandles);
        IL2CPP_UNREACHABLE;
    }

    void MonoIO::Lock(intptr_t handle, int64_t position, int64_t length, int32_t* error)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::Lock(fileHandle, position, length, error);
    }

    void MonoIO::Unlock(intptr_t handle, int64_t position, int64_t length, int32_t* error)
    {
        il2cpp::os::FileHandle* fileHandle = (il2cpp::os::FileHandle*)handle;
        return il2cpp::os::File::Unlock(fileHandle, position, length, error);
    }
} /* namespace IO */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\MonoIO.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\Path.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System.IO/Path.h"
#include "vm/Path.h"
#include "vm/String.h"


namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace IO
{
    Il2CppString* Path::get_temp_path()
    {
        return il2cpp::vm::String::New(il2cpp::vm::Path::GetTempPath().c_str());
    }
} /* namespace IO */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.IO\Path.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\Assembly.cpp---------------
.
.
#include "il2cpp-config.h"
#include <stddef.h>
#include <vector>
#include <algorithm>
#include "icalls/mscorlib/System.Reflection/Assembly.h"
#include "icalls/mscorlib/System.Reflection/RuntimeModule.h"
#include "utils/StringUtils.h"
#include "utils/PathUtils.h"
#include "os/File.h"
#include "os/Mutex.h"
#include "os/Path.h"
#include "utils/Memory.h"
#include "utils/MemoryMappedFile.h"
#include "utils/Runtime.h"
#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/AssemblyName.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Image.h"
#include "vm/MetadataCache.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "il2cpp-class-internals.h"
#include "mono-structs.h"
#include <limits>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
#define CHECK_IF_NULL(v)    \
    if ( (v) == NULL && throwOnError ) \
        vm::Exception::Raise (vm::Exception::GetTypeLoadException (info)); \
    if ( (v) == NULL ) \
        return NULL;

    intptr_t Assembly::InternalGetReferencedAssemblies(Il2CppReflectionAssembly* module)
    {
        VoidPtrArray assemblyPointers;
        vm::AssemblyNameVector referencedAssemblies;
        vm::Assembly::GetReferencedAssemblies(module->assembly, &referencedAssemblies);
        for (vm::AssemblyNameVector::const_iterator aname = referencedAssemblies.begin(); aname != referencedAssemblies.end(); ++aname)
        {
            Il2CppMonoAssemblyName* monoAssemblyName = (Il2CppMonoAssemblyName*)IL2CPP_MALLOC_ZERO(sizeof(Il2CppMonoAssemblyName));
            il2cpp::vm::AssemblyName::FillNativeAssemblyName(*(*aname), monoAssemblyName);
            assemblyPointers.push_back(monoAssemblyName);
        }

        return reinterpret_cast<intptr_t>(void_ptr_array_to_gptr_array(assemblyPointers));
    }

    Il2CppReflectionAssembly* Assembly::GetCallingAssembly()
    {
        return vm::Reflection::GetAssemblyObject(vm::Image::GetCallingImage()->assembly);
    }

    Il2CppObject* Assembly::GetEntryAssembly()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(Assembly::GetEntryAssembly, "In the case of Unity this is always NULL. For a normal exe this is the assembly with Main.");
        return NULL;
    }

    Il2CppReflectionAssembly* Assembly::GetExecutingAssembly()
    {
        return vm::Reflection::GetAssemblyObject(vm::Image::GetExecutingImage()->assembly);
    }

    Il2CppReflectionAssembly* Assembly::load_with_partial_name(Il2CppString* name, Il2CppObject* e)
    {
        const Il2CppAssembly* assembly = vm::Assembly::GetLoadedAssembly(il2cpp::utils::StringUtils::Utf16ToUtf8(name->chars).c_str());
        if (assembly != NULL)
            return vm::Reflection::GetAssemblyObject(assembly);

        return NULL;
    }

    Il2CppReflectionAssembly* Assembly::LoadFile_internal(Il2CppString* assemblyFile, int32_t* stackMark)
    {
        return LoadFrom(assemblyFile, false, stackMark);
    }

    Il2CppReflectionAssembly* Assembly::LoadFrom(Il2CppString* assemblyFile, bool refOnly, int32_t* stackMark)
    {
        IL2CPP_ASSERT(!refOnly && "This icall is not supported by il2cpp when refOnly=true");

        // Our implementation is going to behave a bit different.  We can't actually load any assembly.  If we didn't know about the assembly at conversion time,
        // then we won't be able to do anything.
        // On the other hand, if the name of the assembly matches the name of an assembly that we converted, then lets return the assembly that we know about.
        std::string utf8Path = utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(assemblyFile));
        std::string fileName = utils::PathUtils::BasenameNoExtension(utf8Path);

        const Il2CppAssembly* foundAssembly = vm::MetadataCache::GetAssemblyByName(fileName.c_str());

        if (!foundAssembly)
        {
            vm::Exception::Raise(vm::Exception::GetFileLoadException(fileName.c_str()));
            IL2CPP_UNREACHABLE;
        }

        return vm::Reflection::GetAssemblyObject(foundAssembly);
    }

#define CHECK_IF_NULL(v)    \
    if ( (v) == NULL && throwOnError ) \
        vm::Exception::Raise (vm::Exception::GetTypeLoadException (info)); \
    if ( (v) == NULL ) \
        return NULL;

    Il2CppReflectionType* Assembly::InternalGetType(Il2CppReflectionAssembly* assembly, Il2CppObject* module, Il2CppString* name, bool throwOnError, bool ignoreCase)
    {
        std::string str = utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(name));

        il2cpp::vm::TypeNameParseInfo info;
        il2cpp::vm::TypeNameParser parser(str, info, false);

        if (!parser.Parse())
        {
            if (throwOnError)
                vm::Exception::Raise(vm::Exception::GetTypeLoadException());
            else
                return NULL;
        }

        CHECK_IF_NULL(assembly);

        Il2CppImage *image = (Il2CppImage*)vm::Assembly::GetImage(assembly->assembly);

        CHECK_IF_NULL(image);

        Il2CppClass *klass = vm::Image::FromTypeNameParseInfo(image, info, ignoreCase);

        CHECK_IF_NULL(klass);

        il2cpp::vm::Class::Init(klass);

        const Il2CppType *type = vm::Class::GetType(klass, info);

        CHECK_IF_NULL(type);

        return il2cpp::vm::Reflection::GetTypeObject(type);
    }

    Il2CppArray* Assembly::GetTypes(Il2CppReflectionAssembly* thisPtr, bool exportedOnly)
    {
        const Il2CppImage* image = thisPtr->assembly->image;
        return il2cpp::vm::Image::GetTypes(image, exportedOnly);
    }

    void Assembly::InternalGetAssemblyName(Il2CppString* assemblyFile, void* aname, Il2CppString** codebase)
    {
        NOT_SUPPORTED_IL2CPP(Assembly::InternalGetAssemblyName, "This icall is not supported by il2cpp.");
    }
} /* namespace Reflection */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\Assembly.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\AssemblyName.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "mono-structs.h"

#include "icalls/mscorlib/System.Reflection/AssemblyName.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "vm/Reflection.h"
#include "vm/AssemblyName.h"
#include "utils/StringUtils.h"
#include "vm-utils/VmStringUtils.h"

#include "utils/sha1.h"

using il2cpp::vm::Array;
using il2cpp::vm::Class;
using il2cpp::vm::Object;
using il2cpp::vm::Runtime;
using il2cpp::vm::String;

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    void AssemblyName::get_public_token(uint8_t* token, uint8_t* pubkey, int32_t len)
    {
        uint8_t digest[20];

        IL2CPP_ASSERT(token != NULL);
        sha1_get_digest(pubkey, len, digest);
        for (int i = 0; i < 8; ++i)
            token[i] = digest[19 - i];
    }

    Il2CppMonoAssemblyName* AssemblyName::GetNativeName(intptr_t assembly_ptr)
    {
        Il2CppAssembly *assembly = (Il2CppAssembly*)assembly_ptr;

        Il2CppMonoAssemblyName *aname = (Il2CppMonoAssemblyName*)il2cpp::vm::Reflection::GetMonoAssemblyName(assembly);
        if (aname)
        {
            return aname;
        }
        else
        {
            aname = (Il2CppMonoAssemblyName*)IL2CPP_MALLOC_ZERO(sizeof(Il2CppMonoAssemblyName));
            il2cpp::vm::AssemblyName::FillNativeAssemblyName(assembly->aname, aname);

            il2cpp::vm::Reflection::SetMonoAssemblyName(assembly, aname);
            return aname;
        }
    }

    bool AssemblyName::ParseAssemblyName(intptr_t namePtr, Il2CppMonoAssemblyName* aname, bool* is_version_defined, bool* is_token_defined)
    {
        std::string name((char*)namePtr);

        il2cpp::vm::TypeNameParseInfo info;
        il2cpp::vm::TypeNameParser parser(name, info, false);

        if (!parser.ParseAssembly())
            return false;

        if (is_version_defined)
        {
            *is_version_defined = false;
            size_t index = name.find("Version");
            if (index != std::string::npos)
                *is_version_defined = true;
        }

        if (is_token_defined)
        {
            *is_token_defined = false;
            size_t index = name.find("PublicKeyToken");
            if (index != std::string::npos)
                *is_token_defined = true;
        }

        const il2cpp::vm::TypeNameParseInfo::AssemblyName& parsedName = info.assembly_name();

        aname->name = il2cpp::utils::StringUtils::StringDuplicate(parsedName.name.c_str());
        if (utils::VmStringUtils::CaseInsensitiveEquals(parsedName.culture.c_str(), "neutral")) // culture names are case insensitive
            aname->culture = 0;
        else
            aname->culture = il2cpp::utils::StringUtils::StringDuplicate(parsedName.culture.c_str());

        aname->public_key = reinterpret_cast<uint8_t*>(il2cpp::utils::StringUtils::StringDuplicate(parsedName.public_key.c_str()));

        for (int i = 0; i < il2cpp::vm::kPublicKeyTokenLength; ++i)
            aname->public_key_token.padding[i] = parsedName.public_key_token[i];

        aname->hash_alg = parsedName.hash_alg;
        aname->hash_len = parsedName.hash_len;
        aname->flags = parsedName.flags;
        aname->major = parsedName.major;
        aname->minor = parsedName.minor;
        aname->build = parsedName.build;
        aname->revision = parsedName.revision;

        return true;
    }
} /* namespace Reflection */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\AssemblyName.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\CustomAttributeData.cpp---------------
.
.
#include "il2cpp-config.h"
#include "CustomAttributeData.h"
#include "gc/GarbageCollector.h"
#include "metadata/CustomAttributeDataReader.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/Exception.h"
#include "vm/MetadataCache.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    static void SetCustomAttributeTypeArgument(const MethodInfo* ctor, void* argBuffer, const il2cpp::metadata::CustomAttributeArgument* inArg)
    {
        void* params[] = {
            il2cpp::vm::Reflection::GetTypeObject(&inArg->klass->byval_arg),
            il2cpp::vm::Class::IsValuetype(inArg->klass) ? vm::Object::Box(inArg->klass, (void*)&inArg->data) : reinterpret_cast<Il2CppObject*>(inArg->data.obj)
        };
        il2cpp::vm::Runtime::Invoke(ctor, argBuffer, params, NULL);
    }

    class Visitor : public il2cpp::metadata::CustomAttributeReaderVisitor
    {
        static const MethodInfo* customAttributeTypedArgumentConstructor;
        static const MethodInfo* customAttributeNamedArgumentConstructor;

        Il2CppClass* attrClass;
        Il2CppArray** ctorArgs;
        Il2CppArray** namedArgs;
        uint32_t fieldCount;

    public:

        Visitor(Il2CppClass* attrClass, Il2CppArray** ctorArgs, Il2CppArray** namedArgs) : attrClass(attrClass), ctorArgs(ctorArgs), namedArgs(namedArgs), fieldCount(0)
        {
            if (!customAttributeTypedArgumentConstructor)
            {
                const Il2CppType* typedArgumentCtorArgTypes[] = { &il2cpp_defaults.systemtype_class->byval_arg, &il2cpp_defaults.object_class->byval_arg };
                customAttributeTypedArgumentConstructor = vm::Class::GetMethodFromNameFlagsAndSig(il2cpp_defaults.customattribute_typed_argument_class, ".ctor", 2, 0, typedArgumentCtorArgTypes);

                const Il2CppType* namedArgumentCtorArgTypes[] = { &il2cpp_defaults.member_info_class->byval_arg, &il2cpp_defaults.customattribute_typed_argument_class->byval_arg };
                customAttributeNamedArgumentConstructor = vm::Class::GetMethodFromNameFlagsAndSig(il2cpp_defaults.customattribute_named_argument_class, ".ctor", 2, 0, namedArgumentCtorArgTypes);

                if (customAttributeTypedArgumentConstructor == NULL || customAttributeNamedArgumentConstructor == NULL)
                {
                    customAttributeTypedArgumentConstructor = NULL;
                    IL2CPP_NOT_IMPLEMENTED_ICALL(MonoCustomAttrs::GetCustomAttributesDataInternal);
                }

                IL2CPP_ASSERT(il2cpp::vm::Class::IsValuetype(il2cpp_defaults.customattribute_typed_argument_class));
                IL2CPP_ASSERT(il2cpp::vm::Class::IsValuetype(il2cpp_defaults.customattribute_named_argument_class));
            }
        }

        virtual void VisitArgumentSizes(uint32_t argumentCount, uint32_t fieldCount, uint32_t propertyCount)
        {
            *ctorArgs = il2cpp::vm::Array::New(il2cpp_defaults.object_class, argumentCount);
            il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)ctorArgs);

            *namedArgs = il2cpp::vm::Array::New(il2cpp_defaults.customattribute_named_argument_class, fieldCount + propertyCount);
            il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)namedArgs);

            this->fieldCount = fieldCount;
        }

        virtual void VisitArgument(const il2cpp::metadata::CustomAttributeArgument& argument, uint32_t index)
        {
            int32_t typedArgSize = il2cpp::vm::Class::GetInstanceSize(il2cpp_defaults.customattribute_typed_argument_class) - sizeof(Il2CppObject);
            void* typedArgBuffer = alloca(typedArgSize);
            memset(typedArgBuffer, 0, typedArgSize);
            SetCustomAttributeTypeArgument(customAttributeTypedArgumentConstructor, typedArgBuffer, &argument);
            il2cpp_array_setref(*ctorArgs, index, il2cpp::vm::Object::Box(il2cpp_defaults.customattribute_typed_argument_class, typedArgBuffer));
        }

        void CreateNamedArgument(const il2cpp::metadata::CustomAttributeArgument arg, void* metadataObject, uint32_t index)
        {
            int32_t typedArgSize = il2cpp::vm::Class::GetInstanceSize(il2cpp_defaults.customattribute_typed_argument_class) - sizeof(Il2CppObject);
            int32_t namedArgSize = il2cpp::vm::Class::GetInstanceSize(il2cpp_defaults.customattribute_named_argument_class) - sizeof(Il2CppObject);
            void* namedArgBuffer = alloca(namedArgSize);
            void* typedArgBuffer = alloca(typedArgSize);

            SetCustomAttributeTypeArgument(customAttributeTypedArgumentConstructor, typedArgBuffer, &arg);
            void* params[] = {
                metadataObject,
                typedArgBuffer
            };

            il2cpp::vm::Runtime::Invoke(customAttributeNamedArgumentConstructor, namedArgBuffer, params, NULL);
            il2cpp_array_setref(*namedArgs, index, il2cpp::vm::Object::Box(il2cpp_defaults.customattribute_named_argument_class, namedArgBuffer));
        }

        virtual void VisitField(const il2cpp::metadata::CustomAttributeFieldArgument& field, uint32_t index)
        {
            CreateNamedArgument(field.arg, vm::Reflection::GetFieldObject(attrClass, const_cast<FieldInfo*>(field.field)), index);
        }

        virtual void VisitProperty(const il2cpp::metadata::CustomAttributePropertyArgument& prop, uint32_t index)
        {
            CreateNamedArgument(prop.arg, vm::Reflection::GetPropertyObject(attrClass, const_cast<PropertyInfo*>(prop.prop)), index + fieldCount);
        }
    };

    const MethodInfo* Visitor::customAttributeTypedArgumentConstructor;
    const MethodInfo* Visitor::customAttributeNamedArgumentConstructor;

    void CustomAttributeData::ResolveArgumentsInternal(Il2CppObject* ctor, Il2CppObject* assembly, intptr_t data, uint32_t data_length, Il2CppArray** ctorArgs, Il2CppArray** namedArgs)
    {
        const MethodInfo* ctorMethod = ((Il2CppReflectionMethod*)ctor)->method;
        const Il2CppImage* image = ((Il2CppReflectionAssembly*)assembly)->assembly->image;

        Visitor visitor(ctor->klass, ctorArgs, namedArgs);
        Il2CppException* exc;
        il2cpp::metadata::CustomAttributeDataReader::VisitCustomAttributeData(image, ctorMethod, (const void*)data, data_length, &visitor, &exc);

        if (exc != NULL)
            vm::Exception::Raise(exc);
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\CustomAttributeData.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\EventInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-api.h"
#include "EventInfo.h"
#include "vm/Class.h"
#include "vm/Reflection.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    Il2CppReflectionEvent* EventInfo::internal_from_handle_type(intptr_t handlePtr, intptr_t typePtr)
    {
        Il2CppClass *klass;

        IL2CPP_ASSERT(handlePtr);
        ::EventInfo *handle = (::EventInfo*)handlePtr;
        Il2CppType *type = (Il2CppType*)typePtr;

        if (!type)
        {
            klass = handle->parent;
        }
        else
        {
            klass = il2cpp_class_from_il2cpp_type(type);

            bool found = klass == handle->parent || il2cpp::vm::Class::HasParent(klass, handle->parent);
            if (!found)
                /* Managed code will throw an exception */
                return NULL;
        }

        Il2CppReflectionEvent *result = il2cpp::vm::Reflection::GetEventObject(klass, handle);
        return result;
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\EventInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\FieldInfo.cpp---------------
.
.
#include "il2cpp-config.h"

#include <stddef.h>

#include "icalls/mscorlib/System.Reflection/FieldInfo.h"

#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Reflection.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    Il2CppReflectionField* FieldInfo::internal_from_handle_type(intptr_t field_handle, intptr_t type_handle)
    {
        ::FieldInfo* fieldInfo = (::FieldInfo*)field_handle;
        Il2CppType* il2cppType = (Il2CppType*)type_handle;

        if (il2cppType == NULL)
            return vm::Reflection::GetFieldObject(fieldInfo->parent, fieldInfo);

        Il2CppClass* originalClass = vm::Class::FromIl2CppType(il2cppType);

        for (Il2CppClass* k = originalClass; k; k = k->parent)
        {
            if (k == fieldInfo->parent)
                return vm::Reflection::GetFieldObject(originalClass, fieldInfo);
        }

        return NULL;
    }

    Il2CppObject* FieldInfo::get_marshal_info(Il2CppObject* thisPtr)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(FieldInfo::get_marshal_info, "We currently don't store marshal information in metadata");
        return NULL;
    }
} /* namespace Reflection */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\FieldInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\MethodBase.cpp---------------
.
.
#include "il2cpp-config.h"
#include <stddef.h>
#include "icalls/mscorlib/System.Reflection/MethodBase.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-api.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/GenericClass.h"
#include "vm/Reflection.h"
#include "vm/StackTrace.h"
#include "vm/MetadataCache.h"
#include "metadata/GenericMetadata.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    Il2CppReflectionMethod* MethodBase::GetCurrentMethod()
    {
        NOT_SUPPORTED_IL2CPP(MethodBase::GetCurrentMethod, "This icall is not supported by il2cpp. Use the il2cpp_codegen_get_method_object intrinsic instead.");

        return NULL;
    }
} /* namespace Reflection */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\MethodBase.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\Module.cpp---------------
.
.
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\Module.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\MonoMethod.cpp---------------
.
.
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\MonoMethod.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\MonoMethodInfo.cpp---------------
.
.
#include <stddef.h>
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "icalls/mscorlib/System.Reflection/MonoMethodInfo.h"
#include "gc/WriteBarrier.h"
#include "vm/Class.h"
#include "vm/Reflection.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    void MonoMethodInfo::get_method_info(intptr_t methodPtr, Il2CppMethodInfo *info)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(MonoMethodInfo::get_method_info, "Audit and look over commented code. Work in progress.");

        MethodInfo* method = (MethodInfo*)methodPtr;
        //MonoMethodSignature* sig;

        //sig = mono_method_signature (method);
        //if (!sig) {
        //  IL2CPP_ASSERT(mono_loader_get_last_error ());
        //  mono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));
        //}

        IL2CPP_STRUCT_SETREF(info, parent, il2cpp::vm::Reflection::GetTypeObject(&method->klass->byval_arg));
        if (method->return_type)
            IL2CPP_STRUCT_SETREF(info, ret, il2cpp::vm::Reflection::GetTypeObject(method->return_type));
        info->attrs = method->flags;
        info->implattrs = method->iflags;
        //if (sig->call_convention == MONO_CALL_DEFAULT)
        //  info->callconv = sig->sentinelpos >= 0 ? 2 : 1;
        //else {
        //  if (sig->call_convention == MONO_CALL_VARARG || sig->sentinelpos >= 0)
        //      info->callconv = 2;
        //  else
        //      info->callconv = 1;
        //}
        //info->callconv |= (sig->hasthis << 5) | (sig->explicit_this << 6);
    }

    Il2CppArray * MonoMethodInfo::get_parameter_info(intptr_t methodPtr, Il2CppReflectionMethod *member)
    {
        MethodInfo* method = (MethodInfo*)methodPtr;
        return il2cpp::vm::Reflection::GetParamObjects(method, member->reftype ? vm::Class::FromIl2CppType(member->reftype->type) : NULL);
    }

    void* /* System.Reflection.Emit.UnmanagedMarshal */ MonoMethodInfo::get_retval_marshal(intptr_t handle)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(MonoMethodInfo::get_retval_marshal, "This icall is not supported by il2cpp.");

        return NULL;
    }

    int32_t MonoMethodInfo::get_method_attributes(intptr_t methodPtr)
    {
        MethodInfo* method = (MethodInfo*)methodPtr;
        return method->flags;
    }
} /* namespace Reflection */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\MonoMethodInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\ParameterInfo.cpp---------------
.
.
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\ParameterInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeAssembly.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeAssembly.h"
#include "os/File.h"
#include "os/Mutex.h"
#include "os/Path.h"
#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/AssemblyName.h"
#include "vm/Exception.h"
#include "vm/Image.h"
#include "vm/Reflection.h"
#include "vm/String.h"
#include "utils/MemoryMappedFile.h"
#include "utils/PathUtils.h"
#include "utils/Runtime.h"
#include "utils/StringUtils.h"

#include <vector>
#include <algorithm>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    static os::Mutex* s_ResourceDataMutex = nullptr;

    void RuntimeAssembly::AllocateStaticData()
    {
        s_ResourceDataMutex = new os::Mutex();
    }

    void RuntimeAssembly::FreeStaticData()
    {
        delete s_ResourceDataMutex;
        s_ResourceDataMutex = nullptr;
    }

    bool RuntimeAssembly::get_global_assembly_cache(Il2CppObject* thisPtr)
    {
        return false;
    }

    bool RuntimeAssembly::get_ReflectionOnly(Il2CppObject* thisPtr)
    {
        // It doesn't mean anything to have a reflection only assembly in il2cpp since we can't load a managed assembly that we didn't convert.  So let's always return false.
        return false;
    }

    bool RuntimeAssembly::GetAotIdInternal(Il2CppArray* aotid)
    {
        return false;
    }

    static void* LoadResourceFile(Il2CppReflectionAssembly* assembly)
    {
        std::string resourcesDirectory = utils::PathUtils::Combine(utils::Runtime::GetDataDir(), utils::StringView<char>("Resources"));

        std::string resourceFileName(assembly->assembly->image->name);
        resourceFileName += "-resources.dat";

        std::string resourceFilePath = utils::PathUtils::Combine(resourcesDirectory, resourceFileName);

        int error = 0;
        os::FileHandle* handle = os::File::Open(resourceFilePath, kFileModeOpen, kFileAccessRead, kFileShareRead, kFileOptionsNone, &error);
        if (error != 0)
            return NULL;

        void* fileBuffer = utils::MemoryMappedFile::Map(handle);

        os::File::Close(handle, &error);
        if (error != 0)
        {
            utils::MemoryMappedFile::Unmap(fileBuffer);
            fileBuffer = NULL;
            return NULL;
        }

        return fileBuffer;
    }

    static void* LoadResourceData(Il2CppReflectionAssembly* assembly, vm::EmbeddedResourceRecord record)
    {
        os::AutoLock lock(s_ResourceDataMutex);

        void* resourceData = vm::Image::GetCachedResourceData(record.image, record.name);
        if (resourceData != NULL)
            return resourceData;

        void* fileBuffer = vm::Image::GetCachedMemoryMappedResourceFile(assembly);
        if (fileBuffer == NULL)
        {
            fileBuffer = LoadResourceFile(assembly);
            if (fileBuffer == NULL)
                return NULL;

            vm::Image::CacheMemoryMappedResourceFile(assembly, fileBuffer);
        }

        resourceData = (uint8_t*)fileBuffer + record.offset;

        vm::Image::CacheResourceData(record, resourceData);

        return resourceData;
    }

    static int ReadFromBuffer(uint8_t* buffer, int offset, int size, void* output)
    {
        memcpy(output, buffer + offset, size);

        return size;
    }

    static std::vector<vm::EmbeddedResourceRecord> GetResourceRecords(Il2CppReflectionAssembly* assembly)
    {
        std::vector<vm::EmbeddedResourceRecord> resourceRecords;

        void* fileBuffer = vm::Image::GetCachedMemoryMappedResourceFile(assembly);
        if (fileBuffer == NULL)
        {
            fileBuffer = LoadResourceFile(assembly);
            if (fileBuffer == NULL)
                return resourceRecords;

            vm::Image::CacheMemoryMappedResourceFile(assembly, fileBuffer);
        }

        int32_t resourceRecordsSize = 0;
        uint32_t bytesRead = ReadFromBuffer((uint8_t*)fileBuffer, 0, sizeof(int32_t), &resourceRecordsSize);

        int32_t currentResourceDataOffset = bytesRead + resourceRecordsSize;

        int32_t numberOfResources = 0;
        bytesRead += ReadFromBuffer((uint8_t*)fileBuffer, bytesRead, sizeof(int32_t), &numberOfResources);
        for (int resourceIndex = 0; resourceIndex < numberOfResources; ++resourceIndex)
        {
            uint32_t resourceDataSize = 0;
            bytesRead += ReadFromBuffer((uint8_t*)fileBuffer, bytesRead, sizeof(int32_t), &resourceDataSize);

            int32_t resourceNameSize = 0;
            bytesRead += ReadFromBuffer((uint8_t*)fileBuffer, bytesRead, sizeof(int32_t), &resourceNameSize);

            std::vector<char> resourceName(resourceNameSize);
            bytesRead += ReadFromBuffer((uint8_t*)fileBuffer, bytesRead, resourceNameSize, &resourceName[0]);

            resourceRecords.push_back(vm::EmbeddedResourceRecord(assembly->assembly->image, std::string(resourceName.begin(), resourceName.end()), currentResourceDataOffset, resourceDataSize));

            currentResourceDataOffset += resourceDataSize;
        }

        return resourceRecords;
    }

    class ResourceNameMatcher
    {
    public:
        ResourceNameMatcher(const std::string& resourceNameToFind) : needle(resourceNameToFind)
        {}

        bool operator()(const vm::EmbeddedResourceRecord& data) const
        {
            return data.name == needle;
        }

    private:
        std::string needle;
    };

    bool RuntimeAssembly::GetManifestResourceInfoInternal(Il2CppReflectionAssembly* assembly, Il2CppString* name, Il2CppManifestResourceInfo* info)
    {
        std::vector<vm::EmbeddedResourceRecord> resourceRecords = GetResourceRecords(assembly);
        if (std::find_if(resourceRecords.begin(), resourceRecords.end(), ResourceNameMatcher(utils::StringUtils::Utf16ToUtf8(name->chars))) != resourceRecords.end())
        {
            info->location = IL2CPP_RESOURCE_LOCATION_EMBEDDED | IL2CPP_RESOURCE_LOCATION_IN_MANIFEST;

            IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(Assembly::GetManifestResourceInfoInternal, "We have not yet implemented file or assembly resources.");

            return true;
        }

        return false;
    }

    intptr_t RuntimeAssembly::GetManifestResourceInternal(Il2CppReflectionAssembly* assembly, Il2CppString* name, int* size, Il2CppReflectionModule** module)
    {
        std::vector<vm::EmbeddedResourceRecord> resourceRecords = GetResourceRecords(assembly);
        std::vector<vm::EmbeddedResourceRecord>::iterator resource = std::find_if(resourceRecords.begin(), resourceRecords.end(), ResourceNameMatcher(utils::StringUtils::Utf16ToUtf8(name->chars)));
        if (resource != resourceRecords.end())
        {
            *module = vm::Reflection::GetModuleObject(assembly->assembly->image);
            *size = resource->size;
            intptr_t result;
            result = (intptr_t)LoadResourceData(assembly, *resource);
            return result;
        }

        return 0;
    }

    Il2CppObject* RuntimeAssembly::GetFilesInternal(Il2CppObject* thisPtr, Il2CppString* name, bool getResourceModules)
    {
        // Some code paths in mscorlib (e.g. Encoding.GetEncoding) will expect this icall to return NULL. If it
        // instead throws a NotSupportedException, the mscorlib code path changes, and we see some IL2CPP-specific bugs.
        return NULL;
    }

    Il2CppReflectionMethod* RuntimeAssembly::get_EntryPoint(Il2CppReflectionAssembly* self)
    {
        const MethodInfo* method = vm::Image::GetEntryPoint(self->assembly->image);
        if (method == NULL)
            return NULL;

        return il2cpp::vm::Reflection::GetMethodObject(method, NULL);
    }

    Il2CppObject* RuntimeAssembly::GetManifestModuleInternal(Il2CppObject* thisPtr)
    {
        NOT_SUPPORTED_IL2CPP(Assembly::GetManifestModuleInternal, "This icall is not supported by il2cpp.");

        return 0;
    }

    Il2CppArray* RuntimeAssembly::GetModulesInternal(Il2CppReflectionAssembly * thisPtr)
    {
        Il2CppArray* arr = vm::Array::New(il2cpp_defaults.module_class, 1);
        il2cpp_array_setref(arr, 0, vm::Reflection::GetModuleObject(vm::Assembly::GetImage(thisPtr->assembly)));
        return arr;
    }

    static std::string GetAssemblyPath(const Il2CppAssembly* assembly)
    {
        std::string executableDirectory = os::Path::GetApplicationFolder();
        std::replace(executableDirectory.begin(), executableDirectory.end(), '\\', '/');
        return utils::StringUtils::Printf("%s/%s.dll", executableDirectory.c_str(), assembly->aname.name);
    }

    Il2CppString* RuntimeAssembly::get_code_base(Il2CppReflectionAssembly* assembly, bool escaped)
    {
        return vm::String::New(utils::StringUtils::Printf("file://%s", GetAssemblyPath(assembly->assembly).c_str()).c_str());
    }

    Il2CppString* RuntimeAssembly::get_fullname(Il2CppReflectionAssembly* assembly)
    {
        return vm::String::New(vm::AssemblyName::AssemblyNameToString(assembly->assembly->aname).c_str());
    }

    Il2CppString* RuntimeAssembly::get_location(Il2CppReflectionAssembly* assembly)
    {
        return vm::String::New(GetAssemblyPath(assembly->assembly).c_str());
    }

    Il2CppString* RuntimeAssembly::InternalImageRuntimeVersion(Il2CppObject* a)
    {
        NOT_SUPPORTED_IL2CPP(Assembly::InternalImageRuntimeVersion, "This icall is not supported by il2cpp.");

        return 0;
    }

    Il2CppArray* RuntimeAssembly::GetManifestResourceNames(Il2CppReflectionAssembly* assembly)
    {
        std::vector<vm::EmbeddedResourceRecord> resourceRecords = GetResourceRecords(assembly);

        IL2CPP_ASSERT(resourceRecords.size() <= static_cast<size_t>(std::numeric_limits<il2cpp_array_size_t>::max()));
        Il2CppArray* resourceNameArray = vm::Array::New(il2cpp_defaults.string_class, static_cast<il2cpp_array_size_t>(resourceRecords.size()));
        for (size_t i = 0; i < resourceRecords.size(); ++i)
            il2cpp_array_setref(resourceNameArray, i, vm::String::New(resourceRecords[i].name.c_str()));

        return resourceNameArray;
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeAssembly.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeConstructorInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeConstructorInfo.h"
#include "vm/Reflection.h"
#include "RuntimeMethodInfo.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    int32_t RuntimeConstructorInfo::get_metadata_token(Il2CppObject* method)
    {
        return vm::Reflection::GetMetadataToken(method);
    }

    Il2CppObject* RuntimeConstructorInfo::InternalInvoke(Il2CppReflectionMethod* method, Il2CppObject* thisPtr, Il2CppArray* params, Il2CppException** exc)
    {
        return RuntimeMethodInfo::InternalInvoke(method, thisPtr, params, exc);
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeConstructorInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeEventInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeEventInfo.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Reflection.h"
#include "vm/String.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    int32_t RuntimeEventInfo::get_metadata_token(Il2CppObject* monoEvent)
    {
        return vm::Reflection::GetMetadataToken(monoEvent);
    }

    void RuntimeEventInfo::get_event_info(Il2CppReflectionMonoEvent* event, Il2CppReflectionMonoEventInfo* eventInfo)
    {
        eventInfo->declaringType = vm::Reflection::GetTypeObject(&event->eventInfo->parent->byval_arg);
        eventInfo->reflectedType = event->reflectedType;
        eventInfo->name = vm::String::New(event->eventInfo->name);

        Il2CppClass* reflectedTypeInfo = vm::Class::FromIl2CppType(event->reflectedType->type);
        eventInfo->addMethod = event->eventInfo->add != NULL ? vm::Reflection::GetMethodObject(event->eventInfo->add, reflectedTypeInfo) : NULL;
        eventInfo->removeMethod = event->eventInfo->remove != NULL ? vm::Reflection::GetMethodObject(event->eventInfo->remove, reflectedTypeInfo) : NULL;
        eventInfo->raiseMethod = event->eventInfo->raise != NULL ? vm::Reflection::GetMethodObject(event->eventInfo->raise, reflectedTypeInfo) : NULL;
        eventInfo->eventAttributes = event->eventInfo->eventType->attrs;
        eventInfo->otherMethods = vm::Array::NewCached(il2cpp_defaults.method_info_class, 0); // Empty for now
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeEventInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeFieldInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeFieldInfo.h"
#include <il2cpp-object-internals.h>
#include "gc/GarbageCollector.h"
#include "utils/StringUtils.h"
#include "vm/Object.h"
#include "vm/Class.h"
#include "vm/Field.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm-utils/BlobReader.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    int32_t RuntimeFieldInfo::get_metadata_token(Il2CppObject* monoField)
    {
        return vm::Reflection::GetMetadataToken(monoField);
    }

    int32_t RuntimeFieldInfo::GetFieldOffset(Il2CppReflectionField* field)
    {
        return field->field->offset - sizeof(Il2CppObject);
    }

    Il2CppObject* RuntimeFieldInfo::GetRawConstantValue(Il2CppReflectionField* field)
    {
        ::FieldInfo* fieldInfo = field->field;

        if (!(fieldInfo->type->attrs & FIELD_ATTRIBUTE_HAS_DEFAULT))
            vm::Exception::Raise(vm::Exception::GetInvalidOperationException(NULL));

        const Il2CppType* type = NULL;
        const char* data = vm::Class::GetFieldDefaultValue(fieldInfo, &type);

        switch (type->type)
        {
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_BOOLEAN:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_CHAR:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_R8:
            {
                Il2CppObject* obj = vm::Object::New(vm::Class::FromIl2CppType(type));
                utils::BlobReader::GetConstantValueFromBlob(fieldInfo->parent->image, type->type, data, vm::Object::Unbox(obj));
                return obj;
            }
            case IL2CPP_TYPE_SZARRAY:
            case IL2CPP_TYPE_STRING:
            case IL2CPP_TYPE_CLASS:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_GENERICINST:
            {
                Il2CppObject* obj = NULL;
                utils::BlobReader::GetConstantValueFromBlob(fieldInfo->parent->image, type->type, data, &obj);
                return obj;
            }
            default:
                vm::Exception::Raise(vm::Exception::GetInvalidOperationException(utils::StringUtils::Printf("Attempting to get raw constant value for field of type %d", type).c_str()));
        }

        return NULL;
    }

    Il2CppObject* RuntimeFieldInfo::GetValueInternal(Il2CppReflectionField* field, Il2CppObject* obj)
    {
        return vm::Field::GetValueObject(field->field, obj);
    }

    Il2CppObject* RuntimeFieldInfo::UnsafeGetValue(Il2CppReflectionField* field, Il2CppObject* obj)
    {
        return vm::Field::GetValueObject(field->field, obj);
    }

    Il2CppReflectionType* RuntimeFieldInfo::GetParentType(Il2CppReflectionField* field, bool declaring)
    {
        Il2CppClass *parent;

        parent = declaring ? field->field->parent : field->klass;

        return il2cpp::vm::Reflection::GetTypeObject(&parent->byval_arg);
    }

    Il2CppObject* RuntimeFieldInfo::ResolveType(Il2CppObject* thisPtr)
    {
        // This icall should not be called, since the runtime should always initialize the
        // type field of Il2CppReflectionField to a non-null value.
        IL2CPP_NOT_IMPLEMENTED_ICALL(RuntimeFieldInfo::ResolveType);
        IL2CPP_UNREACHABLE;
        return 0;
    }

    Il2CppArray* RuntimeFieldInfo::GetTypeModifiers(Il2CppObject* thisPtr, bool optional)
    {
        NOT_SUPPORTED_IL2CPP(RuntimeFieldInfo::GetTypeModifiers, "This icall is not supported by il2cpp.");
        return NULL;
    }

    void RuntimeFieldInfo::SetValueInternal(Il2CppReflectionField* field, Il2CppObject* obj, Il2CppObject* value)
    {
        ::FieldInfo* fieldInfo = field->field;
        Il2CppClass* fieldType = vm::Class::FromIl2CppType(fieldInfo->type);
        vm::Class::Init(fieldType);

        uint8_t* fieldAddress;

        if (fieldInfo->type->attrs & FIELD_ATTRIBUTE_STATIC)
        {
            if (fieldInfo->offset == THREAD_STATIC_FIELD_OFFSET)
            {
                IL2CPP_NOT_IMPLEMENTED(Field::StaticSetValue);
            }

            vm::Runtime::ClassInit(fieldInfo->parent);
            fieldAddress = static_cast<uint8_t*>(fieldInfo->parent->static_fields) + fieldInfo->offset;
        }
        else
        {
            IL2CPP_ASSERT(obj);
            fieldAddress = reinterpret_cast<uint8_t*>(obj) + fieldInfo->offset;
        }

        if (fieldType->byval_arg.valuetype)
        {
            if (!vm::Class::IsNullable(fieldType))
            {
                uint32_t fieldSize = vm::Class::GetInstanceSize(fieldType) - sizeof(Il2CppObject);

                if (value != NULL)
                {
                    memcpy(fieldAddress, vm::Object::Unbox(value), fieldSize);
                }
                else
                {
                    // Setting value type to null is defined to zero it out
                    memset(fieldAddress, 0, fieldSize);
                }
                il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)fieldAddress, fieldSize);
            }
            else
            {
                vm::Object::UnboxNullableWithWriteBarrier(value, fieldType, fieldAddress);
            }
        }
        else
        {
            memcpy(fieldAddress, &value, sizeof(Il2CppObject*));
            il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)fieldAddress);
        }
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeFieldInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeMethodInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeMethodInfo.h"
#include <stddef.h>
#include <string>
#include "gc/WriteBarrier.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "metadata/GenericMetadata.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/GenericContainer.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Reflection.h"
#include "vm/Type.h"
#include "vm/GenericClass.h"


namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    static Il2CppClass* il2cpp_class_get_generic_type_definition(Il2CppClass *klass)
    {
        return klass->generic_class ? il2cpp::vm::GenericClass::GetTypeDefinition(klass->generic_class) : klass;
    }

    bool RuntimeMethodInfo::get_IsGenericMethod(Il2CppReflectionMethod* method)
    {
        // if we are a generic method definition
        if (method->method->is_generic)
            return true;

        // is_inflated is true when a method is a generic instance or it's declaring type is a generic instance type.
        // Only return true here if we are a generic instance method
        if (method->method->is_inflated)
        {
            const Il2CppGenericContext* context = vm::MetadataCache::GetMethodGenericContext(method->method);
            return context != NULL && context->method_inst != NULL;
        }

        return false;
    }

    bool RuntimeMethodInfo::get_IsGenericMethodDefinition(Il2CppReflectionMethod* method)
    {
        return method->method->is_generic;
    }

    static std::string FormatExceptionMessageForNonConstructableGenericMethod(const MethodInfo* method, const Il2CppType** genericArguments, uint32_t genericArgumentsLength)
    {
        std::string message;
        message += "Failed to construct generic method '";
        message += vm::Type::GetName(&method->klass->byval_arg, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
        message += "::";
        message += vm::Method::GetName(method);
        message += "' with generic arguments [";
        for (uint32_t i = 0; i < genericArgumentsLength; i++)
        {
            if (i != 0)
                message += ", ";
            message += vm::Type::GetName(genericArguments[i], IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
        }
        message += "] at runtime.";

        return message;
    }

    static std::string FormatExceptionMessageForNonGenericMethod(const MethodInfo* method)
    {
        std::string message;
        message += "The method '";
        message += vm::Type::GetName(&method->klass->byval_arg, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
        message += "::";
        message += vm::Method::GetName(method);
        message += "' is not a generic method.";

        return message;
    }

    int32_t RuntimeMethodInfo::get_metadata_token(Il2CppObject* method)
    {
        return vm::Reflection::GetMetadataToken(method);
    }

    Il2CppObject* RuntimeMethodInfo::InternalInvoke(Il2CppReflectionMethod * method, Il2CppObject * thisPtr, Il2CppArray * params, Il2CppException * * exc)
    {
        /*
         * Invoke from reflection is supposed to always be a virtual call (the API
         * is stupid), mono_runtime_invoke_*() calls the provided method, allowing
         * greater flexibility.
         */
        const MethodInfo *m = method->method;
        int pcount;
        void *obj = thisPtr;

        *exc = NULL;

        if (!(m->flags & METHOD_ATTRIBUTE_STATIC))
        {
            if (thisPtr)
            {
                //if (!mono_class_vtable_full (mono_object_domain (method), m->klass, FALSE)) {
                //  mono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_class_get_exception_for_failure (m->klass));
                //  return NULL;
                //}

                if (!vm::Object::IsInst(thisPtr, m->klass))
                {
                    gc::WriteBarrier::GenericStore(exc, vm::Exception::FromNameMsg(il2cpp_defaults.corlib, "System.Reflection", "TargetException", "Object does not match target type."));
                    return NULL;
                }

                m = vm::Object::GetVirtualMethod(thisPtr, m);

                if (vm::Method::IsEntryPointNotFoundMethodInfo(m))
                    vm::Exception::Raise(vm::Exception::GetEntryPointNotFoundException(vm::Method::GetFullName(method->method).c_str()));

                /* must pass the pointer to the value for valuetype methods */
                if (m->klass->byval_arg.valuetype)
                    obj = vm::Object::Unbox(thisPtr);
            }
            else
#if IL2CPP_ENABLE_MONO_BUG_EMULATION    // Mono doesn't throw on null 'this' if it's an instance constructor, and class libs depend on this behaviour
            if (strcmp(m->name, ".ctor"))
#endif
            {
                vm::Exception::Raise(vm::Exception::GetTargetException("Non-static method requires a target"));
            }
        }

        pcount = params ? il2cpp::vm::Array::GetLength(params) : 0;
        if (pcount != m->parameters_count)
        {
            gc::WriteBarrier::GenericStore(exc, vm::Exception::FromNameMsg(il2cpp_defaults.corlib, "System.Reflection", "TargetParameterCountException", "Incorrect number of parameters"));
            return NULL;
        }

        // TODO: Add check for abstract once types have flags
        //if ((m->klass->flags & TYPE_ATTRIBUTE_ABSTRACT) && !strcmp (m->name, ".ctor") && !this) {
        //  mono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name_msg (mono_defaults.corlib, "System.Reflection", "TargetException", "Cannot invoke constructor of an abstract class."));
        //  return NULL;
        //}

        if (m->klass->rank && !strcmp(m->name, ".ctor"))
        {
            int i;
            il2cpp_array_size_t *lengths;
            il2cpp_array_size_t *lower_bounds;
            pcount = il2cpp::vm::Array::GetLength(params);
            lengths = (il2cpp_array_size_t*)alloca(sizeof(il2cpp_array_size_t) * pcount);
            for (i = 0; i < pcount; ++i)
                lengths[i] = *(il2cpp_array_size_t*)((char*)il2cpp_array_get(params, void*, i) + sizeof(Il2CppObject));

            if (m->klass->rank == pcount)
            {
                /* Only lengths provided. */
                lower_bounds = NULL;
            }
            else
            {
                IL2CPP_ASSERT(pcount == (m->klass->rank * 2));
                /* lower bounds are first. */
                lower_bounds = lengths;
                lengths += m->klass->rank;
            }

            return (Il2CppObject*)il2cpp::vm::Array::NewFull(m->klass, lengths, lower_bounds);
        }

        // If a managed exception was thrown, we need raise it here because Runtime::Invoke catches the exception and returns a pointer to it.
        Il2CppException* exception = NULL;

        Il2CppObject *result = il2cpp::vm::Runtime::InvokeArray(m, obj, params, &exception);

        if (exception)
            vm::Exception::Raise(exception);

        return result;
    }

    static const MethodInfo* il2cpp_method_get_equivalent_method(const MethodInfo *method, Il2CppClass *klass)
    {
        int offset = -1, i;

        if (method->is_inflated)
        {
            const Il2CppGenericContext *context = il2cpp::vm::MetadataCache::GetMethodGenericContext(method);
            if (context->method_inst)
            {
                const MethodInfo *result;

                //MonoMethodInflated *inflated = (MonoMethodInflated*)method;
                //method is inflated, we should inflate it on the other class
                Il2CppGenericContext newCtx;
                newCtx.method_inst = context->method_inst;
                newCtx.class_inst = context->class_inst;
                if (klass->generic_class)
                {
                    newCtx.class_inst = klass->generic_class->context.class_inst;
                }
                else if (klass->genericContainerHandle != NULL)
                {
                    IL2CPP_NOT_IMPLEMENTED(il2cpp_method_get_equivalent_method: generic_container_case);
                    //const Il2CppGenericContainer *genericContainer = il2cpp::vm::MetadataCache::GetGenericContainerFromIndex(klass->genericContainerIndex);
                    //newCtx.class_inst = genericContainer->context.class_inst;
                }

                result = il2cpp::metadata::GenericMetadata::Inflate(method, &newCtx);
                return result;
            }
        }

        il2cpp::vm::Class::SetupMethods(method->klass);

        for (i = 0; i < method->klass->method_count; ++i)
        {
            if (method->klass->methods[i] == method)
            {
                offset = i;
                break;
            }
        }

        il2cpp::vm::Class::SetupMethods(klass);

        IL2CPP_ASSERT(offset >= 0 && offset < klass->method_count);
        return klass->methods[offset];
    }

    Il2CppReflectionMethod* RuntimeMethodInfo::GetMethodFromHandleInternalType_native(intptr_t method_handle, intptr_t type_handle, bool genericCheck)
    {
        Il2CppReflectionMethod *res = NULL;
        Il2CppClass *klass;
        const MethodInfo *method = (const MethodInfo*)method_handle;
        if (type_handle && genericCheck)
        {
            klass = il2cpp_class_from_il2cpp_type((Il2CppType*)type_handle);
            if (il2cpp_class_get_generic_type_definition(method->klass) != il2cpp_class_get_generic_type_definition(klass))
                return NULL;

            if (method->klass != klass)
            {
                method = il2cpp_method_get_equivalent_method(method, klass);
                if (!method)
                    return NULL;
            }
        }
        else if (type_handle)
            klass = il2cpp_class_from_il2cpp_type((Il2CppType*)type_handle);
        else
            klass = method->klass;

        res = il2cpp_method_get_object(method, klass);
        return res;
    }

    Il2CppObject* RuntimeMethodInfo::GetMethodBodyInternal(intptr_t handle)
    {
        NOT_SUPPORTED_IL2CPP(RuntimeMethodInfo::GetMethodBodyInternal, "This icall is not supported by il2cpp.");
        return 0;
    }

    Il2CppReflectionMethod* RuntimeMethodInfo::GetGenericMethodDefinition_impl(Il2CppReflectionMethod* method)
    {
        if (method->method->is_generic)
            return method;

        if (!method->method->is_inflated)
            return NULL;

        const MethodInfo* methodDefinition = vm::MetadataCache::GetGenericMethodDefinition(method->method);
        IL2CPP_ASSERT(methodDefinition);

        if (!methodDefinition->is_generic)
            return NULL;


        const Il2CppGenericContext* methodContext = vm::MetadataCache::GetMethodGenericContext(method->method);
        IL2CPP_ASSERT(methodContext);

        if (methodContext->class_inst)
        {
            IL2CPP_NOT_IMPLEMENTED_ICALL(RuntimeMethodInfo::GetGenericMethodDefinition_impl);
        }

        return il2cpp::vm::Reflection::GetMethodObject(const_cast<MethodInfo*>(methodDefinition), NULL);
    }

    Il2CppReflectionMethod* RuntimeMethodInfo::MakeGenericMethod_impl(Il2CppReflectionMethod* method, Il2CppArray* genericArgumentTypes)
    {
        const MethodInfo* genericMethodDefinition = method->method;

        if (!genericMethodDefinition->is_generic)
            vm::Exception::Raise(vm::Exception::GetInvalidOperationException(FormatExceptionMessageForNonGenericMethod(genericMethodDefinition).c_str()));

        uint32_t arrayLength = vm::Array::GetLength(genericArgumentTypes);
        const Il2CppType** genericArguments = (const Il2CppType**)alloca(arrayLength * sizeof(Il2CppType*));

        for (uint32_t i = 0; i < arrayLength; i++)
        {
            Il2CppReflectionType* genericArgumentType = il2cpp_array_get(genericArgumentTypes, Il2CppReflectionType*, i);
            genericArguments[i] = genericArgumentType->type;
        }

        const MethodInfo* genericInstanceMethod = vm::MetadataCache::GetGenericInstanceMethod(genericMethodDefinition, genericArguments, arrayLength);

        if (!genericInstanceMethod)
        {
            vm::Exception::Raise(vm::Exception::GetNotSupportedException(FormatExceptionMessageForNonConstructableGenericMethod(genericMethodDefinition, genericArguments, arrayLength).c_str()));
            return NULL;
        }

        return il2cpp::vm::Reflection::GetMethodObject(genericInstanceMethod, NULL);
    }

    Il2CppReflectionMethod* RuntimeMethodInfo::get_base_method(Il2CppReflectionMethod* method, bool definition)
    {
        // On the C# side, RuntimeMethodInfo.GetBaseDefinition is the only caller of this icall that passes definition=true,
        // so we can do the equivalent call that net20 would do, which would be to call get_base_definition.
        //
        // When definition=false.  This is called by RuntimeMethodInfo.GetBaseMethod, which is internal, and seems to
        // only be called by some GetCustomAttributes(true) calls.  There is only a small difference in the behavior of this method
        // when definition is false.
        const MethodInfo *method2 = method->method;
        Il2CppClass *klass = method2->klass;

        if (klass == NULL)
            return method;

        if (!(method2->flags & METHOD_ATTRIBUTE_VIRTUAL) || vm::Class::IsInterface(klass) || method2->flags & METHOD_ATTRIBUTE_NEW_SLOT)
            return method;

        /*if(klass->generic_class)
        klass = klass->generic_class->container_class;*/

        const MethodInfo *result;
        bool found = true;

        do
        {
            if (definition)
            {
                for (Il2CppClass* parent = klass->parent; parent != NULL; parent = parent->parent)
                {
                    if (parent->vtable_count <= method2->slot)
                        break;

                    klass = parent;
                }
            }
            else
            {
                if (!klass->parent)
                {
                    IL2CPP_ASSERT(klass == il2cpp_defaults.object_class);
                    return method;
                }

                klass = klass->parent;
            }

            if (klass == method2->klass)
                return method;

            il2cpp::vm::Class::Init(klass);

            if (method2->slot >= klass->vtable_count)
                return method;

            result = klass->vtable[method2->slot].method;

            if (result == NULL || il2cpp::vm::Method::IsEntryPointNotFoundMethodInfo(result))
            {
                void *iterator = NULL;
                found = false;

                for (result = vm::Class::GetMethods(klass, &iterator); result != NULL; result = vm::Class::GetMethods(klass, &iterator))
                {
                    if (result->slot == method2->slot)
                    {
                        found = true;
                        break;
                    }
                }

                IL2CPP_ASSERT(!(definition && !found));
            }
        }
        while (!found);

        return il2cpp::vm::Reflection::GetMethodObject(result, klass);
    }

    Il2CppString* RuntimeMethodInfo::get_name(Il2CppReflectionMethod* reflectionMethod)
    {
        const MethodInfo *method = reflectionMethod->method;
        return vm::String::New(vm::Method::GetName(method));
    }

    Il2CppArray* RuntimeMethodInfo::GetGenericArguments(Il2CppReflectionMethod* method)
    {
        uint32_t count = 0;
        Il2CppArray* res = NULL;
        const MethodInfo* methodInfo = method->method;
        if (methodInfo->is_inflated)
        {
            const Il2CppGenericContext* context = vm::MetadataCache::GetMethodGenericContext(methodInfo);
            if (context && context->method_inst)
            {
                const Il2CppGenericInst *inst = context->method_inst;
                count = inst->type_argc;
                res = vm::Array::New(il2cpp_defaults.systemtype_class, count);

                for (uint32_t i = 0; i < count; i++)
                    il2cpp_array_setref(res, i, il2cpp::vm::Reflection::GetTypeObject(inst->type_argv[i]));

                return res;
            }

            // method is inflated because it's owner is a generic instance type, extract method definition out of the method
            IL2CPP_ASSERT(methodInfo->is_generic || methodInfo->is_inflated);
            methodInfo = methodInfo->genericMethod->methodDefinition;
        }

        Il2CppMetadataGenericContainerHandle containerHandle = vm::MetadataCache::GetGenericContainerFromMethod(methodInfo->methodMetadataHandle);

        count = vm::MetadataCache::GetGenericContainerCount(containerHandle);
        res = vm::Array::New(il2cpp_defaults.systemtype_class, count);

        for (uint32_t i = 0; i < count; i++)
        {
            Il2CppMetadataGenericParameterHandle  param = vm::GenericContainer::GetGenericParameter(containerHandle, i);
            Il2CppClass *pklass = vm::Class::FromGenericParameter(param);
            il2cpp_array_setref(res, i, il2cpp::vm::Reflection::GetTypeObject(&pklass->byval_arg));
        }

        return res;
    }

    void RuntimeMethodInfo::GetPInvoke(Il2CppReflectionMethod* _this, int32_t* flags, Il2CppString** entryPoint, Il2CppString** dllName)
    {
        // we don't keep these around in metadata
        *flags = 0;
        gc::WriteBarrier::GenericStore(dllName, vm::String::Empty());
        gc::WriteBarrier::GenericStore(entryPoint, vm::String::Empty());
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeMethodInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeModule.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeModule.h"
#include "il2cpp-class-internals.h"
#include "vm/Exception.h"
#include "vm/Image.h"
#include "vm/Array.h"
#include "vm/Module.h"
#include "vm/Reflection.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    Il2CppArray* RuntimeModule::ResolveSignature(intptr_t module, int32_t metadataToken, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(Module::ResolveSignature, "This icall is not supported by il2cpp.");

        return 0;
    }

    int32_t RuntimeModule::get_MetadataToken(Il2CppReflectionModule* module)
    {
        return vm::Module::GetToken(module->image);
    }

    int32_t RuntimeModule::GetMDStreamVersion(intptr_t module)
    {
        NOT_SUPPORTED_IL2CPP(Module::GetMDStreamVersion, "This icall is not supported by il2cpp.");

        return 0;
    }

    intptr_t RuntimeModule::GetHINSTANCE(intptr_t module)
    {
        NOT_SUPPORTED_IL2CPP(RuntimeModule::GetHINSTANCE,  "This icall is not supported by il2cpp.");
        return 0;
    }

    intptr_t RuntimeModule::ResolveFieldToken(intptr_t module, int32_t token, Il2CppArray* type_args, Il2CppArray* method_args, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(Module::ResolveFieldToken, "This icall is not supported by il2cpp.");

        return intptr_t();
    }

    intptr_t RuntimeModule::ResolveMethodToken(intptr_t module, int32_t token, Il2CppArray* type_args, Il2CppArray* method_args, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(Module::ResolveMethodToken, "This icall is not supported by il2cpp.");

        return intptr_t();
    }

    intptr_t RuntimeModule::ResolveTypeToken(intptr_t module, int32_t token, Il2CppArray* type_args, Il2CppArray* method_args, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(Module::ResolveTypeToken, "This icall is not supported by il2cpp.");

        return intptr_t();
    }

    Il2CppObject* RuntimeModule::ResolveMemberToken(intptr_t module, int32_t token, Il2CppArray* type_args, Il2CppArray* method_args, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(Module::ResolveMemberToken, "This icall is not supported by il2cpp.");

        return 0;
    }

    Il2CppString* RuntimeModule::ResolveStringToken(intptr_t module, int32_t token, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(Module::ResolveStringToken, "This icall is not supported by il2cpp.");

        return 0;
    }

    Il2CppObject* RuntimeModule::GetGlobalType(intptr_t module)
    {
        NOT_SUPPORTED_IL2CPP(Module::GetGlobalType, "This icall is not supported by il2cpp.");

        return 0;
    }

    Il2CppArray* RuntimeModule::InternalGetTypes(const Il2CppImage* image)
    {
        return il2cpp::vm::Image::GetTypes(image, false);
    }

    void RuntimeModule::GetGuidInternal(intptr_t module, Il2CppArray* guid)
    {
        // No implementation on purpose. The guid array will be unchanged, as IL2CPP
        // does not support GUIDs for modules. But we don't want to throw an
        // exception here.
    }

    void RuntimeModule::GetPEKind(intptr_t module, int32_t* peKind, int32_t* machine)
    {
        NOT_SUPPORTED_IL2CPP(Module::GetPEKind, "This icall is not supported by il2cpp.");
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeModule.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeParameterInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeParameterInfo.h"
#include "vm/Exception.h"
#include "vm/Reflection.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    int32_t RuntimeParameterInfo::GetMetadataToken(Il2CppObject* thisPtr)
    {
        return vm::Reflection::GetMetadataToken(thisPtr);
    }

    Il2CppArray* RuntimeParameterInfo::GetTypeModifiers(Il2CppObject* type, Il2CppObject* member, int32_t position, bool optional)
    {
        NOT_SUPPORTED_IL2CPP(RuntimeParameterInfo::GetTypeModifiers, "This icall is not supported by il2cpp.");
        return NULL;
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimeParameterInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimePropertyInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimePropertyInfo.h"
#include "gc/WriteBarrier.h"
#include "vm/Class.h"
#include "vm/Reflection.h"
#include "vm/String.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Reflection
{
    int32_t RuntimePropertyInfo::get_metadata_token(Il2CppObject* monoProperty)
    {
        return vm::Reflection::GetMetadataToken(monoProperty);
    }

    Il2CppObject* RuntimePropertyInfo::get_default_value(Il2CppObject* prop)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(RuntimePropertyInfo::get_default_value);
        IL2CPP_UNREACHABLE;
        return 0;
    }

    Il2CppReflectionProperty* RuntimePropertyInfo::internal_from_handle_type(intptr_t handlePtr, intptr_t typePtr)
    {
        Il2CppClass *klass;

        IL2CPP_ASSERT(handlePtr);

        ::PropertyInfo *handle = (::PropertyInfo*)handlePtr;
        Il2CppType *type = (Il2CppType*)typePtr;

        if (!type)
        {
            klass = handle->parent;
        }
        else
        {
            klass = vm::Class::FromIl2CppType(type);

            bool found = klass == handle->parent || il2cpp::vm::Class::HasParent(klass, handle->parent);
            if (!found)
                /* Managed code will throw an exception */
                return NULL;
        }

        Il2CppReflectionProperty *result = il2cpp::vm::Reflection::GetPropertyObject(klass, handle);
        return result;
    }

    Il2CppArray* RuntimePropertyInfo::GetTypeModifiers(Il2CppObject* prop, bool optional)
    {
        NOT_SUPPORTED_IL2CPP(MonoPropertyInfo::GetTypeModifiers, "This icall is not supported by il2cpp.");

        return 0;
    }

    void RuntimePropertyInfo::get_property_info(Il2CppReflectionProperty *property, Il2CppPropertyInfo *info, PInfo req_info)
    {
        if ((req_info & PInfo_ReflectedType) != 0)
            IL2CPP_STRUCT_SETREF(info, parent, vm::Reflection::GetTypeObject(&property->klass->byval_arg));
        else if ((req_info & PInfo_DeclaringType) != 0)
            IL2CPP_STRUCT_SETREF(info, declaringType, vm::Reflection::GetTypeObject(&property->property->parent->byval_arg));

        if ((req_info & PInfo_Name) != 0)
            IL2CPP_STRUCT_SETREF(info, name, vm::String::New(property->property->name));

        if ((req_info & PInfo_Attributes) != 0)
            info->attrs = property->property->attrs;

        if ((req_info & PInfo_GetMethod) != 0)
            IL2CPP_STRUCT_SETREF(info, get, property->property->get ?
                vm::Reflection::GetMethodObject(property->property->get, property->klass) : NULL);

        if ((req_info & PInfo_SetMethod) != 0)
            IL2CPP_STRUCT_SETREF(info, set, property->property->set ?
                vm::Reflection::GetMethodObject(property->property->set, property->klass) : NULL);
        /*
         * There may be other methods defined for properties, though, it seems they are not exposed
         * in the reflection API
         */
    }
} // namespace Reflection
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Reflection\RuntimePropertyInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime\RuntimeImports.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeImports.h"

#include <stdlib.h>
#include <algorithm>

#include "gc/GarbageCollector.h"
#include "vm/Class.h"
#include "vm/Type.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
#if IL2CPP_TARGET_WINDOWS
    void RuntimeImports::ecvt_s(char* buffer, int32_t sizeInBytes, double value, int32_t count, int32_t* dec, int32_t* sign)
    {
        errno_t returnValue = _ecvt_s(buffer, sizeInBytes, value, count, dec, sign);
        IL2CPP_ASSERT(returnValue == 0);
        NO_UNUSED_WARNING(returnValue);
    }

#endif

    void RuntimeImports::Memmove(uint8_t* dest, uint8_t* src, uint32_t len)
    {
        memmove(dest, src, len);
    }

    void RuntimeImports::Memmove_wbarrier(uint8_t* dest, uint8_t* src, uint32_t len, intptr_t type_handle)
    {
        uint32_t size = len * sizeof(void*);
        if (!vm::Type::IsReference((Il2CppType*)type_handle))
            size = vm::Class::GetValueSize(vm::Class::FromIl2CppType((Il2CppType*)type_handle), NULL) * len;

        memmove(dest, src, size);
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)dest, size);
    }

    void RuntimeImports::ZeroMemory(void* p, uint32_t byteLength)
    {
        memset(p, 0, byteLength);
    }
} // namespace Runtime
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime\RuntimeImports.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.CompilerServices\RuntimeHelpers.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-tabledefs.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "vm/Type.h"
#include "icalls/mscorlib/System.Runtime.CompilerServices/RuntimeHelpers.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace CompilerServices
{
    int RuntimeHelpers::get_OffsetToStringData(void)
    {
        return offsetof(Il2CppString, chars);
    }

    void RuntimeHelpers::InitializeArray(Il2CppArray * array, intptr_t ptr)
    {
        FieldInfo* field_handle = (FieldInfo*)ptr;
        Il2CppClass *klass = array->klass;
        uint32_t size = vm::Array::GetElementSize(klass);
        const Il2CppType *type = vm::Type::GetUnderlyingType(&klass->element_class->byval_arg);

        const char *field_data;

        if (vm::Type::IsReference(type) || (type->type == IL2CPP_TYPE_VALUETYPE && (!vm::Type::GetClass(type) || vm::Type::GetClass(type)->has_references)))
        {
            Il2CppException *exc = vm::Exception::GetArgumentException("array",
                "Cannot initialize array containing references");
            vm::Exception::Raise(exc);
        }

        if (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA))
        {
            Il2CppException *exc = vm::Exception::GetArgumentException("field_handle", "Field doesn't have an RVA");
            vm::Exception::Raise(exc);
        }

        size *= ARRAY_LENGTH_AS_INT32(array->max_length);
        field_data = vm::Field::GetData(field_handle);

        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(RuntimeHelpers::InitializeArray, "Check type size");
        //int align;
        //if (size > mono_type_size (field_handle->type, &align)) {
        //  MonoException *exc = mono_get_exception_argument("field_handle",
        //      "Field not large enough to fill array");
        //  mono_raise_exception (exc);
        //}

        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(RuntimeHelpers::InitializeArray, "Ignoring Endianess");
        memcpy(il2cpp_array_addr(array, char, 0), field_data, size);
    }

    Il2CppObject* RuntimeHelpers::GetObjectValue(Il2CppObject* obj)
    {
        if (obj == NULL || !vm::Class::IsValuetype(obj->klass))
            return obj;
        else
            return vm::Object::Clone(obj);
    }

    void RuntimeHelpers::RunClassConstructor(intptr_t typeIntPtr)
    {
        const Il2CppType* type = reinterpret_cast<const Il2CppType*>(typeIntPtr);
        IL2CPP_CHECK_ARG_NULL(type);

        Il2CppClass* klass = vm::Class::FromIl2CppType(type);
        //MONO_CHECK_ARG(handle, klass);

        il2cpp::vm::Runtime::ClassInit(klass);
    }

    void RuntimeHelpers::RunModuleConstructor(intptr_t module)
    {
        NOT_SUPPORTED_IL2CPP(RuntimeHelpers::RunModuleConstructor, "This icall is not supported by il2cpp.");
    }

    bool RuntimeHelpers::SufficientExecutionStack()
    {
        return true;
    }
} /* namespace CompilerServices */
} /* namespace Runtime */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.CompilerServices\RuntimeHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.InteropServices\GCHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "icalls/mscorlib/System.Runtime.InteropServices/GCHandle.h"
#include "gc/GCHandle.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/GenericClass.h"
#include "vm/Type.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace InteropServices
{
    bool GCHandle::CheckCurrentDomain(intptr_t handle)
    {
        return true; // il2cpp doesn't support multiple domains
    }

    void GCHandle::FreeHandle(intptr_t handle)
    {
        gc::GCHandle::Free((Il2CppGCHandle)handle);
    }

// Returns -2 if gchandle is not pinned
    intptr_t GCHandle::GetAddrOfPinnedObject(intptr_t handle)
    {
        gc::GCHandleType type = gc::GCHandle::GetHandleType((Il2CppGCHandle)handle);

        if (type != gc::HANDLE_PINNED)
            return reinterpret_cast<intptr_t>(reinterpret_cast<uint8_t*>(-2)); // mscorlib on managed land expects us to return "-2" as IntPtr if this condition occurs

        Il2CppObject* obj = gc::GCHandle::GetTarget((Il2CppGCHandle)handle);
        if (obj == NULL)
            return 0;

        ptrdiff_t offset;

        if (obj->klass->rank > 0)
        {
            // Pointer to first array element
            offset = kIl2CppSizeOfArray;
        }
        else if (obj->klass->byval_arg.type == IL2CPP_TYPE_STRING)
        {
            // Pointer to first character
            offset = offsetof(Il2CppString, chars);
        }
        else
        {
            // Pointer to struct in boxed object
            offset = sizeof(Il2CppObject);
        }

        return reinterpret_cast<intptr_t>((reinterpret_cast<uint8_t*>(obj) + offset));
    }

    Il2CppObject* GCHandle::GetTarget(intptr_t handle)
    {
        return gc::GCHandle::GetTarget((Il2CppGCHandle)handle);
    }

    static bool IsTypePinnable(Il2CppClass* klass)
    {
        // IL2CPP is matching the .NET Core behavior now, not .NET Framework.
        // Any type that does not have fields which are reference types can be
        // pinned.
        return !vm::Class::HasReferences(klass);
    }

    static inline bool IsObjectPinnable(Il2CppObject* obj)
    {
        if (obj == NULL)
            return true;

        return IsTypePinnable(obj->klass);
    }

    intptr_t GCHandle::GetTargetHandle(Il2CppObject* obj, intptr_t handle, int32_t type)
    {
        if (type == gc::HANDLE_PINNED && !IsObjectPinnable(obj))
        {
            Il2CppException* ex = vm::Exception::GetArgumentException(NULL, "Object contains references.");
            vm::Exception::Raise(ex);
        }

        auto targetHandle = gc::GCHandle::GetTargetHandle(obj, (Il2CppGCHandle)handle, type);
        vm::Exception::RaiseIfError(targetHandle.GetError());
        return (intptr_t)targetHandle.Get();
    }
} /* namespace InteropServices */
} /* namespace Runtime */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.InteropServices\GCHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.InteropServices\Marshal.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System.Runtime.InteropServices/Marshal.h"

#include "il2cpp-class-internals.h"
#include "il2cpp-tabledefs.h"

#include "gc/GarbageCollector.h"
#include "metadata/FieldLayout.h"
#include "os/Atomic.h"
#include "os/MarshalStringAlloc.h"
#include "vm/Array.h"
#include "vm/CCW.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Image.h"
#include "vm/LastError.h"
#include "vm/MarshalAlloc.h"
#include "vm/Object.h"
#include "vm/PlatformInvoke.h"
#include "vm/RCW.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "utils/MarshalingUtils.h"
#include "utils/StringUtils.h"
#include <string>
#include <deque>
#include <algorithm>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace InteropServices
{
    int32_t Marshal::AddRefInternal(intptr_t pUnk)
    {
        return static_cast<Il2CppIUnknown*>((void*)pUnk)->AddRef();
    }

    intptr_t Marshal::AllocCoTaskMem(int32_t size)
    {
        intptr_t result;
        result = (intptr_t)vm::MarshalAlloc::Allocate(size);
        return result;
    }

    intptr_t Marshal::AllocHGlobal(intptr_t size)
    {
        intptr_t result;
        result = (intptr_t)vm::MarshalAlloc::AllocateHGlobal((size_t)size);
        return result;
    }

    void Marshal::copy_from_unmanaged(intptr_t source, int startIndex, Il2CppArray * destination, int length)
    {
        uint32_t element_size = (uint32_t)il2cpp_array_element_size(destination->klass);
        memcpy(il2cpp_array_addr_with_size(destination, element_size, startIndex), reinterpret_cast<void*>(source), length * element_size);
    }

    void Marshal::copy_to_unmanaged(Il2CppArray * source, int32_t startIndex, intptr_t destination, int32_t length)
    {
        uint32_t element_size = (uint32_t)il2cpp_array_element_size(source->klass);
        memcpy(reinterpret_cast<void*>(destination), il2cpp_array_addr_with_size(source, element_size, startIndex), length * element_size);
    }

    void Marshal::FreeBSTR(intptr_t ptr)
    {
        vm::PlatformInvoke::MarshalFreeBString(reinterpret_cast<Il2CppChar*>(ptr));
    }

    void Marshal::FreeCoTaskMem(intptr_t ptr)
    {
        vm::MarshalAlloc::Free(reinterpret_cast<void*>(ptr));
    }

    void Marshal::FreeHGlobal(intptr_t hglobal)
    {
        vm::MarshalAlloc::FreeHGlobal(reinterpret_cast<void*>(hglobal));
    }

    bool Marshal::IsComObject(Il2CppObject* o)
    {
        if (o == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("o"));

        return o->klass->is_import_or_windows_runtime;
    }

    intptr_t Marshal::GetCCW(Il2CppObject* o, Il2CppReflectionType* T)
    {
        if (o == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("o"));

        if (T == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("T"));

        Il2CppClass* klass = vm::Class::FromIl2CppType(T->type);

        if (!vm::Class::IsInterface(klass))
        {
            DECLARE_NATIVE_C_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(parameter, IL2CPP_NATIVE_STRING("T"));
            DECLARE_NATIVE_C_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(message, IL2CPP_NATIVE_STRING("The T parameter is not an interface."));
            vm::Exception::Raise(vm::Exception::GetArgumentException(parameter, message));
        }

        if (vm::Class::IsGeneric(klass))
        {
            DECLARE_NATIVE_C_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(parameter, IL2CPP_NATIVE_STRING("T"));
            DECLARE_NATIVE_C_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(message, IL2CPP_NATIVE_STRING("The T parameter is a generic type."));
            vm::Exception::Raise(vm::Exception::GetArgumentException(parameter, message));
        }

        const Il2CppInteropData* interopData = klass->interopData;
        if (interopData == NULL || interopData->guid == NULL)
        {
            DECLARE_NATIVE_C_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(parameter, IL2CPP_NATIVE_STRING("T"));
            DECLARE_NATIVE_C_STRING_AS_STRING_VIEW_OF_IL2CPP_CHARS(message, IL2CPP_NATIVE_STRING("The specified type must be visible from COM."));
            vm::Exception::Raise(vm::Exception::GetArgumentException(parameter, message));
        }

        return reinterpret_cast<intptr_t>(vm::CCW::GetOrCreate(o, *interopData->guid));
    }

    int32_t Marshal::GetComSlotForMethodInfoInternal(mscorlib_System_Reflection_MemberInfo * m)
    {
        NOT_SUPPORTED_IL2CPP(Marshal::GetComSlotForMethodInfoInternal, "Not implemented.");
        return 0;
    }

    Il2CppDelegate* Marshal::GetDelegateForFunctionPointerInternal(intptr_t ptr, Il2CppReflectionType* t)
    {
        Il2CppClass* delegateType = il2cpp::vm::Class::FromIl2CppType(t->type);
        return vm::PlatformInvoke::MarshalFunctionPointerToDelegate(reinterpret_cast<void*>(ptr), delegateType);
    }

    intptr_t Marshal::GetFunctionPointerForDelegateInternal(Il2CppDelegate* d)
    {
        return vm::PlatformInvoke::MarshalDelegate(d);
    }

    intptr_t Marshal::GetIDispatchForObjectInternal(Il2CppObject* o)
    {
        NOT_SUPPORTED_IL2CPP(Marshal::GetIDispatchForObjectInternal, "Not implemented.");
        return 0;
    }

    intptr_t Marshal::GetIUnknownForObjectInternal(Il2CppObject* o)
    {
        NOT_SUPPORTED_IL2CPP(Marshal::GetIUnknownForObjectInternal, "This icall is not supported by il2cpp. Use the il2cpp_codegen_com_get_iunknown_for_object intrinsic instead.");
        return 0;
    }

    Il2CppObject* Marshal::GetObjectForCCW(intptr_t pUnk)
    {
        if (pUnk == 0)
            return NULL;

        return vm::RCW::GetOrCreateFromIUnknown(reinterpret_cast<Il2CppIUnknown*>(pUnk), il2cpp_defaults.il2cpp_com_object_class);
    }

    Il2CppString* Marshal::PtrToStringBSTR(intptr_t ptr)
    {
        if (ptr == 0)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("ptr"));

        return vm::PlatformInvoke::MarshalCppBStringToCSharpStringResult(reinterpret_cast<const Il2CppChar*>(ptr));
    }

    Il2CppString* Marshal::PtrToStringAnsi_mscorlib_System_String_mscorlib_System_IntPtr(intptr_t ptr)
    {
        char* value = (char*)ptr;
        if (value == NULL)
            return NULL;
        return vm::String::New(value);
    }

    Il2CppString* Marshal::PtrToStringAnsi_mscorlib_System_String_mscorlib_System_IntPtr_mscorlib_System_Int32(intptr_t ptr, int32_t len)
    {
        char* value = (char*)ptr;
        if (value == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("ptr"));

        return vm::String::NewLen(value, len);
    }

    Il2CppString* Marshal::PtrToStringUni_mscorlib_System_String_mscorlib_System_IntPtr(intptr_t ptr)
    {
        Il2CppChar* value = reinterpret_cast<Il2CppChar*>(ptr);
        if (value == NULL)
            return NULL;

        int32_t len = 0;
        Il2CppChar* t = value;

        while (*t++)
            len++;

        return vm::String::NewUtf16(value, len);
    }

    Il2CppString* Marshal::PtrToStringUni_mscorlib_System_String_mscorlib_System_IntPtr_mscorlib_System_Int32(intptr_t ptr, int32_t len)
    {
        Il2CppChar* value = reinterpret_cast<Il2CppChar*>(ptr);
        if (value == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("ptr"));

        return vm::String::NewUtf16(value, len);
    }

    Il2CppObject* Marshal::PtrToStructure(intptr_t ptr, Il2CppReflectionType* structureType)
    {
        if (ptr == 0)
            return NULL;

        if (structureType == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("structureType"));

        Il2CppClass* type = vm::Class::FromIl2CppType(structureType->type);

        Il2CppTypeEnum typeType = structureType->type->type;

        if (typeType == IL2CPP_TYPE_STRING || typeType == IL2CPP_TYPE_SZARRAY || (typeType == IL2CPP_TYPE_CLASS && !vm::Class::HasDefaultConstructor(type)))
        {
            vm::Exception::Raise(vm::Exception::GetMissingMethodException("No parameterless constructor defined for this object."));
        }

        if (type->interopData != NULL && type->interopData->pinvokeMarshalFromNativeFunction != NULL)
        {
            Il2CppObject* result = vm::Object::New(type);

            if (typeType == IL2CPP_TYPE_CLASS)
            {
                typedef void (*Constructor)(Il2CppObject*);
                Constructor ctor = reinterpret_cast<Constructor>(vm::Class::GetMethodFromName(type, ".ctor", 0)->virtualMethodPointer);
                ctor(result);
                utils::MarshalingUtils::MarshalStructFromNative(reinterpret_cast<void*>(ptr), result, type->interopData);
            }
            else
            {
                utils::MarshalingUtils::MarshalStructFromNative(reinterpret_cast<void*>(ptr), vm::Object::Unbox(result), type->interopData);
            }

            return result;
        }

        // If there's no custom marshal function, it means it's either a primitive, or invalid argument
        if (type->native_size != -1)
        {
            // We may also need to throw a NotSupportedException for an ArgIterator.
            if (structureType->type->type == IL2CPP_TYPE_VOID)
                vm::Exception::Raise(vm::Exception::GetNotSupportedException("Cannot dynamically create an instance of System.Void."));

            // PtrToStructure is supposed to throw on enums
            if (!type->enumtype)
            {
                Il2CppObject* result = vm::Object::New(type);
                memcpy(vm::Object::Unbox(result), reinterpret_cast<void*>(ptr), type->native_size);
                return result;
            }
        }

        // If we got this far, throw an exception

        if (type->generic_class != NULL || type->is_generic)
            vm::Exception::Raise(vm::Exception::GetArgumentException("structure", "The specified object must not be an instance of a generic type."));

        vm::Exception::Raise(vm::Exception::GetArgumentException("structure", "The specified structure must be blittable or have layout information."));
        return NULL;
    }

    void Marshal::PtrToStructureObject(intptr_t ptr, Il2CppObject* structure)
    {
        if (ptr == 0)
            return;

        if (structure == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("structure"));

        Il2CppClass* type = structure->klass;

        // This is only legal for classes.
        if (type->byval_arg.type != IL2CPP_TYPE_CLASS)
        {
            vm::Exception::Raise(vm::Exception::GetArgumentException("structure", "The specified structure must be an instance of a formattable class."));
        }

        if (type->interopData != NULL && type->interopData->pinvokeMarshalFromNativeFunction != NULL)
        {
            utils::MarshalingUtils::MarshalStructFromNative(reinterpret_cast<void*>(ptr), structure, type->interopData);
            return;
        }

        if (type->generic_class || type->is_generic)
            vm::Exception::Raise(vm::Exception::GetArgumentException("structure", "The specified object must not be an instance of a generic type."));

        vm::Exception::Raise(vm::Exception::GetArgumentException("structure", "The specified structure must be blittable or have layout information."));
    }

    int32_t Marshal::QueryInterfaceInternal(intptr_t pUnk, mscorlib_System_Guid * iid, intptr_t* ppv)
    {
        Il2CppIUnknown* unknown = reinterpret_cast<Il2CppIUnknown*>(pUnk);
        return unknown->QueryInterface(reinterpret_cast<Il2CppGuid&>(*iid), reinterpret_cast<void**>(ppv));
    }

    template<typename T>
    static inline T ReadValue(intptr_t ptr, int32_t offset)
    {
        return *reinterpret_cast<T*>(reinterpret_cast<uint8_t*>(ptr) + offset);
    }

    uint8_t Marshal::ReadByte(intptr_t ptr, int32_t ofs)
    {
        return ReadValue<uint8_t>(ptr, ofs);
    }

    int16_t Marshal::ReadInt16(intptr_t ptr, int32_t ofs)
    {
        return ReadValue<int16_t>(ptr, ofs);
    }

    int32_t Marshal::ReadInt32(intptr_t ptr, int32_t ofs)
    {
        return ReadValue<int32_t>(ptr, ofs);
    }

    int64_t Marshal::ReadInt64(intptr_t ptr, int32_t ofs)
    {
        return ReadValue<int64_t>(ptr, ofs);
    }

    intptr_t Marshal::ReadIntPtr(intptr_t ptr, int32_t ofs)
    {
        return ReadValue<intptr_t>(ptr, ofs);
    }

    int32_t Marshal::ReleaseInternal(intptr_t pUnk)
    {
        return reinterpret_cast<Il2CppIUnknown*>(pUnk)->Release();
    }

    int32_t Marshal::ReleaseComObjectInternal(Il2CppObject* co)
    {
        // There's a check in mscorlib before calling this internal icall, so assert instead of full check is OK here.
        IL2CPP_ASSERT(co->klass->is_import_or_windows_runtime);

        int32_t newRefCount = os::Atomic::Decrement(&static_cast<Il2CppComObject*>(co)->refCount);
        if (newRefCount == 0)
        {
            // We can't really release the COM object directly, because it might have additional
            // fields that cache different interfaces. So let's just call its finalizer here.
            // In order to deal with the fact that this may get called from different threads
            // at the same time, we (atomically) register a NULL finalizer, and if another finalizer
            // was already registered, we call it. If there was no finalizer registered, it means
            // that we lost the race and we should just carry on.
            gc::GarbageCollector::FinalizerCallback oldFinalizer = gc::GarbageCollector::RegisterFinalizerWithCallback(co, NULL);
            if (oldFinalizer != NULL)
                oldFinalizer(co, NULL);
        }

        return newRefCount;
    }

    int Marshal::SizeOf(Il2CppReflectionType* rtype)
    {
        if (rtype == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("t"));

        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(rtype->type);

        if (typeInfo->native_size != -1)
        {
            // SizeOf "cannot" get size of enums and strings
            if (!typeInfo->enumtype && rtype->type->type != IL2CPP_TYPE_STRING)
                return typeInfo->native_size;
        }

        // If we get to here, type does not have a native size
        // So let's figure what kind of exception to throw

        if (typeInfo->generic_class != NULL || typeInfo->is_generic)
            vm::Exception::Raise(vm::Exception::GetArgumentException("t", "The t parameter is a generic type."));

        std::string exceptionMessage = utils::StringUtils::Printf("Type \'%s\' cannot be marshaled as an unmanaged structure; no meaningful size or offset can be computed.",
            vm::Type::GetName(rtype->type, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME).c_str());

        vm::Exception::Raise(vm::Exception::GetArgumentException(NULL, exceptionMessage.c_str()));
        return 0;
    }

    intptr_t Marshal::StringToBSTR(Il2CppString* s)
    {
        return reinterpret_cast<intptr_t>(vm::PlatformInvoke::MarshalCSharpStringToCppBString(s));
    }

    intptr_t Marshal::StringToHGlobalAnsi(Il2CppChar* s, int32_t length)
    {
        if (s == NULL)
            return 0;

        std::string str = il2cpp::utils::StringUtils::Utf16ToUtf8(s);
        char *cstr = (char*)vm::MarshalAlloc::AllocateHGlobal(str.size() + 1);
        strcpy(cstr, str.c_str());
        return reinterpret_cast<intptr_t>(cstr);
    }

    intptr_t Marshal::StringToHGlobalUni(Il2CppChar* s, int32_t length)
    {
        if (s == NULL)
            return 0;

        size_t bytes = (length + 1) * 2;
        Il2CppChar* cstr = static_cast<Il2CppChar*>(vm::MarshalAlloc::AllocateHGlobal(bytes));
        memcpy(cstr, s, bytes);
        return reinterpret_cast<intptr_t>(cstr);
    }

    void Marshal::StructureToPtr(Il2CppObject* structure, intptr_t ptr, bool deleteOld)
    {
        if (structure == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("structure"));

        if (ptr == 0)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("ptr"));

        Il2CppClass* type = structure->klass;

        if (type->interopData != NULL && type->interopData->pinvokeMarshalToNativeFunction != NULL)
        {
            if (deleteOld)
                utils::MarshalingUtils::MarshalFreeStruct(reinterpret_cast<void*>(ptr), type->interopData);

            void* objectPtr = (type->byval_arg.type == IL2CPP_TYPE_CLASS) ? structure : vm::Object::Unbox(structure);
            utils::MarshalingUtils::MarshalStructToNative(objectPtr, reinterpret_cast<void*>(ptr), type->interopData);
            return;
        }

        // If there's no custom marshal function, it means it's either a primitive, or invalid argument

        if (type->native_size != -1)
        {
            // StructureToPtr is supposed to throw on strings and enums
            if (!type->enumtype && type->byval_arg.type != IL2CPP_TYPE_STRING)
            {
                memcpy(reinterpret_cast<void*>(ptr), vm::Object::Unbox(structure), type->native_size);
                return;
            }
        }

        // If we got this far, throw an exception
        Il2CppException* exception;

        if (type->generic_class != NULL || type->is_generic)
        {
            exception = vm::Exception::GetArgumentException("structure", "The specified object must not be an instance of a generic type.");
        }
        else
        {
            exception = vm::Exception::GetArgumentException("structure", "The specified structure must be blittable or have layout information.");
        }

        vm::Exception::Raise(exception);
    }

    template<typename T>
    static inline void WriteValue(intptr_t ptr, int32_t offset, T value)
    {
        *reinterpret_cast<T*>(reinterpret_cast<uint8_t*>(ptr) + offset) = value;
    }

    void Marshal::WriteByte(intptr_t ptr, int32_t ofs, uint8_t val)
    {
        WriteValue(ptr, ofs, val);
    }

    void Marshal::WriteInt16(intptr_t ptr, int32_t ofs, int16_t val)
    {
        WriteValue(ptr, ofs, val);
    }

    void Marshal::WriteInt32(intptr_t ptr, int32_t ofs, int32_t val)
    {
        WriteValue(ptr, ofs, val);
    }

    void Marshal::WriteInt64(intptr_t ptr, int32_t ofs, int64_t val)
    {
        WriteValue(ptr, ofs, val);
    }

    void Marshal::WriteIntPtr(intptr_t ptr, int32_t ofs, intptr_t val)
    {
        WriteValue(ptr, ofs, val);
    }

    void Marshal::DestroyStructure(intptr_t ptr, Il2CppReflectionType* structureType)
    {
        if (ptr == 0)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("ptr"));

        if (structureType == NULL)
            vm::Exception::Raise(vm::Exception::GetArgumentNullException("structureType"));

        Il2CppClass* type = vm::Class::FromIl2CppType(structureType->type);

        // If cleanup function exists, it will call it and return true
        // In that case, we're done.
        if (utils::MarshalingUtils::MarshalFreeStruct(reinterpret_cast<void*>(ptr), type->interopData))
            return;

        if (type->is_generic || type->generic_class != NULL)
        {
            vm::Exception::Raise(vm::Exception::GetArgumentException("structureType", "The specified type must not be a generic type definition."));
        }

        // Enums are blittable, but they don't have layout information, therefore Marshal.DestroyStructure is supposed to throw
        if (!type->enumtype)
        {
            // Char and Boolean are not blittable, but they should not raise this exception, as we can call DestroyStructure on them without problems.
            if (type->is_blittable || structureType->type->type == IL2CPP_TYPE_CHAR || structureType->type->type == IL2CPP_TYPE_BOOLEAN)
                return;
        }

        // If we got this far, throw an exception
        vm::Exception::Raise(vm::Exception::GetArgumentException("structureType", "The specified type must be blittable or have layout information."));
    }

    int32_t Marshal::GetLastWin32Error()
    {
        return vm::LastError::GetLastError();
    }

    void Marshal::SetLastWin32Error(uint32_t error)
    {
        vm::LastError::SetLastError(error);
    }

    static size_t RoundUpToMultiple(size_t numToRound, size_t multiple)
    {
        if (multiple == 0)
            return numToRound;

        size_t remainder = numToRound % multiple;
        if (remainder == 0)
            return numToRound;
        return numToRound + multiple - remainder;
    }

    intptr_t Marshal::OffsetOf(Il2CppReflectionType* t, Il2CppString* fieldName)
    {
        std::string fieldNameToFind = utils::StringUtils::Utf16ToUtf8(fieldName->chars);
        Il2CppClass* type = vm::Class::FromIl2CppType(t->type);

        FieldInfo* field = vm::Class::GetFieldFromName(type, fieldNameToFind.c_str());
        if (field == NULL || (vm::Field::GetFlags(field) & FIELD_ATTRIBUTE_STATIC))
        {
            std::string message;
            message = "Field '" + fieldNameToFind + "' is not a marshaled member of the type '" + type->name + "'";
            vm::Exception::Raise(vm::Exception::GetArgumentException("fieldName", message.c_str()));
        }

        // Order the base classes so the most base class is first.
        std::deque<Il2CppClass*> inheritanceHierarchy;
        while (type)
        {
            inheritanceHierarchy.push_front(type);
            type = type->parent;
        }

        bool fieldFound = false;

        size_t offset = 0;
        FieldInfo* previousField = NULL;
        for (std::deque<Il2CppClass*>::iterator it = inheritanceHierarchy.begin(); it < inheritanceHierarchy.end(); ++it)
        {
            type = *it;
            void* iter = NULL;
            int layout = vm::Class::GetFlags(type) & TYPE_ATTRIBUTE_LAYOUT_MASK;
            bool layoutIsExplicit = layout == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT;

            while ((field = vm::Class::GetFields(type, &iter)))
            {
                if (vm::Field::GetFlags(field) & FIELD_ATTRIBUTE_STATIC)
                    continue;

                if (layoutIsExplicit)
                {
                    offset = field->offset - sizeof(Il2CppObject);
                }
                else if (previousField != NULL) // Determine how much the previous field added to the offset.
                {
                    if (!vm::Type::IsStruct(previousField->type))
                    {
                        size_t managedOffset = field->offset - previousField->offset;
                        if (managedOffset != 0) // overlapping fields have a zero offset
                        {
                            offset += vm::Class::GetFieldMarshaledSize(previousField);
                        }
                    }
                    else
                    {
                        offset += vm::Class::FromIl2CppType(previousField->type)->native_size;
                    }

                    if (offset != 0)
                    {
                        int marshaledFieldAlignment = vm::Class::GetFieldMarshaledAlignment(field);
                        offset = RoundUpToMultiple(offset, type->packingSize == 0 ? marshaledFieldAlignment : std::min((int)type->packingSize, marshaledFieldAlignment));
                    }
                }
                else
                {
                    // If this is the first field, it might have a non-zero offset, as it could be in a type
                    // with an explicit layout. So calculate it offset based on the distance it is from the
                    // end of the object header.
                    offset = field->offset - sizeof(Il2CppObject);
                }

                previousField = field;

                if (fieldNameToFind == vm::Field::GetName(field))
                {
                    fieldFound = true;
                    break;
                }
            }

            if (fieldFound)
                break;
        }

        return static_cast<intptr_t>(offset);
    }

    // We _could_ implement these two if we wanted - we'd just need to init their metadata
    void Marshal::Prelink(Il2CppReflectionMethod* m)
    {
        NOT_SUPPORTED_IL2CPP(Marshal::Prelink, "Not implemented.");
    }

    void Marshal::PrelinkAll(Il2CppReflectionType* c)
    {
        NOT_SUPPORTED_IL2CPP(Marshal::PrelinkAll, "Not implemented.");
    }

    intptr_t Marshal::ReAllocCoTaskMem(intptr_t ptr, int32_t size)
    {
        return reinterpret_cast<intptr_t>(vm::MarshalAlloc::ReAlloc(reinterpret_cast<void*>(ptr), size));
    }

    intptr_t Marshal::ReAllocHGlobal(intptr_t ptr, intptr_t size)
    {
        if (ptr == 0)
            vm::Exception::RaiseOutOfMemoryException();

        return reinterpret_cast<intptr_t>(vm::MarshalAlloc::ReAllocHGlobal(reinterpret_cast<void*>(ptr), (size_t)size));
    }

    intptr_t Marshal::UnsafeAddrOfPinnedArrayElement(Il2CppArray* arr, int32_t index)
    {
        return reinterpret_cast<intptr_t>(il2cpp_array_addr_with_size(arr, il2cpp_array_element_size(arr->klass), index));
    }

    intptr_t Marshal::BufferToBSTR(Il2CppChar* ptr, int32_t slen)
    {
        Il2CppChar* bstr = NULL;
        os::MarshalStringAlloc::AllocateBStringLength(ptr, slen, &bstr);
        return (intptr_t)bstr;
    }

    int32_t Marshal::GetHRForException_WinRT(Il2CppException* e)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Marshal::GetHRForException_WinRT);
        IL2CPP_UNREACHABLE;
    }

    intptr_t Marshal::GetRawIUnknownForComObjectNoAddRef(Il2CppObject* o)
    {
        IL2CPP_ASSERT(o->klass->is_import_or_windows_runtime);

        return reinterpret_cast<intptr_t>(static_cast<Il2CppComObject*>(o)->identity);
    }

    Il2CppObject* Marshal::GetNativeActivationFactory(Il2CppObject* type)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Marshal::GetNativeActivationFactory);
        IL2CPP_UNREACHABLE;
    }

    intptr_t Marshal::AllocCoTaskMemSize(intptr_t sizet)
    {
        intptr_t result;
        result = (intptr_t)vm::MarshalAlloc::Allocate(sizet);
        return result;
    }

    void Marshal::copy_from_unmanaged_fixed(intptr_t source, int32_t startIndex, Il2CppArray* destination, int32_t length, void* fixed_destination_element)
    {
        uint32_t element_size = (uint32_t)il2cpp_array_element_size(destination->klass);
        memcpy(il2cpp_array_addr_with_size(destination, element_size, startIndex), reinterpret_cast<void*>(source), length * element_size);
    }

    void Marshal::copy_to_unmanaged_fixed(Il2CppArray* source, int32_t startIndex, intptr_t destination, int32_t length, void* fixed_source_element)
    {
        uint32_t element_size = (uint32_t)il2cpp_array_element_size(source->klass);
        memcpy(reinterpret_cast<void*>(destination), il2cpp_array_addr_with_size(source, element_size, startIndex), length * element_size);
    }
} /* namespace InteropServices */
} /* namespace Runtime */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.InteropServices\Marshal.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.InteropServices\RuntimeInformation.cpp---------------
.
.
#include "il2cpp-config.h"
#include "RuntimeInformation.h"
#include "vm/String.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace InteropServices
{
    Il2CppString* RuntimeInformation::GetOSName()
    {
#if IL2CPP_TARGET_WINDOWS_DESKTOP
        return vm::String::New("windows");
#elif IL2CPP_TARGET_OSX
        return vm::String::New("osx");
#elif IL2CPP_TARGET_LINUX
        return vm::String::New("linux");
#else
        return vm::String::New("unknown");
#endif
    }

    Il2CppString* RuntimeInformation::GetRuntimeArchitecture()
    {
#if IL2CPP_TARGET_ARM64
        return vm::String::New("armv8");
#elif IL2CPP_TARGET_ARMV7
        return vm::String::New("arm");
#elif IL2CPP_TARGET_X86
        return vm::String::New("x86");
#elif IL2CPP_TARGET_X64
        return vm::String::New("x86-64");
#else
        return vm::String::New("unknown");
#endif
    }
} // namespace InteropServices
} // namespace Runtime
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.InteropServices\RuntimeInformation.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting\RemotingServices.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System.Runtime.Remoting/RemotingServices.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace Remoting
{
    Il2CppReflectionMethod* RemotingServices::GetVirtualMethod(Il2CppReflectionType*, Il2CppReflectionMethod*)
    {
        NOT_SUPPORTED_REMOTING(RemotingServices::GetVirtualMethod);
        return NULL;
    }

    Il2CppObject* RemotingServices::InternalExecute(Il2CppReflectionMethod*, Il2CppObject*, Il2CppArray*, Il2CppArray**)
    {
        NOT_SUPPORTED_REMOTING(RemotingServices::InternalExecute);
        return NULL;
    }
} /* namespace Remoting */
} /* namespace Runtime */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting\RemotingServices.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Activation\ActivationServices.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-api.h"
#include "icalls/mscorlib/System.Runtime.Remoting.Activation/ActivationServices.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-runtime-metadata.h"
#include "vm/Image.h"
#include "vm/Class.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace Remoting
{
namespace Activation
{
    void ActivationServices::EnableProxyActivation(Il2CppReflectionType*, bool)
    {
        NOT_SUPPORTED_REMOTING(ActivationServices::EnableProxyActivation);
    }

    Il2CppObject* ActivationServices::AllocateUninitializedClassInstance(Il2CppReflectionType * type)
    {
        Il2CppClass* typeInfo = vm::Class::FromIl2CppType(type->type);

        if (typeInfo == NULL)
            return NULL;

        il2cpp::vm::Class::Init(typeInfo);
        return il2cpp_object_new(typeInfo);
    }
} /* namespace Activation */
} /* namespace Remoting */
} /* namespace Runtime */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Activation\ActivationServices.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Contexts\Context.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Context.h"

#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace Remoting
{
namespace Contexts
{
    void Context::RegisterContext(Il2CppObject* ctx)
    {
        NOT_SUPPORTED_IL2CPP(Context::RegisterContext, "This icall is not supported by il2cpp.");
    }

    void Context::ReleaseContext(Il2CppObject* ctx)
    {
        NOT_SUPPORTED_IL2CPP(Context::ReleaseContext, "This icall is not supported by il2cpp.");
    }
} // namespace Contexts
} // namespace Remoting
} // namespace Runtime
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Contexts\Context.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Messaging\AsyncResult.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-api.h"
#include "AsyncResult.h"
#include "gc/WriteBarrier.h"
#include "vm/Runtime.h"
#include "vm/WaitHandle.h"
#include "vm/ThreadPoolMs.h"
#include "os/Event.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace Remoting
{
namespace Messaging
{
    Il2CppObject* AsyncResult::Invoke(Il2CppObject* _this)
    {
        Il2CppAsyncCall *ac;
        Il2CppObject *res;
        Il2CppAsyncResult *ares = (Il2CppAsyncResult*)_this;

        IL2CPP_ASSERT(ares);
        IL2CPP_ASSERT(ares->async_delegate);

        ac = (Il2CppAsyncCall*)ares->object_data;
        if (!ac)
        {
            res = vm::Runtime::DelegateInvoke(ares->async_delegate, (void**)&ares->async_state, NULL);
        }
        else
        {
            il2cpp::os::EventHandle *wait_event = NULL;

            IL2CPP_OBJECT_SETREF_NULL(ac->msg, exc);
            res = il2cpp::vm::ThreadPoolMs::MessageInvoke((Il2CppObject*)ares->async_delegate->target, ac->msg, &ac->msg->exc, &ac->out_args);
            IL2CPP_OBJECT_SETREF(ac, res, res);

            il2cpp_monitor_enter((Il2CppObject*)ares);
            ares->completed = 1;
            if (ares->handle)
                wait_event = (il2cpp::os::EventHandle*)il2cpp::vm::WaitHandle::GetPlatformHandle(ares->handle);

            il2cpp_monitor_exit((Il2CppObject*)ares);

            if (wait_event != NULL)
                wait_event->Get().Set();

            Il2CppException* completionException = NULL;

            if (ac->cb_method)
                vm::Runtime::Invoke(ac->cb_method, ac->cb_target, (void**)&ares, &completionException);

            if (completionException != NULL)
                vm::Exception::Raise(completionException);
        }

        return res;
    }
} // namespace Messaging
} // namespace Remoting
} // namespace Runtime
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Messaging\AsyncResult.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Messaging\MonoMethodMessage.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"
#include "icalls/mscorlib/System.Runtime.Remoting.Messaging/MonoMethodMessage.h"
#include "gc/WriteBarrier.h"
#include "os/Atomic.h"
#include "vm/Array.h"
#include "vm/Exception.h"
#include "vm/Method.h"
#include "vm/String.h"
#include "utils/dynamic_array.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace Remoting
{
namespace Messaging
{
    void MonoMethodMessage::InitMessage(Il2CppMethodMessage *this_obj, Il2CppReflectionMethod *method, Il2CppArray *out_args)
    {
        static Il2CppClass *object_array_klass;
        static Il2CppClass *byte_array_klass;
        static Il2CppClass *string_array_klass;
        Il2CppString *name;
        Il2CppArray *arr;
        int i, j;
        unsigned char arg_type;

        if (!object_array_klass)
        {
            Il2CppClass *klass;

            klass = il2cpp_array_class_get(il2cpp_defaults.byte_class, 1);
            IL2CPP_ASSERT(klass);
            byte_array_klass = klass;

            klass = il2cpp_array_class_get(il2cpp_defaults.string_class, 1);
            IL2CPP_ASSERT(klass);
            string_array_klass = klass;

            klass = il2cpp_array_class_get(il2cpp_defaults.object_class, 1);
            IL2CPP_ASSERT(klass);

            il2cpp::os::Atomic::ExchangePointer(&object_array_klass, klass);
        }

        IL2CPP_OBJECT_SETREF(this_obj, method, method);

        arr = il2cpp_array_new_specific(object_array_klass, method->method->parameters_count);

        IL2CPP_OBJECT_SETREF(this_obj, args, arr);

        arr = il2cpp_array_new_specific(byte_array_klass, method->method->parameters_count);

        IL2CPP_OBJECT_SETREF(this_obj, arg_types, arr);

        this_obj->async_result = NULL;
        this_obj->call_type = Il2Cpp_CallType_Sync;

        il2cpp::utils::dynamic_array<const char*> names(method->method->parameters_count);

        for (int i = 0; i < method->method->parameters_count; ++i)
            names[i] = vm::Method::GetParamName(method->method, i);

        arr = il2cpp_array_new_specific(string_array_klass, method->method->parameters_count);

        IL2CPP_OBJECT_SETREF(this_obj, names, arr);

        for (i = 0; i < method->method->parameters_count; i++)
        {
            name = il2cpp::vm::String::New(names[i]);
            il2cpp_array_setref(this_obj->names, i, name);
        }

        for (i = 0, j = 0; i < method->method->parameters_count; i++)
        {
            if (method->method->parameters[i]->byref)
            {
                if (out_args)
                {
                    Il2CppObject* arg = (Il2CppObject*)il2cpp_array_get(out_args, void*, j);
                    il2cpp_array_setref(this_obj->args, i, arg);
                    j++;
                }

                arg_type = 2;
                if (!(method->method->parameters[i]->attrs & PARAM_ATTRIBUTE_OUT))
                    arg_type |= 1;
            }
            else
            {
                arg_type = 1;
                if (method->method->parameters[i]->attrs & PARAM_ATTRIBUTE_OUT)
                    arg_type |= 4;
            }

            il2cpp_array_set(this_obj->arg_types, unsigned char, i, arg_type);
        }
    }
} /* namespace Messaging */
} /* namespace Remoting */
} /* namespace Runtime */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Messaging\MonoMethodMessage.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Proxies\RealProxy.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System.Runtime.Remoting.Proxies/RealProxy.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace Remoting
{
namespace Proxies
{
    Il2CppObject* RealProxy::InternalGetTransparentProxy(Il2CppObject*, Il2CppString*)
    {
        NOT_SUPPORTED_REMOTING(RealProxy::InternalGetTransparentProxy);
        return NULL;
    }

    Il2CppReflectionType* RealProxy::InternalGetProxyType(Il2CppObject *)
    {
        NOT_SUPPORTED_REMOTING(RealProxy::InternalGetProxyType);
        return NULL;
    }
} /* namespace Proxies */
} /* namespace Remoting */
} /* namespace Runtime */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Remoting.Proxies\RealProxy.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Versioning\VersioningHelper.cpp---------------
.
.
#include "il2cpp-config.h"
#include "VersioningHelper.h"

#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Runtime
{
namespace Versioning
{
    int32_t VersioningHelper::GetRuntimeId()
    {
        NOT_SUPPORTED_IL2CPP(VersioningHelper::GetRuntimeId, "This icall is not supported by il2cpp.");
        return 0;
    }
} // namespace Versioning
} // namespace Runtime
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Runtime.Versioning\VersioningHelper.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Cryptography\RNGCryptoServiceProvider.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-api.h"
#include "vm/Array.h"
#include "os/Cryptography.h"
#include "utils/Memory.h"
#include "icalls/mscorlib/System.Security.Cryptography/RNGCryptoServiceProvider.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Security
{
namespace Cryptography
{
    bool RNGCryptoServiceProvider::RngOpen()
    {
        return os::Cryptography::OpenCryptographyProvider();
    }

    intptr_t RNGCryptoServiceProvider::RngGetBytes(intptr_t handle, uint8_t* data, intptr_t data_length)
    {
        IL2CPP_ASSERT(data || !data_length);

        if (!os::Cryptography::FillBufferWithRandomBytes(reinterpret_cast<void*>(handle), data_length, data))
        {
            os::Cryptography::ReleaseCryptographyProvider(reinterpret_cast<void*>(handle));
            handle = RngInitialize(NULL, 0);

            if (!os::Cryptography::FillBufferWithRandomBytes(reinterpret_cast<void*>(handle), data_length, data))
            {
                os::Cryptography::ReleaseCryptographyProvider(reinterpret_cast<void*>(handle));
                return 0;
            }
        }

        return handle;
    }

    intptr_t RNGCryptoServiceProvider::RngInitialize(uint8_t* seed, intptr_t seed_length)
    {
        void* provider = os::Cryptography::GetCryptographyProvider();

        if ((provider != 0) && seed)
        {
            unsigned char* data = (unsigned char*)IL2CPP_MALLOC(seed_length);
            if (data)
            {
                memcpy(data, seed, seed_length);
                os::Cryptography::FillBufferWithRandomBytes(provider, seed_length, data);
                memset(data, 0, seed_length);
                IL2CPP_FREE(data);
            }
        }

        return reinterpret_cast<intptr_t>(provider);
    }

    void RNGCryptoServiceProvider::RngClose(intptr_t handle)
    {
        os::Cryptography::ReleaseCryptographyProvider(reinterpret_cast<void*>(handle));
    }
} /* namespace Cryptography */
} /* namespace Security */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Cryptography\RNGCryptoServiceProvider.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Policy\Evidence.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System.Security.Policy/Evidence.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Security
{
namespace Policy
{
    bool Evidence::IsAuthenticodePresent(Il2CppAssembly* a)
    {
        NOT_SUPPORTED_IL2CPP(Evidence::IsAuthenticodePresent, "This icall is not supported by il2cpp.");

        return false;
    }
} /* namespace Policy */
} /* namespace Security */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Policy\Evidence.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Principal\WindowsIdentity.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System.Security.Principal/WindowsIdentity.h"
#include "vm/String.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Security
{
namespace Principal
{
    intptr_t WindowsIdentity::GetCurrentToken()
    {
        return 0;
    }

    intptr_t WindowsIdentity::GetUserToken(Il2CppString* username)
    {
        NOT_SUPPORTED_IL2CPP(WindowsIdentity::GetUserToken, "This icall is not supported by il2cpp.");

        return 0;
    }

    Il2CppString* WindowsIdentity::GetTokenName(intptr_t token)
    {
        return vm::String::Empty();
    }

    Il2CppArray* WindowsIdentity::_GetRoles(intptr_t token)
    {
        NOT_SUPPORTED_IL2CPP(WindowsIdentity::_GetRoles, "This icall is not supported by il2cpp.");

        return 0;
    }
} /* namespace Principal */
} /* namespace Security */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Principal\WindowsIdentity.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Principal\WindowsImpersonationContext.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System.Security.Principal/WindowsImpersonationContext.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Security
{
namespace Principal
{
    bool WindowsImpersonationContext::CloseToken(intptr_t token)
    {
        NOT_SUPPORTED_IL2CPP(WindowsImpersonationContext::CloseToken, "This icall is not supported by il2cpp.");

        return false;
    }

    bool WindowsImpersonationContext::RevertToSelf()
    {
        NOT_SUPPORTED_IL2CPP(WindowsImpersonationContext::RevertToSelf, "This icall is not supported by il2cpp.");

        return false;
    }

    bool WindowsImpersonationContext::SetCurrentToken(intptr_t token)
    {
        NOT_SUPPORTED_IL2CPP(WindowsImpersonationContext::SetCurrentToken, "This icall is not supported by il2cpp.");

        return false;
    }

    intptr_t WindowsImpersonationContext::DuplicateToken(intptr_t token)
    {
        NOT_SUPPORTED_IL2CPP(WindowsImpersonationContext::DuplicateToken, "This icall is not supported by il2cpp.");

        return 0;
    }
} /* namespace Principal */
} /* namespace Security */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Principal\WindowsImpersonationContext.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Principal\WindowsPrincipal.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/mscorlib/System.Security.Principal/WindowsPrincipal.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Security
{
namespace Principal
{
    bool WindowsPrincipal::IsMemberOfGroupId(intptr_t user, intptr_t group)
    {
        NOT_SUPPORTED_IL2CPP(WindowsPrincipal::IsMemberOfGroupId, "This icall is not supported by il2cpp.");

        return false;
    }

    bool WindowsPrincipal::IsMemberOfGroupName(intptr_t user, intptr_t group)
    {
        NOT_SUPPORTED_IL2CPP(WindowsPrincipal::IsMemberOfGroupName, "This icall is not supported by il2cpp.");

        return false;
    }
} /* namespace Principal */
} /* namespace Security */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Security.Principal\WindowsPrincipal.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Text\EncodingHelper.cpp---------------
.
.
#include "il2cpp-config.h"
#include "EncodingHelper.h"
#include <string>
#include "os/Encoding.h"
#include <vm/String.h>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Text
{
    static const char* encodings[] =
    {
        (char*)1,
        "ascii", "us_ascii", "us", "ansi_x3.4_1968",
        "ansi_x3.4_1986", "cp367", "csascii", "ibm367",
        "iso_ir_6", "iso646_us", "iso_646.irv:1991",
        (char*)2,
        "utf_7", "csunicode11utf7", "unicode_1_1_utf_7",
        "unicode_2_0_utf_7", "x_unicode_1_1_utf_7",
        "x_unicode_2_0_utf_7",
        (char*)3,
        "utf_8", "unicode_1_1_utf_8", "unicode_2_0_utf_8",
        "x_unicode_1_1_utf_8", "x_unicode_2_0_utf_8",
        (char*)4,
        "utf_16", "UTF_16LE", "ucs_2", "unicode",
        "iso_10646_ucs2",
        (char*)5,
        "unicodefffe", "utf_16be",
        (char*)6,
        "iso_8859_1",
        (char*)0
    };

    Il2CppString* EncodingHelper::InternalCodePage(int32_t* resultCodePage)
    {
        const int32_t want_name = *resultCodePage;

        *resultCodePage = -1;

        const std::string charSet = os::Encoding::GetCharSet();

        std::string codepage(charSet);

        for (size_t i = 0, length = codepage.length(); i < length; ++i)
        {
            char& c = codepage[i];

            if (isalpha(c))
                c = tolower(c);

            if (c == '-')
                c = '_';
        }

        // handle some common aliases
        const char* p = encodings[0];
        int code = 0;

        for (size_t i = 0; p != 0;)
        {
            if ((size_t)p < 7)
            {
                code = (int)(size_t)p;
                p = encodings[++i];
                continue;
            }

            if (codepage == p)
            {
                *resultCodePage = code;
                break;
            }

            p = encodings[++i];
        }

        if (codepage.find("utf_8") != std::string::npos)
            *resultCodePage |= 0x10000000;

        if (want_name && *resultCodePage == -1)
            return il2cpp::vm::String::NewWrapper(charSet.c_str());
        else
            return NULL;
    }
} // namespace Text
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Text\EncodingHelper.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Text\Normalization.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Normalization.h"
#include <il2cpp-normalization-tables.h>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Text
{
    void Normalization::load_normalization_resource(intptr_t* argProps, intptr_t* argMappedChars, intptr_t* argCharMapIndex, intptr_t* argHelperIndex, intptr_t* argMapIdxToComposite, intptr_t* argCombiningClass)
    {
        *argProps = reinterpret_cast<intptr_t>(props);
        *argMappedChars = reinterpret_cast<intptr_t>(mappedChars);
        *argCharMapIndex = reinterpret_cast<intptr_t>(charMapIndex);
        *argHelperIndex = reinterpret_cast<intptr_t>(helperIndex);
        *argMapIdxToComposite = reinterpret_cast<intptr_t>(mapIdxToComposite);
        *argCombiningClass = reinterpret_cast<intptr_t>(combiningClass);
    }
} // namespace Text
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Text\Normalization.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\InternalThread.cpp---------------
.
.
#include "il2cpp-config.h"
#include "InternalThread.h"
#include "utils/Memory.h"
#include "os/Mutex.h"
#include "os/Thread.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
    void InternalThread::Thread_free_internal(Il2CppInternalThread* _this)
    {
        delete _this->longlived->synch_cs;
        _this->longlived->synch_cs = NULL;

        IL2CPP_FREE(_this->longlived);
        _this->longlived = NULL;

        IL2CPP_FREE(_this->name.chars);
        _this->name.chars = NULL;

        delete reinterpret_cast<il2cpp::os::Thread*>(_this->handle);
        _this->handle = NULL;
    }
} // namespace Threading
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\InternalThread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Monitor.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "icalls/mscorlib/System.Threading/Monitor.h"
#include "vm/Monitor.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
    bool Monitor::Monitor_test_owner(Il2CppObject* obj)
    {
        IL2CPP_CHECK_ARG_NULL(obj);
        return il2cpp::vm::Monitor::IsOwnedByCurrentThread(obj);
    }

    bool Monitor::Monitor_test_synchronised(Il2CppObject* obj)
    {
        IL2CPP_CHECK_ARG_NULL(obj);
        return il2cpp::vm::Monitor::IsAcquired(obj);
    }

    bool Monitor::Monitor_wait(Il2CppObject* obj, int32_t ms)
    {
        IL2CPP_CHECK_ARG_NULL(obj);
        return il2cpp::vm::Monitor::TryWait(obj, ms);
    }

    void Monitor::Enter(Il2CppObject* obj)
    {
        IL2CPP_CHECK_ARG_NULL(obj);
        il2cpp::vm::Monitor::Enter(obj);
    }

    void Monitor::Exit(Il2CppObject* obj)
    {
        IL2CPP_CHECK_ARG_NULL(obj);
        il2cpp::vm::Monitor::Exit(obj);
    }

    void Monitor::Monitor_pulse(Il2CppObject* obj)
    {
        IL2CPP_CHECK_ARG_NULL(obj);
        il2cpp::vm::Monitor::Pulse(obj);
    }

    void Monitor::Monitor_pulse_all(Il2CppObject* obj)
    {
        IL2CPP_CHECK_ARG_NULL(obj);
        il2cpp::vm::Monitor::PulseAll(obj);
    }

    void Monitor::try_enter_with_atomic_var(Il2CppObject* obj, int32_t millisecondsTimeout, bool* lockTaken)
    {
        if (*lockTaken)
            vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentException("lockTaken", "lockTaken must be false"));

        *lockTaken = il2cpp::vm::Monitor::TryEnter(obj, millisecondsTimeout);
    }
} /* namespace Threading */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Monitor.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Mutex.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System.Threading/Mutex.h"
#include "os/Mutex.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
    bool Mutex::ReleaseMutex_internal(intptr_t handle)
    {
        il2cpp::os::MutexHandle* mutex = (il2cpp::os::MutexHandle*)handle;
        mutex->Get()->Unlock();
        return true;
    }

    intptr_t Mutex::CreateMutex_icall(bool initiallyOwned, Il2CppChar* name, int32_t name_length, bool* created)
    {
        *created = true;
        il2cpp::os::Mutex* mutex = NULL;

        if (name == NULL)
        {
            mutex = new il2cpp::os::Mutex();
        }
        else
        {
            NOT_SUPPORTED_IL2CPP(Mutex::CreateMutex_internal, "Named mutexes are not supported");
        }

        if (initiallyOwned)
            mutex->Lock();

        return reinterpret_cast<intptr_t>(new il2cpp::os::MutexHandle(mutex));
    }

    intptr_t Mutex::OpenMutex_icall(Il2CppChar* name, int32_t name_length, int32_t rights, int32_t* error)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Mutex::OpenMutex_internal);

        return intptr_t();
    }
} /* namespace Threading */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Mutex.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\NativeEventCalls.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/mscorlib/System.Threading/NativeEventCalls.h"
#include "os/Event.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
    bool NativeEventCalls::ResetEvent_internal(intptr_t handlePtr)
    {
        os::EventHandle* handle = (os::EventHandle*)handlePtr;
        os::ErrorCode result = handle->Get().Reset();

        return os::kErrorCodeSuccess == result;
    }

    bool NativeEventCalls::SetEvent_internal(intptr_t handlePtr)
    {
        os::EventHandle* handle = (os::EventHandle*)handlePtr;
        os::ErrorCode result = handle->Get().Set();

        return os::kErrorCodeSuccess == result;
    }

    intptr_t NativeEventCalls::CreateEvent_icall(bool manual, bool initial, Il2CppChar* name, int32_t name_length, int32_t* errorCode)
    {
        *errorCode = 0;
        il2cpp::os::Event* event = NULL;

        if (name == NULL)
            event = new os::Event(manual, initial);
        else
            NOT_SUPPORTED_IL2CPP(NativeEventCalls::CreateEvent_internal, "Named events are not supported.");

        return reinterpret_cast<intptr_t>(new os::EventHandle(event));
    }

    void NativeEventCalls::CloseEvent_internal(intptr_t handlePtr)
    {
        os::Handle* handle = (os::Handle*)handlePtr;
        // should we close or just delete
        //handle->Close ();
        delete handle;
    }
} /* namespace Threading */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\NativeEventCalls.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\OSSpecificSynchronizationContext.cpp---------------
.
.
#include "il2cpp-config.h"
#include "OSSpecificSynchronizationContext.h"
#include "os/SynchronizationContext.h"

using il2cpp::icalls::mscorlib::System::Threading::OSSpecificSynchronizationContext;

Il2CppObject* OSSpecificSynchronizationContext::GetOSContext()
{
#if IL2CPP_HAS_OS_SYNCHRONIZATION_CONTEXT
    return il2cpp::os::SynchronizationContext::GetForCurrentThread();
#else
    return NULL;
#endif
}

void OSSpecificSynchronizationContext::PostInternal(Il2CppObject* context, SynchronizationContextCallback callback, intptr_t arg)
{
#if IL2CPP_HAS_OS_SYNCHRONIZATION_CONTEXT
    il2cpp::os::SynchronizationContext::Post(context, callback, arg);
#endif
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\OSSpecificSynchronizationContext.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Thread.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>
#include "icalls/mscorlib/System.Threading/Thread.h"
#include "il2cpp-class-internals.h"
#include "gc/GarbageCollector.h"
#include "os/Atomic.h"
#include "os/Thread.h"
#include "os/Mutex.h"
#include "os/Semaphore.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/Domain.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Thread.h"
#include "vm/Exception.h"
#include "vm/String.h"
#include "vm/StackTrace.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"

using il2cpp::gc::GarbageCollector;

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
    struct StartData
    {
        Il2CppThread* m_Thread;
        Il2CppDomain* m_Domain;
        Il2CppDelegate* m_Delegate;
        Il2CppObject* m_StartArg;
        il2cpp::os::Semaphore* m_Semaphore;
    };

    static void ThreadStart(void* arg)
    {
        StartData* startData = (StartData*)arg;

        startData->m_Semaphore->Wait();

        {
            GarbageCollector::RegisterThread();

            il2cpp::vm::StackTrace::InitializeStackTracesForCurrentThread();

            il2cpp::vm::Thread::InitializeManagedThread(startData->m_Thread, startData->m_Domain);
            il2cpp::vm::Thread::SetState(startData->m_Thread, vm::kThreadStateRunning);

            try
            {
                Il2CppException* exc = NULL;
                void* args[1] = { startData->m_StartArg };
                vm::Runtime::DelegateInvoke(startData->m_Delegate, args, &exc);

                if (exc)
                    vm::Runtime::UnhandledException(exc);
            }
            catch (il2cpp::vm::Thread::NativeThreadAbortException)
            {
                // Nothing to do. We've successfully aborted the thread.
                il2cpp::vm::Thread::SetState(startData->m_Thread, vm::kThreadStateAborted);
            }

            il2cpp::vm::Thread::ClrState(startData->m_Thread, vm::kThreadStateRunning);
            il2cpp::vm::Thread::SetState(startData->m_Thread, vm::kThreadStateStopped);
            il2cpp::vm::Thread::UninitializeManagedThread(startData->m_Thread);

            il2cpp::vm::StackTrace::CleanupStackTracesForCurrentThread();
        }

        delete startData->m_Semaphore;
        GarbageCollector::FreeFixed(startData);
    }

    bool Thread::JoinInternal(Il2CppThread* thisPtr, int32_t millisecondsTimeout)
    {
        // Throw ThreadStateException if thread has not been started yet.
        if (il2cpp::vm::Thread::GetState(thisPtr) & vm::kThreadStateUnstarted)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetThreadStateException("Thread has not been started."));

        // Mark current thread as blocked.
        Il2CppThread* currentThread = il2cpp::vm::Thread::Current();
        SetState(currentThread->internal_thread, vm::kThreadStateWaitSleepJoin);

        // Join with other thread.
        il2cpp::os::Thread* osThread = (il2cpp::os::Thread*)thisPtr->GetInternalThread()->handle;
        IL2CPP_ASSERT(osThread != NULL);
        il2cpp::os::WaitStatus status = osThread->Join(millisecondsTimeout);

        // Unblock current thread.
        ClrState(currentThread->internal_thread, vm::kThreadStateWaitSleepJoin);

        if (status == kWaitStatusSuccess)
            return true;

        return false;
    }

    bool Thread::Thread_internal(Il2CppThread* thisPtr, Il2CppDelegate* start)
    {
        IL2CPP_ASSERT(thisPtr->GetInternalThread()->longlived->synch_cs != NULL);
        il2cpp::os::FastAutoLock lock(thisPtr->GetInternalThread()->longlived->synch_cs);

        if (il2cpp::vm::Thread::GetState(thisPtr) & vm::kThreadStateAborted)
        {
            return reinterpret_cast<intptr_t>(thisPtr->GetInternalThread()->handle);
        }

        // use fixed GC memory since we are storing managed object pointers
        StartData* startData = (StartData*)GarbageCollector::AllocateFixed(sizeof(StartData), NULL);

        startData->m_Thread = thisPtr;
        GarbageCollector::SetWriteBarrier((void**)&startData->m_Thread);
        startData->m_Domain = vm::Domain::GetCurrent();
        startData->m_Delegate = start;
        GarbageCollector::SetWriteBarrier((void**)&startData->m_Delegate);
        startData->m_StartArg = thisPtr->start_obj;
        GarbageCollector::SetWriteBarrier((void**)&startData->m_StartArg);
        startData->m_Semaphore = new il2cpp::os::Semaphore(0);

        il2cpp::os::Thread* thread = thisPtr->GetInternalThread()->handle;
        thread->SetStackSize(thisPtr->GetInternalThread()->stack_size);
        thread->SetExplicitApartment(static_cast<il2cpp::os::ApartmentState>(thisPtr->GetInternalThread()->apartment_state));
        il2cpp::os::ErrorCode status = thread->Run(&ThreadStart, startData);
        if (status != il2cpp::os::kErrorCodeSuccess)
        {
            return false;
        }

        thisPtr->GetInternalThread()->state &= ~vm::kThreadStateUnstarted;
        thisPtr->GetInternalThread()->tid = thread->Id();
        if (!thisPtr->GetInternalThread()->managed_id)
            thisPtr->GetInternalThread()->managed_id = il2cpp::vm::Thread::GetNewManagedId();

        startData->m_Semaphore->Post(1, NULL);

        // this is just checked against 0 in the calling code
        return reinterpret_cast<intptr_t>(thisPtr->GetInternalThread()->handle);
    }

    bool Thread::YieldInternal()
    {
        return vm::Thread::YieldInternal();
    }

    Il2CppArray* Thread::ByteArrayToCurrentDomain(Il2CppArray* arr)
    {
        // IL2CPP only has one domain, so just return the same array.
        return arr;
    }

    Il2CppArray* Thread::ByteArrayToRootDomain(Il2CppArray* arr)
    {
        // IL2CPP only has one domain, so just return the same array.
        return arr;
    }

    int32_t Thread::GetDomainID()
    {
        return il2cpp::vm::Domain::GetCurrent()->domain_id;
    }

    int32_t Thread::GetPriorityNative(Il2CppThread* _this)
    {
        return il2cpp::vm::Thread::GetPriority(_this);
    }

    int32_t Thread::SystemMaxStackStize()
    {
        return il2cpp::os::Thread::GetMaxStackSize();
    }

    Il2CppObject* Thread::GetAbortExceptionState(Il2CppThread* thisPtr)
    {
        NOT_SUPPORTED_IL2CPP(Thread::GetAbortExceptionState, "Thread abortion is currently not implemented on IL2CPP; it is recommended to use safer mechanisms to terminate threads.");
        return 0;
    }

// Unlike Mono we cannot just do a memory read/write of the correct type and reuse that for the
// floating-point types because we are compiling to C++ and have to account for its type conversion
// rules. For example, if we read a double as a uint64_t and return it as such, the compiler will
// perform a default conversion from uint64_t to double -- whereas what we want is to simply interpret
// the memory contents as a double.
    int8_t Thread::VolatileRead_1(volatile void* address)
    {
        int8_t tmp = *reinterpret_cast<volatile int8_t*>(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return tmp;
    }

    double Thread::VolatileRead_Double(volatile double* address)
    {
        double tmp = *reinterpret_cast<volatile double*>(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return tmp;
    }

    float Thread::VolatileRead_Float(volatile float* address)
    {
        float tmp = *reinterpret_cast<volatile float*>(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return tmp;
    }

    int16_t Thread::VolatileRead_2(volatile void* address)
    {
        int16_t tmp = *reinterpret_cast<volatile int16_t*>(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return tmp;
    }

    int32_t Thread::VolatileRead_4(volatile void* address)
    {
        int32_t tmp = *reinterpret_cast<volatile int32_t*>(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return tmp;
    }

    int64_t Thread::VolatileRead_8(volatile void* address)
    {
        int64_t tmp = *reinterpret_cast<volatile int64_t*>(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return tmp;
    }

    intptr_t Thread::VolatileRead_IntPtr(volatile void* address)
    {
        intptr_t tmp = *reinterpret_cast<volatile intptr_t*>(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return tmp;
    }

    Il2CppObject* Thread::VolatileRead_Object(volatile void* address)
    {
        volatile Il2CppObject* tmp = *(volatile Il2CppObject**)(address);
        il2cpp::os::Atomic::FullMemoryBarrier();
        return (Il2CppObject*)tmp;
    }

    Il2CppString* Thread::GetName_internal(Il2CppInternalThread* thread)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);

        if (thread->name.length == 0)
            return NULL;

        return il2cpp::vm::String::NewUtf16(thread->name.chars, thread->name.length);
    }

    int32_t Thread::GetState(Il2CppInternalThread* thread)
    {
        // There is a chance that the managed thread object can be used from code (like a
        // finalizer) after it has been destroyed. In that case, the objects that
        // the runtime uses to track this thread may have been freed. Try to check for
        // that case here and return early.
        if (thread->longlived == NULL)
            return vm::kThreadStateStopped;

        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);
        return (il2cpp::vm::ThreadState)thread->state;
    }

    void Thread::Abort_internal(Il2CppInternalThread* thread, Il2CppObject* stateInfo)
    {
        il2cpp::vm::Thread::RequestAbort(thread);
    }

    void Thread::ClrState(Il2CppInternalThread* thread, int32_t clr)
    {
        il2cpp::vm::Thread::ClrState(thread, (il2cpp::vm::ThreadState)clr);
    }

    void Thread::ConstructInternalThread(Il2CppThread* _this)
    {
        // The os::Thread object is deallocated in the InternalThread::Thread_free_internal icall, which
        // is called from the managed thread finalizer.
        vm::Thread::SetupInternalManagedThread(_this, new os::Thread());
        _this->GetInternalThread()->state = vm::kThreadStateUnstarted;
    }

    void Thread::GetCurrentThread_icall(volatile Il2CppThread** thread)
    {
        *thread = il2cpp::vm::Thread::Current();
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)thread);
    }

    void Thread::GetStackTraces(Il2CppArray** threads, Il2CppArray** stack_frames)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Thread::GetStackTraces);
        IL2CPP_UNREACHABLE;
    }

    void Thread::InterruptInternal(Il2CppThread* thisPtr)
    {
        il2cpp::vm::Thread::RequestInterrupt(thisPtr);
    }

    void Thread::MemoryBarrier()
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
    }

    void Thread::ResetAbortNative(Il2CppThread* thisPtr)
    {
        vm::Thread::ResetAbort(vm::Thread::CurrentInternal());
    }

    void Thread::ResumeInternal(Il2CppThread* thisPtr)
    {
        NOT_SUPPORTED_IL2CPP(Thread::Resume_internal, "Thread suspension is obsolete and not supported on IL2CPP.");
    }

    void Thread::SetName_icall(Il2CppInternalThread* thread, Il2CppChar* name, int32_t nameLength)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);

        // Throw if already set.
        if (thread->name.length != 0)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetInvalidOperationException("Thread name can only be set once."));

        // Store name.
        thread->name.length = nameLength;
        thread->name.chars = il2cpp::utils::StringUtils::StringDuplicate(name, thread->name.length);

        // Hand over to OS layer, if thread has been started already.
        if (thread->handle)
        {
            std::string utf8Name = il2cpp::utils::StringUtils::Utf16ToUtf8(thread->name.chars);
            thread->handle->SetName(utf8Name.c_str());
        }
    }

    void Thread::SetPriorityNative(Il2CppThread* thisPtr, int32_t priority)
    {
        vm::Thread::SetPriority(thisPtr, priority);
    }

    void Thread::SetState(Il2CppInternalThread* thisPtr, int32_t state)
    {
        il2cpp::os::FastAutoLock lock(thisPtr->longlived->synch_cs);
        il2cpp::vm::Thread::SetState(thisPtr, (il2cpp::vm::ThreadState)state);
    }

    void Thread::SleepInternal(int32_t millisecondsTimeout)
    {
        Il2CppInternalThread* thread = il2cpp::vm::Thread::Current()->internal_thread;
        SetState(thread, vm::kThreadStateWaitSleepJoin);
        il2cpp::os::Thread::Sleep(millisecondsTimeout, true);
        ClrState(thread, vm::kThreadStateWaitSleepJoin);
    }

    void Thread::SpinWait_nop()
    {
        // :rotating_thinking_face:
    }

    void Thread::SuspendInternal(Il2CppThread* thisPtr)
    {
        NOT_SUPPORTED_IL2CPP(Thread::SuspendInternal, "Thread suspension is obsolete and not supported on IL2CPP.");
    }

    void Thread::VolatileWrite_1(volatile void* address, int8_t value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<volatile int8_t*>(address) = value;
    }

    void Thread::VolatileWrite_Double(volatile void* address, double value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<volatile double*>(address) = value;
    }

    void Thread::VolatileWrite_2(volatile void* address, int16_t value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<volatile int16_t*>(address) = value;
    }

    void Thread::VolatileWrite_4(volatile void* address, int32_t value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<volatile int32_t*>(address) = value;
    }

    void Thread::VolatileWrite_8(volatile void* address, int64_t value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<volatile int64_t*>(address) = value;
    }

    void Thread::VolatileWrite_IntPtr(volatile void* address, intptr_t value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<volatile intptr_t*>(address) = value;
    }

    void Thread::VolatileWrite_Object(volatile void* address, Il2CppObject* value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<Il2CppObject* volatile *>(address) = value;
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)&address);
    }

    void Thread::VolatileWrite_Float(volatile void* address, float value)
    {
        il2cpp::os::Atomic::FullMemoryBarrier();
        *reinterpret_cast<volatile float*>(address) = value;
    }
} /* namespace Threading */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Timer.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Timer.h"
#include "os/Time.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
    int64_t Timer::GetTimeMonotonic()
    {
        return os::Time::GetTicks100NanosecondsMonotonic();
    }
} // namespace Threading
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\Timer.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\WaitHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include <vector>
#include <algorithm>
#include "icalls/mscorlib/System.Threading/WaitHandle.h"
#include "os/Mutex.h"
#include "os/Thread.h"
#include "vm/Thread.h"
#include "vm/Exception.h"
#include "vm/Array.h"
#include "vm/WaitHandle.h"

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
    bool waitone_internal(Il2CppObject* unused, intptr_t handlePtr, int32_t ms, bool exitContext)
    {
        il2cpp::os::Handle* handle = (il2cpp::os::Handle*)handlePtr;

        vm::ThreadStateSetter state(vm::kThreadStateWaitSleepJoin);

        // Check for pending interrupt before we go waiting.
        il2cpp::vm::Thread::CheckCurrentThreadForInterruptAndThrowIfNecessary();

        if (ms == -1)
            return handle->Wait();

        return handle->Wait((uint32_t)ms);
    }

    int32_t WaitHandle::SignalAndWait_Internal(intptr_t toSignal, intptr_t toWaitOn, int32_t ms)
    {
        os::Handle* toSignalOsHandle = (os::Handle*)toSignal;
        toSignalOsHandle->Signal();

        return waitone_internal(NULL, toWaitOn, ms, true) ? 0 : 1;
    }

#define MANAGED_WAIT_FAILED 0x7fffffff
#define MANAGED_WAIT_OBJECT_0 0x00000000
#define MANAGED_WAIT_TIMEOUT 258
#define MANAGED_WAIT_ABANDONED_0 0x00000080L

    static int32_t map_native_wait_result_to_managed(UnityPalWaitStatus val, int32_t numobjects)
    {
        switch (val)
        {
            case kWaitStatusSuccess:
                return MANAGED_WAIT_OBJECT_0 + val;
            case  kWaitStatusAbandoned:
                return MANAGED_WAIT_ABANDONED_0 + val;
            case  kWaitStatusFailure:
                return MANAGED_WAIT_FAILED;
            case  kWaitStatusTimeout:
                return MANAGED_WAIT_TIMEOUT;
            default:
                return MANAGED_WAIT_FAILED;
        }
    }

    int32_t WaitHandle::Wait_internal(intptr_t* handles, int32_t numHandles, bool waitAll, int32_t timeouts)
    {
        vm::ThreadStateSetter state(vm::kThreadStateWaitSleepJoin);

        if (numHandles == 1)
        {
            os::WaitStatus status = ((os::Handle**)handles)[0]->Wait((uint32_t)timeouts, true);

            // The managed code expects either success or timeout from this function, so
            // throw away any other error codes.
            if (status != kWaitStatusSuccess)
                status = kWaitStatusTimeout;
            return map_native_wait_result_to_managed(status, 1);
        }

        std::vector<os::Handle*> osWaitHandles((os::Handle**)handles, (os::Handle**)handles + numHandles);

        if (waitAll)
        {
            if (os::Handle::WaitAll(osWaitHandles, timeouts))
            {
                return map_native_wait_result_to_managed(kWaitStatusSuccess, numHandles);
            }
            else
            {
                return map_native_wait_result_to_managed(kWaitStatusTimeout, numHandles);
            }
        }
        else
            return os::Handle::WaitAny(osWaitHandles, timeouts);
    }
} /* namespace Threading */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\mscorlib\System.Threading\WaitHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\Microsoft.Win32\NativeMethods.cpp---------------
.
.
#include "il2cpp-config.h"
#include "NativeMethods.h"
#include "os/NativeMethods.h"
#include "os/Process.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace Microsoft
{
namespace Win32
{
    bool NativeMethods::CloseProcess(intptr_t handle)
    {
        return os::NativeMethods::CloseProcess((il2cpp::os::ProcessHandle*)handle);
    }

    bool NativeMethods::GetExitCodeProcess(intptr_t processHandle, int32_t* exitCode)
    {
        auto result = os::NativeMethods::GetExitCodeProcess((il2cpp::os::ProcessHandle*)processHandle, exitCode);
        vm::Exception::RaiseIfError(result.GetError());
        return result.Get();
    }

    bool NativeMethods::GetProcessTimes(intptr_t handle, int64_t* creation, int64_t* exit, int64_t* kernel, int64_t* user)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::SetPriorityClass, "IL2CPP does not support process times");
        return false;
    }

    bool NativeMethods::GetProcessWorkingSetSize(intptr_t handle, intptr_t* min, intptr_t* max)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::SetPriorityClass, "IL2CPP does not support process working set size");
        return false;
    }

    bool NativeMethods::SetPriorityClass(intptr_t handle, int32_t priorityClass)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::SetPriorityClass, "IL2CPP does not support process priority");
        return false;
    }

    bool NativeMethods::SetProcessWorkingSetSize(intptr_t handle, intptr_t min, intptr_t max)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::SetPriorityClass, "IL2CPP does not support process working set size");
        return false;
    }

    bool NativeMethods::TerminateProcess(intptr_t processHandle, int32_t exitCode)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::SetPriorityClass, "IL2CPP does not support process termination");
        return false;
    }

    int32_t NativeMethods::GetCurrentProcessId()
    {
        return os::NativeMethods::GetCurrentProcessId();
    }

    int32_t NativeMethods::GetPriorityClass(intptr_t handle)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::GetPriorityClass, "IL2CPP does not support process priority");
        return 0;
    }

    int32_t NativeMethods::WaitForInputIdle(intptr_t handle, int32_t milliseconds)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::GetPriorityClass, "IL2CPP does not support waiting for input idle for a process");
        return 0;
    }

    intptr_t NativeMethods::GetCurrentProcess()
    {
        auto currentProcess = os::NativeMethods::GetCurrentProcess();
        vm::Exception::RaiseIfError(currentProcess.GetError());
        return reinterpret_cast<intptr_t>(currentProcess.Get());
    }
} // namespace Win32
} // namespace Microsoft
} // namespace System
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\Microsoft.Win32\NativeMethods.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\Mono.Net.Security\MonoTlsProviderFactory.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MonoTlsProviderFactory.h"
#include "vm/String.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace Mono
{
namespace Net
{
namespace Security
{
    bool MonoTlsProviderFactory::IsBtlsSupported()
    {
        return false;
    }

    Il2CppString* MonoTlsProviderFactory::GetDefaultProviderForPlatform()
    {
#if IL2CPP_TARGET_IOS
        return vm::String::New("apple");
#else
        return vm::String::New("mbedtls");
#endif
    }
} // namespace Security
} // namespace Net
} // namespace Mono
} // namespace System
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\Mono.Net.Security\MonoTlsProviderFactory.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\DefaultTraceListener.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/System/System.Diagnostics/DefaultTraceListener.h"
#include "os/Debug.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Diagnostics
{
    void DefaultTraceListener::WriteWindowsDebugString(Il2CppChar* message)
    {
        DECLARE_IL2CPP_CHAR_PTR_AS_STRING_VIEW_OF_NATIVE_CHARS(messageNative, message);
        il2cpp::os::Debug::WriteString(messageNative);
    }
} /* namespace Diagnostics */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\DefaultTraceListener.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\FileVersionInfo.cpp---------------
.
.
#include "il2cpp-config.h"
#include "FileVersionInfo.h"

#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Diagnostics
{
    void FileVersionInfo::GetVersionInfo_icall(Il2CppObject* thisPtr, Il2CppChar* fileName, int32_t fileName_length)
    {
        NOT_SUPPORTED_IL2CPP(FileVersionInfo::GetVersionInfo_icall, "This icall is not supported by il2cpp.");
    }
} /* namespace Diagnostics */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\FileVersionInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\Process.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/System/System.Diagnostics/Process.h"
#include "os/Process.h"
#include "vm/Exception.h"
#include "vm/String.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Diagnostics
{
    bool Process::CreateProcess_internal(Il2CppObject* startInfo, intptr_t _stdin, intptr_t _stdout, intptr_t _stderr, ProcInfo* procInfo)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Process::CreateProcess_internal);

        return false;
    }

    bool Process::ShellExecuteEx_internal(Il2CppObject* startInfo, ProcInfo* procInfo)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Process::ShellExecuteEx_internal);

        return false;
    }

    Il2CppArray* Process::GetModules_icall(Il2CppObject* thisPtr, intptr_t handle)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Process::GetModules_icall);

        return 0;
    }

    Il2CppArray* Process::GetProcesses_internal()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Process::GetProcesses_internal);

        return 0;
    }

    int64_t Process::GetProcessData(int32_t pid, int32_t data_type, int32_t* error)
    {
        NOT_SUPPORTED_IL2CPP(NativeMethods::GetProcessData, "IL2CPP does not support access to process data");
        return 0;
    }

    intptr_t Process::GetProcess_internal(int32_t pid)
    {
        auto process = os::Process::GetProcess(pid);
        vm::Exception::RaiseIfError(process.GetError());
        return reinterpret_cast<intptr_t>(process.Get());
    }

    Il2CppString* Process::ProcessName_icall(intptr_t handle)
    {
        os::ProcessHandle *pHandle = (os::ProcessHandle*)handle;
        auto name = os::Process::GetProcessName(pHandle);
        vm::Exception::RaiseIfError(name.GetError());
        return il2cpp::vm::String::New(name.Get().c_str());
    }

    intptr_t Process::MainWindowHandle_icall(int32_t pid)
    {
        return os::Process::GetMainWindowHandle(pid);
    }
} /* namespace Diagnostics */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\Process.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\Stopwatch.cpp---------------
.
.
#include "il2cpp-config.h"
#include "icalls/System/System.Diagnostics/Stopwatch.h"
#include "os/Time.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Diagnostics
{
    int64_t Stopwatch::GetTimestamp()
    {
        return il2cpp::os::Time::GetTicks100NanosecondsMonotonic();
    }
} /* namespace Diagnostics */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Diagnostics\Stopwatch.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.IO\FileSystemWatcher.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/System/System.IO/FileSystemWatcher.h"
#include "os/FileSystemWatcher.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace IO
{
    int32_t FileSystemWatcher::InternalSupportsFSW()
    {
        return os::FileSystemWatcher::IsSupported();
    }
} /* namespace IO */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.IO\FileSystemWatcher.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net\Dns.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/System/System.Net/Dns.h"

#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "gc/GarbageCollector.h"
#include "vm/Array.h"
#include "vm/String.h"
#include "os/Socket.h"
#include "os/WaitStatus.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Net
{
    bool Dns::GetHostByAddr_icall(Il2CppString* addr, Il2CppString** h_name, Il2CppArray** h_aliases, Il2CppArray** h_addr_list, int32_t hint)
    {
        std::string name;
        std::vector<std::string> aliases;
        std::vector<std::string> addr_list;

        const std::string address = il2cpp::utils::StringUtils::Utf16ToUtf8(addr->chars);
        const os::WaitStatus result = os::Socket::GetHostByAddr(address, name, aliases, addr_list);

        *h_name = vm::String::New(name.c_str());
        *h_aliases = vm::Array::New(il2cpp_defaults.string_class, (il2cpp_array_size_t)aliases.size());
        *h_addr_list = vm::Array::New(il2cpp_defaults.string_class, (il2cpp_array_size_t)addr_list.size());

        int32_t index = 0;

        std::vector<std::string>::const_iterator it = aliases.begin();
        while (it != aliases.end())
        {
            il2cpp_array_setref(*h_aliases, index++, vm::String::New((*it).c_str()));
            ++it;
        }

        index = 0;

        it = addr_list.begin();
        while (it != addr_list.end())
        {
            il2cpp_array_setref(*h_addr_list, index++, vm::String::New((*it).c_str()));
            ++it;
        }

        return (result != kWaitStatusFailure);
    }

    bool Dns::GetHostByName_icall(Il2CppString* host, Il2CppString** h_name, Il2CppArray** h_aliases, Il2CppArray** h_addr_list, int32_t hint)
    {
        std::string name;
        std::vector<std::string> aliases;
        std::vector<std::string> addr_list;

        const std::string host_name = il2cpp::utils::StringUtils::Utf16ToUtf8(host->chars);
        const os::WaitStatus result = os::Socket::GetHostByName(host_name, name, aliases, addr_list);

        *h_name = vm::String::New(name.c_str());
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)h_name);
        *h_aliases = vm::Array::New(il2cpp_defaults.string_class, (il2cpp_array_size_t)aliases.size());
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)h_aliases);
        *h_addr_list = vm::Array::New(il2cpp_defaults.string_class, (il2cpp_array_size_t)addr_list.size());
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)h_addr_list);

        int32_t index = 0;

        std::vector<std::string>::const_iterator it = aliases.begin();
        while (it != aliases.end())
        {
            il2cpp_array_setref(*h_aliases, index++, vm::String::New((*it).c_str()));
            ++it;
        }

        index = 0;

        it = addr_list.begin();
        while (it != addr_list.end())
        {
            il2cpp_array_setref(*h_addr_list, index++, vm::String::New((*it).c_str()));
            ++it;
        }

        return (result != kWaitStatusFailure);
    }

    bool Dns::GetHostName_icall(Il2CppString** h_name)
    {
        std::string host_name;

        *h_name = (os::Socket::GetHostName(host_name) != kWaitStatusFailure)
            ? vm::String::New(host_name.c_str())
            : NULL;


        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)h_name);

        return *h_name != NULL;
    }
} /* namespace Net */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net\Dns.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.NetworkInformation\LinuxNetworkInterface.cpp---------------
.
.
#include "il2cpp-config.h"
#include "LinuxNetworkInterface.h"
#include "il2cpp-api.h"
#include "vm/AndroidRuntime.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Net
{
namespace NetworkInformation
{
    bool LinuxNetworkInterface::unitydroid_get_network_interface_up_state(Il2CppString* ifName, bool* isUp)
    {
        return vm::AndroidRuntime::GetNetworkInterfaceUpState(ifName, isUp);
    }
} // namespace NetworkInformation
} // namespace Net
} // namespace System
} // namespace System
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.NetworkInformation\LinuxNetworkInterface.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.NetworkInformation\MacOsIPInterfaceProperties.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MacOsIPInterfaceProperties.h"

#if IL2CPP_TARGET_OSX || IL2CPP_TARGET_IOS

#include "il2cpp-class-internals.h"
#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Path.h"
#include "vm/String.h"
#include "vm/Exception.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"

#include <sys/socket.h>
#include <net/if.h>
#include <net/if_dl.h>
#if IL2CPP_TARGET_OSX
#include <net/route.h>
#else

// Borrowed necessary defines and structs from the macOS route.h for use on iOS/tvOS

/*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 */
struct rt_metrics
{
    u_int32_t       rmx_locks;      /* Kernel leaves these values alone */
    u_int32_t       rmx_mtu;        /* MTU for this path */
    u_int32_t       rmx_hopcount;   /* max hops expected */
    int32_t         rmx_expire;     /* lifetime for route, e.g. redirect */
    u_int32_t       rmx_recvpipe;   /* inbound delay-bandwidth product */
    u_int32_t       rmx_sendpipe;   /* outbound delay-bandwidth product */
    u_int32_t       rmx_ssthresh;   /* outbound gateway buffer limit */
    u_int32_t       rmx_rtt;        /* estimated round trip time */
    u_int32_t       rmx_rttvar;     /* estimated rtt variance */
    u_int32_t       rmx_pksent;     /* packets sent using this route */
    u_int32_t       rmx_state;      /* route state */
    u_int32_t       rmx_filler[3];  /* will be used for T/TCP later */
};

/*
 * Structures for routing messages.
 */
struct rt_msghdr
{
    u_short rtm_msglen;     /* to skip over non-understood messages */
    u_char  rtm_version;    /* future binary compatibility */
    u_char  rtm_type;       /* message type */
    u_short rtm_index;      /* index for associated ifp */
    int     rtm_flags;      /* flags, incl. kern & message, e.g. DONE */
    int     rtm_addrs;      /* bitmask identifying sockaddrs in msg */
    pid_t   rtm_pid;        /* identify sender */
    int     rtm_seq;        /* for sender to identify action */
    int     rtm_errno;      /* why failed */
    int     rtm_use;        /* from rtentry */
    u_int32_t rtm_inits;    /* which metrics we are initializing */
    struct rt_metrics rtm_rmx; /* metrics themselves */
};

#define RTA_GATEWAY     0x2     /* gateway sockaddr present */
#define RTM_VERSION     5       /* Up the ante and ignore older versions */
#endif

#include <netinet/in.h>
#include <sys/param.h>
#include <sys/sysctl.h>
#include <stdlib.h>
#include <string.h>


static in_addr_t gateway_from_rtm(struct rt_msghdr *rtm)
{
    struct sockaddr *gw;
    unsigned int l;

    struct sockaddr *addr = (struct sockaddr *)(rtm + 1);
    l = roundup(addr->sa_len, sizeof(long));
    gw = (struct sockaddr *)((char *)addr + l);

    if (rtm->rtm_addrs & RTA_GATEWAY)
    {
        if (gw->sa_family == AF_INET)
        {
            struct sockaddr_in *sockin = (struct sockaddr_in *)gw;
            return (sockin->sin_addr.s_addr);
        }
    }

    return 0;
}

#endif // IL2CPP_TARGET_OSX || IL2CPP_TARGET_IOS

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Net
{
namespace NetworkInformation
{
    bool MacOsIPInterfaceProperties::ParseRouteInfo_icall(Il2CppString* iface, Il2CppArray** gw_addr_list)
    {
#if IL2CPP_TARGET_OSX || IL2CPP_TARGET_IOS
        size_t needed;
        in_addr_t in;
        int mib[6];
        int num_gws = 0;
        int gwnum = 0;
        unsigned int ifindex = 0;
        char *buf;
        char *next;
        char *lim;
        struct rt_msghdr *rtm;

        std::string ifacename = il2cpp::utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(iface));

        if ((ifindex = if_nametoindex(ifacename.c_str())) == 0)
            return false;

        // MIB array defining data to read from sysctl
        mib[0] = CTL_NET; // Networking
        mib[1] = PF_ROUTE; // Routing messages
        mib[2] = 0; // Protocol number (always zero)
        mib[3] = AF_INET; // Address family (IPv4)
        mib[4] = NET_RT_DUMP; // Dump routing table
        mib[5] = 0; //

        // First sysctl call with oldp set to NULL to determine size of available data
        if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
            return false;

        // Allocate suffcient memory for available data based on the previous sysctl call
        if ((buf = (char*)IL2CPP_MALLOC(needed)) == NULL)
            return false;

        // Second sysctl call to retrieve data into appropriately sized buffer
        if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
        {
            IL2CPP_FREE(buf);
            return false;
        }


        lim = buf + needed;
        for (next = buf; next < lim; next += rtm->rtm_msglen)
        {
            rtm = (struct rt_msghdr *)next;
            if (rtm->rtm_version != RTM_VERSION)
                continue;
            if (rtm->rtm_index != ifindex)
                continue;
            if ((in = gateway_from_rtm(rtm)) == 0)
                continue;
            num_gws++;
        }

        *gw_addr_list = (Il2CppArray*)vm::Array::New(il2cpp_defaults.string_class, num_gws);

        for (next = buf; next < lim; next += rtm->rtm_msglen)
        {
            rtm = (struct rt_msghdr *)next;
            if (rtm->rtm_version != RTM_VERSION)
                continue;
            if (rtm->rtm_index != ifindex)
                continue;
            if ((in = gateway_from_rtm(rtm)) == 0)
                continue;

            char addr[16], *ptr;
            int len;

            ptr = (char *)&in;
            len = snprintf(addr, sizeof(addr), "%u.%u.%u.%u",
                (unsigned char)ptr[0],
                (unsigned char)ptr[1],
                (unsigned char)ptr[2],
                (unsigned char)ptr[3]);

            if ((len >= sizeof(addr)) || (len < 0))
                continue;

            il2cpp_array_setref(*gw_addr_list, gwnum, il2cpp::vm::String::New(addr));
            gwnum++;
        }

        IL2CPP_FREE(buf);

        return true;
#else
        IL2CPP_NOT_IMPLEMENTED_ICALL(MacOsIPInterfaceProperties::ParseRouteInfo_icall);
        IL2CPP_UNREACHABLE;
        return false;
#endif
    }
} // namespace NetworkInformation
} // namespace Net
} // namespace System
} // namespace System
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.NetworkInformation\MacOsIPInterfaceProperties.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.Sockets\Socket.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/System/System.Net.Sockets/Socket.h"

#include "il2cpp-class-internals.h"
#include "gc/WriteBarrier.h"
#include "os/Socket.h"
#include "os/Mutex.h"
#include "os/Thread.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/String.h"
#include "vm/Thread.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Net
{
namespace Sockets
{
    static os::AddressFamily convert_address_family(AddressFamily family)
    {
        switch (family)
        {
            case kAddressFamilyUnknown:
            case kAddressFamilyImpLink:
            case kAddressFamilyPup:
            case kAddressFamilyChaos:
            case kAddressFamilyIso:
            case kAddressFamilyEcma:
            case kAddressFamilyDataKit:
            case kAddressFamilyCcitt:
            case kAddressFamilyDataLink:
            case kAddressFamilyLat:
            case kAddressFamilyHyperChannel:
            case kAddressFamilyNetBios:
            case kAddressFamilyVoiceView:
            case kAddressFamilyFireFox:
            case kAddressFamilyBanyan:
            case kAddressFamilyAtm:
            case kAddressFamilyCluster:
            case kAddressFamilyIeee12844:
            case kAddressFamilyNetworkDesigners:
                // Unsupported
                return os::kAddressFamilyError;

            case kAddressFamilyUnspecified:
                return os::kAddressFamilyUnspecified;

            case kAddressFamilyUnix:
                return os::kAddressFamilyUnix;

            case kAddressFamilyInterNetwork:
                return os::kAddressFamilyInterNetwork;

            case kAddressFamilyIpx:
                return os::kAddressFamilyIpx;

            case kAddressFamilySna:
                return os::kAddressFamilySna;

            case kAddressFamilyDecNet:
                return os::kAddressFamilyDecNet;

            case kAddressFamilyAppleTalk:
                return os::kAddressFamilyAppleTalk;

            case kAddressFamilyInterNetworkV6:
                return os::kAddressFamilyInterNetworkV6;

            case kAddressFamilyIrda:
                return os::kAddressFamilyIrda;

            default:
                return os::kAddressFamilyError;
        }

        return os::kAddressFamilyError;
    }

    static os::SocketType convert_socket_type(SocketType type)
    {
        switch (type)
        {
            case kSocketTypeStream:
                return os::kSocketTypeStream;

            case kSocketTypeDgram:
                return os::kSocketTypeDgram;

            case kSocketTypeRaw:
                return os::kSocketTypeRaw;

            case kSocketTypeRdm:
                return os::kSocketTypeRdm;

            case kSocketTypeSeqpacket:
                return os::kSocketTypeSeqpacket;

            default:
                return os::kSocketTypeError;
        }

        return os::kSocketTypeError;
    }

    static os::ProtocolType convert_socket_protocol(ProtocolType protocol)
    {
        switch (protocol)
        {
            case kProtocolTypeIP:
            case kProtocolTypeIPv6:
            case kProtocolTypeIcmp:
            case kProtocolTypeIgmp:
            case kProtocolTypeGgp:
            case kProtocolTypeTcp:
            case kProtocolTypePup:
            case kProtocolTypeUdp:
            case kProtocolTypeIdp:
            case kProtocolTypeIcmpV6:
                // In this case the enum values map exactly.
                return (os::ProtocolType)protocol;

            case kProtocolTypeND:
            case kProtocolTypeRaw:
            case kProtocolTypeIpx:
            case kProtocolTypeSpx:
            case kProtocolTypeSpxII:
            case kProtocolTypeUnknown:
                // Everything else in unsupported
                return os::kProtocolTypeUnknown;

            default:
                return os::kProtocolTypeUnknown;
        }

        return os::kProtocolTypeUnknown;
    }

    static AddressFamily convert_from_os_address_family(os::AddressFamily family)
    {
        switch (family)
        {
            case os::kAddressFamilyUnspecified:
                return kAddressFamilyUnspecified;

            case os::kAddressFamilyUnix:
                return kAddressFamilyUnix;

            case os::kAddressFamilyInterNetwork:
                return kAddressFamilyInterNetwork;

//  #ifdef AF_IPX
            case os::kAddressFamilyIpx:
                return kAddressFamilyIpx;
//  #endif

            case os::kAddressFamilySna:
                return kAddressFamilySna;

            case os::kAddressFamilyDecNet:
                return kAddressFamilyDecNet;

            case os::kAddressFamilyAppleTalk:
                return kAddressFamilyAppleTalk;

//  #ifdef AF_INET6
            case os::kAddressFamilyInterNetworkV6:
                return kAddressFamilyInterNetworkV6;
//  #endif

//  #ifdef AF_IRDA
            case os::kAddressFamilyIrda:
                return kAddressFamilyIrda;
//  #endif
            default:
                break;
        }

        return kAddressFamilyUnknown;
    }

    static os::SocketFlags convert_socket_flags(SocketFlags flags)
    {
        return (os::SocketFlags)flags;
    }

    static Il2CppSocketAddress* end_point_info_to_socket_address(const os::EndPointInfo &info)
    {
        static Il2CppClass *System_Net_SocketAddress = NULL;

        Il2CppSocketAddress *socket_address = NULL;

        if (!System_Net_SocketAddress)
        {
            System_Net_SocketAddress = vm::Class::FromName(
                vm::Assembly::GetImage(
                    vm::Assembly::Load("System.dll")),
                "System.Net", "SocketAddress");
        }

        socket_address = (Il2CppSocketAddress*)vm::Object::New(System_Net_SocketAddress);

        const AddressFamily family = convert_from_os_address_family(info.family);

        if (info.family == os::kAddressFamilyInterNetwork)
        {
            socket_address->m_Size = 8;
            IL2CPP_OBJECT_SETREF(socket_address, data, vm::Array::New(il2cpp_defaults.byte_class, 8));

            const uint16_t port = info.data.inet.port;
            const uint32_t address = info.data.inet.address;

            il2cpp_array_set(socket_address->data, uint8_t, 0, (family >> 0) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 1, (family >> 8) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 2, (port >> 8) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 3, (port >> 0) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 4, (address >> 24) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 5, (address >> 16) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 6, (address >>  8) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 7, (address >>  0) & 0xFF);
        }
        else if (info.family == os::kAddressFamilyUnix)
        {
            const int32_t path_len = (int32_t)strlen(info.data.path);

            socket_address->m_Size = 3 + path_len;
            IL2CPP_OBJECT_SETREF(socket_address, data, vm::Array::New(il2cpp_defaults.byte_class, 3 + path_len));

            il2cpp_array_set(socket_address->data, uint8_t, 0, (family >> 0) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 1, (family >> 8) & 0xFF);

            for (int32_t i = 0; i <= path_len; i++)
                il2cpp_array_set(socket_address->data, uint8_t, i + 2, info.data.path[i]);

            il2cpp_array_set(socket_address->data, uint8_t, 2 + path_len, 0);
        }
        else if (info.family == os::kAddressFamilyInterNetworkV6)
        {
            socket_address->m_Size = 28;
            IL2CPP_OBJECT_SETREF(socket_address, data, vm::Array::New(il2cpp_defaults.byte_class, 28));

            il2cpp_array_set(socket_address->data, uint8_t, 0, (family >> 0) & 0xFF);
            il2cpp_array_set(socket_address->data, uint8_t, 1, (family >> 8) & 0xFF);

            // Note that we start at the 3rd byte in both the managed array, where the first
            // two bytes are the family, set just above this. We also start at the third byte
            // in the info.data.raw array, as the first two bytes are unused and garbage data.
            for (int i = 2; i < 28; ++i)
                il2cpp_array_set(socket_address->data, uint8_t, i, info.data.raw[i]);
        }
        else
        {
            // Not supported
            return NULL;
        }

        return socket_address;
    }

    static bool check_thread_status()
    {
        static baselib::ReentrantLock _mutex;

        os::FastAutoLock lock(&_mutex);

        Il2CppThread *current_thread = vm::Thread::Current();
        const vm::ThreadState state = vm::Thread::GetState(current_thread);

        if (state & vm::kThreadStateAbortRequested)
            return false;

        if (state & vm::kThreadStateSuspendRequested)
        {
            IL2CPP_ASSERT(0 && "kThreadStateSuspendRequested not supported yet!");
            return true;
        }

        if (state & vm::kThreadStateStopRequested)
            return false;

        if (current_thread->GetInternalThread()->interruption_requested)
        {
            IL2CPP_ASSERT(0 && "thread->interruption_requested not supported yet!");
            return false;
        }

        return true;
    }

/// Acquire os::SocketHandle in IntPtr "socket" for the current scope.
#define AUTO_ACQUIRE_SOCKET \
    os::SocketHandleWrapper socketHandle (os::PointerToSocketHandle (reinterpret_cast<void*>(socket)))

#define RETURN_IF_SOCKET_IS_INVALID(...) \
    if (!socketHandle.IsValid ()) \
    { \
        *error = os::kErrorCodeInvalidHandle; \
        return __VA_ARGS__; \
    }

    intptr_t Socket::Accept_icall(intptr_t socket, int32_t* error, bool blocking)
    {
        *error = 0;

        os::Socket *new_sock = NULL;

        AUTO_ACQUIRE_SOCKET;

        if (socketHandle.IsValid())
        {
            const os::WaitStatus status = socketHandle->Accept(&new_sock);

            if (status == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else
        {
            *error = os::kErrorCodeInvalidHandle;
        }

        intptr_t ret;
        if (new_sock)
            ret = static_cast<intptr_t>(os::CreateSocketHandle(new_sock));
        else
            ret = static_cast<intptr_t>(os::kInvalidSocketHandle);

        return ret;
    }

    bool Socket::SupportsPortReuse(int32_t proto)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Socket::SupportsPortReuse);
        return false;
    }

    int32_t Socket::Available_icall(intptr_t socket, int32_t* error)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(0);

        int32_t available = 0;

        const os::WaitStatus status = socketHandle->Available(&available);

        if (status == kWaitStatusFailure)
        {
            *error = socketHandle->GetLastError();
            return 0;
        }

        return available;
    }

    void UnpackIPv6AddressFromBuffer(const uint8_t* buffer, int32_t length, uint16_t* port, uint8_t* address, uint32_t* scope)
    {
        if (length < 28)
        {
            vm::Exception::Raise(vm::Exception::GetSystemException());
            return;
        }

        *port = ((buffer[2] << 8) | buffer[3]);

        for (int i = 0; i < ipv6AddressSize; i++)
            address[i] = buffer[i + 8];

        *scope = (uint32_t)((buffer[27] << 24) +
            (buffer[26] << 16) +
            (buffer[25] << 8) +
            (buffer[24]));
    }

    void Socket::Bind_icall(intptr_t socket, Il2CppSocketAddress* socket_address, int32_t* error)
    {
        *error = 0;

        const int32_t length = ARRAY_LENGTH_AS_INT32(socket_address->data->max_length);
        const uint8_t *buffer = (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress(socket_address->data);

        if (length < 2)
        {
            vm::Exception::Raise(vm::Exception::GetSystemException());
            return;
        }

        const os::AddressFamily family = convert_address_family((AddressFamily)(buffer[0] | (buffer[1] << 8)));

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        if (family == os::kAddressFamilyInterNetwork)
        {
            if (length < 8)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return;
            }

            const uint16_t port = ((buffer[2] << 8) | buffer[3]);
            const uint32_t address = ((buffer[4] << 24) | (buffer[5] << 16) | (buffer[6] << 8) | buffer[7]);

            const os::WaitStatus status = socketHandle->Bind(address, port);

            if (status == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyUnix)
        {
            if (length - 2 >= END_POINT_MAX_PATH_LEN)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return;
            }

            char path[END_POINT_MAX_PATH_LEN] = {0};

            for (int32_t i = 0; i < (length - 2); ++i)
            {
                path[i] = (char)buffer[i + 2];
            }

            const os::WaitStatus status = socketHandle->Bind(path);

            if (status == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyInterNetworkV6)
        {
            uint16_t port;
            uint8_t address[ipv6AddressSize] = {0};
            uint32_t scope;
            UnpackIPv6AddressFromBuffer(buffer, length, &port, address, &scope);

            auto status = socketHandle->Bind(address, scope, port);
            vm::Exception::RaiseIfError(status.GetError());

            if (status.Get() == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else
        {
            *error = os::kWSAeafnosupport;
            return;
        }
    }

    void Socket::Blocking_icall(intptr_t socket, bool block, int32_t* error)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        const os::WaitStatus status = socketHandle->SetBlocking(block);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();
    }

    void Socket::Close_icall(intptr_t socket, int32_t* error)
    {
        *error = 0;

        // Socket::Close get invoked when running the finalizers; in case Socket_internal
        // didn't succeed, the socket has a NULL value and thus we don't need to do
        // anything here.
        if (os::PointerToSocketHandle(reinterpret_cast<void*>(socket)) == os::kInvalidSocketHandle)
            return;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        // There is an implicit acquisition happening when we create the socket which we undo
        // now that we have closed the socket.
        os::ReleaseSocketHandle(socketHandle.GetHandle(), socketHandle.GetSocket(), true);

        socketHandle->Close();
    }

    void Socket::Connect_icall(intptr_t socket, Il2CppSocketAddress* socket_address, int32_t* error, bool blocking)
    {
        *error = 0;

        const int32_t length = ARRAY_LENGTH_AS_INT32(socket_address->data->max_length);
        const uint8_t *buffer = (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress(socket_address->data);

        if (length < 2)
        {
            vm::Exception::Raise(vm::Exception::GetSystemException());
            return;
        }

        const os::AddressFamily family = convert_address_family((AddressFamily)(buffer[0] | (buffer[1] << 8)));

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        if (family == os::kAddressFamilyInterNetwork)
        {
            if (length < 8)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return;
            }

            const uint16_t port = ((buffer[2] << 8) | buffer[3]);
            const uint32_t address = ((buffer[4] << 24) | (buffer[5] << 16) | (buffer[6] << 8) | buffer[7]);

            const os::WaitStatus status = socketHandle->Connect(address, port);

            if (status == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyUnix)
        {
            if (length - 2 >= END_POINT_MAX_PATH_LEN)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return;
            }

            char path[END_POINT_MAX_PATH_LEN] = {0};

            for (int32_t i = 0; i < (length - 2); ++i)
            {
                path[i] = (char)buffer[i + 2];
            }

            const os::WaitStatus status = socketHandle->Connect(path);

            if (status == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyInterNetworkV6)
        {
            uint16_t port;
            uint8_t address[ipv6AddressSize] = {0};
            uint32_t scope;
            UnpackIPv6AddressFromBuffer(buffer, length, &port, address, &scope);

            auto status = socketHandle->Connect(address, scope, port);
            vm::Exception::RaiseIfError(status.GetError());

            if (status.Get() == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else
        {
            *error = os::kWSAeafnosupport;
            return;
        }
    }

    void Socket::Disconnect_icall(intptr_t socket, bool reuse, int32_t* error)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        const os::WaitStatus status = socketHandle->Disconnect(reuse);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();
    }

    void Socket::GetSocketOption_arr_icall(intptr_t socket, SocketOptionLevel level, SocketOptionName name, Il2CppArray** byte_val, int32_t *error)
    {
        *error = 0;

        // Note: for now the options map one to one.
        const os::SocketOptionName system_name = (os::SocketOptionName)(name);
        const os::SocketOptionLevel system_level = (os::SocketOptionLevel)(level);

        int32_t length = ARRAY_LENGTH_AS_INT32((*byte_val)->max_length);
        uint8_t *buffer = (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress((*byte_val));

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        const os::WaitStatus status = socketHandle->GetSocketOption(system_level, system_name, buffer, &length);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();
    }

    void Socket::GetSocketOption_obj_icall(intptr_t socket, SocketOptionLevel level, SocketOptionName name, Il2CppObject** obj_val, int32_t *error)
    {
        *error = 0;

        // Note: for now the options map one to one.
        const os::SocketOptionName system_name = (os::SocketOptionName)(name);
        const os::SocketOptionLevel system_level = (os::SocketOptionLevel)(level);

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        int32_t first = 0;
        int32_t second = 0;

        const os::WaitStatus status = socketHandle->GetSocketOptionFull(system_level, system_name, &first, &second);

        if (status == kWaitStatusFailure)
        {
            *error = socketHandle->GetLastError();
            return;
        }

        switch (name)
        {
            case kSocketOptionNameLinger:
            {
                static Il2CppClass *System_Net_Sockets_LingerOption = NULL;

                if (!System_Net_Sockets_LingerOption)
                {
                    System_Net_Sockets_LingerOption = vm::Class::FromName(
                        vm::Assembly::GetImage(
                            vm::Assembly::Load("System.dll")),
                        "System.Net.Sockets", "LingerOption");
                }

                *obj_val = vm::Object::New(System_Net_Sockets_LingerOption);

                const FieldInfo *enabled_field_info = vm::Class::GetFieldFromName(System_Net_Sockets_LingerOption, "enabled");
                const FieldInfo *seconds_field_info = vm::Class::GetFieldFromName(System_Net_Sockets_LingerOption, "lingerTime");

                *((bool*)((char*)(*obj_val) + enabled_field_info->offset)) = (first ? 1 : 0);
                *((int32_t*)((char*)(*obj_val) + seconds_field_info->offset)) = second;
            }

            break;

            case kSocketOptionNameDontLinger:
            case kSocketOptionNameSendTimeout:
            case kSocketOptionNameReceiveTimeout:
            default:
                *obj_val = vm::Object::Box(il2cpp_defaults.int32_class, &first);
                break;
        }
    }

    void Socket::Listen_icall(intptr_t socket, int32_t backlog, int32_t* error)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        const os::WaitStatus status = socketHandle->Listen(backlog);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();
    }

    static os::PollFlags select_mode_to_poll_flags(SelectMode mode)
    {
        switch (mode)
        {
            case kSelectModeSelectRead:
                return os::kPollFlagsIn;

            case kSelectModeSelectWrite:
                return os::kPollFlagsOut;

            case kSelectModeSelectError:
                return os::kPollFlagsErr;
        }

        return os::kPollFlagsNone;
    }

    bool Socket::Poll_icall(intptr_t socket, SelectMode mode, int32_t timeout, int32_t* error)
    {
        *error = 0;

        os::PollRequest request;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(false);

        request.fd = socketHandle.GetSocket()->GetDescriptor();
        request.events = select_mode_to_poll_flags(mode);
        request.revents = os::kPollFlagsNone;

        if (request.events == os::kPollFlagsNone)
        {
            *error = os::kWSAefault;
            return false;
        }

        std::vector<os::PollRequest> requests;

        requests.push_back(request);

        // The timeout from managed code is in microseconds. Convert it to milliseconds
        // for the poll implementation.
        timeout = (timeout >= 0) ? (timeout / 1000) : -1;

        int32_t results = 0;
        const os::WaitStatus result = os::Socket::Poll(requests, timeout, &results, error);

        if (result == kWaitStatusFailure || results == 0)
            return false;

        return (requests[0].revents != os::kPollFlagsNone);
    }

    int32_t Socket::Receive_array_icall(intptr_t socket, os::WSABuf* bufarray, int32_t count, SocketFlags flags, int32_t *error, bool blocking)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(0);

        const os::SocketFlags c_flags = convert_socket_flags(flags);

        int32_t len = 0;

        const os::WaitStatus status = socketHandle->ReceiveArray(bufarray, count, &len, c_flags);

        if (status == kWaitStatusFailure)
        {
            *error = socketHandle->GetLastError();
            return 0;
        }

        return len;
    }

    int32_t Socket::Receive_icall(intptr_t socket, uint8_t* buffer, int32_t count, SocketFlags flags, int32_t* error, bool blocking)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(0);

        const os::SocketFlags c_flags = convert_socket_flags(flags);

        int32_t len = 0;

        const os::WaitStatus status = socketHandle->Receive(buffer, count, c_flags, &len);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();

        return len;
    }

    int32_t Socket::ReceiveFrom_icall(intptr_t socket, uint8_t* buffer, int32_t count, SocketFlags flags, Il2CppSocketAddress** socket_address, int32_t* error, bool blocking)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(0);

        const os::SocketFlags c_flags = convert_socket_flags(flags);

        int32_t len = 0;

        const int32_t length = ARRAY_LENGTH_AS_INT32((*socket_address)->data->max_length);
        const uint8_t *socket_buffer = (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress((*socket_address)->data);

        if (length < 2)
        {
            vm::Exception::Raise(vm::Exception::GetSystemException());
            return 0;
        }

        const os::AddressFamily family = convert_address_family((AddressFamily)(socket_buffer[0] | (socket_buffer[1] << 8)));

        os::EndPointInfo info;

        info.family = os::kAddressFamilyError;

        if (family == os::kAddressFamilyInterNetwork)
        {
            if (length < 8)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return 0;
            }

            const uint16_t port = ((socket_buffer[2] << 8) | socket_buffer[3]);
            const uint32_t address = ((socket_buffer[4] << 24) | (socket_buffer[5] << 16) | (socket_buffer[6] << 8) | socket_buffer[7]);

            const os::WaitStatus status = socketHandle->RecvFrom(address, port, buffer, count, c_flags, &len, info);

            if (status == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyUnix)
        {
            if (length - 2 >= END_POINT_MAX_PATH_LEN)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return 0;
            }

            char path[END_POINT_MAX_PATH_LEN] = {0};

            for (int32_t i = 0; i < (length - 2); ++i)
            {
                path[i] = (char)socket_buffer[i + 2];
            }

            auto status = socketHandle->RecvFrom(path, buffer, count, c_flags, &len, info);
            vm::Exception::RaiseIfError(status.GetError());

            if (status.Get() == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyInterNetworkV6)
        {
            uint16_t port;
            uint8_t address[ipv6AddressSize] = {0};
            uint32_t scope;
            UnpackIPv6AddressFromBuffer(socket_buffer, length, &port, address, &scope);

            auto status = socketHandle->RecvFrom(address, scope, port, buffer, count, c_flags, &len, info);
            vm::Exception::RaiseIfError(status.GetError());

            if (status.Get() == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else
        {
            *error = os::kWSAeafnosupport;
            return 0;
        }

        *socket_address = (info.family == os::kAddressFamilyError) ? NULL : end_point_info_to_socket_address(info);

        return len;
    }

    Il2CppSocketAddress* Socket::LocalEndPoint_icall(intptr_t socket, int32_t family, int32_t* error)
    {
        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(NULL);

        os::EndPointInfo info;

        memset(&info, 0x00, sizeof(os::EndPointInfo));

        const os::WaitStatus status = socketHandle->GetLocalEndPointInfo(info);

        if (status == kWaitStatusFailure)
        {
            *error = socketHandle->GetLastError();
            return NULL;
        }

        Il2CppSocketAddress *socket_address = end_point_info_to_socket_address(info);

        if (socket_address == NULL)
            *error = os::kWSAeafnosupport;

        return socket_address;
    }

    Il2CppSocketAddress* Socket::RemoteEndPoint_icall(intptr_t socket, int32_t family, int32_t* error)
    {
        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(NULL);

        os::EndPointInfo info;

        memset(&info, 0x00, sizeof(os::EndPointInfo));

        const os::WaitStatus status = socketHandle->GetRemoteEndPointInfo(info);

        if (status == kWaitStatusFailure)
        {
            *error = socketHandle->GetLastError();
            return NULL;
        }

        Il2CppSocketAddress *socket_address = end_point_info_to_socket_address(info);

        if (socket_address == NULL)
            *error = os::kWSAeafnosupport;

        return socket_address;
    }

    void Socket::Select_icall(Il2CppArray** sockets, int32_t timeout, int32_t* error)
    {
        *error = 0;

        // Layout: READ, null, WRITE, null, ERROR, null
        const uint32_t input_sockets_count = ARRAY_LENGTH_AS_INT32((*sockets)->max_length);

        std::vector<os::PollRequest> requests;
        std::vector<os::SocketHandleWrapper> socketHandles;

        requests.reserve(input_sockets_count - 3);

        int32_t mode = 0;

        for (uint32_t i = 0; i < input_sockets_count; ++i)
        {
            Il2CppObject *obj = il2cpp_array_get(*sockets, Il2CppObject*, i);

            if (obj == NULL)
            {
                if (++mode > 3)
                {
                    // Something very bad happened here (ie: the input array was wrong)
                    // so we gracefully terminate the method.
                    *error = os::kWSAefault;
                    return;
                }

                continue;
            }

            FieldInfo *safe_handle_field_info = vm::Class::GetFieldFromName(obj->klass, "m_Handle");
            const Il2CppObject* value = NULL;
            vm::Field::GetValue(obj, safe_handle_field_info, &value);

            const FieldInfo *handle_field_info = vm::Class::GetFieldFromName(value->klass, "handle");
            intptr_t& intPtr = *((intptr_t*)((char*)value + handle_field_info->offset));

            // Acquire socket.
            socketHandles.push_back(os::SocketHandleWrapper());
            os::SocketHandleWrapper& socketHandle = socketHandles.back();
            socketHandle.Acquire(os::PointerToSocketHandle(reinterpret_cast<void*>(intPtr)));

            os::PollRequest request;
            // May 'invalid socket' (-1); we want the error from Poll() in that case.
            request.fd = socketHandle.GetSocket() == NULL ? -1 : socketHandle.GetSocket()->GetDescriptor();
            request.events = (mode == 0 ? os::kPollFlagsIn : (mode == 1 ? os::kPollFlagsOut : os::kPollFlagsErr));
            request.revents = os::kPollFlagsNone;

            requests.push_back(request);
        }

        if (requests.size() == 0)
            return;

        int32_t results = 0;

        // The timeout from managed code is in microseconds. Convert it to milliseconds
        // for the poll implementation.
        timeout = (timeout >= 0) ? (timeout / 1000) : -1;

        const os::WaitStatus result = os::Socket::Poll(requests, timeout, &results, error);

        if (result == kWaitStatusFailure)
        {
            *sockets = NULL;
            return;
        }

        Il2CppArray *new_sockets = vm::Array::New(((Il2CppObject*)(*sockets))->klass->element_class, results + 3);

        if (results > 0)
        {
            mode = 0;

            uint32_t request_index = 0;

            // This odd loop is due to the layout of the sockets input array:
            // Layout: READ, null, WRITE, null, ERROR, null
            // We need to iterate each request and iterate the sockets array, skipping
            // the null entries. We try to avoid an infinite loop here as well.
            uint32_t add_index = 0;
            while (request_index < requests.size())
            {
                const uint32_t input_sockets_index = (request_index + mode);
                if (input_sockets_index > input_sockets_count - 1)
                    break; // We have exhausted the input sockets array, so exit.

                Il2CppObject *obj = il2cpp_array_get(*sockets, Il2CppObject*, input_sockets_index);

                if (obj == NULL)
                {
                    ++mode;
                    continue; // Here is a null entry, skip it without updated the next request index.
                }

                os::PollRequest &request = requests[request_index];

                if (request.revents != os::kPollFlagsNone)
                {
                    switch (mode)
                    {
                        case 0:
                            if (request.revents & (os::kPollFlagsIn | os::kPollFlagsErr))
                            {
                                il2cpp_array_setref(new_sockets, (add_index + mode), obj);
                                add_index++;
                            }
                            break;

                        case 1:
                            if (request.revents & (os::kPollFlagsOut | os::kPollFlagsErr))
                            {
                                il2cpp_array_setref(new_sockets, (add_index + mode), obj);
                                add_index++;
                            }
                            break;

                        default:
                            if (request.revents & os::kPollFlagsErr)
                            {
                                il2cpp_array_setref(new_sockets, (add_index + mode), obj);
                                add_index++;
                            }
                            break;
                    }
                }

                ++request_index;
            }
        }

        *sockets = new_sockets;
    }

    bool Socket::SendFile_icall(intptr_t socket, Il2CppString* filename, Il2CppArray* pre_buffer, Il2CppArray* post_buffer, TransmitFileOptions flags, int32_t* error, bool blocking)
    {
        if (filename == NULL)
            return false;

        os::TransmitFileBuffers t_buffers = {0};

        if (pre_buffer != NULL)
        {
            t_buffers.head = il2cpp_array_addr(pre_buffer, uint8_t, 0);
            t_buffers.head_length = ARRAY_LENGTH_AS_INT32(pre_buffer->max_length);
        }

        if (post_buffer != NULL)
        {
            t_buffers.tail = il2cpp_array_addr(post_buffer, uint8_t, 0);
            t_buffers.tail_length = ARRAY_LENGTH_AS_INT32(post_buffer->max_length);
        }

        AUTO_ACQUIRE_SOCKET;
        if (!socketHandle.IsValid())
            return false;

        const Il2CppChar* ustr = utils::StringUtils::GetChars(filename);
        const std::string str = utils::StringUtils::Utf16ToUtf8(ustr);

        // Note: for now they map 1-1
        const os::TransmitFileOptions o_flags = (os::TransmitFileOptions)flags;
        const os::WaitStatus status = socketHandle->SendFile(str.c_str(), &t_buffers, o_flags);

        if (status == kWaitStatusFailure)
        {
            // TODO: mono stores socketHandle->GetLastError into a threadlocal global variable
            // that can be retrieved later by other icalls.
            return false;
        }

        if ((flags & kTransmitFileOptionsDisconnect) == kTransmitFileOptionsDisconnect)
            socketHandle->Disconnect(true);

        return true;
    }

    int32_t Socket::SendTo_icall(intptr_t socket, uint8_t* buffer, int32_t count, SocketFlags flags, Il2CppSocketAddress* socket_address, int32_t* error, bool blocking)
    {
        *error = 0;

        const os::SocketFlags c_flags = convert_socket_flags(flags);

        int32_t len = 0;

        const int32_t length = ARRAY_LENGTH_AS_INT32(socket_address->data->max_length);
        const uint8_t *socket_buffer = (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress(socket_address->data);

        if (length < 2)
        {
            vm::Exception::Raise(vm::Exception::GetSystemException());
            return 0;
        }

        const os::AddressFamily family = convert_address_family((AddressFamily)(socket_buffer[0] | (socket_buffer[1] << 8)));

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(0);

        if (family == os::kAddressFamilyInterNetwork)
        {
            if (length < 8)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return 0;
            }

            const uint16_t port = ((socket_buffer[2] << 8) | socket_buffer[3]);
            const uint32_t address = ((socket_buffer[4] << 24) | (socket_buffer[5] << 16) | (socket_buffer[6] << 8) | socket_buffer[7]);

            const os::WaitStatus status = socketHandle->SendTo(address, port, buffer, count, c_flags, &len);

            if (status == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyUnix)
        {
            if (length - 2 >= END_POINT_MAX_PATH_LEN)
            {
                vm::Exception::Raise(vm::Exception::GetSystemException());
                return 0;
            }

            char path[END_POINT_MAX_PATH_LEN] = {0};

            for (int32_t i = 0; i < (length - 2); ++i)
            {
                path[i] = (char)socket_buffer[i + 2];
            }

            auto status = socketHandle->SendTo(path, buffer, count, c_flags, &len);
            vm::Exception::RaiseIfError(status.GetError());

            if (status.Get() == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else if (family == os::kAddressFamilyInterNetworkV6)
        {
            uint16_t port;
            uint8_t address[ipv6AddressSize] = {0};
            uint32_t scope;
            UnpackIPv6AddressFromBuffer(socket_buffer, length, &port, address, &scope);

            auto status = socketHandle->SendTo(address, scope, port, buffer, count, c_flags, &len);
            vm::Exception::RaiseIfError(status.GetError());

            if (status.Get() == kWaitStatusFailure)
                *error = socketHandle->GetLastError();
        }
        else
        {
            *error = os::kWSAeafnosupport;
            return 0;
        }

        return len;
    }

    int32_t Socket::Send_array_icall(intptr_t socket, os::WSABuf* bufarray, int32_t count, SocketFlags flags, int32_t* error, bool blocking)
    {
        *error = 0;

        const os::SocketFlags c_flags = convert_socket_flags(flags);

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(0);

        int32_t sent = 0;

        const os::WaitStatus status = socketHandle->SendArray(bufarray, count, &sent, c_flags);

        if (status == kWaitStatusFailure)
        {
            *error = socketHandle->GetLastError();
            return 0;
        }

        return sent;
    }

    int32_t Socket::Send_icall(intptr_t socket, uint8_t* buffer, int32_t count, SocketFlags flags, int32_t* error, bool blocking)
    {
        *error = 0;

        const os::SocketFlags c_flags = convert_socket_flags(flags);

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(0);

        int32_t len = 0;

        const os::WaitStatus status = socketHandle->Send(buffer, count, c_flags, &len);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();

        return len;
    }

#if IL2CPP_SUPPORT_IPV6
    static os::IPv6Address ipaddress_to_ipv6_addr(Il2CppObject *ipaddr)
    {
        FieldInfo* numbersFieldInfo = vm::Class::GetFieldFromName(ipaddr->klass, "_numbers");
        IL2CPP_ASSERT(numbersFieldInfo);
        Il2CppArray* data = (Il2CppArray*)vm::Field::GetValueObject(numbersFieldInfo, ipaddr);

        os::IPv6Address ipv6;
        for (int i = 0; i < 8; i++)
        {
            uint16_t s = il2cpp_array_get(data, uint16_t, i);
            ipv6.addr[2 * i] = (s >> 8) & 0xff;
            ipv6.addr[2 * i + 1] = s & 0xff;
        }

        return ipv6;
    }

    static void GetAddressAndInterfaceFromObject(Il2CppObject* object, const char* groupField, const char* interfaceField,
        os::IPv6Address& ipv6, uint64_t& interfaceOffset)
    {
        FieldInfo* groupFieldInfo = vm::Class::GetFieldFromName(object->klass, groupField);
        IL2CPP_ASSERT(groupFieldInfo);
        Il2CppObject* address = vm::Field::GetValueObject(groupFieldInfo, object);

        if (address)
            ipv6 = ipaddress_to_ipv6_addr(address);

        FieldInfo* interfaceFieldInfo = vm::Class::GetFieldFromName(object->klass, interfaceField);
        IL2CPP_ASSERT(interfaceFieldInfo);
        vm::Field::GetValue(object, interfaceFieldInfo, &interfaceOffset);
    }

#endif // IL2CPP_SUPPORT_IPV6

    void Socket::SetSocketOption_icall(intptr_t socket, SocketOptionLevel level, SocketOptionName name, Il2CppObject* obj_val, Il2CppArray* byte_val, int32_t int_val, int32_t* error)
    {
        *error = 0;

        // Note: for now the options map one to one.
        const os::SocketOptionName system_name = (os::SocketOptionName)(name);
        const os::SocketOptionLevel system_level = (os::SocketOptionLevel)(level);

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        os::WaitStatus status = kWaitStatusFailure;

        if (byte_val != NULL)
        {
            const int32_t length = ARRAY_LENGTH_AS_INT32(byte_val->max_length);
            const uint8_t *buffer = (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress(byte_val);

            status = socketHandle->SetSocketOptionArray(system_level, system_name, buffer, length);
        }
        else if (obj_val != NULL)
        {
            switch (name)
            {
                case kSocketOptionNameLinger:
                {
                    const FieldInfo *enabled_field_info = vm::Class::GetFieldFromName(obj_val->klass, "enabled");
                    const FieldInfo *seconds_field_info = vm::Class::GetFieldFromName(obj_val->klass, "lingerTime");

                    const bool enabled = *((bool*)((char*)obj_val + enabled_field_info->offset));
                    const int32_t seconds = *((int32_t*)((char*)obj_val + seconds_field_info->offset));

                    status = socketHandle->SetSocketOptionLinger(system_level, system_name, enabled, seconds);
                }

                break;

                case kSocketOptionNameAddMembership:
                case kSocketOptionNameDropMembership:
                {
#if IL2CPP_SUPPORT_IPV6
                    if (system_level == (os::SocketOptionLevel)kSocketOptionLevelIPv6)
                    {
                        os::IPv6Address ipv6 = {{0}};
                        uint64_t interfaceOffset;
                        GetAddressAndInterfaceFromObject(obj_val, "m_Group", "m_Interface", ipv6, interfaceOffset);
                        status = socketHandle->SetSocketOptionMembership(system_level, system_name, ipv6, interfaceOffset);
                    }
                    else if (system_level == (os::SocketOptionLevel)kSocketOptionLevelIP)
#endif // IL2CPP_SUPPORT_IPV6
                    {
                        FieldInfo *group_field_info = vm::Class::GetFieldFromName(obj_val->klass, "group");
                        Il2CppObject* group_obj = vm::Field::GetValueObject(group_field_info, obj_val);
                        const FieldInfo *group_address_field_info = vm::Class::GetFieldFromName(group_obj->klass, "_addressOrScopeId");
                        IL2CPP_ASSERT(group_address_field_info != NULL);
                        const uint32_t group_address = *((uint32_t*)(uint64_t*)((char*)group_obj + group_address_field_info->offset));

                        uint32_t local_address = 0;
                        FieldInfo *local_field_info = vm::Class::GetFieldFromName(obj_val->klass, "localAddress");
                        if (local_field_info != NULL)
                        {
                            Il2CppObject* local_obj = vm::Field::GetValueObject(local_field_info, obj_val);
                            if (local_obj != NULL)
                            {
                                const FieldInfo *local_address_field_info = vm::Class::GetFieldFromName(local_obj->klass, "_addressOrScopeId");
                                IL2CPP_ASSERT(local_address_field_info != NULL);
                                local_address = *((uint32_t*)(uint64_t*)((char*)local_obj + local_address_field_info->offset));
                            }
                        }

                        status = socketHandle->SetSocketOptionMembership(system_level, system_name, group_address, local_address);
                    }
                }

                break;

                default:
                    *error = os::kWSAeinval;
                    return; // early out
            }
        }
        else
            status = socketHandle->SetSocketOption(system_level, system_name, int_val);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();
    }

    void Socket::Shutdown_icall(intptr_t socket, SocketShutdown how, int32_t* error)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID();

        const os::WaitStatus status = socketHandle->Shutdown(how);

        if (status == kWaitStatusFailure)
            *error = socketHandle->GetLastError();
    }

    intptr_t Socket::Socket_icall(AddressFamily family, SocketType type, ProtocolType protocol, int32_t* error)
    {
        intptr_t socket = static_cast<intptr_t>(os::kInvalidSocketHandle);

        *error = 0;

        os::AddressFamily n_family = convert_address_family(family);
        os::SocketType n_type = convert_socket_type(type);
        os::ProtocolType n_protocol = convert_socket_protocol(protocol);

        if (n_family == os::kAddressFamilyError)
        {
            *error = os::kWSAeafnosupport;
            return socket;
        }

        if (n_type == os::kSocketTypeError)
        {
            *error = os::kWSAesocktnosupport;
            return socket;
        }

        if (n_protocol == os::kProtocolTypeUnknown)
        {
            *error = os::kWSAeprotonosupport;
            return socket;
        }

        os::Socket *sock = new os::Socket(check_thread_status);

        const os::WaitStatus status = sock->Create(n_family, n_type, n_protocol);

        if (status == kWaitStatusFailure)
        {
            *error = sock->GetLastError();

            // Okay to delete socket directly. We haven't created a handle yet.
            delete sock;

            return socket;
        }

        os::SocketHandle socketHandle = os::CreateSocketHandle(sock);
        socket = static_cast<intptr_t>(socketHandle);

        return socket;
    }

    int32_t Socket::IOControl_icall(intptr_t socket, int32_t ioctl_code, Il2CppArray* input, Il2CppArray* output, int32_t* error)
    {
        *error = 0;

        AUTO_ACQUIRE_SOCKET;
        RETURN_IF_SOCKET_IS_INVALID(-1);

        if (ioctl_code == 0x5421 /* FIONBIO */)
        {
            // Invalid command. Must use Socket.Blocking
            return -1;
        }

        const int32_t in_length = (input ? ARRAY_LENGTH_AS_INT32(input->max_length) : 0);
        const uint8_t *in_buffer = (input ? (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress(input) : NULL);

        const int32_t out_length = (output ? ARRAY_LENGTH_AS_INT32(output->max_length) : 0);
        uint8_t *out_buffer = (output ? (uint8_t*)il2cpp::vm::Array::GetFirstElementAddress(output) : NULL);

        int32_t output_bytes = 0;

        const os::WaitStatus status = socketHandle->Ioctl(ioctl_code, in_buffer, in_length, out_buffer, out_length, &output_bytes);

        if (status == kWaitStatusFailure)
        {
            *error = socketHandle->GetLastError();
            return -1;
        }

        return output_bytes;
    }

    static void STDCALL
    abort_apc(void* param)
    {
    }

    void Socket::cancel_blocking_socket_operation(Il2CppObject* thread)
    {
        Il2CppThread* t = reinterpret_cast<Il2CppThread*>(thread);
        t->internal_thread->handle->QueueUserAPC(abort_apc, NULL);
        // IL2CPP_NOT_IMPLEMENTED_ICALL(Socket::cancel_blocking_socket_operation);
        //IL2CPP_UNREACHABLE;
    }

    bool Socket::Duplicate_icall(intptr_t handle, int32_t targetProcessId, intptr_t* duplicateHandle, int32_t* error)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Socket::Duplicate_icall);
        return false;
    }

    bool Socket::IsProtocolSupported_internal(int32_t networkInterface)
    {
        // The networkInterface argument is from the
        // System.Net.NetworkInformation.NetworkInterfaceComponent enum
        // 0 => IPv4
        // 1 => IPv6
#if IL2CPP_SUPPORT_IPV6_SUPPORT_QUERY
        return networkInterface == 1 ? os::Socket::IsIPv6Supported() : true;
#elif IL2CPP_SUPPORT_IPV6
        // This platform supports both IPv6 and IPv4.
        return true;
#else
        // This platform only supports IPv4.
        return networkInterface == 0;
#endif
    }
} /* namespace Sockets */
} /* namespace Net */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.Sockets\Socket.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.Sockets\SocketException.cpp---------------
.
.
#include "il2cpp-config.h"

#include "icalls/System/System.Net.Sockets/SocketException.h"

#include "os/Error.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Net
{
namespace Sockets
{
    int32_t SocketException::WSAGetLastError_icall()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(SocketException::WSAGetLastError, "Ignore this for now");

        return (int32_t)os::Error::GetLastError();
    }
} /* namespace Sockets */
} /* namespace Net */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Net.Sockets\SocketException.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Threading\Semaphore.cpp---------------
.
.
#include "icalls/System/System.Threading/Semaphore.h"
#include "os/Semaphore.h"
#include "vm/Exception.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace System
{
namespace Threading
{
    bool Semaphore::ReleaseSemaphore_internal(intptr_t handlePtr, int32_t releaseCount, int32_t* previousCount)
    {
        os::SemaphoreHandle* handle = (os::SemaphoreHandle*)handlePtr;

        return handle->Get().Post(releaseCount, previousCount);
    }

    intptr_t Semaphore::CreateSemaphore_icall(int32_t initialCount, int32_t maximumCount, Il2CppChar* name, int32_t name_length, int32_t* errorCode)
    {
        *errorCode = true;
        os::Semaphore* semaphore = NULL;

        if (name == NULL)
            semaphore = new os::Semaphore(initialCount, maximumCount);
        else
            NOT_SUPPORTED_IL2CPP(Semaphore::CreateSemaphore_internal, "Named semaphores are not supported.");

        return reinterpret_cast<intptr_t>(new os::SemaphoreHandle(semaphore));
    }

    intptr_t Semaphore::OpenSemaphore_icall(Il2CppChar* name, int32_t name_length, int32_t rights, int32_t* errorCode)
    {
        NOT_SUPPORTED_IL2CPP(Semaphore::OpenSemaphore_internal, "Named semaphores are not supported.");

        return 0;
    }
} /* namespace Threading */
} /* namespace System */
} /* namespace System */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System\System.Threading\Semaphore.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System.Core\System.IO.MemoryMappedFiles\MemoryMapImpl.cpp---------------
.
.
#include <algorithm>
#include <vector>
#include "il2cpp-config.h"
#include "MemoryMapImpl.h"
#include "os/File.h"
#include "os/MemoryMappedFile.h"
#include "os/Mutex.h"
#include "utils/StringUtils.h"
#include "utils/Memory.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace icalls
{
namespace System
{
namespace Core
{
namespace System
{
namespace IO
{
namespace MemoryMappedFiles
{
    static baselib::ReentrantLock s_Mutex;
    static std::vector<os::FileHandle*> s_OwnedFileHandles;

    typedef struct
    {
        void *address;
        void *free_handle;
        size_t length;
    } MmapInstance;

    static int32_t ConvertMemoryMappedFileAccessToIL2CPPFileAccess(os::MemoryMappedFileAccess access)
    {
        switch (access)
        {
            case os::MMAP_FILE_ACCESS_READ:
            case os::MMAP_FILE_ACCESS_READ_EXECUTE:
                return kFileAccessRead;
            case os::MMAP_FILE_ACCESS_READ_WRITE:
            case os::MMAP_FILE_ACCESS_COPY_ON_WRITE:
            case os::MMAP_FILE_ACCESS_READ_WRITE_EXECUTE:
                return kFileAccessRead | kFileAccessWrite;
            case os::MMAP_FILE_ACCESS_WRITE:
                return kFileAccessWrite;
            default:
                IL2CPP_ASSERT("unknown MemoryMappedFileAccess");
        }

        return kFileAccessRead;
    }

    static void CloseFileHandleIfOwned(os::FileHandle* file)
    {
        std::vector<os::FileHandle*>::iterator ownedHandleEntry = std::find(s_OwnedFileHandles.begin(), s_OwnedFileHandles.end(), file);
        if (ownedHandleEntry != s_OwnedFileHandles.end())
        {
            int error = 0;
            os::File::Close(file, &error);
            s_OwnedFileHandles.erase(ownedHandleEntry);
            IL2CPP_ASSERT(error == 0);
        }
    }

    bool MemoryMapImpl::Unmap(intptr_t mmap_handle)
    {
        IL2CPP_ASSERT(mmap_handle);

        MmapInstance *h = (MmapInstance*)mmap_handle;

        bool result = os::MemoryMappedFile::UnmapView(h->address, h->length);

        IL2CPP_FREE(h);

        return result;
    }

    int32_t MemoryMapImpl::MapInternal(intptr_t handle, int64_t offset, int64_t* size, int32_t access, intptr_t* mmap_handle, intptr_t* base_address)
    {
        IL2CPP_ASSERT(handle);

        MmapInstance* h = (MmapInstance*)IL2CPP_MALLOC_ZERO(sizeof(MmapInstance));

        os::MemoryMappedFileError error = os::NO_MEMORY_MAPPED_FILE_ERROR;
        int64_t actualOffset = offset;
        h->address = os::MemoryMappedFile::View((os::FileHandle*)handle, size, offset, (os::MemoryMappedFileAccess)access, &actualOffset, &error);
        h->length = (size_t)*size;

        if (h->address)
        {
            *mmap_handle = (intptr_t)h;
            *base_address = (intptr_t)((char*)h->address + (offset - actualOffset));
        }
        else
        {
            IL2CPP_FREE(h);
        }

        return error;
    }

    static os::FileHandle* OpenHandle(os::FileHandle* handle, Il2CppChar* mapName, os::MemoryMappedFileMode mode, int64_t* capacity, int32_t access, int32_t options, int32_t* error)
    {
        os::MemoryMappedFileError memoryMappedFileError = os::NO_MEMORY_MAPPED_FILE_ERROR;
        std::string utf8MapNameString = mapName != NULL ? utils::StringUtils::Utf16ToUtf8(mapName) : std::string();
        const char* utf8MapName = !utf8MapNameString.empty() ? utf8MapNameString.c_str() : NULL;
        os::FileHandle* memoryMappedFileData = os::MemoryMappedFile::Create(handle, utf8MapName, mode, capacity, (os::MemoryMappedFileAccess)access, options, &memoryMappedFileError);

        *error = (int32_t)memoryMappedFileError;
        return memoryMappedFileData;
    }

    intptr_t  MemoryMapImpl::OpenFileInternal(Il2CppChar* path, int32_t path_length, int32_t mode, Il2CppChar* mapName, int32_t mapName_length, int64_t* capacity, int32_t access, int32_t options, int32_t* error)
    {
        IL2CPP_ASSERT(path || mapName);
        os::FastAutoLock lock(&s_Mutex);

        *error = 0;

        os::FileHandle* file = NULL;
        if (path != NULL)
        {
            std::string filePath = utils::StringUtils::Utf16ToUtf8(path);
            file = os::File::Open(filePath, mode, ConvertMemoryMappedFileAccessToIL2CPPFileAccess((os::MemoryMappedFileAccess)access), 0, options, error);

            s_OwnedFileHandles.push_back(file);
        }

        os::FileHandle* result = NULL;
        if (*error == 0)
        {
            result = OpenHandle(file, mapName, (os::MemoryMappedFileMode)mode, capacity, access, options, error);
            if (result != NULL && result != file)
                CloseFileHandleIfOwned(file);
        }

        return (intptr_t)result;
    }

    intptr_t MemoryMapImpl::OpenHandleInternal(intptr_t handle, Il2CppChar* mapName, int32_t mapName_length, int64_t* capacity, int32_t access, int32_t options, int32_t* error)
    {
        IL2CPP_ASSERT(handle);

        return (intptr_t)OpenHandle((os::FileHandle*)handle, mapName, os::FILE_MODE_OPEN, capacity, access, options, error);
    }

    void MemoryMapImpl::CloseMapping(intptr_t handle)
    {
        IL2CPP_ASSERT(handle);
        os::FastAutoLock lock(&s_Mutex);

        os::FileHandle* file = (os::FileHandle*)handle;

        os::MemoryMappedFile::Close(file);
        CloseFileHandleIfOwned(file);
    }

    void MemoryMapImpl::ConfigureHandleInheritability(intptr_t handle, int32_t inheritability)
    {
        IL2CPP_ASSERT(handle);

        os::MemoryMappedFile::ConfigureHandleInheritability((os::FileHandle*)handle, inheritability);
    }

    void MemoryMapImpl::Flush(intptr_t file_handle)
    {
        IL2CPP_ASSERT(file_handle);

        MmapInstance *h = (MmapInstance*)file_handle;
        os::MemoryMappedFile::Flush(h->address, h->length);
    }
} // namespace MemoryMappedFiles
} // namespace IO
} // namespace System
} // namespace Core
} // namespace System
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\icalls\System.Core\System.IO.MemoryMappedFiles\MemoryMapImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\ArrayMetadata.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-runtime-stats.h"
#include "os/Mutex.h"
#include "vm/Class.h"
#include "vm/GenericClass.h"
#include "vm/Image.h"
#include "vm/MetadataLock.h"
#include "vm/Method.h"
#include "vm/Type.h"
#include "metadata/ArrayMetadata.h"
#include "metadata/GenericMetadata.h"
#include "metadata/GenericMethod.h"
#include "metadata/Il2CppGenericClassHash.h"
#include "metadata/Il2CppGenericClassCompare.h"
#include "metadata/Il2CppGenericInstCompare.h"
#include "metadata/Il2CppGenericInstHash.h"
#include "metadata/Il2CppTypeCompare.h"
#include "metadata/Il2CppTypeHash.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataCache.h"
#include "vm/Runtime.h"
#include "utils/Memory.h"
#include "utils/Il2CppHashMap.h"
#include "utils/StringUtils.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-tabledefs.h"
#include <vector>
#include <limits>

using namespace il2cpp::vm;
using il2cpp::os::FastAutoLock;
using il2cpp::utils::StringUtils;
using il2cpp::vm::MetadataCache;

using il2cpp::vm::MetadataCalloc;
using il2cpp::vm::MetadataMalloc;

using std::vector;
using std::pair;


const size_t kImplicitArrayInterfaceCount = 5;

namespace il2cpp
{
namespace metadata
{
    static const char* GetArrayName(const char* elementClassName, uint32_t rank, bool bounded)
    {
        std::string name;
        name += elementClassName;
        name += "[";
        for (uint32_t i = 1; i < rank; i++)
            name += ",";
        if (bounded)
            name += "*";
        name += "]";

        return StringUtils::StringDuplicate(name.c_str());
    }

    static MethodInfo* ConstructArrayMethod(Il2CppClass* declaringType, const char* name, const Il2CppType* returnType, uint8_t parameterCount, const Il2CppType** parameterTypes)
    {
        MethodInfo* method = (MethodInfo*)MetadataCalloc(1, sizeof(MethodInfo));
        method->klass = declaringType;
        method->flags = METHOD_ATTRIBUTE_PUBLIC;
        method->iflags = METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL;
        method->name = name;
        method->slot = kInvalidIl2CppMethodSlot;
        method->return_type = returnType;
        method->parameters_count = parameterCount;
        const Il2CppType** parameters = (const Il2CppType**)MetadataCalloc(parameterCount, sizeof(Il2CppType*));
        for (uint8_t i = 0; i < parameterCount; i++)
        {
            parameters[i] = parameterTypes[i];
        }
        method->parameters = parameters;

        if (!strcmp(".ctor", name))
        {
            method->flags |= METHOD_ATTRIBUTE_RT_SPECIAL_NAME | METHOD_ATTRIBUTE_SPECIAL_NAME;
        }
        else
        {
            method->iflags |= METHOD_IMPL_ATTRIBUTE_RUNTIME;
        }

        ++il2cpp_runtime_stats.method_count;

        return method;
    }

    struct GenericArrayMethod
    {
        const char* name;
        const MethodInfo* method;
        const MethodInfo* interfaceMethodDefinition;
    };

    typedef vector<GenericArrayMethod> GenericArrayMethods;
    static GenericArrayMethods s_GenericArrayMethods;

    static size_t GetArrayGenericMethodsCount();
    static void PopulateArrayGenericMethods(Il2CppClass* klass, uint16_t offset);

    static void CollectImplicitArrayInterfaces(Il2CppClass* elementClass, ::std::vector<Il2CppClass*>& interfaces);

    static void SetupArrayMethods(Il2CppClass* arrayClass)
    {
        size_t methodIndex = 0;
        uint8_t rank = arrayClass->rank;
        ::std::vector<Il2CppClass*> interfaces;
        CollectImplicitArrayInterfaces(arrayClass, interfaces);

        size_t methodCount = 3 + (rank > 1 ? 2 : 1) + interfaces.size() * GetArrayGenericMethodsCount();
        IL2CPP_ASSERT(methodCount <= std::numeric_limits<uint16_t>::max());
        arrayClass->method_count = static_cast<uint16_t>(methodCount);
        arrayClass->methods = (const MethodInfo**)MetadataCalloc(methodCount, sizeof(MethodInfo*));

        const Il2CppType** parameters = (const Il2CppType**)alloca(rank * sizeof(Il2CppType*));
        for (uint8_t i = 0; i < rank; i++)
            parameters[i] = &il2cpp_defaults.int32_class->byval_arg;
        arrayClass->methods[methodIndex++] = ConstructArrayMethod(arrayClass, ".ctor", &il2cpp_defaults.void_class->byval_arg, rank, parameters);

        if (rank > 1)
        {
            parameters = (const Il2CppType**)alloca(2 * rank * sizeof(Il2CppType*));
            for (uint8_t i = 0; i < 2 * rank; i++)
                parameters[i] = &il2cpp_defaults.int32_class->byval_arg;
            arrayClass->methods[methodIndex++] = ConstructArrayMethod(arrayClass, ".ctor", &il2cpp_defaults.void_class->byval_arg, 2 * rank, parameters);
        }

        parameters = (const Il2CppType**)alloca((rank + 1) * sizeof(Il2CppType*));
        for (uint8_t i = 0; i < rank; i++)
            parameters[i] = &il2cpp_defaults.int32_class->byval_arg;
        parameters[rank] = &arrayClass->element_class->byval_arg;
        MethodInfo* setMethod = ConstructArrayMethod(arrayClass, "Set", &il2cpp_defaults.void_class->byval_arg, rank + 1, parameters);
        setMethod->invoker_method = vm::Runtime::GetArraySetInvoker();
        arrayClass->methods[methodIndex++] = setMethod;

        parameters = (const Il2CppType**)alloca(rank * sizeof(Il2CppType*));
        for (uint8_t i = 0; i < rank; i++)
            parameters[i] = &il2cpp_defaults.int32_class->byval_arg;
        MethodInfo* addressMethod = ConstructArrayMethod(arrayClass, "Address", &arrayClass->element_class->this_arg, rank, parameters);
        addressMethod->invoker_method = vm::Runtime::GetMissingMethodInvoker();
        arrayClass->methods[methodIndex++] = addressMethod;

        parameters = (const Il2CppType**)alloca(rank * sizeof(Il2CppType*));
        for (uint8_t i = 0; i < rank; i++)
            parameters[i] = &il2cpp_defaults.int32_class->byval_arg;
        MethodInfo* getMethod = ConstructArrayMethod(arrayClass, "Get", &arrayClass->element_class->byval_arg, rank, parameters);
        getMethod->invoker_method = vm::Runtime::GetArrayGetInvoker();
        arrayClass->methods[methodIndex++] = getMethod;

        IL2CPP_ASSERT(methodIndex <= std::numeric_limits<uint16_t>::max());
        PopulateArrayGenericMethods(arrayClass, static_cast<uint16_t>(methodIndex));
    }

    static void CollectImplicitArrayInterfacesFromElementClass(Il2CppClass* elementClass, ::std::vector<Il2CppClass*>& interfaces)
    {
        while (elementClass != NULL)
        {
            interfaces.push_back(elementClass);
            if (!elementClass->byval_arg.valuetype && elementClass != il2cpp_defaults.value_type_class && elementClass != il2cpp_defaults.enum_class)
            {
                void* iter = NULL;
                while (Il2CppClass* itf = Class::GetInterfaces(elementClass, &iter))
                    interfaces.push_back(itf);
            }

            if (elementClass->rank == 1)
            {
                ::std::vector<Il2CppClass*> elementInterfaces;
                CollectImplicitArrayInterfacesFromElementClass(elementClass->element_class, elementInterfaces);

                for (::std::vector<Il2CppClass*>::iterator iter = elementInterfaces.begin(); iter != elementInterfaces.end(); ++iter)
                {
                    const Il2CppType* genericArgument = &(*iter)->byval_arg;

                    interfaces.push_back(Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ilist_class, &genericArgument, 1));
                    interfaces.push_back(Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_icollection_class, &genericArgument, 1));
                    interfaces.push_back(Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ienumerable_class, &genericArgument, 1));

                    interfaces.push_back(Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ireadonlylist_class, &genericArgument, 1));
                    interfaces.push_back(Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ireadonlycollection_class, &genericArgument, 1));
                }
            }

            elementClass = Class::GetParent(elementClass);
            if (elementClass != NULL && (elementClass->byval_arg.valuetype || elementClass == il2cpp_defaults.value_type_class || elementClass == il2cpp_defaults.enum_class))
                break;
        }
    }

    static void CollectImplicitArrayInterfaces(Il2CppClass* arrayClass, ::std::vector<Il2CppClass*>& interfaces)
    {
        if (arrayClass->byval_arg.type != IL2CPP_TYPE_SZARRAY)
            return;

        CollectImplicitArrayInterfacesFromElementClass(arrayClass->element_class, interfaces);
    }

// note assuming list is ordered as IList, ICollection, IEnumerable

    static void CollectGenericArrayMethods()
    {
        const size_t kNumGenericArrayMethods = 13;
        s_GenericArrayMethods.reserve(kNumGenericArrayMethods);

        void* iter = NULL;
        while (const MethodInfo* method = Class::GetMethods(il2cpp_defaults.array_class, &iter))
        {
            if (strncmp(method->name, "InternalArray__", 15))
                continue;

            std::string name;
            std::string methodName;

            Il2CppClass* implementingInterface = NULL;
            if (!strncmp(method->name, "InternalArray__ICollection_", 27))
            {
                implementingInterface = il2cpp_defaults.generic_icollection_class;
                methodName = method->name + 27;
                name = StringUtils::Printf("System.Collections.Generic.ICollection`1.%s", method->name + 27);
            }
            else if (!strncmp(method->name, "InternalArray__IEnumerable_", 27))
            {
                implementingInterface = il2cpp_defaults.generic_ienumerable_class;
                methodName = method->name + 27;
                name = StringUtils::Printf("System.Collections.Generic.IEnumerable`1.%s", method->name + 27);
            }
            else if (!strncmp(method->name, "InternalArray__IReadOnlyList_", 29))
            {
                implementingInterface = il2cpp_defaults.generic_ireadonlylist_class;
                methodName = method->name + 29;
                name = StringUtils::Printf("System.Collections.Generic.IReadOnlyList`1.%s", method->name + 29);
            }
            else if (!strncmp(method->name, "InternalArray__IReadOnlyCollection_", 35))
            {
                implementingInterface = il2cpp_defaults.generic_ireadonlycollection_class;
                methodName = method->name + 35;
                name = StringUtils::Printf("System.Collections.Generic.IReadOnlyCollection`1.%s", method->name + 35);
            }
            else
            {
                implementingInterface = il2cpp_defaults.generic_ilist_class;
                methodName = method->name + 15;
                name = StringUtils::Printf("System.Collections.Generic.IList`1.%s", method->name + 15);
            }

            Class::Init(implementingInterface);

            const MethodInfo* matchingInterfacesMethod = NULL;
            for (int methodIndex = 0; methodIndex < implementingInterface->method_count; methodIndex++)
            {
                const MethodInfo* interfaceMethod = implementingInterface->methods[methodIndex];
                if (methodName == interfaceMethod->name)
                    matchingInterfacesMethod = interfaceMethod;
            }

            if (matchingInterfacesMethod != NULL)
            {
                GenericArrayMethod genericArrayMethod = { StringUtils::StringDuplicate(name.c_str()), method, matchingInterfacesMethod };
                s_GenericArrayMethods.push_back(genericArrayMethod);
            }
        }
    }

    static size_t GetArrayGenericMethodsCount()
    {
        if (s_GenericArrayMethods.size() == 0)
            CollectGenericArrayMethods();

        return s_GenericArrayMethods.size();
    }

    static MethodInfo* ConstructGenericArrayMethod(const GenericArrayMethod& genericArrayMethod, Il2CppClass* klass, Il2CppGenericContext* context)
    {
        MethodInfo* inflatedMethod;
        if (genericArrayMethod.method->is_generic)
        {
            inflatedMethod = GenericMethod::AllocateNewMethodInfo(genericArrayMethod.method, context->class_inst, context->method_inst);
        }
        else
        {
            inflatedMethod = (MethodInfo*)MetadataCalloc(1, sizeof(MethodInfo));
            memcpy(inflatedMethod, genericArrayMethod.method, sizeof(MethodInfo));
        }

        inflatedMethod->name = genericArrayMethod.name;

        // The array methods are owned by the specific array instance, but they do not exist in metadata
        // Ensure that the metadata token is zero (and not copied from the method definition) so any
        // metadata lookup (e.g. custom attributes) will not find anything
        inflatedMethod->klass = klass;
        inflatedMethod->token = 0;

        return inflatedMethod;
    }

    static void PopulateArrayGenericMethods(Il2CppClass* klass, uint16_t offset)
    {
        for (int i = 0; i < klass->interface_offsets_count; i++)
        {
            Il2CppClass* interfaceType = klass->interfaceOffsets[i].interfaceType;
            if (!interfaceType->generic_class)
                continue;

            Il2CppClass* interfaceDefinition = GenericClass::GetTypeDefinition(interfaceType->generic_class);

            Il2CppGenericContext context = { 0 };
            context.method_inst = MetadataCache::GetGenericInst(&interfaceType->generic_class->context.class_inst->type_argv[0], 1);

            for (GenericArrayMethods::const_iterator iter = s_GenericArrayMethods.begin(); iter != s_GenericArrayMethods.end(); ++iter)
            {
                if (iter->interfaceMethodDefinition->klass != interfaceDefinition)
                    continue;

                MethodInfo* arrayMethod = ConstructGenericArrayMethod(*iter, klass, &context);
                klass->methods[offset++] = arrayMethod;

                size_t vtableIndex = klass->interfaceOffsets[i].offset + iter->interfaceMethodDefinition->slot;
                klass->vtable[vtableIndex].method = arrayMethod;
                klass->vtable[vtableIndex].methodPtr = arrayMethod->virtualMethodPointer;
            }
        }
    }

    static void SetupArrayVTableAndInterfaceOffsets(Il2CppClass* klass)
    {
        Il2CppClass* arrayClass = Class::GetParent(klass);
        size_t arrayInterfacesCount = arrayClass->interface_offsets_count;

        ::std::vector<Il2CppClass*> interfaces;

        if (klass->byval_arg.type == IL2CPP_TYPE_SZARRAY)
        {
            CollectImplicitArrayInterfaces(klass, interfaces);
        }

        Il2CppRuntimeInterfaceOffsetPair* newInterfaceOffsets = (Il2CppRuntimeInterfaceOffsetPair*)MetadataMalloc((arrayInterfacesCount + kImplicitArrayInterfaceCount * interfaces.size()) * sizeof(Il2CppRuntimeInterfaceOffsetPair));
        memcpy(newInterfaceOffsets, arrayClass->interfaceOffsets, (arrayInterfacesCount) * sizeof(Il2CppRuntimeInterfaceOffsetPair));

        int32_t arrayVTableSlot = arrayClass->vtable_count;
        size_t slots = arrayVTableSlot + interfaces.size() * (il2cpp_defaults.generic_ilist_class->method_count + il2cpp_defaults.generic_icollection_class->method_count + il2cpp_defaults.generic_ienumerable_class->method_count);

        slots += interfaces.size() * (il2cpp_defaults.generic_ireadonlylist_class->method_count + il2cpp_defaults.generic_ireadonlycollection_class->method_count);

        memcpy(klass->vtable, arrayClass->vtable, arrayVTableSlot * sizeof(VirtualInvokeData));

        size_t index = arrayInterfacesCount;
        int32_t vtableSlot = arrayVTableSlot;
        for (::std::vector<Il2CppClass*>::iterator iter = interfaces.begin(); iter != interfaces.end(); iter++, index += kImplicitArrayInterfaceCount)
        {
            const Il2CppType* genericArgument = &(*iter)->byval_arg;

            newInterfaceOffsets[index].interfaceType = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ilist_class, &genericArgument, 1);
            newInterfaceOffsets[index].offset = vtableSlot;
            vtableSlot += newInterfaceOffsets[index].interfaceType->method_count;

            newInterfaceOffsets[index + 1].interfaceType = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_icollection_class, &genericArgument, 1);
            newInterfaceOffsets[index + 1].offset = vtableSlot;
            vtableSlot += newInterfaceOffsets[index + 1].interfaceType->method_count;

            newInterfaceOffsets[index + 2].interfaceType = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ienumerable_class, &genericArgument, 1);
            newInterfaceOffsets[index + 2].offset = vtableSlot;
            vtableSlot += newInterfaceOffsets[index + 2].interfaceType->method_count;

            newInterfaceOffsets[index + 3].interfaceType = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ireadonlylist_class, &genericArgument, 1);
            newInterfaceOffsets[index + 3].offset = vtableSlot;
            vtableSlot += newInterfaceOffsets[index + 3].interfaceType->method_count;

            newInterfaceOffsets[index + 4].interfaceType = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ireadonlycollection_class, &genericArgument, 1);
            newInterfaceOffsets[index + 4].offset = vtableSlot;
            vtableSlot += newInterfaceOffsets[index + 4].interfaceType->method_count;
        }

        size_t interfaceOffsetsCount = arrayInterfacesCount + kImplicitArrayInterfaceCount * interfaces.size();
        IL2CPP_ASSERT(interfaceOffsetsCount <= std::numeric_limits<uint16_t>::max());
        klass->interface_offsets_count = static_cast<uint16_t>(interfaceOffsetsCount);
        klass->interfaceOffsets = newInterfaceOffsets;
    }

    void SetupCastClass(Il2CppClass *arrayType)
    {
        Il2CppClass *elementType = arrayType->element_class;

        arrayType->castClass = ArrayMetadata::GetArrayVarianceReducedType(elementType);
        arrayType->has_references = Type::IsReference(&elementType->byval_arg) || elementType->has_references;
    }

    void ArrayMetadata::SetupArrayInterfaces(Il2CppClass* klass, const FastAutoLock& lock)
    {
        if (klass->byval_arg.type == IL2CPP_TYPE_SZARRAY)
        {
            IL2CPP_ASSERT(klass->implementedInterfaces == NULL);

            const Il2CppType* genericArguments = &klass->element_class->byval_arg;

            IL2CPP_ASSERT(klass->interfaces_count == kImplicitArrayInterfaceCount);
            klass->implementedInterfaces = (Il2CppClass**)MetadataMalloc(klass->interfaces_count * sizeof(Il2CppClass*));
            klass->implementedInterfaces[0] = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ilist_class, &genericArguments, 1);
            IL2CPP_ASSERT(klass->implementedInterfaces[0]);
            klass->implementedInterfaces[1] = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_icollection_class, &genericArguments, 1);
            IL2CPP_ASSERT(klass->implementedInterfaces[1]);
            klass->implementedInterfaces[2] = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ienumerable_class, &genericArguments, 1);
            IL2CPP_ASSERT(klass->implementedInterfaces[2]);
            klass->implementedInterfaces[3] = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ireadonlylist_class, &genericArguments, 1);
            IL2CPP_ASSERT(klass->implementedInterfaces[3]);
            klass->implementedInterfaces[4] = Class::GetInflatedGenericInstanceClass(il2cpp_defaults.generic_ireadonlycollection_class, &genericArguments, 1);
            IL2CPP_ASSERT(klass->implementedInterfaces[4]);
        }
    }

    void ArrayMetadata::SetupArrayVTable(Il2CppClass* klass, const FastAutoLock& lock)
    {
        // we assume we are being called as part of Class::Init and that the element class has already been initialized
        IL2CPP_ASSERT(klass->element_class->initialized);

        SetupCastClass(klass);
        SetupArrayVTableAndInterfaceOffsets(klass);
        SetupArrayMethods(klass);
    }

    struct SZArrayClassHash
    {
        size_t operator()(const Il2CppClass* arrayClass) const
        {
            return Il2CppTypeHash::Hash(&arrayClass->byval_arg);
        }
    };

    struct SZArrayClassCompare
    {
        bool operator()(const Il2CppClass* arrayClass1, const Il2CppClass* arrayClass2) const
        {
            return Il2CppTypeEqualityComparer::AreEqual(&arrayClass1->byval_arg, &arrayClass2->byval_arg);
        }
    };

    struct ArrayClassHash
    {
        size_t operator()(const std::pair<Il2CppClass*, uint32_t>& arrayClass) const
        {
            return Il2CppTypeHash::Hash(&arrayClass.first->byval_arg) * arrayClass.second;
        }
    };

    struct ArrayClassCompare
    {
        bool operator()(const std::pair<Il2CppClass*, uint32_t>& arrayClass1, const std::pair<Il2CppClass*, uint32_t>& arrayClass2) const
        {
            return Il2CppTypeEqualityComparer::AreEqual(&arrayClass1.first->byval_arg, &arrayClass2.first->byval_arg) && arrayClass1.second == arrayClass2.second;
        }
    };

    typedef Il2CppReaderWriterLockedHashMap<Il2CppClass*, Il2CppClass*, SZArrayClassHash, SZArrayClassCompare> SZArrayClassMap;
    typedef Il2CppReaderWriterLockedHashMap<std::pair<Il2CppClass*, uint32_t>, Il2CppClass*, ArrayClassHash, ArrayClassCompare> ArrayClassMap;

    SZArrayClassMap s_SZArrayClassMap;
    ArrayClassMap s_ArrayClassMap;

    void ArrayMetadata::Clear()
    {
        s_SZArrayClassMap.Clear();
        s_ArrayClassMap.Clear();

        for (auto genericArrayMethod : s_GenericArrayMethods)
            IL2CPP_FREE((void*)genericArrayMethod.name);

        s_GenericArrayMethods.clear();
    }

    static Il2CppClass* FindBoundedArrayClass(Il2CppClass* elementClass, uint32_t rank, bool bounded)
    {
        Il2CppClass* arrayClass = NULL;
        if (rank > 1 || bounded)
        {
            if (s_ArrayClassMap.TryGet(std::make_pair(elementClass, rank), &arrayClass))
                return arrayClass;
        }
        else
        {
            if (s_SZArrayClassMap.TryGet(elementClass, &arrayClass))
                return arrayClass;
        }

        return NULL;
    }

    Il2CppClass* ArrayMetadata::GetBoundedArrayClass(Il2CppClass* elementClass, uint32_t rank, bool bounded)
    {
        IL2CPP_ASSERT(rank <= 255);

        if (rank > 1)
            bounded = false;

        // Check for a cached array class using the reader lock only
        Il2CppClass* cachedArrayClass = FindBoundedArrayClass(elementClass, rank, bounded);
        if (cachedArrayClass != NULL)
            return cachedArrayClass;

        FastAutoLock lock(&il2cpp::vm::g_MetadataLock);

        // Check if the array class was created while we were waiting for the g_MetadataLock
        cachedArrayClass = FindBoundedArrayClass(elementClass, rank, bounded);
        if (cachedArrayClass != NULL)
            return cachedArrayClass;

        Il2CppClass* arrayClass = il2cpp_defaults.array_class;
        Class::Init(arrayClass);

        //count number of virtual call slots for array class
        ::std::vector<Il2CppClass*> interfaces;

        if (rank <= 1 && !bounded)
            CollectImplicitArrayInterfacesFromElementClass(elementClass, interfaces);

        size_t slots = arrayClass->vtable_count + interfaces.size() * (il2cpp_defaults.generic_ilist_class->method_count + il2cpp_defaults.generic_icollection_class->method_count + il2cpp_defaults.generic_ienumerable_class->method_count);

        slots += interfaces.size() * (il2cpp_defaults.generic_ireadonlylist_class->method_count + il2cpp_defaults.generic_ireadonlycollection_class->method_count);

        Il2CppClass* klass = (Il2CppClass*)MetadataCalloc(1, sizeof(Il2CppClass) + (slots * sizeof(VirtualInvokeData)));
        klass->klass = klass;
        klass->image = elementClass->image;
        // can share the const char* since it's immutable
        klass->namespaze = elementClass->namespaze;
        klass->name = GetArrayName(elementClass->name, rank, bounded);

        klass->parent = il2cpp_defaults.array_class;

        klass->flags = TYPE_ATTRIBUTE_AUTO_LAYOUT | TYPE_ATTRIBUTE_ANSI_CLASS | TYPE_ATTRIBUTE_CLASS | TYPE_ATTRIBUTE_PUBLIC | TYPE_ATTRIBUTE_SEALED | TYPE_ATTRIBUTE_SERIALIZABLE;
        klass->rank = rank;

        klass->instance_size = Class::GetInstanceSize(arrayClass);
        klass->stack_slot_size = sizeof(void*);
        klass->vtable_count = static_cast<uint16_t>(slots);

        // need this before we access the size or has_references
        Class::SetupFields(elementClass);

        klass->element_size = Class::GetArrayElementSize(elementClass);
        klass->native_size = klass->thread_static_fields_offset = -1;

        klass->has_references = Type::IsReference(&elementClass->byval_arg) || elementClass->has_references;

        klass->size_inited = true; // set only after instance_size and has_references are set

        klass->element_class = elementClass;
        SetupCastClass(klass);

        if (rank > 1 || bounded)
        {
            Il2CppArrayType *at = (Il2CppArrayType*)MetadataCalloc(1, sizeof(Il2CppArrayType));
            klass->byval_arg.type = IL2CPP_TYPE_ARRAY;
            klass->byval_arg.data.array = at;
            at->etype = &elementClass->byval_arg;
            at->rank = rank;
        }
        else
        {
            klass->byval_arg.type = IL2CPP_TYPE_SZARRAY;
            klass->byval_arg.data.type = &elementClass->byval_arg;
        }

        klass->this_arg = klass->byval_arg;
        klass->this_arg.byref = 1;

        if (rank > 1 || bounded)
        {
            klass->interfaces_count = 0;
        }
        else
        {
            klass->interfaces_count = kImplicitArrayInterfaceCount;
        }

        klass->interopData = MetadataCache::GetInteropDataForType(&klass->byval_arg);

        // Insert the new array class while still holding the g_MetadataLock
        // This ensures that the class is only added once
        // And WalkSZArrays and WalkArrays (see below) only take the g_MetadataLock and assume that the maps won't be changed
        // It's not safe to take the reader/writer lock there because those locks aren't re-entrant and those methods take
        // call backs that call arbitrary code

        if (rank > 1 || bounded)
            s_ArrayClassMap.Add(ArrayClassMap::key_type(std::make_pair(klass->element_class, klass->rank)), klass);
        else
            s_SZArrayClassMap.Add(klass->element_class, klass);

        return klass;
    }

    void ArrayMetadata::WalkSZArrays(ArrayTypeWalkCallback callback, void* context)
    {
        FastAutoLock lock(&il2cpp::vm::g_MetadataLock);

        for (SZArrayClassMap::iterator it = s_SZArrayClassMap.UnlockedBegin(); it != s_SZArrayClassMap.UnlockedEnd(); it++)
        {
            callback(it->second, context);
        }
    }

    void ArrayMetadata::WalkArrays(ArrayTypeWalkCallback callback, void* context)
    {
        FastAutoLock lock(&il2cpp::vm::g_MetadataLock);

        for (ArrayClassMap::iterator it = s_ArrayClassMap.UnlockedBegin(); it != s_ArrayClassMap.UnlockedEnd(); it++)
        {
            callback(it->second, context);
        }
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\ArrayMetadata.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\CustomAttributeCreator.cpp---------------
.
.
#include "CustomAttributeCreator.h"
#include "gc/WriteBarrier.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Property.h"
#include "vm/Runtime.h"

namespace il2cpp
{
namespace metadata
{
    static void* ConvertArgumentValue(const Il2CppType* targetType, const CustomAttributeArgument* arg)
    {
        // If the argument target target is a value type, then just pass a pointer to the data
        if (targetType->valuetype)
            return (void*)&arg->data;

        // Our target isn't value type, but our data is, we need to box
        if (il2cpp::vm::Class::IsValuetype(arg->klass))
            return il2cpp::vm::Object::Box(arg->klass, (void*)&arg->data);

        // Storing reference type data in a reference type field, just get the pointer to the object
        return arg->data.obj;
    }

    void CustomAttributeCreator::VisitCtor(const MethodInfo* ctor, CustomAttributeArgument args[], uint32_t argumentCount)
    {
        attr = il2cpp::vm::Object::New(ctor->klass);

        void** ctorArgs = (void**)alloca(argumentCount * sizeof(void*));
        for (uint32_t i = 0; i < argumentCount; i++)
            ctorArgs[i] = ConvertArgumentValue(ctor->parameters[i], args + i);
        il2cpp::vm::Runtime::Invoke(ctor, attr, ctorArgs, &exc);

        if (exc != NULL)
            attr = NULL;
    }

    void CustomAttributeCreator::VisitField(const CustomAttributeFieldArgument& field, uint32_t index)
    {
        if (exc != NULL)
            return;

        IL2CPP_ASSERT(attr);
        il2cpp::vm::Field::SetValue(attr, field.field, ConvertArgumentValue(field.field->type, &field.arg));
    }

    void CustomAttributeCreator::VisitProperty(const CustomAttributePropertyArgument& prop, uint32_t index)
    {
        if (exc != NULL)
            return;

        IL2CPP_ASSERT(attr);

        const MethodInfo* setMethod = il2cpp::vm::Property::GetSetMethod(prop.prop);
        IL2CPP_ASSERT(setMethod->parameters_count == 1);
        void* param = ConvertArgumentValue(setMethod->parameters[0], &prop.arg);

        il2cpp::vm::Runtime::Invoke(setMethod, attr, &param, &exc);
    }

    Il2CppObject* CustomAttributeCreator::GetAttribute(Il2CppException** exc)
    {
        *exc = this->exc;
        return attr;
    }
}     /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\CustomAttributeCreator.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\CustomAttributeDataReader.cpp---------------
.
.
#include "CustomAttributeDataReader.h"
#include "il2cpp-metadata.h"
#include "gc/WriteBarrier.h"
#include "utils/MemoryRead.h"
#include "vm-utils/BlobReader.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/GlobalMetadata.h"
#include "vm/MetadataCache.h"

// Custom attribute metadata format
//
// Custom attribute data is tightly packed and is not stored aligned
// it must be read with the helpers in MemoryRead
//
// Header:
// 1 Compressed uint32: Count of attributes types
// n uint32:            Attribute constructor indexes
//
// Argument data immediate follows the header
// There is no size data stored for arguments they must be serialized
// out as they are read.  This relies the writing code exactly matching
// the reading code.  Or else data will be read at the wrong offsets.
//
// Argument data
// 1 Compressed uint32:         Count of constructor arguments
//  n Blob data, variable sized:   Argument data
// 1 Compressed uint32:         Count of field arguments
//  n Blob data, variable sized:   Field argument data
//     Each field data ends with a compressed int32 of the field index on the type,
//     If the field index is negative, a compressed uint32_t with the declaring type index follows
// 1 Compressed uint32:         Count of property arguments
//  n Blob data, variable sized:   Property argument data
//     Each property data ends with a compressed int32 of the property index on the type
//     If the property index is negative, a compressed uint32_t with the declaring type index follows

// An example format is:
//
// 0x02         - Count of custom attribute constructors (compressed uint32_t)
// 0x0010023f   - Method definition index for ctor1
// 0x02001fc1   - Method definition index for ctor2
// 0x02         - Constructor argument count for ctor1 (compressed uint32_t)
// 0x04 (2)     - argument 1 type code (compressed int32_t)
// 0x00         - Field for ctor1 (compressed uint32_t)
// 0x01         - Property count for ctor1 (compressed uint32_t)
// ....         - argument 1 data
// 0x55         - property type code (enum) (compressed uint32_t)
// 0x023F       - type index for enum type (compressed uint32_t))
// ....         - property 1 data
// 0x02         - Constructor argument count for ctor2 (compressed uint32_t)
// 0x02         - Field argument count for ctor2 (compressed uint32_t)
// 0x00         - Property count for ctor2
// 0x03         - argument 1 type code (compressed uint32_t)
// ....         - argument 1 data
// 0x04         - argument 2 type code (compressed uint32_t)
// ....         - argument 2 data
// 0x04         - field 1 type code (compressed uint32_t)
// ....         - field 1 data
// 0x02 (1)     - field 1 field index (compressed int32_t)
// 0x04         - field 2 type code (compressed uint32_t)
// ....         - field 2 data
// 0x03 (-1)    - field 2 field index (compressed int32_t)
// 0x023E       - field 2 declaring type index (compressed int32_t)
// [Start of next custom attribute data]

static void SetInvalidDataException(Il2CppException** exc)
{
    il2cpp::gc::WriteBarrier::GenericStore(exc, il2cpp::vm::Exception::GetCustomAttributeFormatException("Binary format of the specified custom attribute was invalid."));
}

static bool ReadAttributeDataValue(const Il2CppImage* image, const char** buffer, il2cpp::metadata::CustomAttributeArgument* arg, Il2CppException** exc, bool deserializedManagedObjects)
{
    const Il2CppTypeEnum type = il2cpp::utils::BlobReader::ReadEncodedTypeEnum(image, buffer, &arg->klass);

    if (!il2cpp::utils::BlobReader::GetConstantValueFromBlob(image, type, buffer, &arg->data, deserializedManagedObjects))
    {
        SetInvalidDataException(exc);
        return false;
    }

    if (deserializedManagedObjects && type == IL2CPP_TYPE_SZARRAY && arg->data.obj != NULL)
    {
        // For arrays get the actual array class, not just System.Array
        arg->klass = ((Il2CppArray*)arg->data.obj)->klass;
    }

    return true;
}

namespace il2cpp
{
namespace metadata
{
    CustomAttributeDataReader::CustomAttributeDataReader(const Il2CppImage* image, const void* buffer, const void* bufferEnd) :
        image(image), bufferStart((const char*)buffer), bufferEnd((const char*)bufferEnd)
    {
        if (bufferStart != NULL)
            count = utils::ReadCompressedUInt32(&bufferStart);
        else
            count = 0;
    }

    // private, used by CustomAttributeDataReader::ReadCustomAttributeData(const MethodInfo* ctor, const void* dataStart, uint32_t dataLength, CustomAttributeData* data, Il2CppException** exc)
    CustomAttributeDataReader::CustomAttributeDataReader(const Il2CppImage* image, const char* dataStart, uint32_t dataLength) :
        image(image), bufferStart(dataStart), bufferEnd(dataStart + dataLength), count(0)
    {
    }

    uint32_t CustomAttributeDataReader::GetCount(const CustomAttributeFilter& filter) const
    {
        uint32_t count = 0;
        const char* ctorBuffer = bufferStart;
        const MethodInfo* ctor;
        while (IterateAttributeCtorsImpl(&ctor, &ctorBuffer))
        {
            if (filter(ctor))
                count++;
        }

        return count;
    }

    CustomAttributeCtorIterator CustomAttributeDataReader::GetCtorIterator() const
    {
        return CustomAttributeCtorIterator(bufferStart);
    }

    CustomAttributeCtorIterator CustomAttributeDataReader::GetCtorIterator(const CustomAttributeFilter& filter) const
    {
        return CustomAttributeCtorIterator(bufferStart, filter);
    }

    CustomAttributeDataIterator CustomAttributeDataReader::GetDataIterator() const
    {
        return CustomAttributeDataIterator(bufferStart, GetDataBufferStart());
    }

    CustomAttributeDataIterator CustomAttributeDataReader::GetDataIterator(const CustomAttributeFilter& filter) const
    {
        return CustomAttributeDataIterator(bufferStart, GetDataBufferStart(), filter);
    }

    const char* CustomAttributeDataReader::GetDataBufferStart() const
    {
        return (const char*)(((uint32_t*)bufferStart) + count);
    }

    bool CustomAttributeDataReader::IterateAttributeCtorsImpl(const MethodInfo** attributeCtor, const char** ctorBuffer) const
    {
        if (*ctorBuffer < GetDataBufferStart())
        {
            MethodIndex ctorIndex = utils::Read32(ctorBuffer);
            *attributeCtor = il2cpp::vm::MetadataCache::GetMethodInfoFromMethodDefinitionIndex(image, ctorIndex);
            return true;
        }

        *attributeCtor = NULL;
        return false;
    }

    bool CustomAttributeDataReader::IterateAttributeCtors(const MethodInfo** attributeCtor, CustomAttributeCtorIterator* iter) const
    {
        while (IterateAttributeCtorsImpl(attributeCtor, &iter->ctorBuffer))
        {
            if (iter->filter(*attributeCtor))
                return true;
        }

        return false;
    }

    bool CustomAttributeDataReader::ReadLazyCustomAttributeData(LazyCustomAttributeData* data, CustomAttributeDataIterator* iter, Il2CppException** exc) const
    {
        if (!IterateAttributeCtorsImpl(&data->ctor, &iter->ctorBuffer))
            return false;

        data->dataStart = (void*)iter->dataBuffer;

        if (!ReadPastCustomAttribute(data->ctor, iter, exc))
            return false;

        data->dataLength = (uint32_t)((char*)iter->dataBuffer - (char*)data->dataStart);

        return true;
    }

    bool CustomAttributeDataReader::VisitCustomAttributeData(const Il2CppImage* image, const MethodInfo* ctor, const void* dataStart, uint32_t dataLength, CustomAttributeReaderVisitor* visitor, Il2CppException** exc)
    {
        CustomAttributeDataReader reader = CustomAttributeDataReader(image, (const char*)dataStart, dataLength);
        CustomAttributeDataIterator iter = CustomAttributeDataIterator(NULL, reader.bufferStart);
        return reader.ReadAndVisitCustomAttributeData(ctor, &iter, visitor, exc);
    }

    bool CustomAttributeDataReader::VisitCustomAttributeData(CustomAttributeDataIterator* iter, CustomAttributeReaderVisitor* visitor, Il2CppException** exc) const
    {
        const MethodInfo* ctor;
        while (IterateAttributeCtorsImpl(&ctor, &iter->ctorBuffer))
        {
            bool shouldProcessThisAttr = iter->filter(ctor);
            if (shouldProcessThisAttr)
                return ReadAndVisitCustomAttributeData(ctor, iter, visitor, exc);

            if (!ReadPastCustomAttribute(ctor, iter, exc))
                return false;
        }

        return false;
    }

    static std::tuple<const Il2CppClass*, int32_t> ReadCustomAttributeNamedArgumentClassAndIndex(const char** dataBuffer, const Il2CppClass* attrClass)
    {
        int32_t memberIndex = utils::ReadCompressedInt32(dataBuffer);
        if (memberIndex >= 0)
            return std::make_tuple(attrClass, memberIndex);

        memberIndex = -(memberIndex + 1);

        TypeDefinitionIndex typeIndex = utils::ReadCompressedUInt32(dataBuffer);
        Il2CppClass* declaringClass = il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeDefinitionIndex(typeIndex);

        IL2CPP_ASSERT(declaringClass == attrClass || il2cpp::vm::Class::IsSubclassOf(const_cast<Il2CppClass*>(attrClass), declaringClass, false));

        return std::make_tuple(declaringClass, memberIndex);
    }

    bool CustomAttributeDataReader::ReadPastCustomAttribute(const MethodInfo* ctor, CustomAttributeDataIterator* iter, Il2CppException** exc) const
    {
        CustomAttributeReaderVisitor nullVisitor;
        return ReadAndVisitCustomAttributeImpl(ctor, iter, &nullVisitor, exc, false);
    }

    bool CustomAttributeDataReader::ReadAndVisitCustomAttributeData(const MethodInfo* ctor, CustomAttributeDataIterator* iter, CustomAttributeReaderVisitor* visitor, Il2CppException** exc) const
    {
        return ReadAndVisitCustomAttributeImpl(ctor, iter, visitor, exc, true);
    }

    bool CustomAttributeDataReader::ReadAndVisitCustomAttributeImpl(const MethodInfo* ctor, CustomAttributeDataIterator* iter, CustomAttributeReaderVisitor* visitor, Il2CppException** exc, bool deserializedManagedObjects) const
    {
        il2cpp::gc::WriteBarrier::GenericStoreNull(exc);

        Il2CppClass* attrClass = ctor->klass;

        uint32_t argumentCount = utils::ReadCompressedUInt32(&iter->dataBuffer);
        IL2CPP_ASSERT(iter->dataBuffer <= bufferEnd);
        uint32_t fieldCount = utils::ReadCompressedUInt32(&iter->dataBuffer);
        IL2CPP_ASSERT(iter->dataBuffer <= bufferEnd);
        uint32_t propertyCount = utils::ReadCompressedUInt32(&iter->dataBuffer);
        IL2CPP_ASSERT(iter->dataBuffer <= bufferEnd);

        if (iter->dataBuffer > bufferEnd)
        {
            // This should never happen
            IL2CPP_ASSERT(false);
            SetInvalidDataException(exc);
            return false;
        }

        visitor->MoveNext(ctor);

        visitor->VisitArgumentSizes(argumentCount, fieldCount, propertyCount);

        // CustomAttributeArgument may contain GC allocated types
        // So it either needs to be allocated on the stack or on the GC heap
        // Since these are arguments that would be passed to a method call, we assume that we're safe to stack allocate them
        CustomAttributeArgument* args = (CustomAttributeArgument*)alloca(argumentCount * sizeof(CustomAttributeArgument));

        for (uint32_t i = 0; i < argumentCount; i++)
        {
            if (!ReadAttributeDataValue(image, &iter->dataBuffer, args + i, exc, deserializedManagedObjects))
                return false;

            IL2CPP_ASSERT(iter->dataBuffer <= bufferEnd);
            visitor->VisitArgument(args[i], i);
        }

        visitor->VisitCtor(ctor, args, argumentCount);

        if (fieldCount > 0 || propertyCount > 0)
            vm::Class::Init(attrClass);

        for (uint32_t i = 0; i < fieldCount; i++)
        {
            CustomAttributeFieldArgument field = { 0 };
            if (!ReadAttributeDataValue(image, &iter->dataBuffer, &field.arg, exc, deserializedManagedObjects))
                return false;

            const Il2CppClass* klass;
            TypeFieldIndex fieldIndex;
            std::tie(klass, fieldIndex) = ReadCustomAttributeNamedArgumentClassAndIndex(&iter->dataBuffer, attrClass);

            IL2CPP_ASSERT(iter->dataBuffer <= bufferEnd);
            IL2CPP_ASSERT(fieldIndex < klass->field_count);

            field.field = &klass->fields[fieldIndex];
            visitor->VisitField(field, i);
        }

        for (uint32_t i = 0; i < propertyCount; i++)
        {
            CustomAttributePropertyArgument propArg = { 0 };
            if (!ReadAttributeDataValue(image, &iter->dataBuffer, &propArg.arg, exc, deserializedManagedObjects))
                return false;

            const Il2CppClass* klass;
            TypePropertyIndex propertyIndex;
            std::tie(klass, propertyIndex) = ReadCustomAttributeNamedArgumentClassAndIndex(&iter->dataBuffer, attrClass);

            IL2CPP_ASSERT(iter->dataBuffer <= bufferEnd);
            IL2CPP_ASSERT(propertyIndex < klass->property_count);

            propArg.prop = &klass->properties[propertyIndex];
            visitor->VisitProperty(propArg, i);
        }

        return true;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\CustomAttributeDataReader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\FieldLayout.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "vm/Class.h"
#include "vm/GenericClass.h"
#include "vm/GlobalMetadata.h"
#include "vm/Type.h"
#include "vm/Field.h"
#include "metadata/FieldLayout.h"
#include <limits>
#include <algorithm>

using il2cpp::vm::Class;
using il2cpp::vm::GenericClass;
using il2cpp::vm::Type;

namespace il2cpp
{
namespace metadata
{
    typedef void* voidptr_t;
#define IL2CPP_ALIGN_STRUCT(type) struct type ## AlignStruct {uint8_t pad; type t; };

    IL2CPP_ALIGN_STRUCT(voidptr_t)
    IL2CPP_ALIGN_STRUCT(int8_t)
    IL2CPP_ALIGN_STRUCT(int16_t)
    IL2CPP_ALIGN_STRUCT(int32_t)
    IL2CPP_ALIGN_STRUCT(int64_t)
    IL2CPP_ALIGN_STRUCT(intptr_t)
    IL2CPP_ALIGN_STRUCT(float)
    IL2CPP_ALIGN_STRUCT(double)

#define IL2CPP_ALIGN_OF(type) ((size_t)offsetof(type ## AlignStruct, t))

    SizeAndAlignment FieldLayout::GetTypeSizeAndAlignment(const Il2CppType* type)
    {
        SizeAndAlignment sa = { 0 };
        if (type->byref)
        {
            sa.size = sizeof(voidptr_t);
            sa.alignment = IL2CPP_ALIGN_OF(voidptr_t);
            return sa;
        }

        switch (type->type)
        {
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_BOOLEAN:
                sa.size = sizeof(int8_t);
                sa.alignment = IL2CPP_ALIGN_OF(int8_t);
                return sa;
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_CHAR:
                sa.size = sizeof(int16_t);
                sa.alignment = IL2CPP_ALIGN_OF(int16_t);
                return sa;
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_U4:
                sa.size = sizeof(int32_t);
                sa.alignment = IL2CPP_ALIGN_OF(int32_t);
                return sa;
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U8:
                sa.size = sizeof(int64_t);
                sa.alignment = IL2CPP_ALIGN_OF(int64_t);
                return sa;
            case IL2CPP_TYPE_I:
            case IL2CPP_TYPE_U:
                // TODO should we use pointer or size_t here?
                sa.size = sizeof(intptr_t);
                sa.alignment = IL2CPP_ALIGN_OF(intptr_t);
                return sa;
            case IL2CPP_TYPE_R4:
                sa.size = sizeof(float);
                sa.alignment = IL2CPP_ALIGN_OF(float);
                return sa;
            case IL2CPP_TYPE_R8:
                sa.size = sizeof(double);
                sa.alignment = IL2CPP_ALIGN_OF(double);
                return sa;
            case IL2CPP_TYPE_PTR:
            case IL2CPP_TYPE_FNPTR:
            case IL2CPP_TYPE_STRING:
            case IL2CPP_TYPE_SZARRAY:
            case IL2CPP_TYPE_ARRAY:
            case IL2CPP_TYPE_CLASS:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:
                sa.size = sizeof(voidptr_t);
                sa.alignment = IL2CPP_ALIGN_OF(voidptr_t);
                return sa;
            case IL2CPP_TYPE_VALUETYPE:
                if (Type::IsEnum(type))
                {
                    return GetTypeSizeAndAlignment(Class::GetEnumBaseType(Type::GetClass(type)));
                }
                else
                {
                    uint32_t alignment;
                    Il2CppClass* klass = Type::GetClass(type);
                    sa.size = Class::GetValueSize(klass, &alignment);
                    sa.alignment = alignment;
                    return sa;
                }
            case IL2CPP_TYPE_GENERICINST:
            {
                Il2CppGenericClass* gclass = type->data.generic_class;
                Il2CppClass* container_class = GenericClass::GetTypeDefinition(gclass);

                if (container_class != NULL && container_class->byval_arg.valuetype)
                {
                    if (container_class->enumtype)
                    {
                        return GetTypeSizeAndAlignment(Class::GetEnumBaseType(container_class));
                    }
                    else
                    {
                        uint32_t alignment;
                        sa.size = Class::GetValueSize(Class::FromIl2CppType(type), &alignment);
                        sa.alignment = alignment;
                        return sa;
                    }
                }
                else
                {
                    sa.size = sizeof(voidptr_t);
                    sa.alignment = IL2CPP_ALIGN_OF(voidptr_t);
                    return sa;
                }
            }
            default:
                IL2CPP_ASSERT(0);
                break;
        }
        return sa;
    }

    static size_t AlignTo(size_t size, size_t alignment)
    {
        if (size & (alignment - 1))
        {
            size += alignment - 1;
            size &= ~(alignment - 1);
        }

        return size;
    }

    void FieldLayout::LayoutInstanceFields(const Il2CppClass* klass, size_t parentSize, size_t actualParentSize, size_t parentAlignment, uint8_t packing, FieldLayoutData& data)
    {
        LayoutFields(klass, vm::Field::IsInstance, parentSize, actualParentSize, parentAlignment, packing, klass->flags & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT && klass->generic_class == NULL, data);
    }

    void FieldLayout::LayoutStaticFields(const Il2CppClass* klass, FieldLayoutData& data)
    {
        LayoutFields(klass, vm::Field::IsNormalStatic, 0, 0, 1, 0, false, data);
    }

    void FieldLayout::LayoutThreadStaticFields(const Il2CppClass* klass, FieldLayoutData& data)
    {
        LayoutFields(klass, vm::Field::IsThreadStatic, 0, 0, 1, 0, false, data);
    }

    void FieldLayout::LayoutFields(const Il2CppClass* klass, FieldInfoFilter filter, size_t parentSize, size_t actualParentSize, size_t parentAlignment, uint8_t packing, bool isExplicitLayout, FieldLayoutData& data)
    {
        data.classSize = parentSize;
        data.actualClassSize = actualParentSize;
        IL2CPP_ASSERT(parentAlignment <= std::numeric_limits<uint8_t>::max());
        data.minimumAlignment = static_cast<uint8_t>(parentAlignment);
        for (uint16_t i = 0; i < klass->field_count; i++)
        {
            if (!filter(klass->fields + i))
                continue;

            SizeAndAlignment sa = GetTypeSizeAndAlignment(klass->fields[i].type);
            uint8_t alignment = sa.alignment;
            if (packing > 0)
                alignment = std::min(sa.alignment, packing);
            size_t offset = isExplicitLayout ? klass->fields[i].offset : data.actualClassSize;

            offset += alignment - 1;
            offset &= ~(alignment - 1);

            data.FieldOffsets.push_back(offset);
            data.actualClassSize = std::max(data.actualClassSize, offset + std::max(sa.size, (size_t)1));
            data.minimumAlignment = std::max(data.minimumAlignment, alignment);
        }

        data.classSize = AlignTo(data.actualClassSize, data.minimumAlignment);

        // C++ ABI difference between MS and Clang
#if IL2CPP_CXX_ABI_MSVC
        data.actualClassSize = data.classSize;
#endif
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\FieldLayout.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\GenericMetadata.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-runtime-stats.h"
#include "os/Mutex.h"
#include "vm/Class.h"
#include "vm/GenericClass.h"
#include "vm/Image.h"
#include "vm/Runtime.h"
#include "vm/Type.h"
#include "metadata/GenericMetadata.h"
#include "metadata/GenericMethod.h"
#include "metadata/Il2CppGenericClassHash.h"
#include "metadata/Il2CppGenericClassCompare.h"
#include "metadata/Il2CppGenericInstCompare.h"
#include "metadata/Il2CppGenericInstHash.h"
#include "metadata/Il2CppTypeCompare.h"
#include "metadata/Il2CppTypeHash.h"
#include "utils/Memory.h"
#include "utils/Il2CppHashMap.h"
#include "utils/Il2CppHashSet.h"
#include "utils/StringUtils.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataCache.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-tabledefs.h"
#include <vector>

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

using namespace il2cpp::vm;
using il2cpp::metadata::GenericMethod;
using il2cpp::os::FastAutoLock;
using il2cpp::utils::StringUtils;

using std::vector;
using std::pair;

namespace il2cpp
{
namespace metadata
{
    const Il2CppType** GenericMetadata::InflateParameters(const Il2CppType** parameters, uint8_t parameterCount, const Il2CppGenericContext* context, bool inflateMethodVars)
    {
        const Il2CppType** inflatedParameters = (const Il2CppType**)MetadataCalloc(parameterCount, sizeof(Il2CppType*));

        for (uint8_t j = 0; j < parameterCount; j++)
        {
            inflatedParameters[j] = InflateIfNeeded(parameters[j], context, inflateMethodVars);
        }

        return inflatedParameters;
    }

    static const Il2CppType* InflateGenericParameterIfNeeded(const Il2CppType* type, const Il2CppGenericInst* inst)
    {
        IL2CPP_ASSERT(inst);

        Il2CppGenericParameterInfo gp = Type::GetGenericParameterInfo(type);
        IL2CPP_ASSERT(gp.num < inst->type_argc);

        const Il2CppType* genericArgument = inst->type_argv[gp.num];
        if (genericArgument->attrs == type->attrs && genericArgument->byref == type->byref)
            return genericArgument;

        Il2CppType* inflatedType = (Il2CppType*)MetadataMalloc(sizeof(Il2CppType));
        memcpy(inflatedType,  genericArgument, sizeof(Il2CppType));
        inflatedType->byref = type->byref;
        inflatedType->attrs = type->attrs;

        ++il2cpp_runtime_stats.inflated_type_count;

        return inflatedType;
    }

    const Il2CppType* GenericMetadata::InflateIfNeeded(const Il2CppType* type, const Il2CppGenericContext* context, bool inflateMethodVars)
    {
        switch (type->type)
        {
            case IL2CPP_TYPE_VAR:
                return InflateGenericParameterIfNeeded(type, context->class_inst);
            case IL2CPP_TYPE_MVAR:
            {
                if (context->method_inst)
                    return InflateGenericParameterIfNeeded(type, context->method_inst);
                return type;
            }
            case IL2CPP_TYPE_ARRAY:
            {
                const Il2CppType* inflatedElementType = InflateIfNeeded(type->data.array->etype, context, inflateMethodVars);
                if (!Il2CppTypeEqualityComparer::AreEqual(inflatedElementType, type->data.array->etype))
                {
                    Il2CppType* inflatedType = (Il2CppType*)MetadataMalloc(sizeof(Il2CppType));
                    memcpy(inflatedType, type, sizeof(Il2CppType));

                    Il2CppArrayType* arrayType = (Il2CppArrayType*)MetadataMalloc(sizeof(Il2CppArrayType));
                    memcpy(arrayType, type->data.array, sizeof(Il2CppArrayType));
                    arrayType->etype = inflatedElementType;
                    inflatedType->data.array = arrayType;

                    ++il2cpp_runtime_stats.inflated_type_count;

                    return inflatedType;
                }
                return type;
            }
            case IL2CPP_TYPE_PTR:
            case IL2CPP_TYPE_SZARRAY:
            {
                const Il2CppType* inflatedElementType = InflateIfNeeded(type->data.type, context, inflateMethodVars);
                if (!Il2CppTypeEqualityComparer::AreEqual(inflatedElementType, type->data.type))
                {
                    Il2CppType* arrayType = (Il2CppType*)MetadataMalloc(sizeof(Il2CppType));
                    memcpy(arrayType, type, sizeof(Il2CppType));
                    arrayType->data.type = inflatedElementType;

                    ++il2cpp_runtime_stats.inflated_type_count;

                    return arrayType;
                }
                return type;
            }
            case IL2CPP_TYPE_GENERICINST:
            {
                const Il2CppGenericInst* inst = type->data.generic_class->context.class_inst;
                if (inst == NULL)
                    return NULL; // This is a generic type that was too deeply nested to generate

                const Il2CppGenericInst* inflatedInst = GetInflatedGenericIntance(inst, context, inflateMethodVars);
                Il2CppGenericClass* genericClass = GenericMetadata::GetGenericClass(GenericClass::GetTypeDefinition(type->data.generic_class), inflatedInst);
                if (genericClass != type->data.generic_class)
                {
                    Il2CppType* genericType = (Il2CppType*)MetadataMalloc(sizeof(Il2CppType));
                    memcpy(genericType, type, sizeof(Il2CppType));
                    genericType->data.generic_class = genericClass;

                    ++il2cpp_runtime_stats.inflated_type_count;

                    return genericType;
                }

                return type;
            }
            default:
                return type;
        }
    }

    static baselib::ReentrantLock s_GenericClassMutex;
    typedef Il2CppHashSet<Il2CppGenericClass*, Il2CppGenericClassHash, Il2CppGenericClassCompare> Il2CppGenericClassSet;
    static Il2CppGenericClassSet s_GenericClassSet;


    Il2CppGenericClass* GenericMetadata::GetGenericClass(const Il2CppClass* genericTypeDefinition, const Il2CppGenericInst* inst)
    {
        return GetGenericClass(&genericTypeDefinition->byval_arg, inst);
    }

    Il2CppGenericClass* GenericMetadata::GetGenericClass(const Il2CppType* genericTypeDefinition, const Il2CppGenericInst* inst)
    {
        // Assert that the element type is a non-inflated generic type defintion
        IL2CPP_ASSERT(il2cpp::vm::Class::IsGenericTypeDefinition(vm::Class::FromIl2CppType(genericTypeDefinition)));

        // temporary inst to lookup a permanent one that may already exist
        Il2CppGenericClass genericClass = { 0 };
        genericClass.type = genericTypeDefinition;
        genericClass.context.class_inst = inst;

        FastAutoLock lock(&s_GenericClassMutex);
        Il2CppGenericClassSet::const_iterator iter = s_GenericClassSet.find(&genericClass);
        if (iter != s_GenericClassSet.end())
            return *iter;

        Il2CppGenericClass* newClass = MetadataAllocGenericClass();
        newClass->type = genericTypeDefinition;
        newClass->context.class_inst = inst;

        s_GenericClassSet.insert(newClass);

        ++il2cpp_runtime_stats.generic_class_count;

        return newClass;
    }

    const MethodInfo* GenericMetadata::Inflate(const MethodInfo* methodDefinition, const Il2CppGenericContext* context)
    {
        return GenericMethod::GetMethod(methodDefinition, context->class_inst, context->method_inst);
    }

    static int RecursiveGenericDepthFor(const Il2CppGenericInst* inst);

    static int RecursiveGenericDepthFor(Il2CppGenericClass* genericClass)
    {
        int classInstDepth = RecursiveGenericDepthFor(genericClass->context.class_inst);
        int methodInstDepth = RecursiveGenericDepthFor(genericClass->context.method_inst);
        return std::max(classInstDepth, methodInstDepth);
    }

    static int RecursiveGenericDepthFor(const Il2CppGenericInst* inst)
    {
        if (inst == NULL)
            return 0;

        int maximumDepth = 0;
        for (size_t i = 0; i < inst->type_argc; i++)
        {
            if (inst->type_argv[i]->type == IL2CPP_TYPE_GENERICINST)
            {
                maximumDepth = std::max(maximumDepth, RecursiveGenericDepthFor(inst->type_argv[i]->data.generic_class));
            }
        }

        return maximumDepth + 1;
    }

    const Il2CppGenericMethod* GenericMetadata::Inflate(const Il2CppGenericMethod* genericMethod, const Il2CppGenericContext* context)
    {
        const Il2CppGenericInst* classInst = GetInflatedGenericIntance(genericMethod->context.class_inst, context, true);
        const Il2CppGenericInst* methodInst = GetInflatedGenericIntance(genericMethod->context.method_inst, context, true);

        // We have cases where we could infinitely recurse, inflating generics at runtime. This will lead to a stack overflow.
        // As we do for code generation, let's cut this off at an arbitrary level. If something tries to execute code at this
        // level, a crash will happen. We'll assume that this code won't actually be executed though.
        int maximumRuntimeGenericDepth = GetMaximumRuntimeGenericDepth();
        if (!il2cpp::vm::Runtime::IsLazyRGCTXInflationEnabled() && (RecursiveGenericDepthFor(classInst) > maximumRuntimeGenericDepth || RecursiveGenericDepthFor(methodInst) > maximumRuntimeGenericDepth))
            return NULL;

        return MetadataCache::GetGenericMethod(genericMethod->methodDefinition, classInst, methodInst);
    }

    const Il2CppGenericInst* GenericMetadata::GetInflatedGenericIntance(const Il2CppGenericInst* inst, const Il2CppGenericContext* context, bool inflateMethodVars)
    {
        if (inst == NULL)
            return NULL;

        const Il2CppType** inflatedArgs = (const Il2CppType**)alloca(inst->type_argc * sizeof(Il2CppType*));
        for (size_t i = 0; i < inst->type_argc; i++)
            inflatedArgs[i] = InflateIfNeeded(inst->type_argv[i], context, inflateMethodVars);
        return MetadataCache::GetGenericInst(inflatedArgs, inst->type_argc);
    }

    static void ConstrainedCallsToGenericInterfaceMethodsOnStructsAreNotSupported()
    {
        vm::Exception::Raise(vm::Exception::GetNotSupportedException("Cannot make a constrained call to a default interface method from a value type"));
    }

    static void ConstrainedCallsToGenericInterfaceMethodsOnStructsAreNotSupportedInvoker(Il2CppMethodPointer ptr, const MethodInfo* method, void* obj, void** args, void* ret)
    {
        ConstrainedCallsToGenericInterfaceMethodsOnStructsAreNotSupported();
    }

    Il2CppRGCTXData* GenericMetadata::InflateRGCTXLocked(const Il2CppImage* image, uint32_t token, const Il2CppGenericContext* context, const FastAutoLock& lock)
    {
        // This method assumes that it has the g_MetadataLock

        RGCTXCollection collection = MetadataCache::GetRGCTXs(image, token);
        if (collection.count == 0)
            return NULL;

        Il2CppRGCTXData* dataValues = (Il2CppRGCTXData*)MetadataCalloc(collection.count, sizeof(Il2CppRGCTXData));
        for (RGCTXIndex rgctxIndex = 0; rgctxIndex < collection.count; rgctxIndex++)
        {
            const Il2CppRGCTXDefinition* definitionData = collection.items + rgctxIndex;
            switch (definitionData->type)
            {
                case IL2CPP_RGCTX_DATA_TYPE:
                    dataValues[rgctxIndex].type = GenericMetadata::InflateIfNeeded(MetadataCache::GetTypeFromRgctxDefinition(definitionData), context, true);
                    break;
                case IL2CPP_RGCTX_DATA_CLASS:
                    dataValues[rgctxIndex].klass = Class::FromIl2CppType(GenericMetadata::InflateIfNeeded(MetadataCache::GetTypeFromRgctxDefinition(definitionData), context, true));
                    Class::InitSizeAndFieldLayoutLocked(dataValues[rgctxIndex].klass, lock);
                    break;
                case IL2CPP_RGCTX_DATA_METHOD:
                    dataValues[rgctxIndex].method = GenericMethod::GetMethod(Inflate(MetadataCache::GetGenericMethodFromRgctxDefinition(definitionData), context));
                    break;
                case IL2CPP_RGCTX_DATA_CONSTRAINED:
                {
                    const Il2CppType* type;
                    const MethodInfo* method;
                    std::tie(type, method) = MetadataCache::GetConstrainedCallFromRgctxDefinition(definitionData);

                    const Il2CppType* inflatedType = GenericMetadata::InflateIfNeeded(type, context, true);
                    if (method->is_inflated)
                        method = GenericMethod::GetMethod(Inflate(method->genericMethod, context));

                    if (inflatedType->valuetype)
                    {
                        Il2CppClass* inflatedClass = Class::FromIl2CppType(inflatedType);
                        Class::InitLocked(inflatedClass, lock);
                        Class::InitLocked(method->klass, lock);
                        method = Class::GetVirtualMethod(inflatedClass, method);
                    }

                    dataValues[rgctxIndex].method = method;
                }
                break;
                default:
                    IL2CPP_ASSERT(0);
            }
        }

        return dataValues;
    }

// temporary while we generate generics
    void GenericMetadata::RegisterGenericClasses(Il2CppGenericClass* const * genericClasses, int32_t genericClassesCount)
    {
        s_GenericClassSet.resize(genericClassesCount / 2 + 1);

        // don't lock, this should only be called from startup and temporarily
        for (int32_t i = 0; i < genericClassesCount; i++)
        {
            if (genericClasses[i]->type != NULL)
                s_GenericClassSet.insert(genericClasses[i]);
        }
    }

    bool GenericMetadata::ContainsGenericParameters(const Il2CppClass* klass)
    {
        if (!klass->generic_class)
            return false;

        return ContainsGenericParameters(klass->generic_class->context.class_inst);
    }

    bool GenericMetadata::ContainsGenericParameters(const MethodInfo* method)
    {
        if (!method->is_inflated)
            return false;

        if (ContainsGenericParameters(method->genericMethod->context.method_inst))
            return true;
        if (method->genericMethod->context.class_inst == NULL)
            return false;
        return ContainsGenericParameters(method->genericMethod->context.class_inst);
    }

    bool GenericMetadata::ContainsGenericParameters(const Il2CppGenericInst* inst)
    {
        for (uint32_t i = 0; i < inst->type_argc; i++)
        {
            if (ContainsGenericParameters(inst->type_argv[i]))
                return true;
        }

        return false;
    }

    bool GenericMetadata::ContainsGenericParameters(const Il2CppType* type)
    {
        switch (type->type)
        {
            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:
                return true;
            case IL2CPP_TYPE_GENERICINST:
                return ContainsGenericParameters(type->data.generic_class->context.class_inst);
            case IL2CPP_TYPE_ARRAY:
                return ContainsGenericParameters(type->data.array->etype);
            case IL2CPP_TYPE_SZARRAY:
            case IL2CPP_TYPE_PTR:
            case IL2CPP_TYPE_BYREF:
                return ContainsGenericParameters(type->data.type);
            default:
                return false;
        }

        return false;
    }

    void GenericMetadata::WalkAllGenericClasses(GenericClassWalkCallback callback, void* context)
    {
        FastAutoLock lock(&s_GenericClassMutex);

        for (Il2CppGenericClassSet::iterator it = s_GenericClassSet.begin(); it != s_GenericClassSet.end(); it++)
        {
            if ((*it).key->cached_class != NULL)
                callback((*it).key->cached_class, context);
        }
    }

    void GenericMetadata::Clear()
    {
        for (Il2CppGenericClassSet::iterator genericClass = s_GenericClassSet.begin(); genericClass != s_GenericClassSet.end(); genericClass++)
            (*genericClass).key->cached_class = NULL;
        s_GenericClassSet.clear();
    }

    static int s_MaximumRuntimeGenericDepth;
    static int s_GenericVirtualIterations;

    int GenericMetadata::GetMaximumRuntimeGenericDepth()
    {
        return s_MaximumRuntimeGenericDepth;
    }

    void GenericMetadata::SetMaximumRuntimeGenericDepth(int depth)
    {
        s_MaximumRuntimeGenericDepth = depth;
    }

    int GenericMetadata::GetGenericVirtualIterations()
    {
        return s_GenericVirtualIterations;
    }

    void GenericMetadata::SetGenericVirtualIterations(int iterations)
    {
        s_GenericVirtualIterations = iterations;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\GenericMetadata.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\GenericMethod.cpp---------------
.
.
#include "il2cpp-config.h"
#include "metadata/GenericMetadata.h"
#include "metadata/GenericMethod.h"
#include "metadata/GenericSharing.h"
#include "metadata/Il2CppGenericMethodCompare.h"
#include "metadata/Il2CppGenericMethodHash.h"
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "utils/Memory.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/GenericClass.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataCache.h"
#include "vm/MetadataLock.h"
#include "vm/Method.h"
#include "vm/Runtime.h"
#include "vm/Type.h"
#include "utils/Il2CppHashMap.h"
#include "utils/InitOnce.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-runtime-metadata.h"
#include "il2cpp-runtime-stats.h"
#include <string>

using il2cpp::metadata::GenericMetadata;
using il2cpp::metadata::GenericSharing;
using il2cpp::os::FastAutoLock;
using il2cpp::vm::Class;
using il2cpp::vm::GenericClass;
using il2cpp::vm::MetadataCalloc;
using il2cpp::vm::MetadataCache;
using il2cpp::vm::Method;
using il2cpp::vm::Runtime;
using il2cpp::vm::Type;

struct FullySharedGenericMethodInfo : public MethodInfo
{
    FullySharedGenericMethodInfo() { memset(this, 0, sizeof(*this)); }
    Il2CppMethodPointer rawVirtualMethodPointer;
    Il2CppMethodPointer rawDirectMethodPointer;
    InvokerMethod rawInvokerMethod;
};

static size_t SizeOfGenericMethodInfo(bool hasFullGenericSignature)
{
    if (hasFullGenericSignature)
        return sizeof(FullySharedGenericMethodInfo);
    return sizeof(MethodInfo);
}

static MethodInfo* AllocGenericMethodInfo(bool hasFullGenericSignature)
{
    return (MethodInfo*)MetadataCalloc(1, SizeOfGenericMethodInfo(hasFullGenericSignature));
}

static MethodInfo* AllocCopyGenericMethodInfo(const MethodInfo* sourceMethodInfo)
{
    MethodInfo* newMethodInfo = AllocGenericMethodInfo(sourceMethodInfo->has_full_generic_sharing_signature);
    memcpy(newMethodInfo, sourceMethodInfo, SizeOfGenericMethodInfo(sourceMethodInfo->has_full_generic_sharing_signature));
    return newMethodInfo;
}

static void FullySharedGenericInvokeRedirectHasAdjustorThunk(Il2CppMethodPointer methodPointer, const MethodInfo* method, void* obj, void** args, void* retVal)
{
    IL2CPP_ASSERT(Method::IsGenericInstance(method));
    IL2CPP_ASSERT(il2cpp::vm::Runtime::IsFullGenericSharingEnabled());
    IL2CPP_ASSERT(methodPointer == method->virtualMethodPointer || methodPointer == method->methodPointer);

    const FullySharedGenericMethodInfo* sharedMethodInfo = reinterpret_cast<const FullySharedGenericMethodInfo*>(method);
    IL2CPP_ASSERT(sharedMethodInfo->rawDirectMethodPointer != sharedMethodInfo->rawVirtualMethodPointer);

    if (methodPointer == sharedMethodInfo->virtualMethodPointer)
        sharedMethodInfo->rawInvokerMethod(sharedMethodInfo->rawVirtualMethodPointer, method, obj, args, retVal);
    else
        sharedMethodInfo->rawInvokerMethod(sharedMethodInfo->rawDirectMethodPointer, method, obj, args, retVal);
}

static void FullySharedGenericInvokeRedirectNoAdjustorThunk(Il2CppMethodPointer methodPointer, const MethodInfo* method, void* obj, void** args, void* retVal)
{
    IL2CPP_ASSERT(Method::IsGenericInstance(method));
    IL2CPP_ASSERT(il2cpp::vm::Runtime::IsFullGenericSharingEnabled());
    IL2CPP_ASSERT(methodPointer == method->methodPointer || methodPointer == method->virtualMethodPointer);

    const FullySharedGenericMethodInfo* sharedMethodInfo = reinterpret_cast<const FullySharedGenericMethodInfo*>(method);
    IL2CPP_ASSERT(sharedMethodInfo->rawDirectMethodPointer == sharedMethodInfo->rawVirtualMethodPointer);

    sharedMethodInfo->rawInvokerMethod(sharedMethodInfo->rawDirectMethodPointer, method, obj, args, retVal);
}

namespace il2cpp
{
namespace metadata
{
    typedef Il2CppReaderWriterLockedHashMap<const Il2CppGenericMethod*, MethodInfo*, Il2CppGenericMethodHash, Il2CppGenericMethodCompare> Il2CppGenericMethodMap;
    static Il2CppGenericMethodMap s_GenericMethodMap;
    static Il2CppGenericMethodMap s_PendingGenericMethodMap;

    static bool HasFullGenericSharedParametersOrReturn(const MethodInfo* methodDefinition, const Il2CppType** inflatedParameterTypes)
    {
        // If a method has a variable sized return type, the FGS method will always
        // expect the return value to be passed as a by ref parameter
        if (Type::HasVariableRuntimeSizeWhenFullyShared(methodDefinition->return_type))
            return true;

        for (int i = 0; i < methodDefinition->parameters_count; i++)
        {
            // Value types are passed by ref, but reference types are passed normally, so if the inflated parameter is a
            // reference type, we don't have a signature difference.
            if (Type::IsValueType(inflatedParameterTypes[i]) && Type::HasVariableRuntimeSizeWhenFullyShared(methodDefinition->parameters[i]))
                return true;
        }

        return false;
    }

    static void AnUnresolvedCallStubWasNotFound()
    {
        vm::Exception::Raise(vm::Exception::GetExecutionEngineException("An unresolved indirect call lookup failed"));
    }

    // This method must have a different signature than AnUnresolvedCallStubWasNotFound to prevent identical COMDAT folding
    // FullySharedGenericInvokeRedirectHasAdjustorThunk relies on this method having a different address
    static void AnUnresolvedCallStubWasNotFoundValueType(void* obj)
    {
        vm::Exception::Raise(vm::Exception::GetExecutionEngineException("An unresolved indirect call to a value type failed"));
    }

    static void AGenericMethodWhichIsTooDeeplyNestedWasInvoked()
    {
        vm::Exception::Raise(vm::Exception::GetMaximumNestedGenericsException());
    }

    static void AGenericMethodWhichIsTooDeeplyNestedWasInvokedInvoker(Il2CppMethodPointer ptr, const MethodInfo* method, void* obj, void** args, void* ret)
    {
        AGenericMethodWhichIsTooDeeplyNestedWasInvoked();
    }

    static FullySharedGenericMethodInfo ambiguousMethodInfo;

    bool GenericMethod::IsGenericAmbiguousMethodInfo(const MethodInfo* method)
    {
        return method == &ambiguousMethodInfo;
    }

    const MethodInfo* GenericMethod::GetGenericVirtualMethod(const MethodInfo* vtableSlotMethod, const MethodInfo* genericVirtualMethod)
    {
        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(GetGenericVirtualMethod, "We should only do the following slow method lookup once and then cache on type itself.");

        const Il2CppGenericInst* classInst = NULL;
        if (vtableSlotMethod->is_inflated)
        {
            classInst = vtableSlotMethod->genericMethod->context.class_inst;
            vtableSlotMethod = vtableSlotMethod->genericMethod->methodDefinition;
        }

        return metadata::GenericMethod::GetMethod(vtableSlotMethod, classInst, genericVirtualMethod->genericMethod->context.method_inst);
    }

    const MethodInfo* GenericMethod::GetMethod(const MethodInfo* methodDefinition, const Il2CppGenericInst* classInst, const Il2CppGenericInst* methodInst)
    {
        Il2CppGenericMethod gmethod = { 0 };
        gmethod.methodDefinition = methodDefinition;
        gmethod.context.class_inst = classInst;
        gmethod.context.method_inst = methodInst;
        return GetMethod(&gmethod, true);
    }

    MethodInfo* GenericMethod::AllocateNewMethodInfo(const MethodInfo* methodDefinition, const Il2CppGenericInst* classInst, const Il2CppGenericInst* methodInst)
    {
        const MethodInfo* methodInfo = GetMethod(methodDefinition, classInst, methodInst);
        return AllocCopyGenericMethodInfo(methodInfo);
    }

    const MethodInfo* GenericMethod::GetMethod(const Il2CppGenericMethod* gmethod)
    {
        return GetMethod(gmethod, false);
    }

    const MethodInfo* GenericMethod::GetMethod(const Il2CppGenericMethod* gmethod, bool copyMethodPtr)
    {
        // This can be NULL only when we have hit the generic recursion depth limit.
        if (gmethod == NULL)
        {
            MethodInfo* newMethod = AllocGenericMethodInfo(il2cpp::vm::Runtime::IsFullGenericSharingEnabled());
            if (il2cpp::vm::Runtime::IsFullGenericSharingEnabled())
            {
                ((FullySharedGenericMethodInfo*)newMethod)->rawVirtualMethodPointer = AGenericMethodWhichIsTooDeeplyNestedWasInvoked;
                ((FullySharedGenericMethodInfo*)newMethod)->rawDirectMethodPointer = AGenericMethodWhichIsTooDeeplyNestedWasInvoked;
                ((FullySharedGenericMethodInfo*)newMethod)->rawInvokerMethod = AGenericMethodWhichIsTooDeeplyNestedWasInvokedInvoker;
            }

            newMethod->methodPointer = AGenericMethodWhichIsTooDeeplyNestedWasInvoked;
            newMethod->virtualMethodPointer = AGenericMethodWhichIsTooDeeplyNestedWasInvoked;
            newMethod->invoker_method = AGenericMethodWhichIsTooDeeplyNestedWasInvokedInvoker;
            return newMethod;
        }

        // First check for an already constructed generic method using the shared/reader lock
        MethodInfo* existingMethod;
        if (s_GenericMethodMap.TryGet(gmethod, &existingMethod))
            return existingMethod;

        if (Method::IsAmbiguousMethodInfo(gmethod->methodDefinition))
        {
            // is_inflated is used as an initialized check
            if (!ambiguousMethodInfo.is_inflated)
            {
                memcpy(&ambiguousMethodInfo, gmethod->methodDefinition, sizeof(MethodInfo));
                ambiguousMethodInfo.is_inflated = true;
                ambiguousMethodInfo.rawVirtualMethodPointer = gmethod->methodDefinition->virtualMethodPointer;
                ambiguousMethodInfo.rawDirectMethodPointer = gmethod->methodDefinition->methodPointer;
                ambiguousMethodInfo.invoker_method = gmethod->methodDefinition->invoker_method;
            }

            return &ambiguousMethodInfo;
        }

        return CreateMethodLocked(gmethod, copyMethodPtr);
    }

    const MethodInfo* GenericMethod::CreateMethodLocked(const Il2CppGenericMethod* gmethod, bool copyMethodPtr)
    {
        // We need to inflate a new generic method, take the metadata mutex
        // All code below this point can and does assume mutual exclusion
        FastAutoLock lock(&il2cpp::vm::g_MetadataLock);

        // Recheck the s_GenericMethodMap in case there was a race to add this generic method
        MethodInfo* existingMethod;
        if (s_GenericMethodMap.TryGet(gmethod, &existingMethod))
            return existingMethod;

        // GetMethodLocked may be called recursively, we keep tracking of pending inflations
        if (s_PendingGenericMethodMap.TryGet(gmethod, &existingMethod))
            return existingMethod;

        if (copyMethodPtr)
            gmethod = MetadataCache::GetGenericMethod(gmethod->methodDefinition, gmethod->context.class_inst, gmethod->context.method_inst);

        const MethodInfo* methodDefinition = gmethod->methodDefinition;
        Il2CppClass* declaringClass = methodDefinition->klass;
        if (gmethod->context.class_inst)
        {
            Il2CppGenericClass* genericClassDeclaringType = GenericMetadata::GetGenericClass(methodDefinition->klass, gmethod->context.class_inst);
            declaringClass = GenericClass::GetClass(genericClassDeclaringType);

            // we may fail if we cannot construct generic type
            if (!declaringClass)
                return NULL;
        }

        const Il2CppType** parameters = GenericMetadata::InflateParameters(methodDefinition->parameters, methodDefinition->parameters_count, &gmethod->context, true);
        il2cpp::vm::Il2CppGenericMethodPointers methodPointers = MetadataCache::GetGenericMethodPointers(methodDefinition, &gmethod->context);
        bool hasFullGenericSharingSignature = methodPointers.isFullGenericShared && HasFullGenericSharedParametersOrReturn(gmethod->methodDefinition, parameters);

        MethodInfo* newMethod = AllocGenericMethodInfo(hasFullGenericSharingSignature);

        // we set the pending generic method map here because the initialization may recurse and try to retrieve the same generic method
        // this is safe because we *always* take the lock when retrieving the MethodInfo from a generic method.
        // if we move lock to only if MethodInfo needs constructed then we need to revisit this since we could return a partially initialized MethodInfo
        s_PendingGenericMethodMap.Add(gmethod, newMethod);

        newMethod->klass = declaringClass;
        newMethod->flags = methodDefinition->flags;
        newMethod->iflags = methodDefinition->iflags;
        newMethod->slot = methodDefinition->slot;
        newMethod->name = methodDefinition->name;
        newMethod->is_generic = false;
        newMethod->is_inflated = true;
        newMethod->token = methodDefinition->token;

        newMethod->return_type = GenericMetadata::InflateIfNeeded(methodDefinition->return_type, &gmethod->context, true);

        newMethod->parameters_count = methodDefinition->parameters_count;
        newMethod->parameters = parameters;

        newMethod->genericMethod = gmethod;

        if (!gmethod->context.method_inst)
        {
            if (methodDefinition->is_generic)
                newMethod->is_generic = true;

            if (!declaringClass->generic_class)
            {
                newMethod->genericContainerHandle = methodDefinition->genericContainerHandle;
            }

            newMethod->methodMetadataHandle = methodDefinition->methodMetadataHandle;
        }
        else if (!il2cpp::vm::Runtime::IsLazyRGCTXInflationEnabled() && !il2cpp::metadata::GenericMetadata::ContainsGenericParameters(newMethod))
        {
            // we only need RGCTX for generic instance methods
            newMethod->rgctx_data = InflateRGCTXLocked(gmethod, lock);
        }

        newMethod->virtualMethodPointer = methodPointers.virtualMethodPointer;
        newMethod->methodPointer = methodPointers.methodPointer;
        if (methodPointers.methodPointer)
        {
            newMethod->invoker_method = methodPointers.invoker_method;
        }
        else
        {
            newMethod->invoker_method = Runtime::GetMissingMethodInvoker();
            il2cpp::vm::Il2CppUnresolvedCallStubs stubs = MetadataCache::GetUnresovledCallStubs(newMethod);
            newMethod->methodPointer = stubs.methodPointer;
            newMethod->virtualMethodPointer = stubs.virtualMethodPointer;
        }

        newMethod->has_full_generic_sharing_signature = hasFullGenericSharingSignature;

        ++il2cpp_runtime_stats.inflated_method_count;

        if (il2cpp::vm::Method::HasFullGenericSharingSignature(newMethod))
        {
            // The method has a full generic sharing signature - that is it a fully shared method an has any fully shared parameter types or return type,
            // then its signature doesn't match the expected signature
            // e.g. If List<T>::Insert(T t) is fully shared then for List<int>::Insert(int), the C++ fully shared instance would be List::Insert(void*) and require an int* to be passed in.
            // So in that case we use the unresolved call stubs to find a matching standard signature to wrap any indirect/virtual calls

            FullySharedGenericMethodInfo* sharedMethodInfo = reinterpret_cast<FullySharedGenericMethodInfo*>(newMethod);
            sharedMethodInfo->rawVirtualMethodPointer = newMethod->virtualMethodPointer;
            sharedMethodInfo->rawDirectMethodPointer = newMethod->methodPointer;
            sharedMethodInfo->rawInvokerMethod = newMethod->invoker_method;

            bool hasAdjustorThunk = newMethod->methodPointer != newMethod->virtualMethodPointer;
            if (hasAdjustorThunk)
                newMethod->invoker_method = FullySharedGenericInvokeRedirectHasAdjustorThunk;
            else
                newMethod->invoker_method = FullySharedGenericInvokeRedirectNoAdjustorThunk;

            il2cpp::vm::Il2CppUnresolvedCallStubs stubs = MetadataCache::GetUnresovledCallStubs(newMethod);
            if (stubs.stubsFound)
            {
                newMethod->methodPointer = stubs.methodPointer;
                newMethod->virtualMethodPointer = stubs.virtualMethodPointer;
            }
            else
            {
                newMethod->methodPointer = AnUnresolvedCallStubWasNotFound;
                newMethod->virtualMethodPointer = AnUnresolvedCallStubWasNotFound;

                if (hasAdjustorThunk)
                {
                    // The FullySharedGenericInvokeRedirectHasAdjustorThunk requires that methodPointer and virtualMethodPointer be different
                    // so it can tell which raw* method it should call even though it doesn't directly call them
                    IL2CPP_ASSERT(reinterpret_cast<Il2CppMethodPointer>(AnUnresolvedCallStubWasNotFoundValueType) != AnUnresolvedCallStubWasNotFound);
                    if (reinterpret_cast<Il2CppMethodPointer>(AnUnresolvedCallStubWasNotFoundValueType) != AnUnresolvedCallStubWasNotFound)
                    {
                        newMethod->methodPointer = reinterpret_cast<Il2CppMethodPointer>(AnUnresolvedCallStubWasNotFoundValueType);
                    }
                    else
                    {
                        // If we got hit by COMDAT folding (but in DEBUG, which is the most likely way it would happen)
                        // Ensure that are methodPointers are definitely different
                        // We'll get an less specific error message, but it's better than corruption
                        // Make the change on methodPointer because we're most likely to be called
                        newMethod->methodPointer = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo()->methodPointer;
                    }
                }
            }
        }

        // If we are a default interface method on a generic instance interface we need to ensure that the interfaces rgctx is inflated
        if (Method::IsDefaultInterfaceMethodOnGenericInstance(newMethod))
            vm::Class::InitLocked(declaringClass, lock);

        // The generic method is fully created,
        // Update the generic method map, this needs to take an exclusive lock
        // **** This must happen with the metadata lock held and be released before the metalock is released ****
        // **** This prevents deadlocks and ensures that there is no race condition
        // **** creating a new method adding it to s_GenericMethodMap and removing it from s_PendingGenericMethodMap
        s_GenericMethodMap.Add(gmethod, newMethod);

        // Remove the method from the pending table
        s_PendingGenericMethodMap.Remove(gmethod);

        return newMethod;
    }

    const Il2CppRGCTXData* GenericMethod::InflateRGCTX(const MethodInfo* method)
    {
        IL2CPP_ASSERT(method->is_inflated);
        IL2CPP_ASSERT(method->genericMethod);
        IL2CPP_ASSERT(method->genericMethod->context.method_inst);

        return il2cpp::utils::InitOnce(const_cast<Il2CppRGCTXData**>(&method->rgctx_data), &il2cpp::vm::g_MetadataLock, [method](const il2cpp::os::FastAutoLock& lock) {
            return const_cast<Il2CppRGCTXData*>(GenericMethod::InflateRGCTXLocked(method->genericMethod, lock));
        });
    }

    const Il2CppRGCTXData* GenericMethod::InflateRGCTXLocked(const Il2CppGenericMethod* gmethod, const il2cpp::os::FastAutoLock &lock)
    {
        return GenericMetadata::InflateRGCTXLocked(gmethod->methodDefinition->klass->image, gmethod->methodDefinition->token, &gmethod->context, lock);
    }

    const Il2CppGenericContext* GenericMethod::GetContext(const Il2CppGenericMethod* gmethod)
    {
        return &gmethod->context;
    }

    static std::string FormatGenericArguments(const Il2CppGenericInst* inst)
    {
        std::string output;
        if (inst)
        {
            output.append("<");
            for (size_t i = 0; i < inst->type_argc; ++i)
            {
                if (i != 0)
                    output.append(", ");
                output.append(Type::GetName(inst->type_argv[i], IL2CPP_TYPE_NAME_FORMAT_FULL_NAME));
            }
            output.append(">");
        }

        return output;
    }

    std::string GenericMethod::GetFullName(const Il2CppGenericMethod* gmethod)
    {
        const MethodInfo* method = gmethod->methodDefinition;
        std::string output;
        output.append(Type::GetName(&gmethod->methodDefinition->klass->byval_arg, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME));
        output.append(FormatGenericArguments(gmethod->context.class_inst));
        output.append("::");
        output.append(Method::GetName(method));
        output.append(FormatGenericArguments(gmethod->context.method_inst));

        return output;
    }

    void GenericMethod::ClearStatics()
    {
        s_GenericMethodMap.Clear();
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\GenericMethod.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\GenericSharing.cpp---------------
.
.
#include "il2cpp-config.h"
#include "metadata/GenericSharing.h"
#include "vm/Type.h"
#include "il2cpp-runtime-metadata.h"

using il2cpp::vm::Type;

namespace il2cpp
{
namespace metadata
{
    bool GenericSharing::IsShareable(Il2CppGenericClass* gclass)
    {
        const Il2CppGenericInst* classInst = gclass->context.class_inst;
        if (classInst)
        {
            for (uint32_t i = 0; i < classInst->type_argc; ++i)
            {
                if (!Type::IsReference(classInst->type_argv[i]))
                    return false;
            }
        }

        return true;
    }

    bool GenericSharing::IsShareable(Il2CppGenericMethod* gmethod)
    {
        const Il2CppGenericInst* methodInst = gmethod->context.method_inst;
        if (methodInst)
        {
            for (uint32_t i = 0; i < methodInst->type_argc; ++i)
            {
                if (!Type::IsReference(methodInst->type_argv[i]))
                    return false;
            }
        }

        return true;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\GenericSharing.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericClassCompare.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericClassCompare.h"
#include "Il2CppGenericInstCompare.h"
#include "Il2CppTypeCompare.h"

namespace il2cpp
{
namespace metadata
{
    bool Il2CppGenericClassCompare::operator()(const Il2CppGenericClass* gc1, const Il2CppGenericClass* gc2) const
    {
        return Compare(gc1, gc2);
    }

    bool Il2CppGenericClassCompare::Compare(const Il2CppGenericClass* gc1, const Il2CppGenericClass* gc2)
    {
        if (!Il2CppTypeEqualityComparer::AreEqual(gc1->type, gc2->type))
            return false;

        return Il2CppGenericInstCompare::Compare(gc1->context.class_inst, gc2->context.class_inst);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericClassCompare.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericClassHash.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericClassHash.h"
#include "Il2CppGenericContextHash.h"
#include "Il2CppTypeHash.h"
#include "utils/HashUtils.h"

using il2cpp::utils::HashUtils;

namespace il2cpp
{
namespace metadata
{
    size_t Il2CppGenericClassHash::operator()(const Il2CppGenericClass* item) const
    {
        return Hash(item);
    }

    size_t Il2CppGenericClassHash::Hash(const Il2CppGenericClass* item)
    {
        size_t containerHash = Il2CppTypeHash::Hash(item->type);
        size_t contextHash = Il2CppGenericContextHash::Hash(&item->context);

        return HashUtils::Combine(containerHash, contextHash);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericClassHash.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericContextCompare.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericContextCompare.h"
#include "Il2CppGenericInstCompare.h"

namespace il2cpp
{
namespace metadata
{
    bool Il2CppGenericContextCompare::operator()(const Il2CppGenericContext* gc1, const Il2CppGenericContext* gc2) const
    {
        return Compare(gc1, gc2);
    }

    bool Il2CppGenericContextCompare::Compare(const Il2CppGenericContext* gc1, const Il2CppGenericContext* gc2)
    {
        return gc1->class_inst == gc2->class_inst && gc1->method_inst == gc2->method_inst;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericContextCompare.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericContextHash.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericContextHash.h"
#include "Il2CppGenericInstHash.h"
#include "Il2CppTypeHash.h"
#include "utils/HashUtils.h"

using il2cpp::utils::HashUtils;

namespace il2cpp
{
namespace metadata
{
    size_t Il2CppGenericContextHash::operator()(const Il2CppGenericContext* context) const
    {
        return Hash(context);
    }

    size_t Il2CppGenericContextHash::Hash(const Il2CppGenericContext* context)
    {
        size_t classInstHash = HashUtils::AlignedPointerHash(context->class_inst);
        size_t methodInstHash = HashUtils::AlignedPointerHash(context->method_inst);

        return HashUtils::Combine(classInstHash, methodInstHash);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericContextHash.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericInstCompare.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericInstCompare.h"
#include "Il2CppTypeCompare.h"

namespace il2cpp
{
namespace metadata
{
    bool Il2CppGenericInstCompare::operator()(const KeyWrapper<const Il2CppGenericInst*>& t1, const KeyWrapper<const Il2CppGenericInst*>& t2) const
    {
        return Compare(t1, t2);
    }

    bool Il2CppGenericInstCompare::Compare(const KeyWrapper<const Il2CppGenericInst*>& t1, const KeyWrapper<const Il2CppGenericInst*>& t2)
    {
        if (t1.type != t2.type)
            return false;
        else if (!t1.isNormal())
            return true;

        return AreEqual(t1.key, t2.key);
    }

    bool Il2CppGenericInstCompare::AreEqual(const Il2CppGenericInst* t1, const Il2CppGenericInst* t2)
    {
        if (t1->type_argc != t2->type_argc)
            return false;

        for (size_t i = 0; i < t1->type_argc; ++i)
        {
            if (!Il2CppTypeEqualityComparer::AreEqual(t1->type_argv[i], t2->type_argv[i]))
                return false;
        }

        return true;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericInstCompare.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericInstHash.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericInstHash.h"
#include "Il2CppTypeHash.h"
#include "utils/HashUtils.h"

using il2cpp::utils::HashUtils;

namespace il2cpp
{
namespace metadata
{
    size_t Il2CppGenericInstHash::operator()(const Il2CppGenericInst* item) const
    {
        return Hash(item);
    }

    size_t Il2CppGenericInstHash::Hash(const Il2CppGenericInst* item)
    {
        size_t hash = item->type_argc;
        for (size_t i = 0; i < item->type_argc; ++i)
            hash = HashUtils::Combine(hash, Il2CppTypeHash::Hash(item->type_argv[i]));

        return hash;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericInstHash.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericMethodCompare.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericMethodCompare.h"
#include "Il2CppGenericContextCompare.h"

namespace il2cpp
{
namespace metadata
{
    bool Il2CppGenericMethodCompare::operator()(const Il2CppGenericMethod* m1, const Il2CppGenericMethod* m2) const
    {
        return Equals(m1, m2);
    }

    bool Il2CppGenericMethodCompare::Equals(const Il2CppGenericMethod* m1, const Il2CppGenericMethod* m2)
    {
        if (m1->methodDefinition != m2->methodDefinition)
            return false;

        return Il2CppGenericContextCompare::Compare(&m1->context, &m2->context);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericMethodCompare.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericMethodHash.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppGenericMethodHash.h"
#include "Il2CppGenericContextHash.h"
#include "utils/HashUtils.h"

using il2cpp::utils::HashUtils;

namespace il2cpp
{
namespace metadata
{
    size_t Il2CppGenericMethodHash::operator()(const Il2CppGenericMethod* method) const
    {
        return Hash(method);
    }

    size_t Il2CppGenericMethodHash::Hash(const Il2CppGenericMethod* method)
    {
        size_t tokenHash = method->methodDefinition->token;
        size_t contextHash = Il2CppGenericContextHash::Hash(&method->context);

        return HashUtils::Combine(tokenHash, contextHash);
    }
} /* namespace metadata */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppGenericMethodHash.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppSignature.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppSignature.h"
#include "Il2CppTypeCompare.h"
#include "Il2CppTypeHash.h"
#include "utils/HashUtils.h"

using il2cpp::utils::HashUtils;

namespace il2cpp
{
namespace metadata
{
    size_t Il2CppSignatureHash::operator()(const Il2CppSignature& signature) const
    {
        return Hash(signature);
    }

    size_t Il2CppSignatureHash::Hash(const Il2CppSignature& signature)
    {
        size_t retVal = signature.Count;

        for (size_t i = 0; i < signature.Count; ++i)
            retVal = HashUtils::Combine(retVal, Il2CppTypeHash::Hash(signature.Types[i]));

        return retVal;
    }

    bool Il2CppSignatureCompare::operator()(const Il2CppSignature& s1, const Il2CppSignature& s2) const
    {
        return Equals(s1, s2);
    }

    bool Il2CppSignatureCompare::Equals(const Il2CppSignature& s1, const Il2CppSignature& s2)
    {
        if (s1.Count != s2.Count)
            return false;


        for (size_t i = 0; i < s1.Count; ++i)
        {
            if (!Il2CppTypeEqualityComparer::AreEqual(s1.Types[i], s2.Types[i]))
                return false;
        }

        return true;
    }
} /* namespace metadata */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppSignature.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppTypeCompare.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppTypeCompare.h"

namespace il2cpp
{
namespace metadata
{
    template<typename T>
    static inline int Compare(const T& left, const T& right)
    {
        if (left == right)
            return 0;

        if (left < right)
            return -1;

        return 1;
    }

    static int Compare(const Il2CppType* t1, const Il2CppType* t2)
    {
        int result = Compare(t1->type, t2->type);
        if (result != 0)
            return result;

        result = Compare(t1->byref, t2->byref);
        if (result != 0)
            return result;

        switch (t1->type)
        {
            case IL2CPP_TYPE_VALUETYPE:
            case IL2CPP_TYPE_CLASS:
                return Compare(t1->data.typeHandle, t2->data.typeHandle);

            case IL2CPP_TYPE_PTR:
            case IL2CPP_TYPE_SZARRAY:
                return Compare(t1->data.type, t2->data.type);

            case IL2CPP_TYPE_ARRAY:
            {
                result = Compare(t1->data.array->rank, t2->data.array->rank);
                if (result != 0)
                    return result;

                return Compare(t1->data.array->etype, t2->data.array->etype);
            }
            case IL2CPP_TYPE_GENERICINST:
            {
                const Il2CppGenericInst *i1 = t1->data.generic_class->context.class_inst;
                const Il2CppGenericInst *i2 = t2->data.generic_class->context.class_inst;

                // this happens when maximum generic recursion is hit
                if (i1 == NULL || i2 == NULL)
                {
                    if (i1 == i2)
                        return 0;
                    return (i1 == NULL) ? -1 : 1;
                }

                result = Compare(i1->type_argc, i2->type_argc);
                if (result != 0)
                    return result;

                result = Compare(t1->data.generic_class->type, t2->data.generic_class->type);
                if (result != 0)
                    return result;

                /* FIXME: we should probably just compare the instance pointers directly.  */
                for (uint32_t i = 0; i < i1->type_argc; ++i)
                {
                    result = Compare(i1->type_argv[i], i2->type_argv[i]);
                    if (result != 0)
                        return result;
                }

                return 0;
            }
            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:
                return Compare(t1->data.genericParameterHandle, t2->data.genericParameterHandle);
            default:
                return 0;
        }

        IL2CPP_NOT_IMPLEMENTED(Il2CppTypeEqualityComparer::compare);
        return Compare(static_cast<const void*>(t1), static_cast<const void*>(t2));
    }

    bool Il2CppTypeEqualityComparer::AreEqual(const Il2CppType* t1, const Il2CppType* t2)
    {
        return Compare(t1, t2) == 0;
    }

    bool Il2CppTypeLess::operator()(const Il2CppType * t1, const Il2CppType * t2) const
    {
        return Compare(t1, t2) < 0;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppTypeCompare.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppTypeHash.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "Il2CppTypeHash.h"
#include "utils/StringUtils.h"
#include "utils/HashUtils.h"

using il2cpp::utils::HashUtils;
using il2cpp::utils::StringUtils;

namespace il2cpp
{
namespace metadata
{
    size_t Il2CppTypeHash::operator()(const Il2CppType* t1) const
    {
        return Hash(t1);
    }

    size_t Il2CppTypeHash::Hash(const Il2CppType* t1)
    {
        size_t hash = t1->type;

        hash = HashUtils::Combine(hash, t1->byref);

        switch (t1->type)
        {
            case IL2CPP_TYPE_VALUETYPE:
            case IL2CPP_TYPE_CLASS:
            {
                return HashUtils::Combine(hash, reinterpret_cast<size_t>(t1->data.typeHandle));
            }
            case IL2CPP_TYPE_SZARRAY:
            case IL2CPP_TYPE_PTR:
            {
                return HashUtils::Combine(hash, Hash(t1->data.type));
            }
            case IL2CPP_TYPE_GENERICINST:
            {
                const Il2CppGenericInst *inst = t1->data.generic_class->context.class_inst;
                hash = HashUtils::Combine(hash, Hash(t1->data.generic_class->type));
                for (uint32_t i = 0; i < inst->type_argc; ++i)
                {
                    hash = HashUtils::Combine(hash, Hash(inst->type_argv[i]));
                }
                return hash;
            }
            default:
                return hash;
        }
        return hash;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\metadata\Il2CppTypeHash.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\MonoPosixHelper.cpp---------------
.
.
#include "MonoPosixHelper.h"

#include <string.h>
#include <stdlib.h>

#include "../external/zlib/zlib.h"

#include "vm/Exception.h"

#define BUFFER_SIZE 4096
#define ARGUMENT_ERROR -10
#define IO_ERROR -11

typedef int32_t (*read_write_func)(intptr_t buffer, int32_t length, intptr_t gchandle);

struct ZStream
{
    z_stream *stream;
    uint8_t *buffer;
    read_write_func func;
    void *gchandle;
    uint8_t compress;
    uint8_t eof;
    uint32_t total_in;
};

static int32_t write_to_managed(ZStream *stream)
{
    int32_t n;
    z_stream *zs;

    zs = stream->stream;
    if (zs->avail_out != BUFFER_SIZE)
    {
        intptr_t buffer_ptr = reinterpret_cast<intptr_t>(stream->buffer);
        intptr_t gchandle_ptr = reinterpret_cast<intptr_t>(stream->gchandle);

        n = stream->func(buffer_ptr, BUFFER_SIZE - zs->avail_out, gchandle_ptr);
        zs->next_out = stream->buffer;
        zs->avail_out = BUFFER_SIZE;
        if (n < 0)
            return IO_ERROR;
    }
    return 0;
}

static int32_t flush_internal(ZStream *stream, bool is_final)
{
    int32_t status;

    if (!stream->compress)
        return 0;

    if (!is_final && stream->stream->avail_in != 0)
    {
        status = deflate(stream->stream, Z_PARTIAL_FLUSH);
        if (status != Z_OK && status != Z_STREAM_END)
            return status;
    }

    return write_to_managed(stream);
}

static void *z_alloc(void *opaque, uint32_t nitems, uint32_t item_size)
{
    return calloc(nitems, item_size);
}

static void z_free(void *opaque, void *ptr)
{
    free(ptr);
}

intptr_t CreateZStream(int32_t compress, uint8_t gzip, Il2CppMethodPointer func_ptr, intptr_t gchandle)
{
    z_stream *z;
    int32_t retval;
    ZStream *result;

    intptr_t result_ptr = 0;
    read_write_func func = (read_write_func)func_ptr;

    if (func == NULL)
        return result_ptr;

#if !defined(ZLIB_VERNUM) || (ZLIB_VERNUM < 0x1204)
    // Older versions of zlib do not support raw deflate or gzip
    return NULL;
#endif

    z = (z_stream*)calloc(1, sizeof(z_stream));
    if (compress)
    {
        retval = deflateInit2(z, Z_DEFAULT_COMPRESSION, Z_DEFLATED, gzip ? 31 : -15, 8, Z_DEFAULT_STRATEGY);
    }
    else
    {
        retval = inflateInit2(z, gzip ? 31 : -15);
    }

    if (retval != Z_OK)
    {
        free(z);
        return result_ptr;
    }

    z->zalloc = z_alloc;
    z->zfree = z_free;
    result = (ZStream*)calloc(1, sizeof(ZStream));
    result->stream = z;
    result->func = func;
    result->gchandle = reinterpret_cast<void*>(gchandle);
    result->compress = compress;
    result->buffer = (uint8_t*)malloc(BUFFER_SIZE * sizeof(uint8_t));

    result->stream->next_out = result->buffer;
    result->stream->avail_out = BUFFER_SIZE;
    result->stream->total_in = 0;

    result_ptr = reinterpret_cast<intptr_t>(result);
    return result_ptr;
}

int32_t CloseZStream(intptr_t zstream)
{
    int32_t status;
    int32_t flush_status;

    ZStream *stream = reinterpret_cast<ZStream*>(zstream);

    if (stream == NULL)
        return ARGUMENT_ERROR;

    status = 0;
    if (stream->compress)
    {
        if (stream->stream->total_in > 0)
        {
            do
            {
                status = deflate(stream->stream, Z_FINISH);
                flush_status = flush_internal(stream, true);
            }
            while (status == Z_OK); /* We want Z_STREAM_END or error here here */

            if (status == Z_STREAM_END)
                status = flush_status;
        }
        deflateEnd(stream->stream);
    }
    else
    {
        inflateEnd(stream->stream);
    }

    free(stream->buffer);
    free(stream->stream);
    memset(stream, 0, sizeof(ZStream));
    free(stream);

    return status;
}

int32_t Flush(intptr_t zstream)
{
    ZStream *stream = (ZStream*)zstream;
    return flush_internal(stream, false);
}

int32_t ReadZStream(intptr_t zstream, intptr_t zbuffer, int32_t length)
{
    int32_t n;
    int32_t status;
    z_stream *zs;

    ZStream *stream = (ZStream*)zstream;
    uint8_t *buffer = (uint8_t*)zbuffer;

    if (stream == NULL || buffer == NULL || length < 0)
        return ARGUMENT_ERROR;

    if (stream->eof)
        return 0;

    zs = stream->stream;
    zs->next_out = buffer;
    zs->avail_out = length;
    while (zs->avail_out > 0)
    {
        if (zs->avail_in == 0)
        {
            intptr_t buffer_ptr = reinterpret_cast<intptr_t>(stream->buffer);
            intptr_t gchandle_ptr = reinterpret_cast<intptr_t>(stream->gchandle);

            n = stream->func(buffer_ptr, BUFFER_SIZE, gchandle_ptr);
            if (n < 0)
                n = 0;

            // Even if avail_in reports zero, and we have no more data from the stream,
            // inflate may have more data to return.  So we cannot break here and need to
            // keep calling inflate until it returns Z_STREAM_END.

            stream->total_in += n;
            zs->next_in = stream->buffer;
            zs->avail_in = n;
        }

        status = inflate(stream->stream, Z_SYNC_FLUSH);
        if (status == Z_STREAM_END)
        {
            stream->eof = 1;
            break;
        }
        else if (status == Z_BUF_ERROR && stream->total_in == zs->total_in)
        {
            if (zs->avail_in != 0)
            {
                stream->eof = 1;
            }
            break;
        }
        else if (status != Z_OK)
        {
            return status;
        }
    }
    return length - zs->avail_out;
}

int32_t WriteZStream(intptr_t zstream, intptr_t zbuffer, int32_t length)
{
    int32_t n;
    int32_t status;
    z_stream *zs;

    ZStream *stream = (ZStream*)zstream;
    uint8_t *buffer = (uint8_t*)zbuffer;

    if (stream == NULL || buffer == NULL || length < 0)
        return ARGUMENT_ERROR;

    if (stream->eof)
        return IO_ERROR;

    zs = stream->stream;
    zs->next_in = buffer;
    zs->avail_in = length;
    while (zs->avail_in > 0)
    {
        if (zs->avail_out == 0)
        {
            zs->next_out = stream->buffer;
            zs->avail_out = BUFFER_SIZE;
        }
        status = deflate(stream->stream, Z_NO_FLUSH);
        if (status != Z_OK && status != Z_STREAM_END)
            return status;

        if (zs->avail_out == 0)
        {
            n = write_to_managed(stream);
            if (n < 0)
                return n;
        }
    }
    return length;
}

// The following methods are used by LinuxNetworkChange
// Which the implementation for System.Net.NetworkInformation.NetworkChange on linux
// These are here we throw a NotImplemented exception rather than getting an entry point not found
// We could probably port this if we hard the time

intptr_t CreateNLSocket()
{
    IL2CPP_NOT_IMPLEMENTED(CreateNLSocket);
    NOT_SUPPORTED_IL2CPP(CreateNLSocket, Not implemented);
    return 0;
}

int32_t ReadEvents(intptr_t sock, intptr_t buffer, int32_t count, int32_t size)
{
    IL2CPP_NOT_IMPLEMENTED(ReadEvents);
    NOT_SUPPORTED_IL2CPP(ReadEvents, Not implemented);
    return 0;
}

intptr_t CloseNLSocket(intptr_t sock)
{
    IL2CPP_NOT_IMPLEMENTED(CloseNLSocket);
    NOT_SUPPORTED_IL2CPP(CloseNLSocket, Not implemented);
    return 0;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\MonoPosixHelper.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\threadpool-ms-io-poll.cpp---------------
.
.
#include "il2cpp-config.h"

#include "gc/GarbageCollector.h"
#include "mono/ThreadPool/threadpool-ms-io-poll.h"
#include "os/Socket.h"
#include "utils/Memory.h"
#include "vm/Thread.h"

#include <vector>

static std::vector<il2cpp::os::PollRequest> *poll_fds;
static unsigned int poll_fds_capacity;
static unsigned int poll_fds_size;

static inline void
POLL_INIT_FD(il2cpp::os::PollRequest *poll_fd, int fd, il2cpp::os::PollFlags events)
{
    poll_fd->fd = fd;
    poll_fd->events = events;
    poll_fd->revents = il2cpp::os::kPollFlagsNone;
}

bool poll_init(int wakeup_pipe_fd)
{
    IL2CPP_ASSERT(wakeup_pipe_fd >= 0);

    poll_fds_size = 1;
    poll_fds_capacity = 64;

    poll_fds = new std::vector<il2cpp::os::PollRequest>(poll_fds_capacity);

    POLL_INIT_FD(&(*poll_fds)[0], wakeup_pipe_fd, il2cpp::os::kPollFlagsIn);

    return true;
}

void poll_register_fd(int fd, int events, bool is_new)
{
    unsigned int i;
    il2cpp::os::PollFlags poll_event;

    IL2CPP_ASSERT(fd >= 0);
    IL2CPP_ASSERT(poll_fds_size <= poll_fds_capacity);

    IL2CPP_ASSERT((events & ~(EVENT_IN | EVENT_OUT)) == 0);

    poll_event = il2cpp::os::kPollFlagsNone;
    if (events & EVENT_IN)
        poll_event |= il2cpp::os::kPollFlagsIn;
    if (events & EVENT_OUT)
        poll_event |= il2cpp::os::kPollFlagsOut;

    for (i = 0; i < poll_fds_size; ++i)
    {
        if ((*poll_fds)[i].fd == fd)
        {
            IL2CPP_ASSERT(!is_new);
            POLL_INIT_FD(&(*poll_fds)[i], fd, poll_event);
            return;
        }
    }

    IL2CPP_ASSERT(is_new);

    for (i = 0; i < poll_fds_size; ++i)
    {
        if ((*poll_fds)[i].fd == -1)
        {
            POLL_INIT_FD(&(*poll_fds)[i], fd, poll_event);
            return;
        }
    }

    poll_fds_size += 1;

    if (poll_fds_size > poll_fds_capacity)
    {
        poll_fds_capacity *= 2;
        IL2CPP_ASSERT(poll_fds_size <= poll_fds_capacity);

        poll_fds->resize(poll_fds_capacity, il2cpp::os::PollRequest(-1));
    }

    POLL_INIT_FD(&(*poll_fds)[poll_fds_size - 1], fd, poll_event);
}

void poll_remove_fd(int fd)
{
    unsigned int i;

    IL2CPP_ASSERT(fd >= 0);

    for (i = 0; i < poll_fds_size; ++i)
    {
        if ((*poll_fds)[i].fd == fd)
        {
            POLL_INIT_FD(&(*poll_fds)[i], -1, il2cpp::os::kPollFlagsNone);
            break;
        }
    }

    /* if we don't find the fd in poll_fds,
     * it means we try to delete it twice */
    IL2CPP_ASSERT(i < poll_fds_size);

    /* if we find it again, it means we added
     * it twice */
    for (; i < poll_fds_size; ++i)
        IL2CPP_ASSERT((*poll_fds)[i].fd != fd);

    /* reduce the value of poll_fds_size so we
     * do not keep it too big */
    while (poll_fds_size > 1 && (*poll_fds)[poll_fds_size - 1].fd == -1)
        poll_fds_size -= 1;
}

static inline int
poll_mark_bad_fds(std::vector<il2cpp::os::PollRequest> *poll_fds, int poll_fds_size)
{
    int i, ready = 0;
    int32_t result, error = 0;

    for (i = 0; i < poll_fds_size; i++)
    {
        if ((*poll_fds)[i].fd == -1)
            continue;

        il2cpp::os::WaitStatus status = il2cpp::os::Socket::Poll((*poll_fds)[i], 0, &result, &error);

        if (status == kWaitStatusFailure)
        {
            if ((il2cpp::os::SocketError)error == il2cpp::os::kInvalidHandle)
            {
                (*poll_fds)[i].revents |= il2cpp::os::kPollFlagsNVal;
                ready++;
            }
        }
        else if (result > 0)
            ready++;
    }

    return ready;
}

int poll_event_wait(void (*callback)(int fd, int events, void* user_data), void* user_data)
{
    unsigned int i;

    for (i = 0; i < poll_fds_size; ++i)
        (*poll_fds)[i].revents = il2cpp::os::kPollFlagsNone;

    il2cpp::gc::GarbageCollector::SetSkipThread(true);

    int32_t ready;
    int32_t error;
    il2cpp::os::WaitStatus status = il2cpp::os::Socket::Poll((*poll_fds), poll_fds_size , -1, &ready, &error);

    il2cpp::gc::GarbageCollector::SetSkipThread(false);

    if (ready == -1 || status == kWaitStatusFailure)
    {
        /*
         * Apart from EINTR, we only check EBADF, for the rest:
         *  EINVAL: mono_poll() 'protects' us from descriptor
         *      numbers above the limit if using select() by marking
         *      then as POLLERR.  If a system poll() is being
         *      used, the number of descriptor we're passing will not
         *      be over sysconf(_SC_OPEN_MAX), as the error would have
         *      happened when opening.
         *
         *  EFAULT: we own the memory pointed by pfds.
         *  ENOMEM: we're doomed anyway
         *
         */

        if ((il2cpp::os::SocketError)error == il2cpp::os::kInterrupted)
        {
            il2cpp::vm::Thread::CheckCurrentThreadForInterruptAndThrowIfNecessary();
            ready = 0;
        }
        else if ((il2cpp::os::SocketError)error == il2cpp::os::kInvalidHandle)
        {
            ready = poll_mark_bad_fds(poll_fds, poll_fds_size);
        }
    }

    if (ready == -1)
        return -1;
    if (ready == 0)
        return 0;

    IL2CPP_ASSERT(ready > 0);

    for (i = 0; i < poll_fds_size; ++i)
    {
        int fd, events = 0;

        if ((*poll_fds)[i].fd == -1)
            continue;
        if ((*poll_fds)[i].revents == 0)
            continue;

        fd = (int)(*poll_fds)[i].fd;
        if ((*poll_fds)[i].revents & (il2cpp::os::kPollFlagsIn | il2cpp::os::kPollFlagsErr | il2cpp::os::kPollFlagsHup | il2cpp::os::kPollFlagsNVal))
            events |= EVENT_IN;
        if ((*poll_fds)[i].revents & (il2cpp::os::kPollFlagsOut | il2cpp::os::kPollFlagsErr | il2cpp::os::kPollFlagsHup | il2cpp::os::kPollFlagsNVal))
            events |= EVENT_OUT;
        if ((*poll_fds)[i].revents & (il2cpp::os::kPollFlagsErr | il2cpp::os::kPollFlagsHup | il2cpp::os::kPollFlagsNVal))
            events |= EVENT_ERR;

        callback(fd, events, user_data);

        if (--ready == 0)
            break;
    }

    return 0;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\threadpool-ms-io-poll.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\threadpool-ms-io.cpp---------------
.
.
/*
 * threadpool-ms-io.c: Microsoft IO threadpool runtime support
 *
 * Author:
 *	Ludovic Henry (ludovic.henry@xamarin.com)
 *
 * Copyright 2015 Xamarin, Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */
#include "il2cpp-config.h"
#include "gc/WriteBarrier.h"

#ifndef DISABLE_SOCKETS

#ifndef IL2CPP_USE_PIPES_FOR_WAKEUP
#define IL2CPP_USE_PIPES_FOR_WAKEUP !(IL2CPP_TARGET_WINDOWS || IL2CPP_TARGET_PS4 || IL2CPP_TARGET_PSP2)
#endif

#ifndef IL2CPP_USE_EVENTFD_FOR_WAKEUP
#define IL2CPP_USE_EVENTFD_FOR_WAKEUP (0)
#endif

#if !IL2CPP_USE_PIPES_FOR_WAKEUP && !IL2CPP_USE_EVENTFD_FOR_WAKEUP
#include "os/Win32/WindowsHeaders.h"
#else
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#if IL2CPP_USE_EVENTFD_FOR_WAKEUP
#include <sys/eventfd.h>
#endif
#endif

#include <vector>

#include "gc/Allocator.h"
#include "mono/ThreadPool/threadpool-ms.h"
#include "mono/ThreadPool/threadpool-ms-io.h"
#include "mono/ThreadPool/threadpool-ms-io-poll.h"
#include "il2cpp-object-internals.h"
#include "os/ConditionVariable.h"
#include "os/Mutex.h"
#include "os/Socket.h"
#include "utils/CallOnce.h"
#include "utils/Il2CppHashMap.h"
#include "vm/Domain.h"
#include "vm/Runtime.h"
#include "vm/Thread.h"

#define UPDATES_CAPACITY 128

typedef std::vector<Il2CppObject*, il2cpp::gc::Allocator<Il2CppObject*> > ManagedList;

struct ThreadPoolStateHasher
{
	size_t operator()(int thread) const
	{
		return thread;
	}
};

typedef Il2CppHashMap<int, ManagedList*, ThreadPoolStateHasher> ThreadPoolStateHash;

typedef enum {
	UPDATE_EMPTY = 0,
	UPDATE_ADD,
	UPDATE_REMOVE_SOCKET,
	UPDATE_REMOVE_DOMAIN,
} ThreadPoolIOUpdateType;

typedef struct {
	int fd;
	Il2CppIOSelectorJob *job;
} ThreadPoolIOUpdate_Add;

typedef struct {
	int fd;
} ThreadPoolIOUpdate_RemoveSocket;

typedef struct {
	Il2CppDomain *domain;
} ThreadPoolIOUpdate_RemoveDomain;

typedef struct {
	ThreadPoolIOUpdateType type;
	union {
		ThreadPoolIOUpdate_Add add;
		ThreadPoolIOUpdate_RemoveSocket remove_socket;
		ThreadPoolIOUpdate_RemoveDomain remove_domain;
	} data;
} ThreadPoolIOUpdate;

typedef struct
{
    bool(*init)(int wakeup_pipe_fd);
    void(*register_fd)(int fd, int events, bool is_new);
    void(*remove_fd)(int fd);
    int(*event_wait)(void(*callback)(int fd, int events, void* user_data), void* user_data);
} ThreadPoolIOBackend;

typedef struct {
	ThreadPoolIOBackend backend;

	ThreadPoolIOUpdate* updates;
	int updates_size;
	il2cpp::os::FastMutex updates_lock;
	il2cpp::os::ConditionVariable updates_cond;
#if IL2CPP_USE_PIPES_FOR_WAKEUP || IL2CPP_USE_EVENTFD_FOR_WAKEUP
	int32_t wakeup_pipes [2];
#else
	il2cpp::os::Socket* wakeup_pipes [2];
#endif
} ThreadPoolIO;

static il2cpp::utils::OnceFlag lazy_init_io_status;

static volatile bool io_selector_running = false;

static ThreadPoolIO* threadpool_io;

static ThreadPoolIOBackend backend_poll = { poll_init, poll_register_fd, poll_remove_fd, poll_event_wait };

static Il2CppIOSelectorJob* get_job_for_event (ManagedList *list, int32_t event)
{
	IL2CPP_ASSERT(list);
	Il2CppIOSelectorJob* foundJob = NULL;
	int matchIndex = -1;
	for (size_t i = 0; i < list->size(); i++)
	{
		Il2CppIOSelectorJob *job = (Il2CppIOSelectorJob*)(*list)[i];
		if (job->operation == event)
		{
			foundJob = job;
			matchIndex = (int)i;
			break;
		}
	}

	if (foundJob == NULL)
		return NULL;

	list->erase(list->begin() + matchIndex);

	return foundJob;
}

static int get_operations_for_jobs (ManagedList *list)
{
	int operations = 0;

	for (size_t i = 0; i < list->size(); i++)
	{
		operations |= ((Il2CppIOSelectorJob*)(*list)[i])->operation;
	}

	return operations;
}

static void selector_thread_wakeup (void)
{
	const char msg = 'c';

	for (;;)
	{
#if IL2CPP_USE_PIPES_FOR_WAKEUP
		int32_t written = write (threadpool_io->wakeup_pipes [1], &msg, 1);
		if (written == 1)
			break;
		if (written == -1)
			break;
#elif IL2CPP_USE_EVENTFD_FOR_WAKEUP
		eventfd_t val = 1;
		int32_t written = eventfd_write(threadpool_io->wakeup_pipes[0], val);
		if (written == 0)
			break;
		if (written == -1)
			break;
#else
		int32_t written = 0;
		const il2cpp::os::WaitStatus status = threadpool_io->wakeup_pipes[1]->Send((const uint8_t*)&msg, 1, il2cpp::os::kSocketFlagsNone, &written);
		if (written == 1)
			break;
		if (written == -1)
		{
			//g_warning ("selector_thread_wakeup: write () failed, error (%d)\n", WSAGetLastError ());
			break;
		}

		if (status == kWaitStatusFailure)
			break;
#endif
	}
}

static void selector_thread_wakeup_drain_pipes (void)
{
	uint8_t buffer [128];
	int32_t received;

	for (;;) {
#if IL2CPP_USE_PIPES_FOR_WAKEUP
		received = read (threadpool_io->wakeup_pipes [0], buffer, sizeof (buffer));
		if (received == 0)
			break;
		if (received == -1) {
			if (errno != EINTR && errno != EAGAIN)
				IL2CPP_ASSERT(0 && "selector_thread_wakeup_drain_pipes: read () failed");
			break;
		}
#elif IL2CPP_USE_EVENTFD_FOR_WAKEUP
		eventfd_t val;
		received = eventfd_read(threadpool_io->wakeup_pipes[0], &val);
		if (received == 0)
			break;
		if (received == -1) {
			if (errno != EINTR && errno != EAGAIN)
				IL2CPP_ASSERT(0 && "selector_thread_wakeup_drain_pipes: read () failed");
			break;
		}
#else
		il2cpp::os::WaitStatus status = threadpool_io->wakeup_pipes[0]->Receive(buffer, 128, il2cpp::os::kSocketFlagsNone, &received);
		if (received == 0)
			break;
		if (status == kWaitStatusFailure)
			break;
#endif
	}
}

typedef struct {
	Il2CppDomain *domain;
	ThreadPoolStateHash *states;
} FilterSockaresForDomainData;

static void filter_jobs_for_domain (void* key, void* value, void* user_data)
{
	//FilterSockaresForDomainData *data;
	//MonoMList *list = (MonoMList *)value, *element;
	//MonoDomain *domain;
	//MonoGHashTable *states;

	//IL2CPP_ASSERT(user_data);
	//data = (FilterSockaresForDomainData *)user_data;
	//domain = data->domain;
	//states = data->states;

	//for (element = list; element; element = mono_mlist_next (element)) {
	//	Il2CppIOSelectorJob *job = (Il2CppIOSelectorJob*) mono_mlist_get_data (element);
	//	if (il2cpp::vm::Domain::GetCurrent() == domain)
	//		mono_mlist_set_data (element, NULL);
	//}

	///* we skip all the first elements which are NULL */
	//for (; list; list = mono_mlist_next (list)) {
	//	if (mono_mlist_get_data (list))
	//		break;
	//}

	//if (list) {
	//	IL2CPP_ASSERT(mono_mlist_get_data (list));

	//	/* we delete all the NULL elements after the first one */
	//	for (element = list; element;) {
	//		MonoMList *next;
	//		if (!(next = mono_mlist_next (element)))
	//			break;
	//		if (mono_mlist_get_data (next))
	//			element = next;
	//		else
	//			mono_mlist_set_next (element, mono_mlist_next (next));
	//	}
	//}

	//mono_g_hash_table_replace (states, key, list);
	IL2CPP_NOT_IMPLEMENTED("TODO");
}

static void wait_callback (int fd, int events, void* user_data)
{
	//Il2CppError error;

	if (il2cpp::vm::Runtime::IsShuttingDown ())
		return;

#if IL2CPP_USE_PIPES_FOR_WAKEUP || IL2CPP_USE_EVENTFD_FOR_WAKEUP
	if (fd == threadpool_io->wakeup_pipes [0]) {
#else
	if (fd == threadpool_io->wakeup_pipes [0]->GetDescriptor()) {
#endif
		//mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_IO_THREADPOOL, "io threadpool: wke");
		selector_thread_wakeup_drain_pipes ();
	} else {
		ThreadPoolStateHash *states;
		ManagedList *list = NULL;
		//void* k;
		bool remove_fd = false;
		int operations;

		IL2CPP_ASSERT(user_data);
		states = (ThreadPoolStateHash *)user_data;

		/*mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_IO_THREADPOOL, "io threadpool: cal fd %3d, events = %2s | %2s | %3s",
			fd, (events & EVENT_IN) ? "RD" : "..", (events & EVENT_OUT) ? "WR" : "..", (events & EVENT_ERR) ? "ERR" : "...");*/

		ThreadPoolStateHash::iterator iter = states->find(fd);
		bool exists = iter != states->end();

		if (!exists)
			IL2CPP_ASSERT("wait_callback: fd not found in states table");
		else
			list = iter->second;

		if (list && (events & EVENT_IN) != 0) {
			Il2CppIOSelectorJob *job = get_job_for_event (list, EVENT_IN);
			if (job) {
				threadpool_ms_enqueue_work_item (il2cpp::vm::Domain::GetCurrent(), (Il2CppObject*) job);
			}

		}
		if (list && (events & EVENT_OUT) != 0) {
			Il2CppIOSelectorJob *job = get_job_for_event (list, EVENT_OUT);
			if (job) {
				threadpool_ms_enqueue_work_item (il2cpp::vm::Domain::GetCurrent(), (Il2CppObject*) job);
			}
		}

		remove_fd = (events & EVENT_ERR) == EVENT_ERR;
		if (!remove_fd) {
			//mono_g_hash_table_replace (states, int_TO_POINTER (fd), list);
			states->insert(ThreadPoolStateHash::value_type(fd, list));

			operations = get_operations_for_jobs (list);

			/*mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_IO_THREADPOOL, "io threadpool: res fd %3d, events = %2s | %2s | %3s",
				fd, (operations & EVENT_IN) ? "RD" : "..", (operations & EVENT_OUT) ? "WR" : "..", (operations & EVENT_ERR) ? "ERR" : "...");*/

			threadpool_io->backend.register_fd (fd, operations, false);
		} else {
			//mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_IO_THREADPOOL, "io threadpool: err fd %d", fd);
			states->erase(ThreadPoolStateHash::key_type(fd));
			//mono_g_hash_table_remove (states, int_TO_POINTER (fd));

			threadpool_io->backend.remove_fd (fd);
		}
	}
}

static void selector_thread (void* data)
{
	//Il2CppError error;
	ThreadPoolStateHash *states;

	io_selector_running = true;

	if (il2cpp::vm::Runtime::IsShuttingDown ()) {
		io_selector_running = false;
		return;
	}

	states = new ThreadPoolStateHash();
	//states = mono_g_hash_table_new_type (g_direct_hash, g_direct_equal, MONO_HASH_VALUE_GC, MONO_ROOT_SOURCE_THREAD_POOL, "i/o thread pool states table");

	for (;;) {
		int i, j;
		int res;

		threadpool_io->updates_lock.Lock();

		for (i = 0; i < threadpool_io->updates_size; ++i) {
			ThreadPoolIOUpdate *update = &threadpool_io->updates [i];

			switch (update->type) {
			case UPDATE_EMPTY:
				break;
			case UPDATE_ADD: {
				int fd;
				int operations;
				//void* k;
				bool exists;
				ManagedList *list = NULL;
				Il2CppIOSelectorJob *job;

				fd = update->data.add.fd;
				IL2CPP_ASSERT(fd >= 0);

				job = update->data.add.job;
				IL2CPP_ASSERT(job);

				ThreadPoolStateHash::iterator iter = states->find(fd);
				exists = iter != states->end();

				if (!exists)
					list = new ManagedList();
				else
					list = iter->second;

				//exists = mono_g_hash_table_lookup_extended (states, int_TO_POINTER (fd), &k, (void**) &list);
				list->push_back((Il2CppObject*)job);
				il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)&(*list)[list->size()-1]);
				states->insert(ThreadPoolStateHash::value_type(fd, list));
				//mono_g_hash_table_replace (states, int_TO_POINTER (fd), list);

				operations = get_operations_for_jobs (list);

				/*mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_IO_THREADPOOL, "io threadpool: %3s fd %3d, operations = %2s | %2s | %3s",
					exists ? "mod" : "add", fd, (operations & EVENT_IN) ? "RD" : "..", (operations & EVENT_OUT) ? "WR" : "..", (operations & EVENT_ERR) ? "ERR" : "...");*/

				threadpool_io->backend.register_fd (fd, operations, !exists);

				break;
			}
			case UPDATE_REMOVE_SOCKET: {
				int fd;
				//void* k;
				ManagedList *list = NULL;

				fd = update->data.remove_socket.fd;
				IL2CPP_ASSERT(fd >= 0);

				ThreadPoolStateHash::iterator iter = states->find(fd);
				bool exists = iter != states->end();

				/*if (mono_g_hash_table_lookup_extended (states, int_TO_POINTER (fd), &k, (void**) &list))*/
				if (exists)
				{
					states->erase(ThreadPoolStateHash::key_type(fd));
					//mono_g_hash_table_remove (states, int_TO_POINTER (fd));

					for (j = i + 1; j < threadpool_io->updates_size; ++j) {
						ThreadPoolIOUpdate *update = &threadpool_io->updates [j];
						if (update->type == UPDATE_ADD && update->data.add.fd == fd)
							memset (update, 0, sizeof (ThreadPoolIOUpdate));
					}

					for (size_t i = 0; i < list->size(); i++)
					{
						threadpool_ms_enqueue_work_item(il2cpp::vm::Domain::GetCurrent(), (*list)[i]);
					}

					list->clear();

					//mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_IO_THREADPOOL, "io threadpool: del fd %3d", fd);
					threadpool_io->backend.remove_fd (fd);
				}

				break;
			}
			case UPDATE_REMOVE_DOMAIN: {
				Il2CppDomain *domain;

				domain = update->data.remove_domain.domain;
				IL2CPP_ASSERT(domain);

				FilterSockaresForDomainData user_data = { domain, states };
				//mono_g_hash_table_foreach (states, filter_jobs_for_domain, &user_data);

				for (j = i + 1; j < threadpool_io->updates_size; ++j) {
					ThreadPoolIOUpdate *update = &threadpool_io->updates [j];
					if (update->type == UPDATE_ADD && il2cpp::vm::Domain::GetCurrent() == domain)
						memset (update, 0, sizeof (ThreadPoolIOUpdate));
				}

				break;
			}
			default:
				IL2CPP_ASSERT(0 && "Should not be reached");
			}
		}

		threadpool_io->updates_cond.Broadcast();

		if (threadpool_io->updates_size > 0) {
			threadpool_io->updates_size = 0;
			memset (threadpool_io->updates, 0, UPDATES_CAPACITY * sizeof (ThreadPoolIOUpdate));
		}

		threadpool_io->updates_lock.Unlock();

		//mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_IO_THREADPOOL, "io threadpool: wai");

		res = threadpool_io->backend.event_wait (wait_callback, states);

		if (res == -1 || il2cpp::vm::Runtime::IsShuttingDown ())
			break;
	}

	delete states;

	io_selector_running = false;
}

/* Locking: threadpool_io->updates_lock must be held */
static ThreadPoolIOUpdate* update_get_new (void)
{
	ThreadPoolIOUpdate *update = NULL;
	IL2CPP_ASSERT(threadpool_io->updates_size <= UPDATES_CAPACITY);

	while (threadpool_io->updates_size == UPDATES_CAPACITY) {
		/* we wait for updates to be applied in the selector_thread and we loop
		 * as long as none are available. if it happends too much, then we need
		 * to increase UPDATES_CAPACITY */
		threadpool_io->updates_cond.Wait(&threadpool_io->updates_lock);
	}

	IL2CPP_ASSERT(threadpool_io->updates_size < UPDATES_CAPACITY);

	update = &threadpool_io->updates [threadpool_io->updates_size ++];

	return update;
}

static void wakeup_pipes_init(void)
{
#if IL2CPP_USE_PIPES_FOR_WAKEUP
	if (pipe (threadpool_io->wakeup_pipes) == -1)
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: pipe () failed");
	if (fcntl (threadpool_io->wakeup_pipes [0], F_SETFL, O_NONBLOCK) == -1)
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: fcntl () failed");
#elif IL2CPP_USE_EVENTFD_FOR_WAKEUP
	threadpool_io->wakeup_pipes[0] = eventfd(0, EFD_NONBLOCK);
	threadpool_io->wakeup_pipes[1] = -1;
#else
	il2cpp::os::Socket serverSock(NULL);

	serverSock.Create(il2cpp::os::kAddressFamilyInterNetwork, il2cpp::os::kSocketTypeStream, il2cpp::os::kProtocolTypeTcp);

	threadpool_io->wakeup_pipes[1] = new il2cpp::os::Socket(NULL);
	il2cpp::os::WaitStatus status = threadpool_io->wakeup_pipes[1]->Create(il2cpp::os::kAddressFamilyInterNetwork, il2cpp::os::kSocketTypeStream, il2cpp::os::kProtocolTypeTcp);
	IL2CPP_ASSERT(status != kWaitStatusFailure);

	if (serverSock.Bind("127.0.0.1", 0) == kWaitStatusFailure)
	{
		serverSock.Close();
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: bind () failed");
	}

	il2cpp::os::EndPointInfo info;
	memset(&info, 0x00, sizeof(il2cpp::os::EndPointInfo));
	if (serverSock.GetLocalEndPointInfo(info) == kWaitStatusFailure)
	{
		serverSock.Close();
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: getsockname () failed");
	}

	if (serverSock.Listen(1024) == kWaitStatusFailure)
	{
		serverSock.Close();
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: listen () failed");
	}

	if (threadpool_io->wakeup_pipes[1]->Connect(info.data.inet.address, info.data.inet.port) == kWaitStatusFailure)
	{
		serverSock.Close();
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: connect () failed");
	}

	status = serverSock.Accept(&threadpool_io->wakeup_pipes[0]);
	IL2CPP_ASSERT(status != kWaitStatusFailure);

	status = threadpool_io->wakeup_pipes[0]->SetBlocking(false);

	if (status == kWaitStatusFailure)
	{
		threadpool_io->wakeup_pipes[0]->Close();
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: SetBlocking () failed");
	}

	status = threadpool_io->wakeup_pipes[0]->SetSocketOption(il2cpp::os::kSocketOptionLevelTcp, il2cpp::os::kSocketOptionNameNoDelay, 1);
	if (status == kWaitStatusFailure)
	{
		threadpool_io->wakeup_pipes[0]->Close();
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: SetSocketOption () failed");
	}

	status = threadpool_io->wakeup_pipes[1]->SetSocketOption(il2cpp::os::kSocketOptionLevelTcp, il2cpp::os::kSocketOptionNameNoDelay, 1);
	if (status == kWaitStatusFailure)
	{
		threadpool_io->wakeup_pipes[1]->Close();
		IL2CPP_ASSERT(0 && "wakeup_pipes_init: SetSocketOption () failed");
	}

	serverSock.Close();
#endif
}

static bool lazy_is_initialized()
{
	return lazy_init_io_status.IsSet();
}

static void threadpool_ms_io_initialize(void* args)
{
	IL2CPP_ASSERT(!threadpool_io);
	threadpool_io = new ThreadPoolIO();
	IL2CPP_ASSERT(threadpool_io);

	threadpool_io->updates = (ThreadPoolIOUpdate*)il2cpp::gc::GarbageCollector::AllocateFixed(sizeof(ThreadPoolIOUpdate) * UPDATES_CAPACITY, NULL);

	threadpool_io->updates_size = 0;

	threadpool_io->backend = backend_poll;
//	if (g_getenv ("MONO_ENABLE_AIO") != NULL) {
//#if defined(HAVE_EPOLL)
//		threadpool_io->backend = backend_epoll;
//#elif defined(HAVE_KQUEUE)
//		threadpool_io->backend = backend_kqueue;
//#endif
//	}

	wakeup_pipes_init ();

#if IL2CPP_USE_PIPES_FOR_WAKEUP || IL2CPP_USE_EVENTFD_FOR_WAKEUP
	if (!threadpool_io->backend.init ((int)threadpool_io->wakeup_pipes [0]))
#else
	if (!threadpool_io->backend.init ((int)threadpool_io->wakeup_pipes [0]->GetDescriptor()))
#endif
		IL2CPP_ASSERT(0 && "initialize: backend->init () failed");

	if (!il2cpp::vm::Thread::CreateInternal(selector_thread, NULL, true, SMALL_STACK))
		IL2CPP_ASSERT(0 && "initialize: vm::Thread::CreateInternal () failed ");
}

static void threadpool_ms_io_lazy_initialize()
{
	il2cpp::utils::CallOnce(lazy_init_io_status, threadpool_ms_io_initialize, NULL);
}

static void cleanup_ms_io (void)
{
	/* we make the assumption along the code that we are
	 * cleaning up only if the runtime is shutting down */
	IL2CPP_ASSERT(il2cpp::vm::Runtime::IsShuttingDown ());

	selector_thread_wakeup ();
	while (io_selector_running)
		il2cpp::vm::Thread::YieldInternal();
}

void threadpool_ms_io_cleanup (void)
{
	if (lazy_init_io_status.IsSet())
		cleanup_ms_io();
}

void ves_icall_System_IOSelector_Add (intptr_t handle, Il2CppIOSelectorJob *job)
{
	ThreadPoolIOUpdate *update;

	IL2CPP_ASSERT(handle != 0);

	IL2CPP_ASSERT((job->operation == EVENT_IN) ^ (job->operation == EVENT_OUT));
	IL2CPP_ASSERT(job->callback);

	if (il2cpp::vm::Runtime::IsShuttingDown ())
		return;
	/*if (mono_domain_is_unloading (mono_object_domain (job)))
		return;*/

	threadpool_ms_io_lazy_initialize ();

	threadpool_io->updates_lock.Lock();

	update = update_get_new ();

	il2cpp::os::SocketHandleWrapper socketHandle(il2cpp::os::PointerToSocketHandle(reinterpret_cast<void*>(handle)));

    // At least one user has seen an intermittent crash where the socket is null. We're unsure what conditions cause
    // this to happen, but checking for a value of NULL here seems to allow their project to continue without
    // problems. So let's do the same here. If the value is NULL, we set the update type to be "empty". That will
    // cause the selector thread to simply skip this update.
    il2cpp::os::Socket* socket = socketHandle.GetSocket();
    if (socket != NULL)
    {
        update->type = UPDATE_ADD;
        update->data.add.fd = (int)socket->GetDescriptor();
    }
    else
    {
        update->type = UPDATE_EMPTY;
    }

	il2cpp::gc::WriteBarrier::GenericStore(&update->data.add.job, job);
	il2cpp::os::Atomic::FullMemoryBarrier(); /* Ensure this is safely published before we wake up the selector */

	selector_thread_wakeup ();

	threadpool_io->updates_lock.Unlock();
}

void ves_icall_System_IOSelector_Remove (intptr_t handle)
{
	il2cpp::os::SocketHandleWrapper socketHandle(il2cpp::os::PointerToSocketHandle(reinterpret_cast<void*>(handle)));
	threadpool_ms_io_remove_socket ((int)socketHandle.GetSocket()->GetDescriptor());
}

void threadpool_ms_io_remove_socket (int fd)
{
	ThreadPoolIOUpdate *update;

	if (!lazy_is_initialized ())
		return;

	threadpool_io->updates_lock.Lock();

	update = update_get_new ();
	update->type = UPDATE_REMOVE_SOCKET;
	update->data.add.fd = fd;
	il2cpp::os::Atomic::FullMemoryBarrier(); /* Ensure this is safely published before we wake up the selector */

	selector_thread_wakeup ();

	threadpool_io->updates_cond.Wait(&threadpool_io->updates_lock);

	threadpool_io->updates_lock.Unlock();
}

#else

void ves_icall_System_IOSelector_Add (intptr_t handle, Il2CppIOSelectorJob *job)
{
	IL2CPP_ASSERT(0 && "Should not be called");
}

void ves_icall_System_IOSelector_Remove (intptr_t handle)
{
	IL2CPP_ASSERT(0 && "Should not be called");
}

void threadpool_ms_io_cleanup (void)
{
	IL2CPP_ASSERT(0 && "Should not be called");
}

void threadpool_ms_io_remove_socket (int fd)
{
	IL2CPP_ASSERT(0 && "Should not be called");
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\threadpool-ms-io.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\threadpool-ms.cpp---------------
.
.
/*
 * threadpool-ms.c: Microsoft threadpool runtime support
 *
 * Author:
 *	Ludovic Henry (ludovic.henry@xamarin.com)
 *
 * Copyright 2015 Xamarin, Inc (http://www.xamarin.com)
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//
// Files:
//  - src/vm/comthreadpool.cpp
//  - src/vm/win32threadpoolcpp
//  - src/vm/threadpoolrequest.cpp
//  - src/vm/hillclimbing.cpp
//
// Ported from C++ to C and adjusted to Mono runtime

#include "il2cpp-config.h"

#include <stdlib.h>
#define _USE_MATH_DEFINES // needed by MSVC to define math constants
#include <algorithm>
#include <cmath>
#include <complex>
#include "math.h"

#include "il2cpp-api.h"
#include "gc/GarbageCollector.h"
#include "gc/GCHandle.h"
#include "gc/WriteBarrier.h"
#include "icalls/mscorlib/System.Runtime.Remoting.Messaging/MonoMethodMessage.h"
#include "mono/ThreadPool/threadpool-ms.h"
#include "mono/ThreadPool/threadpool-ms-io.h"
#include "mono/ThreadPool/ThreadPoolDataStructures.h"
#include "mono/ThreadPool/ThreadPoolMacros.h"
#include "mono/ThreadPool/ThreadPoolMonitorThread.h"
#include "mono/ThreadPool/ThreadPoolWorkerThread.h"
#include "il2cpp-object-internals.h"
#include "os/CpuInfo.h"
#include "os/Environment.h"
#include "os/Mutex.h"
#include "os/Time.h"
#include "utils/CallOnce.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Random.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Thread.h"
#include "vm/WaitHandle.h"
#include <icalls/mscorlib/System.Runtime.Remoting.Messaging/MonoMethodMessage.h>

#ifndef CLAMP
#define CLAMP(a,low,high) (((a) < (low)) ? (low) : (((a) > (high)) ? (high) : (a)))
#endif

ThreadPool* g_ThreadPool;

/* The exponent to apply to the gain. 1.0 means to use linear gain,
 * higher values will enhance large moves and damp small ones.
 * default: 2.0 */
#define HILL_CLIMBING_GAIN_EXPONENT 2.0

/* The 'cost' of a thread. 0 means drive for increased throughput regardless
 * of thread count, higher values bias more against higher thread counts.
 * default: 0.15 */
#define HILL_CLIMBING_BIAS 0.15

#define HILL_CLIMBING_WAVE_PERIOD 4
#define HILL_CLIMBING_MAX_WAVE_MAGNITUDE 20
#define HILL_CLIMBING_WAVE_MAGNITUDE_MULTIPLIER 1.0
#define HILL_CLIMBING_WAVE_HISTORY_SIZE 8
#define HILL_CLIMBING_TARGET_SIGNAL_TO_NOISE_RATIO 3.0
#define HILL_CLIMBING_MAX_CHANGE_PER_SECOND 4
#define HILL_CLIMBING_MAX_CHANGE_PER_SAMPLE 20
#define HILL_CLIMBING_SAMPLE_INTERVAL_LOW 10
#define HILL_CLIMBING_SAMPLE_INTERVAL_HIGH 200
#define HILL_CLIMBING_ERROR_SMOOTHING_FACTOR 0.01
#define HILL_CLIMBING_MAX_SAMPLE_ERROR_PERCENT 0.15

static il2cpp::utils::OnceFlag lazy_init_status;

static Il2CppMethodMessage *
mono_method_call_message_new(MethodInfo *method, void* *params, MethodInfo *invoke,
	Il2CppDelegate **cb, Il2CppObject **state)
{
	Il2CppDomain *domain = il2cpp::vm::Domain::GetCurrent();
	Il2CppMethodMessage *msg;
	int i, count;

	msg = (Il2CppMethodMessage *)il2cpp::vm::Object::New(il2cpp_defaults.mono_method_message_class);

	if (invoke) {
		Il2CppReflectionMethod *rm = il2cpp::vm::Reflection::GetMethodObject(invoke, NULL);
		il2cpp::icalls::mscorlib::System::Runtime::Remoting::Messaging::MonoMethodMessage::InitMessage(msg, rm, NULL);
		count = method->parameters_count - 2;
	}
	else {
		Il2CppReflectionMethod *rm = il2cpp::vm::Reflection::GetMethodObject(method, NULL);
		il2cpp::icalls::mscorlib::System::Runtime::Remoting::Messaging::MonoMethodMessage::InitMessage(msg, rm, NULL);
		count = method->parameters_count;
	}

	for (i = 0; i < count; i++) {
		void* vpos;
		Il2CppClass *klass;
		Il2CppObject *arg;

			vpos = params[i];

		klass = il2cpp_class_from_type(method->parameters[i]);
		arg = (Il2CppObject*)vpos;

		il2cpp_array_setref(msg->args, i, arg);
	}

	if (cb != NULL && state != NULL) {
		*cb = (Il2CppDelegate *)params[i];
		i++;
		*state = (Il2CppObject *)params[i];
	}

	return msg;
}

static void* cpu_info_create()
{
	return il2cpp::os::CpuInfo::Create();
}


ThreadPool::ThreadPool() :
    parked_threads_count(0),
    worker_creation_current_second(-1),
    worker_creation_current_count(0),
    heuristic_completions(0),
    heuristic_sample_start(0),
    heuristic_last_dequeue(0),
    heuristic_last_adjustment(0),
    heuristic_adjustment_interval(10),
    limit_worker_min(0),
    limit_worker_max(0),
    limit_io_min(0),
    limit_io_max(0),
    cpu_usage(0),
    suspended(false),
    parked_threads_cond(active_threads_lock)
{
    counters.as_int64_t = 0;
    cpu_usage_state = cpu_info_create();
}

static void initialize(void* arg)
{
	ThreadPoolHillClimbing *hc;
	//const char *threads_per_cpu_env;
	int threads_per_cpu;
	int threads_count;

	IL2CPP_ASSERT(!g_ThreadPool);
    g_ThreadPool = new ThreadPool();
	IL2CPP_ASSERT(g_ThreadPool);

	il2cpp::vm::Random::Open();

	hc = &g_ThreadPool->heuristic_hill_climbing;

	hc->wave_period = HILL_CLIMBING_WAVE_PERIOD;
	hc->max_thread_wave_magnitude = HILL_CLIMBING_MAX_WAVE_MAGNITUDE;
	hc->thread_magnitude_multiplier = (double) HILL_CLIMBING_WAVE_MAGNITUDE_MULTIPLIER;
	hc->samples_to_measure = hc->wave_period * HILL_CLIMBING_WAVE_HISTORY_SIZE;
	hc->target_throughput_ratio = (double) HILL_CLIMBING_BIAS;
	hc->target_signal_to_noise_ratio = (double) HILL_CLIMBING_TARGET_SIGNAL_TO_NOISE_RATIO;
	hc->max_change_per_second = (double) HILL_CLIMBING_MAX_CHANGE_PER_SECOND;
	hc->max_change_per_sample = (double) HILL_CLIMBING_MAX_CHANGE_PER_SAMPLE;
	hc->sample_interval_low = HILL_CLIMBING_SAMPLE_INTERVAL_LOW;
	hc->sample_interval_high = HILL_CLIMBING_SAMPLE_INTERVAL_HIGH;
	hc->throughput_error_smoothing_factor = (double) HILL_CLIMBING_ERROR_SMOOTHING_FACTOR;
	hc->gain_exponent = (double) HILL_CLIMBING_GAIN_EXPONENT;
	hc->max_sample_error = (double) HILL_CLIMBING_MAX_SAMPLE_ERROR_PERCENT;
	hc->current_control_setting = 0;
	hc->total_samples = 0;
	hc->last_thread_count = 0;
	hc->average_throughput_noise = 0;
	hc->elapsed_since_last_change = 0;
	hc->accumulated_completion_count = 0;
	hc->accumulated_sample_duration = 0;
	hc->samples = (double*)IL2CPP_MALLOC_ZERO (sizeof(double) * hc->samples_to_measure);
	hc->thread_counts = (double*)IL2CPP_MALLOC_ZERO(sizeof(double) * hc->samples_to_measure);
	hc->random_interval_generator = il2cpp::vm::Random::Create ();
	hc->current_sample_interval = il2cpp::vm::Random::Next (&hc->random_interval_generator, hc->sample_interval_low, hc->sample_interval_high);

	//std::string threads_per_cpu_env = il2cpp::os::Environment::GetEnvironmentVariable("IL2CPP_THREADS_PER_CPU");
	//if (threads_per_cpu_env.empty())
	threads_per_cpu = 1;
	/*else
		threads_per_cpu = CLAMP (atoi (threads_per_cpu_env.c_str()), 1, 50);*/

	threads_count = il2cpp::os::Environment::GetProcessorCount() * threads_per_cpu;

	g_ThreadPool->limit_worker_min = g_ThreadPool->limit_io_min = threads_count;

#if IL2CPP_TARGET_ANDROID || IL2CPP_TARGET_IOS
	g_ThreadPool->limit_worker_max = g_ThreadPool->limit_io_max = CLAMP (threads_count * 100, std::min (threads_count, 200), std::max (threads_count, 200));
#else
	g_ThreadPool->limit_worker_max = g_ThreadPool->limit_io_max = threads_count * 100;
#endif

	g_ThreadPool->counters._.max_working = g_ThreadPool->limit_worker_min;
}

static void lazy_initialize()
{
	il2cpp::utils::CallOnce(lazy_init_status, initialize, NULL);
}

static void worker_kill(Il2CppInternalThread* thread)
{
	if (thread == il2cpp::vm::Thread::CurrentInternal())
		return;

	il2cpp::vm::Thread::Stop(thread);
}

static void cleanup (void)
{
	unsigned int i;

	/* we make the assumption along the code that we are
	 * cleaning up only if the runtime is shutting down */
	IL2CPP_ASSERT(il2cpp::vm::Runtime::IsShuttingDown ());

	while (GetMonitorStatus() != MONITOR_STATUS_NOT_RUNNING)
		il2cpp::vm::Thread::Sleep(1);

	std::vector<Il2CppInternalThread*> working_threads;

	g_ThreadPool->active_threads_lock.Acquire();
	working_threads = g_ThreadPool->working_threads;
	g_ThreadPool->active_threads_lock.Release();

	/* stop all threadpool->working_threads */
	for (i = 0; i < working_threads.size(); ++i)
		worker_kill (working_threads[i]);

	/* unpark all g_ThreadPool->parked_threads */
	g_ThreadPool->parked_threads_cond.NotifyAll();
}

bool threadpool_ms_enqueue_work_item (Il2CppDomain *domain, Il2CppObject *work_item)
{
	static Il2CppClass *threadpool_class = NULL;
	static MethodInfo *unsafe_queue_custom_work_item_method = NULL;
	//Il2CppDomain *current_domain;
	bool f;
	void* args [2];

	IL2CPP_ASSERT(work_item);

	if (!threadpool_class)
		threadpool_class = il2cpp::vm::Class::FromName(il2cpp_defaults.corlib, "System.Threading", "ThreadPool");

	if (!unsafe_queue_custom_work_item_method)
		unsafe_queue_custom_work_item_method = (MethodInfo*)il2cpp::vm::Class::GetMethodFromName(threadpool_class, "UnsafeQueueCustomWorkItem", 2);
	IL2CPP_ASSERT(unsafe_queue_custom_work_item_method);

	f = false;

	args [0] = (void*) work_item;
	args [1] = (void*) &f;

	Il2CppObject *result = il2cpp::vm::Runtime::InvokeWithThrow(unsafe_queue_custom_work_item_method, NULL, args);
	return true;
}

/* LOCKING: threadpool->domains_lock must be held */
static ThreadPoolDomain* domain_get(Il2CppDomain *domain, bool create)
{
	ThreadPoolDomain *tpdomain = NULL;
	unsigned int i;

	IL2CPP_ASSERT(domain);

	for (i = 0; i < g_ThreadPool->domains.size(); ++i) {
		tpdomain = g_ThreadPool->domains[i];
		if (tpdomain->domain == domain)
			return tpdomain;
	}

	if (create) {
		tpdomain = new ThreadPoolDomain();
		tpdomain->domain = domain;
		g_ThreadPool->domains.push_back(tpdomain);
	}

	return tpdomain;
}

bool worker_try_unpark()
{
	bool worker_unparked = true;

	g_ThreadPool->active_threads_lock.AcquireScoped([&worker_unparked] {
		if (g_ThreadPool->parked_threads_count == 0)
			worker_unparked = false;
		else
			g_ThreadPool->parked_threads_cond.Notify(1);
	});
	
	return worker_unparked;
}

static bool worker_request (Il2CppDomain *domain)
{
	ThreadPoolDomain *tpdomain;

	IL2CPP_ASSERT(domain);
	IL2CPP_ASSERT(g_ThreadPool);

	if (il2cpp::vm::Runtime::IsShuttingDown ())
		return false;

	g_ThreadPool->domains_lock.Acquire();

	/* synchronize check with worker_thread */
	//if (mono_domain_is_unloading (domain)) {
		//mono_coop_mutex_unlock (&threadpool->domains_lock);
		/*return false;
	}*/

	tpdomain = domain_get (domain, true);
	IL2CPP_ASSERT(tpdomain);
	tpdomain->outstanding_request ++;

	/*mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] request worker, domain = %p, outstanding_request = %d",
		mono_native_thread_id_get (), tpdomain->domain, tpdomain->outstanding_request);*/

	g_ThreadPool->domains_lock.Release();

	if (g_ThreadPool->suspended)
		return false;

	monitor_ensure_running ();

	if (worker_try_unpark ()) {
		//mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] request worker, unparked", mono_native_thread_id_get ());
		return true;
	}

	if (worker_try_create ()) {
		//mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] request worker, created", mono_native_thread_id_get ());
		return true;
	}

	//mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] request worker, failed", mono_native_thread_id_get ());
	return false;
}

static void hill_climbing_change_thread_count (int16_t new_thread_count, ThreadPoolHeuristicStateTransition transition)
{
	ThreadPoolHillClimbing *hc;

	IL2CPP_ASSERT(g_ThreadPool);

	hc = &g_ThreadPool->heuristic_hill_climbing;

	//mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_THREADPOOL, "[%p] hill climbing, change max number of threads %d", mono_native_thread_id_get (), new_thread_count);

	hc->last_thread_count = new_thread_count;
	hc->current_sample_interval = il2cpp::vm::Random::Next(&hc->random_interval_generator, hc->sample_interval_low, hc->sample_interval_high);
	hc->elapsed_since_last_change = 0;
	hc->completions_since_last_change = 0;
}

void hill_climbing_force_change (int16_t new_thread_count, ThreadPoolHeuristicStateTransition transition)
{
	ThreadPoolHillClimbing *hc;

	IL2CPP_ASSERT(g_ThreadPool);

	hc = &g_ThreadPool->heuristic_hill_climbing;

	if (new_thread_count != hc->last_thread_count) {
		hc->current_control_setting += new_thread_count - hc->last_thread_count;
		hill_climbing_change_thread_count (new_thread_count, transition);
	}
}

static std::complex<double> hill_climbing_get_wave_component (double *samples, unsigned int sample_count, double period)
{
	ThreadPoolHillClimbing *hc;
	double w, cosine, sine, coeff, q0, q1, q2;
	unsigned int i;

	IL2CPP_ASSERT(g_ThreadPool);
	IL2CPP_ASSERT(sample_count >= period);
	IL2CPP_ASSERT(period >= 2);

	hc = &g_ThreadPool->heuristic_hill_climbing;

	w = 2.0 * M_PI / period;
	cosine = cos (w);
	sine = sin (w);
	coeff = 2.0 * cosine;
	q0 = q1 = q2 = 0;

	for (i = 0; i < sample_count; ++i) {
		q0 = coeff * q1 - q2 + samples [(hc->total_samples - sample_count + i) % hc->samples_to_measure];
		q2 = q1;
		q1 = q0;
	}

	return (std::complex<double> (q1 - q2 * cosine, (q2 * sine)) / ((double)sample_count));
}

static int16_t hill_climbing_update (int16_t current_thread_count, uint32_t sample_duration, int32_t completions, int64_t *adjustment_interval)
{
	ThreadPoolHillClimbing *hc;
	ThreadPoolHeuristicStateTransition transition;
	double throughput;
	double throughput_error_estimate;
	double confidence;
	double move;
	double gain;
	int sample_index;
	int sample_count;
	int new_thread_wave_magnitude;
	int new_thread_count;
	std::complex<double> thread_wave_component;
	std::complex<double> throughput_wave_component;
	std::complex<double> ratio;

	IL2CPP_ASSERT(g_ThreadPool);
	IL2CPP_ASSERT(adjustment_interval);

	hc = &g_ThreadPool->heuristic_hill_climbing;

	/* If someone changed the thread count without telling us, update our records accordingly. */
	if (current_thread_count != hc->last_thread_count)
		hill_climbing_force_change (current_thread_count, TRANSITION_INITIALIZING);

	/* Update the cumulative stats for this thread count */
	hc->elapsed_since_last_change += sample_duration;
	hc->completions_since_last_change += completions;

	/* Add in any data we've already collected about this sample */
	sample_duration += (uint32_t)hc->accumulated_sample_duration;
	completions += hc->accumulated_completion_count;

	/* We need to make sure we're collecting reasonably accurate data. Since we're just counting the end
	 * of each work item, we are goinng to be missing some data about what really happened during the
	 * sample interval. The count produced by each thread includes an initial work item that may have
	 * started well before the start of the interval, and each thread may have been running some new
	 * work item for some time before the end of the interval, which did not yet get counted. So
	 * our count is going to be off by +/- threadCount workitems.
	 *
	 * The exception is that the thread that reported to us last time definitely wasn't running any work
	 * at that time, and the thread that's reporting now definitely isn't running a work item now. So
	 * we really only need to consider threadCount-1 threads.
	 *
	 * Thus the percent error in our count is +/- (threadCount-1)/numCompletions.
	 *
	 * We cannot rely on the frequency-domain analysis we'll be doing later to filter out this error, because
	 * of the way it accumulates over time. If this sample is off by, say, 33% in the negative direction,
	 * then the next one likely will be too. The one after that will include the sum of the completions
	 * we missed in the previous samples, and so will be 33% positive. So every three samples we'll have
	 * two "low" samples and one "high" sample. This will appear as periodic variation right in the frequency
	 * range we're targeting, which will not be filtered by the frequency-domain translation. */
	if (hc->total_samples > 0 && ((current_thread_count - 1.0) / completions) >= hc->max_sample_error) {
		/* Not accurate enough yet. Let's accumulate the data so
		 * far, and tell the ThreadPool to collect a little more. */
		hc->accumulated_sample_duration = sample_duration;
		hc->accumulated_completion_count = completions;
		*adjustment_interval = 10;
		return current_thread_count;
	}

	/* We've got enouugh data for our sample; reset our accumulators for next time. */
	hc->accumulated_sample_duration = 0;
	hc->accumulated_completion_count = 0;

	/* Add the current thread count and throughput sample to our history. */
	throughput = ((double) completions) / sample_duration;

	sample_index = hc->total_samples % hc->samples_to_measure;
	hc->samples [sample_index] = throughput;
	hc->thread_counts [sample_index] = current_thread_count;
	hc->total_samples ++;

	/* Set up defaults for our metrics. */
	throughput_error_estimate = 0;
	confidence = 0;

	transition = TRANSITION_WARMUP;

	/* How many samples will we use? It must be at least the three wave periods we're looking for, and it must also
	 * be a whole multiple of the primary wave's period; otherwise the frequency we're looking for will fall between
	 * two frequency bands in the Fourier analysis, and we won't be able to measure it accurately. */
	sample_count = ((int) std::min (hc->total_samples - 1, (int64_t)hc->samples_to_measure) / hc->wave_period) * hc->wave_period;

	if (sample_count > hc->wave_period) {
		int i;
		double average_throughput;
		double average_thread_count;
		double sample_sum = 0;
		double thread_sum = 0;

		/* Average the throughput and thread count samples, so we can scale the wave magnitudes later. */
		for (i = 0; i < sample_count; ++i) {
			unsigned int j = (hc->total_samples - sample_count + i) % hc->samples_to_measure;
			sample_sum += hc->samples [j];
			thread_sum += hc->thread_counts [j];
		}

		average_throughput = sample_sum / sample_count;
		average_thread_count = thread_sum / sample_count;

		if (average_throughput > 0 && average_thread_count > 0) {
			double noise_for_confidence, adjacent_period_1, adjacent_period_2;

			/* Calculate the periods of the adjacent frequency bands we'll be using to
			 * measure noise levels. We want the two adjacent Fourier frequency bands. */
			adjacent_period_1 = sample_count / (((double) sample_count) / ((double) hc->wave_period) + 1);
			adjacent_period_2 = sample_count / (((double) sample_count) / ((double) hc->wave_period) - 1);

			/* Get the the three different frequency components of the throughput (scaled by average
			 * throughput). Our "error" estimate (the amount of noise that might be present in the
			 * frequency band we're really interested in) is the average of the adjacent bands. */

			throughput_wave_component = hill_climbing_get_wave_component(hc->samples, sample_count, hc->wave_period) / average_throughput;
			//throughput_wave_component = mono_double_complex_scalar_div (hill_climbing_get_wave_component (hc->samples, sample_count, hc->wave_period), average_throughput);

			throughput_error_estimate = std::abs(hill_climbing_get_wave_component(hc->samples, sample_count, adjacent_period_1) / average_throughput);
			//throughput_error_estimate = cabs (mono_double_complex_scalar_div (hill_climbing_get_wave_component (hc->samples, sample_count, adjacent_period_1), average_throughput));

			if (adjacent_period_2 <= sample_count) {
				throughput_error_estimate = std::max (throughput_error_estimate, std::abs (hill_climbing_get_wave_component (
					hc->samples, sample_count, adjacent_period_2) / average_throughput));
			}

			/* Do the same for the thread counts, so we have something to compare to. We don't
			 * measure thread count noise, because there is none; these are exact measurements. */
			thread_wave_component = hill_climbing_get_wave_component (hc->thread_counts, sample_count, hc->wave_period) / average_thread_count;

			/* Update our moving average of the throughput noise. We'll use this
			 * later as feedback to determine the new size of the thread wave. */
			if (hc->average_throughput_noise == 0) {
				hc->average_throughput_noise = throughput_error_estimate;
			} else {
				hc->average_throughput_noise = (hc->throughput_error_smoothing_factor * throughput_error_estimate)
					+ ((1.0 + hc->throughput_error_smoothing_factor) * hc->average_throughput_noise);
			}

			if (std::abs (thread_wave_component) > 0) {
				/* Adjust the throughput wave so it's centered around the target wave,
				 * and then calculate the adjusted throughput/thread ratio. */
				ratio = ((throughput_wave_component - (thread_wave_component * hc->target_throughput_ratio)) / thread_wave_component);
				transition = TRANSITION_CLIMBING_MOVE;
			} else {
				//ratio = mono_double_complex_make (0, 0);
				transition = TRANSITION_STABILIZING;
			}

			noise_for_confidence = std::max (hc->average_throughput_noise, throughput_error_estimate);
			if (noise_for_confidence > 0) {
				confidence = std::abs (thread_wave_component) / noise_for_confidence / hc->target_signal_to_noise_ratio;
			} else {
				/* there is no noise! */
				confidence = 1.0;
			}
		}
	}

	/* We use just the real part of the complex ratio we just calculated. If the throughput signal
	 * is exactly in phase with the thread signal, this will be the same as taking the magnitude of
	 * the complex move and moving that far up. If they're 180 degrees out of phase, we'll move
	 * backward (because this indicates that our changes are having the opposite of the intended effect).
	 * If they're 90 degrees out of phase, we won't move at all, because we can't tell wether we're
	 * having a negative or positive effect on throughput. */
	move = std::real (ratio);
	move = CLAMP (move, -1.0, 1.0);

	/* Apply our confidence multiplier. */
	move *= CLAMP (confidence, -1.0, 1.0);

	/* Now apply non-linear gain, such that values around zero are attenuated, while higher values
	 * are enhanced. This allows us to move quickly if we're far away from the target, but more slowly
	* if we're getting close, giving us rapid ramp-up without wild oscillations around the target. */
	gain = hc->max_change_per_second * sample_duration;
	move = pow (fabs (move), hc->gain_exponent) * (move >= 0.0 ? 1 : -1) * gain;
	move = std::min (move, hc->max_change_per_sample);

	/* If the result was positive, and CPU is > 95%, refuse the move. */
	if (move > 0.0 && g_ThreadPool->cpu_usage > CPU_USAGE_HIGH)
		move = 0.0;

	/* Apply the move to our control setting. */
	hc->current_control_setting += move;

	/* Calculate the new thread wave magnitude, which is based on the moving average we've been keeping of the
	 * throughput error.  This average starts at zero, so we'll start with a nice safe little wave at first. */
	new_thread_wave_magnitude = (int)(0.5 + (hc->current_control_setting * hc->average_throughput_noise
		* hc->target_signal_to_noise_ratio * hc->thread_magnitude_multiplier * 2.0));
	new_thread_wave_magnitude = CLAMP (new_thread_wave_magnitude, 1, hc->max_thread_wave_magnitude);

	/* Make sure our control setting is within the ThreadPool's limits. */
	hc->current_control_setting = CLAMP (hc->current_control_setting, g_ThreadPool->limit_worker_min, g_ThreadPool->limit_worker_max - new_thread_wave_magnitude);

	/* Calculate the new thread count (control setting + square wave). */
	new_thread_count = (int)(hc->current_control_setting + new_thread_wave_magnitude * ((hc->total_samples / (hc->wave_period / 2)) % 2));

	/* Make sure the new thread count doesn't exceed the ThreadPool's limits. */
	new_thread_count = CLAMP (new_thread_count, g_ThreadPool->limit_worker_min, g_ThreadPool->limit_worker_max);

	if (new_thread_count != current_thread_count)
		hill_climbing_change_thread_count (new_thread_count, transition);

	if (std::real (ratio) < 0.0 && new_thread_count == g_ThreadPool->limit_worker_min)
		*adjustment_interval = (int)(0.5 + hc->current_sample_interval * (10.0 * std::max (-1.0 * std::real (ratio), 1.0)));
	else
		*adjustment_interval = hc->current_sample_interval;

	return new_thread_count;
}

static void heuristic_notify_work_completed (void)
{
	IL2CPP_ASSERT(g_ThreadPool);

	g_ThreadPool->heuristic_completions++;
	g_ThreadPool->heuristic_last_dequeue = il2cpp::os::Time::GetTicksMillisecondsMonotonic();
}

static bool heuristic_should_adjust (void)
{
	IL2CPP_ASSERT(g_ThreadPool);

	if (g_ThreadPool->heuristic_last_dequeue > g_ThreadPool->heuristic_last_adjustment + g_ThreadPool->heuristic_adjustment_interval) {
		ThreadPoolCounter counter;
		counter.as_int64_t = COUNTER_READ();
		if (counter._.working <= counter._.max_working)
			return true;
	}

	return false;
}

static void heuristic_adjust (void)
{
	IL2CPP_ASSERT(g_ThreadPool);

	if (g_ThreadPool->heuristic_lock.TryAcquire()) {
		int32_t completions = g_ThreadPool->heuristic_completions.exchange(0);
		int64_t sample_end = il2cpp::os::Time::GetTicksMillisecondsMonotonic();
		int64_t sample_duration = sample_end - g_ThreadPool->heuristic_sample_start;

		if (sample_duration >= g_ThreadPool->heuristic_adjustment_interval / 2) {
			ThreadPoolCounter counter;
			int16_t new_thread_count;

			counter.as_int64_t = COUNTER_READ ();
			new_thread_count = hill_climbing_update (counter._.max_working, (uint32_t)sample_duration, completions, &g_ThreadPool->heuristic_adjustment_interval);

			COUNTER_ATOMIC (counter, { counter._.max_working = new_thread_count; });

			if (new_thread_count > counter._.max_working)
				worker_request (il2cpp::vm::Domain::GetCurrent());

			g_ThreadPool->heuristic_sample_start = sample_end;
			g_ThreadPool->heuristic_last_adjustment = il2cpp::os::Time::GetTicksMillisecondsMonotonic();
		}

		g_ThreadPool->heuristic_lock.Release();
	}
}

void threadpool_ms_cleanup (void)
{
	#ifndef DISABLE_SOCKETS
		threadpool_ms_io_cleanup ();
	#endif

	if (lazy_init_status.IsSet())
		cleanup();
}

Il2CppAsyncResult* threadpool_ms_begin_invoke (Il2CppDomain *domain, Il2CppObject *target, MethodInfo *method, void* *params)
{
	Il2CppMethodMessage *message;
	Il2CppDelegate *async_callback = NULL;
	Il2CppObject *state = NULL;

	Il2CppAsyncCall* async_call = (Il2CppAsyncCall*)il2cpp::vm::Object::New(il2cpp_defaults.async_call_class);

	lazy_initialize ();

	MethodInfo *invoke = NULL;
	if (il2cpp::vm::Class::HasParent(method->klass, il2cpp_defaults.multicastdelegate_class))
		invoke = (MethodInfo*)il2cpp::vm::Class::GetMethodFromName(method->klass, "Invoke", -1);

	message = mono_method_call_message_new (method, params, invoke, (params != NULL) ? (&async_callback) : NULL, (params != NULL) ? (&state) : NULL);

	IL2CPP_OBJECT_SETREF (async_call, msg, message);
	IL2CPP_OBJECT_SETREF (async_call, state, state);

	if (async_callback)
	{
		IL2CPP_OBJECT_SETREF (async_call, cb_method, const_cast<MethodInfo*>(il2cpp::vm::Runtime::GetDelegateInvoke(il2cpp::vm::Object::GetClass((Il2CppObject*)async_callback))));
		IL2CPP_OBJECT_SETREF (async_call, cb_target, async_callback);
	}

	Il2CppAsyncResult* async_result = (Il2CppAsyncResult*)il2cpp::vm::Object::New(il2cpp_defaults.asyncresult_class);

	IL2CPP_OBJECT_SETREF(async_result, async_delegate, (Il2CppDelegate*)target);

	IL2CPP_OBJECT_SETREF(async_result, object_data, async_call);
	IL2CPP_OBJECT_SETREF(async_result, async_state, async_call->state);

	threadpool_ms_enqueue_work_item (domain, (Il2CppObject*) async_result);

	return async_result;
}

Il2CppObject* threadpool_ms_end_invoke (Il2CppAsyncResult *ares, Il2CppArray **out_args, Il2CppObject **exc)
{
	Il2CppAsyncCall *ac;

	IL2CPP_ASSERT(exc);
	IL2CPP_ASSERT(out_args);

	*exc = NULL;
	*out_args = NULL;

	/* check if already finished */
	il2cpp_monitor_enter((Il2CppObject*) ares);

	if (ares->endinvoke_called)
	{
		il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetInvalidOperationException("Cannot call EndInvoke() repeatedly or concurrently on the same AsyncResult!"));
		il2cpp_monitor_exit((Il2CppObject*) ares);
		return NULL;
	}

	ares->endinvoke_called = 1;

	/* wait until we are really finished */
	if (ares->completed)
	{
		il2cpp_monitor_exit((Il2CppObject *) ares);
	}
	else
	{

		if (!ares->handle)
		{
			Il2CppWaitHandle *wait_handle = il2cpp::vm::WaitHandle::NewManualResetEvent(false);
			IL2CPP_OBJECT_SETREF(ares, handle, wait_handle);
		}

		il2cpp::os::Handle* wait_event = il2cpp::vm::WaitHandle::GetPlatformHandle((Il2CppWaitHandle*)ares->handle);

		il2cpp_monitor_exit((Il2CppObject*) ares);

		//MONO_ENTER_GC_SAFE;
		wait_event->Wait();
		//MONO_EXIT_GC_SAFE;
	}

	ac = (Il2CppAsyncCall*) ares->object_data;
	IL2CPP_ASSERT(ac);

	il2cpp::gc::WriteBarrier::GenericStore(exc, ((Il2CppMethodMessage*)ac->msg)->exc);
	*out_args = ac->out_args;
	return ac->res;
}

void threadpool_ms_suspend (void)
{
	if (g_ThreadPool)
		g_ThreadPool->suspended = true;
}

void threadpool_ms_resume (void)
{
	if (g_ThreadPool)
		g_ThreadPool->suspended = false;
}

void ves_icall_System_Threading_ThreadPool_GetAvailableThreadsNative (int32_t *worker_threads, int32_t *completion_port_threads)
{
	ThreadPoolCounter counter;

	if (!worker_threads || !completion_port_threads)
		return;

	lazy_initialize ();

	counter.as_int64_t = COUNTER_READ ();

	*worker_threads = std::max (0, g_ThreadPool->limit_worker_max - counter._.active);
	*completion_port_threads = g_ThreadPool->limit_io_max;
}

void ves_icall_System_Threading_ThreadPool_GetMinThreadsNative (int32_t *worker_threads, int32_t *completion_port_threads)
{
	if (!worker_threads || !completion_port_threads)
		return;

	lazy_initialize ();

	*worker_threads = g_ThreadPool->limit_worker_min;
	*completion_port_threads = g_ThreadPool->limit_io_min;
}

void ves_icall_System_Threading_ThreadPool_GetMaxThreadsNative (int32_t *worker_threads, int32_t *completion_port_threads)
{
	if (!worker_threads || !completion_port_threads)
		return;

	lazy_initialize ();

	*worker_threads = g_ThreadPool->limit_worker_max;
	*completion_port_threads = g_ThreadPool->limit_io_max;
}

bool ves_icall_System_Threading_ThreadPool_SetMinThreadsNative (int32_t worker_threads, int32_t completion_port_threads)
{
	lazy_initialize ();

	if (worker_threads <= 0 || worker_threads > g_ThreadPool->limit_worker_max)
		return false;
	if (completion_port_threads <= 0 || completion_port_threads > g_ThreadPool->limit_io_max)
		return false;

	g_ThreadPool->limit_worker_min = worker_threads;
	g_ThreadPool->limit_io_min = completion_port_threads;

	return true;
}

bool ves_icall_System_Threading_ThreadPool_SetMaxThreadsNative (int32_t worker_threads, int32_t completion_port_threads)
{
	int cpu_count = il2cpp::os::Environment::GetProcessorCount ();

	lazy_initialize ();

	if (worker_threads < g_ThreadPool->limit_worker_min || worker_threads < cpu_count)
		return false;
	if (completion_port_threads < g_ThreadPool->limit_io_min || completion_port_threads < cpu_count)
		return false;

	g_ThreadPool->limit_worker_max = worker_threads;
	g_ThreadPool->limit_io_max = completion_port_threads;

	return true;
}

void ves_icall_System_Threading_ThreadPool_InitializeVMTp (bool *enable_worker_tracking)
{
	if (enable_worker_tracking) {
		// TODO implement some kind of switch to have the possibily to use it
		*enable_worker_tracking = false;
	}

	lazy_initialize ();
}

bool ves_icall_System_Threading_ThreadPool_NotifyWorkItemComplete (void)
{
	ThreadPoolCounter counter;

	if (il2cpp::vm::Runtime::IsShuttingDown ())
		return false;

	heuristic_notify_work_completed ();

	if (heuristic_should_adjust ())
		heuristic_adjust ();

	counter.as_int64_t = COUNTER_READ ();
	return counter._.working <= counter._.max_working;
}

void ves_icall_System_Threading_ThreadPool_NotifyWorkItemProgressNative (void)
{
	heuristic_notify_work_completed ();

	if (heuristic_should_adjust ())
		heuristic_adjust ();
}

void ves_icall_System_Threading_ThreadPool_ReportThreadStatus (bool is_working)
{
	// Mono raises a not implemented exception
	IL2CPP_NOT_IMPLEMENTED_ICALL(ves_icall_System_Threading_ThreadPool_PostQueuedCompletionStatus);
	IL2CPP_UNREACHABLE;
}

bool ves_icall_System_Threading_ThreadPool_RequestWorkerThread (void)
{
	return worker_request (il2cpp::vm::Domain::GetCurrent());
}

bool ves_icall_System_Threading_ThreadPool_PostQueuedCompletionStatus (Il2CppNativeOverlapped *native_overlapped)
{
	// Mono raises a not implemented exception
	IL2CPP_NOT_IMPLEMENTED_ICALL(ves_icall_System_Threading_ThreadPool_PostQueuedCompletionStatus);
	IL2CPP_UNREACHABLE;
}

bool  ves_icall_System_Threading_ThreadPool_BindIOCompletionCallbackNative (void* file_handle)
{
	/* This copy the behavior of the current Mono implementation */
	return true;
}

bool ves_icall_System_Threading_ThreadPool_IsThreadPoolHosted (void)
{
	return false;
}

void ves_icall_System_Threading_ThreadPool_NotifyWorkItemQueued (void)
{
	// We don't need an implementation here. The Mono code only uses this method to increment a performance counter that we don't have in IL2CPP.
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\threadpool-ms.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\ThreadPoolMonitorThread.cpp---------------
.
.
#include "il2cpp-config.h"

#include "gc/GarbageCollector.h"
#include "mono/ThreadPool/threadpool-ms.h"
#include "mono/ThreadPool/ThreadPoolDataStructures.h"
#include "mono/ThreadPool/ThreadPoolMacros.h"
#include "mono/ThreadPool/ThreadPoolMonitorThread.h"
#include "mono/ThreadPool/ThreadPoolWorkerThread.h"
#include "vm/Runtime.h"
#include "vm/Thread.h"
#include "os/Time.h"
#include "os/CpuInfo.h"

#define MONITOR_INTERVAL 500 // ms
#define MONITOR_MINIMAL_LIFETIME 60 * 1000 // ms

static int32_t s_MonitorStatus = MONITOR_STATUS_NOT_RUNNING;

MonitorStatus GetMonitorStatus()
{
    return static_cast<MonitorStatus>(s_MonitorStatus);
}

static int32_t cpu_info_usage(void* prev)
{
    // Note : Implementing CpuInfo on all platforms will be challenging, so for now we are going to cheat
    // and always say it's low
#if !IL2CPP_USE_GENERIC_CPU_INFO
    return il2cpp::os::CpuInfo::Usage(prev);
#else
    return CPU_USAGE_LOW;
#endif
}

static Il2CppException* mono_thread_interruption_checkpoint(void)
{
    // For now just do nothing.  The one place this is used doesn't care about the return value
    return NULL;
}

/* LOCKING: threadpool->domains_lock must be held */
static bool domain_any_has_request(void)
{
    unsigned int i;

    for (i = 0; i < g_ThreadPool->domains.size(); ++i)
    {
        ThreadPoolDomain *tmp = g_ThreadPool->domains[i];
        if (tmp->outstanding_request > 0)
            return true;
    }

    return false;
}

static bool monitor_sufficient_delay_since_last_dequeue(void)
{
    int64_t threshold;

    IL2CPP_ASSERT(g_ThreadPool);

    if (g_ThreadPool->cpu_usage < CPU_USAGE_LOW)
    {
        threshold = MONITOR_INTERVAL;
    }
    else
    {
        ThreadPoolCounter counter;
        counter.as_int64_t = COUNTER_READ();
        threshold = counter._.max_working * MONITOR_INTERVAL * 2;
    }

    return il2cpp::os::Time::GetTicksMillisecondsMonotonic() >= g_ThreadPool->heuristic_last_dequeue + threshold;
}

static bool monitor_should_keep_running(void)
{
    static int64_t last_should_keep_running = -1;

    IL2CPP_ASSERT(s_MonitorStatus == MONITOR_STATUS_WAITING_FOR_REQUEST || s_MonitorStatus == MONITOR_STATUS_REQUESTED);

    if (il2cpp::os::Atomic::Exchange(&s_MonitorStatus, MONITOR_STATUS_WAITING_FOR_REQUEST) == MONITOR_STATUS_WAITING_FOR_REQUEST)
    {
        bool should_keep_running = true, force_should_keep_running = false;

        if (il2cpp::vm::Runtime::IsShuttingDown())
        {
            should_keep_running = false;
        }
        else
        {
            g_ThreadPool->domains_lock.Acquire();
            if (!domain_any_has_request())
                should_keep_running = false;
            g_ThreadPool->domains_lock.Release();

            if (!should_keep_running)
            {
                if (last_should_keep_running == -1 || il2cpp::os::Time::GetTicks100NanosecondsMonotonic() - last_should_keep_running < MONITOR_MINIMAL_LIFETIME * 1000 * 10)
                {
                    should_keep_running = force_should_keep_running = true;
                }
            }
        }

        if (should_keep_running)
        {
            if (last_should_keep_running == -1 || !force_should_keep_running)
                last_should_keep_running = il2cpp::os::Time::GetTicks100NanosecondsMonotonic();
        }
        else
        {
            last_should_keep_running = -1;
            if (il2cpp::os::Atomic::CompareExchange(&s_MonitorStatus, MONITOR_STATUS_NOT_RUNNING, MONITOR_STATUS_WAITING_FOR_REQUEST) == MONITOR_STATUS_WAITING_FOR_REQUEST)
                return false;
        }
    }

    IL2CPP_ASSERT(s_MonitorStatus == MONITOR_STATUS_WAITING_FOR_REQUEST || s_MonitorStatus == MONITOR_STATUS_REQUESTED);

    return true;
}

static void monitor_thread(void* data)
{
    Il2CppInternalThread *current_thread = il2cpp::vm::Thread::CurrentInternal();
    unsigned int i;

    cpu_info_usage(g_ThreadPool->cpu_usage_state);

    //mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] monitor thread, started", mono_native_thread_id_get ());

    do
    {
        ThreadPoolCounter counter;
        bool limit_worker_max_reached;
        int32_t interval_left = MONITOR_INTERVAL;
        int32_t awake = 0; /* number of spurious awakes we tolerate before doing a round of rebalancing */

        IL2CPP_ASSERT(s_MonitorStatus != MONITOR_STATUS_NOT_RUNNING);

        il2cpp::gc::GarbageCollector::SetSkipThread(true);

        do
        {
            int64_t ts;
            bool alerted = false;

            if (il2cpp::vm::Runtime::IsShuttingDown())
                break;

            ts = il2cpp::os::Time::GetTicksMillisecondsMonotonic();
            il2cpp::vm::Thread::Sleep(interval_left);
            /*if (mono_thread_info_sleep (interval_left, &alerted) == 0)
            break;*/
            interval_left -= (int32_t)(il2cpp::os::Time::GetTicksMillisecondsMonotonic() - ts);

            il2cpp::gc::GarbageCollector::SetSkipThread(false);
            if ((current_thread->state & (il2cpp::vm::kThreadStateStopRequested | il2cpp::vm::kThreadStateSuspendRequested)) != 0)
                mono_thread_interruption_checkpoint();
            il2cpp::gc::GarbageCollector::SetSkipThread(true);
        }
        while (interval_left > 0 && ++awake < 10);

        il2cpp::gc::GarbageCollector::SetSkipThread(false);

        if (g_ThreadPool->suspended)
            continue;

        if (il2cpp::vm::Runtime::IsShuttingDown())
            continue;

        g_ThreadPool->domains_lock.Acquire();
        if (!domain_any_has_request())
        {
            g_ThreadPool->domains_lock.Release();
            continue;
        }
        g_ThreadPool->domains_lock.Release();

        g_ThreadPool->cpu_usage = cpu_info_usage(g_ThreadPool->cpu_usage_state);

        if (!monitor_sufficient_delay_since_last_dequeue())
            continue;

        limit_worker_max_reached = false;

        COUNTER_ATOMIC(counter,
        {
            if (counter._.max_working >= g_ThreadPool->limit_worker_max)
            {
                limit_worker_max_reached = true;
                break;
            }
            counter._.max_working++;
        });

        if (limit_worker_max_reached)
            continue;

        hill_climbing_force_change(counter._.max_working, TRANSITION_STARVATION);

        for (i = 0; i < 5; ++i)
        {
            if (il2cpp::vm::Runtime::IsShuttingDown())
                break;

            if (worker_try_unpark())
            {
                //mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] monitor thread, unparked", mono_native_thread_id_get ());
                break;
            }

            if (worker_try_create())
            {
                //mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] monitor thread, created", mono_native_thread_id_get ());
                break;
            }
        }
    }
    while (monitor_should_keep_running());

    //mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] monitor thread, finished", mono_native_thread_id_get ());
}

void monitor_ensure_running()
{
    for (;;)
    {
        switch (s_MonitorStatus)
        {
            case MONITOR_STATUS_REQUESTED:
                return;
            case MONITOR_STATUS_WAITING_FOR_REQUEST:
                il2cpp::os::Atomic::CompareExchange(&s_MonitorStatus, MONITOR_STATUS_REQUESTED, MONITOR_STATUS_WAITING_FOR_REQUEST);
                break;
            case MONITOR_STATUS_NOT_RUNNING:
                if (il2cpp::vm::Runtime::IsShuttingDown())
                    return;
                if (il2cpp::os::Atomic::CompareExchange(&s_MonitorStatus, MONITOR_STATUS_REQUESTED, MONITOR_STATUS_NOT_RUNNING) == MONITOR_STATUS_NOT_RUNNING)
                {
                    if (!il2cpp::vm::Thread::CreateInternal(monitor_thread, NULL, true, SMALL_STACK))
                        s_MonitorStatus = MONITOR_STATUS_NOT_RUNNING;

                    return;
                }
                break;
            default:
                IL2CPP_ASSERT(0 && "should not be reached");
        }
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\ThreadPoolMonitorThread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\ThreadPoolWorkerThread.cpp---------------
.
.
#include "il2cpp-config.h"

#include "gc/GarbageCollector.h"
#include "mono/ThreadPool/threadpool-ms.h"
#include "mono/ThreadPool/ThreadPoolDataStructures.h"
#include "mono/ThreadPool/ThreadPoolMacros.h"
#include "vm/String.h"
#include "vm/Object.h"
#include "vm/Random.h"
#include "vm/Runtime.h"
#include "vm/Thread.h"
#include "os/Time.h"

#define WORKER_CREATION_MAX_PER_SEC 10

static void remove_working_thread(Il2CppInternalThread *thread)
{
    int index = -1;
    for (unsigned i = 0; i < g_ThreadPool->working_threads.size(); ++i)
    {
        if (g_ThreadPool->working_threads[i] == thread)
        {
            index = i;
            break;
        }
    }
    if (index != -1)
        g_ThreadPool->working_threads.erase(g_ThreadPool->working_threads.begin() + index);
}

/*
* mono_thread_info_install_interrupt: install an interruption token for the current thread.
*
*  - @callback: must be able to be called from another thread and always cancel the wait
*  - @data: passed to the callback
*  - @interrupted: will be set to TRUE if a token is already installed, FALSE otherwise
*     if set to TRUE, it must mean that the thread is in interrupted state
*/
static void thread_info_install_interrupt(void(*callback)(void* data), void* data, bool *interrupted)
{
    // We can get by without this for the time being.  Not needed until we have cooperative threading
}

static void thread_info_uninstall_interrupt(bool *interrupted)
{
    // We can get by without this for the time being.  Not needed until we have cooperative threading
}

static void worker_wait_interrupt(void* data)
{
    g_ThreadPool->active_threads_lock.Acquire();
    g_ThreadPool->parked_threads_cond.Notify(1);
    g_ThreadPool->active_threads_lock.Release();
}

/* return true if timeout, false otherwise (worker unpark or interrupt) */
static bool worker_park(void)
{
    bool timeout = false;

    //mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] current worker parking", mono_native_thread_id_get ());

    il2cpp::gc::GarbageCollector::SetSkipThread(true);

    g_ThreadPool->active_threads_lock.Acquire();

    if (!il2cpp::vm::Runtime::IsShuttingDown())
    {
        static void* rand_handle = NULL;
        Il2CppInternalThread *thread_internal;
        bool interrupted = false;

        if (!rand_handle)
            rand_handle = il2cpp::vm::Random::Create();
        IL2CPP_ASSERT(rand_handle);

        thread_internal = il2cpp::vm::Thread::CurrentInternal();
        IL2CPP_ASSERT(thread_internal);

        g_ThreadPool->parked_threads_count += 1;
        remove_working_thread(thread_internal);

        thread_info_install_interrupt(worker_wait_interrupt, NULL, &interrupted);
        if (interrupted)
            goto done;
        if (g_ThreadPool->parked_threads_cond.TimedWait(baselib::timeout_ms(il2cpp::vm::Random::Next(&rand_handle, 5 * 1000, 60 * 1000))) == false)
            timeout = true;

        thread_info_uninstall_interrupt(&interrupted);

    done:
        g_ThreadPool->working_threads.push_back(thread_internal);
        g_ThreadPool->parked_threads_count -= 1;
    }

    g_ThreadPool->active_threads_lock.Release();

    il2cpp::gc::GarbageCollector::SetSkipThread(false);

    //mono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_THREADPOOL, "[%p] current worker unparking, timeout? %s", mono_native_thread_id_get (), timeout ? "yes" : "no");

    return timeout;
}

/* LOCKING: threadpool->domains_lock must be held */
static ThreadPoolDomain* domain_get_next(ThreadPoolDomain *current)
{
    ThreadPoolDomain *tpdomain = NULL;
    unsigned int len;

    len = (unsigned int)g_ThreadPool->domains.size();
    if (len > 0)
    {
        unsigned int i, current_idx = ~0u;
        if (current)
        {
            for (i = 0; i < len; ++i)
            {
                if (current == g_ThreadPool->domains[i])
                {
                    current_idx = i;
                    break;
                }
            }
            IL2CPP_ASSERT(current_idx != ~0u);
        }
        for (i = current_idx + 1; i < len + current_idx + 1; ++i)
        {
            ThreadPoolDomain *tmp = (ThreadPoolDomain*)g_ThreadPool->domains[i % len];
            if (tmp->outstanding_request > 0)
            {
                tpdomain = tmp;
                break;
            }
        }
    }

    return tpdomain;
}

struct WorkerThreadStateHolder
{
    Il2CppInternalThread *thread;
    ThreadPoolDomain* tpdomain;
    ThreadPoolDomain* previous_tpdomain;
    ThreadPoolCounter counter;
    bool retire;

    WorkerThreadStateHolder() :
        thread(il2cpp::vm::Thread::CurrentInternal()),
        tpdomain(NULL),
        previous_tpdomain(NULL),
        retire(false)
    {
        IL2CPP_ASSERT(thread);
        il2cpp::vm::Thread::SetName(thread, il2cpp::vm::String::New("IL2CPP Threadpool worker"));

        g_ThreadPool->active_threads_lock.AcquireScoped([this] {
            g_ThreadPool->working_threads.push_back(thread);
        });
    }

    ~WorkerThreadStateHolder()
    {
        g_ThreadPool->active_threads_lock.AcquireScoped([this] {
            remove_working_thread(thread);
        });

        COUNTER_ATOMIC(counter,
        {
            counter._.working--;
            counter._.active--;
        });
    }
};

struct WorkerThreadParkStateHolder
{
    ThreadPoolCounter& counter;
    il2cpp::os::FastAutoUnlock domainUnlock;

    WorkerThreadParkStateHolder(WorkerThreadStateHolder& workerThreadState) :
        counter(workerThreadState.counter),
        domainUnlock(&g_ThreadPool->domains_lock)
    {
        COUNTER_ATOMIC(counter,
        {
            counter._.working--;
            counter._.parked++;
        });
    }

    ~WorkerThreadParkStateHolder()
    {
        COUNTER_ATOMIC(counter,
        {
            counter._.working++;
            counter._.parked--;
        });
    }
};

struct WorkerThreadJobStateHolder
{
    ThreadPoolDomain* tpdomain;

    WorkerThreadJobStateHolder(const WorkerThreadStateHolder& workerThreadState) :
        tpdomain(workerThreadState.tpdomain)
    {
        tpdomain->outstanding_request--;
        IL2CPP_ASSERT(tpdomain->outstanding_request >= 0);

        IL2CPP_ASSERT(tpdomain->domain);
        IL2CPP_ASSERT(tpdomain->domain->threadpool_jobs >= 0);
        tpdomain->domain->threadpool_jobs++;
    }

    ~WorkerThreadJobStateHolder()
    {
        tpdomain->domain->threadpool_jobs--;
        IL2CPP_ASSERT(tpdomain->domain->threadpool_jobs >= 0);
    }
};

static void worker_thread(void* data)
{
    IL2CPP_ASSERT(g_ThreadPool);

    WorkerThreadStateHolder workerThreadState;
    il2cpp::os::FastAutoLock domainsLock(&g_ThreadPool->domains_lock);

    while (!il2cpp::vm::Runtime::IsShuttingDown())
    {
        workerThreadState.previous_tpdomain = workerThreadState.tpdomain;

        if (workerThreadState.retire || !(workerThreadState.tpdomain = domain_get_next(workerThreadState.previous_tpdomain)))
        {
            WorkerThreadParkStateHolder threadParkState(workerThreadState);

            if (worker_park())
                break;

            workerThreadState.retire = false;
            continue;
        }

        WorkerThreadJobStateHolder threadJobState(workerThreadState);
        il2cpp::os::FastAutoUnlock domainUnlock(&g_ThreadPool->domains_lock);

        Il2CppObject* res = il2cpp::vm::Runtime::InvokeWithThrow(il2cpp_defaults.threadpool_perform_wait_callback_method, NULL, NULL);
        if (res && *(bool*)il2cpp::vm::Object::Unbox(res) == false)
            workerThreadState.retire = true;

        il2cpp::vm::Thread::ClrState(workerThreadState.thread, static_cast<il2cpp::vm::ThreadState>(~il2cpp::vm::kThreadStateBackground));
        if (!il2cpp::vm::Thread::TestState(workerThreadState.thread, il2cpp::vm::kThreadStateBackground))
            il2cpp::vm::Thread::SetState(workerThreadState.thread, il2cpp::vm::kThreadStateBackground);
    }
}

bool worker_try_create()
{
    ThreadPoolCounter counter;
    Il2CppInternalThread *thread;
    int64_t current_ticks;
    int32_t now;

    il2cpp::os::FastAutoLock lock(&g_ThreadPool->worker_creation_lock);

    current_ticks = il2cpp::os::Time::GetTicks100NanosecondsMonotonic();
    now = (int32_t)(current_ticks / (10 * 1000 * 1000));

    if (current_ticks != 0)
    {
        if (g_ThreadPool->worker_creation_current_second != now)
        {
            g_ThreadPool->worker_creation_current_second = now;
            g_ThreadPool->worker_creation_current_count = 0;
        }
        else
        {
            IL2CPP_ASSERT(g_ThreadPool->worker_creation_current_count <= WORKER_CREATION_MAX_PER_SEC);
            if (g_ThreadPool->worker_creation_current_count == WORKER_CREATION_MAX_PER_SEC)
            {
                // Worker creation failed because maximum number of workers already created in the last second
                return false;
            }
        }
    }

    COUNTER_ATOMIC(counter,
    {
        if (counter._.working >= counter._.max_working)
        {
            // Worked creation failed because maximum number of workers are running
            return false;
        }
        counter._.working++;
        counter._.active++;
    });

    if ((thread = il2cpp::vm::Thread::CreateInternal(worker_thread, NULL, true, 0)) != NULL)
    {
        g_ThreadPool->worker_creation_current_count += 1;
        return true;
    }

    // Failed creating native thread :(
    COUNTER_ATOMIC(counter,
    {
        counter._.working--;
        counter._.active--;
    });

    return false;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\mono\ThreadPool\ThreadPoolWorkerThread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ConditionVariable.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/ConditionVariable.h"
#include "os/Mutex.h"

#if IL2CPP_SUPPORT_THREADS

#if IL2CPP_THREADS_WIN32
#include "os/Win32/ConditionVariableImpl.h"
#elif IL2CPP_THREADS_PTHREAD
#include "os/Posix/ConditionVariableImpl.h"
#else
#include "os/ConditionVariableImpl.h"
#endif


namespace il2cpp
{
namespace os
{
    ConditionVariable::ConditionVariable()
        : m_ConditionVariable(new ConditionVariableImpl())
    {
    }

    ConditionVariable::~ConditionVariable()
    {
        delete m_ConditionVariable;
    }

    int ConditionVariable::Wait(FastMutex* lock)
    {
        return m_ConditionVariable->Wait(lock->GetImpl());
    }

    int ConditionVariable::TimedWait(FastMutex* lock, uint32_t timeout_ms)
    {
        return m_ConditionVariable->TimedWait(lock->GetImpl(), timeout_ms);
    }

    void ConditionVariable::Broadcast()
    {
        m_ConditionVariable->Broadcast();
    }

    void ConditionVariable::Signal()
    {
        m_ConditionVariable->Signal();
    }
}
}

#else

namespace il2cpp
{
namespace os
{
    ConditionVariable::ConditionVariable()
    {
    }

    ConditionVariable::~ConditionVariable()
    {
    }

    int ConditionVariable::Wait(FastMutex* lock)
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return 0;
    }

    int ConditionVariable::TimedWait(FastMutex* lock, uint32_t timeout_ms)
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return 0;
    }

    void ConditionVariable::Broadcast()
    {
    }

    void ConditionVariable::Signal()
    {
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ConditionVariable.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\CrashHelpers.cpp---------------
.
.
#include "il2cpp-config.h"

#include "os/CrashHelpers.h"
#include "os/StackTrace.h"
#include "utils/Logging.h"

#include <string>

namespace il2cpp
{
namespace os
{
    void CrashHelpers::Crash()
    {
        std::string nativeStackTrace;
#if IL2CPP_ENABLE_NATIVE_STACKTRACES
        nativeStackTrace = il2cpp::os::StackTrace::NativeStackTrace();
#endif
        if (!nativeStackTrace.empty())
        {
            std::string nativeStackTraceMessage = "Native stack trace:\n" + nativeStackTrace;
            il2cpp::utils::Logging::Write(nativeStackTraceMessage.c_str());
        }
        else
        {
            il2cpp::utils::Logging::Write("No native stack trace exists. Make sure this is platform supports native stack traces.");
        }


        CrashHelpers::CrashImpl();
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\CrashHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Error.cpp---------------
.
.
#include "il2cpp-config.h"

#include "os/Error.h"
#include "os/ThreadLocalValue.h"

// Note: for now the implementation is not platform depentent.

namespace il2cpp
{
namespace os
{
    static ThreadLocalValue s_LastError;

    ErrorCode Error::GetLastError()
    {
        void* value = 0;

        s_LastError.GetValue(&value);

        return (ErrorCode)(int64_t)value;
    }

    void Error::SetLastError(ErrorCode code)
    {
        s_LastError.SetValue((void*)((int64_t)code));
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Error.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Event.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Event.h"

#if IL2CPP_SUPPORT_THREADS

#if IL2CPP_THREADS_WIN32 || IL2CPP_THREADS_PTHREAD
#include "os/Generic/EventImpl.h"
#else
#include "os/EventImpl.h"
#endif


namespace il2cpp
{
namespace os
{
    Event::Event(bool manualReset, bool signaled)
        : m_Event(new EventImpl(manualReset, signaled))
    {
    }

    Event::~Event()
    {
        delete m_Event;
    }

    ErrorCode Event::Set()
    {
        return m_Event->Set();
    }

    ErrorCode Event::Reset()
    {
        return m_Event->Reset();
    }

    WaitStatus Event::Wait(bool interruptible)
    {
        return m_Event->Wait(interruptible);
    }

    WaitStatus Event::Wait(uint32_t ms, bool interruptible)
    {
        return m_Event->Wait(ms, interruptible);
    }

    void* Event::GetOSHandle()
    {
        return m_Event->GetOSHandle();
    }
}
}

#else

namespace il2cpp
{
namespace os
{
    Event::Event(bool manualReset, bool signaled)
    {
    }

    Event::~Event()
    {
    }

    ErrorCode Event::Set()
    {
        return kErrorCodeSuccess;
    }

    ErrorCode Event::Reset()
    {
        return kErrorCodeSuccess;
    }

    WaitStatus Event::Wait(bool interruptible)
    {
        return kWaitStatusSuccess;
    }

    WaitStatus Event::Wait(uint32_t ms, bool interruptible)
    {
        return kWaitStatusSuccess;
    }

    void* Event::GetOSHandle()
    {
        return NULL;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Event.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\FastReaderReaderWriterLock.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/FastReaderReaderWriterLock.h"

#if IL2CPP_SUPPORT_THREADS

#if IL2CPP_USE_BASELIB_FAST_READER_RWL
#include "os/baselib/FastReaderReaderWriterLockImpl.h"
#elif IL2CPP_THREADS_WIN32
#include "os/Win32/FastReaderReaderWriterLockImpl.h"
#elif IL2CPP_THREADS_PTHREAD
#include "os/Posix/FastReaderReaderWriterLockImpl.h"
#else
#include "os/FastReaderReaderWriterLockImpl.h"
#endif

namespace il2cpp
{
namespace os
{
    FastReaderReaderWriterLock::FastReaderReaderWriterLock()
        : m_Impl(new FastReaderReaderWriterLockImpl())
    {
    }

    FastReaderReaderWriterLock::~FastReaderReaderWriterLock()
    {
        delete m_Impl;
    }

    void FastReaderReaderWriterLock::LockExclusive()
    {
        m_Impl->LockExclusive();
    }

    void FastReaderReaderWriterLock::LockShared()
    {
        m_Impl->LockShared();
    }

    void FastReaderReaderWriterLock::ReleaseExclusive()
    {
        m_Impl->ReleaseExclusive();
    }

    void FastReaderReaderWriterLock::ReleaseShared()
    {
        m_Impl->ReleaseShared();
    }

    FastReaderReaderWriterLockImpl* FastReaderReaderWriterLock::GetImpl()
    {
        return m_Impl;
    }
}
}

#else

#include <stddef.h>

namespace il2cpp
{
namespace os
{
    FastReaderReaderWriterLock::FastReaderReaderWriterLock()
    {
    }

    FastReaderReaderWriterLock::~FastReaderReaderWriterLock()
    {
    }

    void FastReaderReaderWriterLock::LockExclusive()
    {
    }

    void FastReaderReaderWriterLock::LockShared()
    {
    }

    void FastReaderReaderWriterLock::ReleaseExclusive()
    {
    }

    void FastReaderReaderWriterLock::ReleaseShared()
    {
    }

    FastReaderReaderWriterLockImpl* FastReaderReaderWriterLock::GetImpl()
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return NULL;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\FastReaderReaderWriterLock.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Image.cpp---------------
.
.
#include "il2cpp-config.h"

#include "Image.h"

namespace il2cpp
{
namespace os
{
namespace Image
{
    static void* s_ManagedSectionStart = NULL;
    static void* s_ManagedSectionEnd = NULL;

    bool ManagedSectionExists()
    {
        return s_ManagedSectionStart != NULL && s_ManagedSectionEnd != NULL;
    }

    bool IsInManagedSection(void* ip)
    {
        if (!ManagedSectionExists())
            return false;

        return s_ManagedSectionStart <= ip && ip <= s_ManagedSectionEnd;
    }

    void GetManagedSectionStartAndEnd(void*& start, void*& end)
    {
        start = s_ManagedSectionStart;
        end = s_ManagedSectionEnd;
    }

    void SetManagedSectionStartAndEnd(void* start, void* end)
    {
        s_ManagedSectionStart = start;
        s_ManagedSectionEnd = end;
    }
}
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Image.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\LibraryLoader.cpp---------------
.
.
#include "LibraryLoader.h"
#include "utils/StringUtils.h"
#include "utils/Exception.h"

#include "os/Mutex.h"

namespace il2cpp
{
namespace os
{
    static Il2CppSetFindPlugInCallback s_FindPluginCallback = NULL;

    typedef std::vector<std::pair<std::basic_string<Il2CppNativeChar>, Baselib_DynamicLibrary_Handle> > DllCacheContainer;
    typedef DllCacheContainer::const_iterator DllCacheIterator;
    static DllCacheContainer s_DllCache; // If a library does not need to be closed - do not add it to the cache.
    static baselib::ReentrantLock s_DllCacheMutex;

    static inline Il2CppNativeChar AsciiToLower(Il2CppNativeChar c)
    {
        if (c >= 'A' && c <= 'Z')
            return c - 'A' + 'a';

        return c;
    }

    static bool DoesNativeDynamicLibraryNameMatch(const il2cpp::utils::StringView<Il2CppNativeChar>& desiredLibraryName, const Il2CppNativeChar* hardcodedLibraryName)
    {
        size_t desiredLibraryNameLength = desiredLibraryName.Length();
        for (size_t i = 0; i < desiredLibraryNameLength; i++)
        {
            Il2CppNativeChar desiredCharacter = AsciiToLower(desiredLibraryName[i]);
            Il2CppNativeChar hardcodedCharacter = hardcodedLibraryName[i];

            // Assume hardcodedLibraryName consists of only lower case ascii characters
            IL2CPP_ASSERT(hardcodedCharacter < 128 && (hardcodedCharacter<'A' || hardcodedCharacter> 'Z'));

            if (desiredCharacter != hardcodedCharacter)
            {
                // If we've reached end of our hardcoded dll name, it can still match if we've
                // reached end of desiredLibraryName file name and only the extension is left
                return hardcodedCharacter == 0 &&
                    i + 4 == desiredLibraryNameLength &&
                    desiredLibraryName[i] == '.' &&
                    AsciiToLower(desiredLibraryName[i + 1]) == 'd' &&
                    AsciiToLower(desiredLibraryName[i + 2]) == 'l' &&
                    AsciiToLower(desiredLibraryName[i + 3]) == 'l';
            }
            else if (hardcodedCharacter == 0)
            {
                // We've reached the end of hardcoded library name
                // It's a match if we're at the end of desired library name too
                return i + 1 == desiredLibraryNameLength;
            }
            else if (i == desiredLibraryNameLength - 1)
            {
                // We've reached the end of desired library name
                // It's a match if we're at the end of hardcoded library name too
                return hardcodedLibraryName[i + 1] == 0;
            }
        }

        // We've reached the end of desired library name,
        // but not the end of hardcoded library name.
        // It is not a match.
        return false;
    }

    Il2CppMethodPointer LibraryLoader::GetHardcodedPInvokeDependencyFunctionPointer(const il2cpp::utils::StringView<Il2CppNativeChar>& nativeDynamicLibrary, const il2cpp::utils::StringView<char>& entryPoint, Il2CppCharSet charSet)
    {
        // We don't support, nor do we need to Ansi functions.  That would break forwarding method names to Unicode MoveFileEx -> MoveFileExW
        if (HardcodedPInvokeDependencies == NULL || charSet == CHARSET_ANSI)
            return NULL;

        for (size_t i = 0; i < HardcodedPInvokeDependenciesCount; i++)
        {
            const HardcodedPInvokeDependencyLibrary& library = HardcodedPInvokeDependencies[i];
            if (DoesNativeDynamicLibraryNameMatch(nativeDynamicLibrary, library.libraryName))
            {
                size_t functionCount = library.functionCount;
                for (size_t j = 0; j < functionCount; j++)
                {
                    const HardcodedPInvokeDependencyFunction function = library.functions[j];
                    if (EntryNameMatches(il2cpp::utils::StringView<char>(function.functionName, function.functionNameLen), entryPoint))
                        return function.functionPointer;
                }

                // We assume that kHardcodedPInvokeDependencies will not contain duplicates
                return NULL;
            }
        }

        return NULL;
    }

    Baselib_DynamicLibrary_Handle LibraryLoader::LoadDynamicLibrary(const utils::StringView<Il2CppNativeChar> nativeDynamicLibrary, std::string& detailedError)
    {
        StringViewAsNullTerminatedStringOf(Il2CppNativeChar, nativeDynamicLibrary, libraryName);
        if (s_FindPluginCallback)
            libraryName = s_FindPluginCallback(libraryName);
        auto libraryNameLength = utils::StringUtils::StrLen(libraryName);

        {
            os::FastAutoLock lock(&s_DllCacheMutex);
            for (DllCacheIterator it = s_DllCache.begin(); it != s_DllCache.end(); it++)
                if (it->first.compare(0, std::string::npos, libraryName, libraryNameLength) == 0)
                    return it->second;
        }

        bool needsClosing = true;

        auto handle = Baselib_DynamicLibrary_Handle_Invalid;
        if (libraryName == nullptr || libraryNameLength == 0)
        {
            auto errorState = Baselib_ErrorState_Create();
            handle = OpenProgramHandle(errorState, needsClosing);
            // Disabling it for emscripten builds as they seem to be quite code sensitive
#if (!defined(__EMSCRIPTEN__))
            if (Baselib_ErrorState_ErrorRaised(&errorState))
            {
                if (!detailedError.empty())
                    detailedError += " ";
                detailedError += "Unable to open program handle because of '";
                detailedError += utils::Exception::FormatBaselibErrorState(errorState);
                detailedError += "'.";
            }
#endif
        }
        else
            handle = ProbeForLibrary(libraryName, libraryNameLength, detailedError);

        if ((handle != Baselib_DynamicLibrary_Handle_Invalid) && needsClosing)
        {
            os::FastAutoLock lock(&s_DllCacheMutex);
            s_DllCache.push_back(std::make_pair(libraryName, handle));
        }

        return handle;
    }

    Il2CppMethodPointer LibraryLoader::GetFunctionPointer(Baselib_DynamicLibrary_Handle handle, const PInvokeArguments& pinvokeArgs, std::string& detailedError)
    {
        if (handle == Baselib_DynamicLibrary_Handle_Invalid)
            return NULL;

        StringViewAsNullTerminatedStringOf(char, pinvokeArgs.entryPoint, entryPoint);

        // If there's 'no mangle' flag set, just return directly what GetProcAddress returns
        if (pinvokeArgs.isNoMangle)
            return GetFunctionPointer(handle, entryPoint, detailedError);

        const size_t kBufferOverhead = 10;
        Il2CppMethodPointer func = nullptr;
        size_t originalFuncNameLength = strlen(entryPoint) + 1;
        std::string functionName;

        functionName.resize(originalFuncNameLength + kBufferOverhead + 1); // Let's index the string from '1', because we might have to prepend an underscore in case of stdcall mangling
        memcpy(&functionName[1], entryPoint, originalFuncNameLength);
        memset(&functionName[1] + originalFuncNameLength, 0, kBufferOverhead);

        // If there's no 'dont mangle' flag set, 'W' function takes priority over original name, but 'A' function does not (yes, really)
        if (pinvokeArgs.charSet == CHARSET_UNICODE)
        {
            functionName[originalFuncNameLength] = 'W';
            if ((func = GetFunctionPointer(handle, functionName.c_str() + 1, detailedError)))
                return func;

            // If charset specific function lookup failed, try with original name
            if ((func = GetFunctionPointer(handle, entryPoint, detailedError)))
                return func;
        }
        else
        {
            if ((func = GetFunctionPointer(handle, entryPoint, detailedError)))
                return func;

            // If original name function lookup failed, try with mangled name
            functionName[originalFuncNameLength] = 'A';
            if ((func = GetFunctionPointer(handle, functionName.c_str() + 1, detailedError)))
                return func;
        }

        // TODO is this Win only?
        // If it's not cdecl, try mangling the name
        // THIS ONLY APPLIES TO 32-bit x86!
#if defined(_X86_) && PLATFORM_ARCH_32
        if (sizeof(void*) == 4 && pinvokeArgs.callingConvention != IL2CPP_CALL_C)
        {
            functionName[0] = '_';
            sprintf(&functionName[0] + originalFuncNameLength, "@%i", pinvokeArgs.parameterSize);
            if ((func = GetFunctionPointer(handle, functionName.c_str(), detailedError)))
                return func;
        }
#endif

        return NULL;
    }

    Il2CppMethodPointer LibraryLoader::GetFunctionPointer(Baselib_DynamicLibrary_Handle handle, const char* functionName, std::string& detailedError)
    {
        auto errorState = Baselib_ErrorState_Create();
        if (handle == Baselib_DynamicLibrary_Handle_Invalid)
            return NULL;
        auto func = reinterpret_cast<Il2CppMethodPointer>(Baselib_DynamicLibrary_GetFunction(handle, functionName, &errorState));
#if (!defined(__EMSCRIPTEN__))
        if (Baselib_ErrorState_ErrorRaised(&errorState))
        {
            if (!detailedError.empty())
                detailedError += " ";
            detailedError += "Unable to get function '";
            detailedError += functionName;
            detailedError += "' because of '";
            detailedError += utils::Exception::FormatBaselibErrorState(errorState);
            detailedError += "'.";
        }
#else
        NO_UNUSED_WARNING(detailedError);
#endif
        return func;
    }

    void LibraryLoader::CleanupLoadedLibraries()
    {
        // We assume that presence of the library in s_DllCache is a valid reason to be able to close it
        for (DllCacheIterator it = s_DllCache.begin(); it != s_DllCache.end(); it++)
        {
            // If libc is a "loaded library", it is a special case, and closing it will cause dlclose
            // on some Posix platforms to return an error (I'm looking at you, iOS 11). This really is
            // not an error, but Baselib_DynamicLibrary_Close will correctly assert when dlclose
            // returns an error. To avoid this assert, let's skip closing libc.
            if (utils::StringUtils::NativeStringToUtf8(it->first.c_str()) != "libc")
                Baselib_DynamicLibrary_Close(it->second);
        }
        s_DllCache.clear();
    }

    bool LibraryLoader::CloseLoadedLibrary(Baselib_DynamicLibrary_Handle handle)
    {
        if (handle == Baselib_DynamicLibrary_Handle_Invalid)
            return false;

        os::FastAutoLock lock(&s_DllCacheMutex);
        // We assume that presence of the library in s_DllCache is a valid reason to be able to close it
        for (DllCacheIterator it = s_DllCache.begin(); it != s_DllCache.end(); it++)
        {
            if (it->second == handle)
            {
                Baselib_DynamicLibrary_Close(it->second);
                s_DllCache.erase(it);
                return true;
            }
        }
        return false;
    }

    void LibraryLoader::SetFindPluginCallback(Il2CppSetFindPlugInCallback method)
    {
        s_FindPluginCallback = method;
    }

    Baselib_DynamicLibrary_Handle LibraryLoader::TryOpeningLibrary(const Il2CppNativeChar* libraryName, std::string& detailedError)
    {
        auto errorState = Baselib_ErrorState_Create();
        auto handle = Baselib_DynamicLibrary_Open(utils::StringUtils::NativeStringToBaselib(libraryName), &errorState);

#if (!defined(__EMSCRIPTEN__))
        if (Baselib_ErrorState_ErrorRaised(&errorState))
        {
            if (!detailedError.empty())
                detailedError += " ";
            detailedError += "Unable to load dynamic library '";
            detailedError += utils::StringUtils::NativeStringToUtf8(libraryName);
            detailedError += "' because of '";
            detailedError += utils::Exception::FormatBaselibErrorState(errorState);
            detailedError += "'.";
        }
#else
        NO_UNUSED_WARNING(detailedError);
#endif
        return handle;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\LibraryLoader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Messages.cpp---------------
.
.
#include <stdlib.h>

#include "il2cpp-config.h"

#include "os/Messages.h"

#define N_ELEMENTS(e) \
    (sizeof (e) / sizeof ((e)[0]))

namespace il2cpp
{
namespace os
{
    ErrorDesc common_messages[] =
    {
        { kErrorCodeSuccess, "Success" },
        { kErrorCodeFileNotFound, "Cannot find the specified file" },
        { kErrorCodePathNotFound, "Cannot find the specified file" },
        { kErrorCodeTooManyOpenFiles, "Too many open files" },
        { kErrorCodeAccessDenied, "Access denied" },
        { kErrorCodeInvalidHandle, "Invalid handle" },
        { kErrorInvalidData, "Invalid data" },
        { kErrorOutofmemory, "Out of memory" },
        { kErrorCodeNotSameDevice, "Not same device" },
        { kErrorCodeNoMoreFiles, "No more files" },
        { kErrorBadLength, "Bad length" },
        { kErrorCodeGenFailure, "General failure" },
        { kErrorCodeSharingViolation, "Sharing violation" },
        { kErrorCodeLockViolation, "Lock violation" },
        { kErrorNotSupported, "Operation not supported" },
        { kErrorCodeInvalidParameter, "Invalid parameter" },
        { kErrorCallNotImplemented, "Call not implemented" },
        { kErrorCodeInvalidName, "Invalid name" },
        { kErrorProcNotFound, "Process not found" },
        { kErrorCodeAlreadyExists, "Already exists" },
        { kErrorDirectory, "Is a directory" },
        { kErrorCodeEncryptionFailed, "Encryption failed" },
        { kWSAeintr, "interrupted" },
        { kWSAebadf, "Bad file number" },
        { kWSAeacces, "Access denied" },
        { kWSAefault, "Bad address" },
        { kWSAeinval, "Invalid arguments" },
        { kWSAemfile, "Too many open files" },
        { kWSAewouldblock, "Operation on non-blocking socket would block" },
        { kWSAeinprogress, "Operation in progress" },
        { kWSAealready, "Operation already in progress" },
        { kWSAenotsock, "The descriptor is not a socket" },
        { kWSAedestaddrreq, "Destination address required" },
        { kWSAemsgsize, "Message too long" },
        { kWSAeprototype, "Protocol wrong type for socket" },
        { kWSAenoprotoopt, "Protocol option not supported" },
        { kWSAeprotonosupport, "Protocol not supported" },
        { kWSAesocktnosupport, "Socket not supported" },
        { kWSAeopnotsupp, "Operation not supported" },
        { kWSAepfnosupport, "Protocol family not supported" },
        { kWSAeafnosupport, "An address incompatible with the requested protocol was used" },
        { kWSAeaddrinuse, "Address already in use" },
        { kWSAeaddrnotavail, "The requested address is not valid in this context" },
        { kWSAenetdown, "Network subsystem is down" },
        { kWSAenetunreach, "Network is unreachable" },
        { kWSAenetreset, "Connection broken, keep-alive detected a problem" },
        { kWSAeconnaborted, "An established connection was aborted in your host machine." },
        { kWSAeconnreset, "Connection reset by peer" },
        { kWSAenobufs, "Not enough buffer space is available" },
        { kWSAeisconn, "Socket is already connected" },
        { kWSAenotconn, "The socket is not connected" },
        { kWSAeshutdown, "The socket has been shut down" },
        { kWSAetoomanyrefs, "Too many references: cannot splice" },
        { kWSAetimedout, "Connection timed out" },
        { kWSAeconnrefused, "Connection refused" },
        { kWSAeloop, "Too many symbolic links encountered" },
        { kWSAenametoolong, "File name too long" },
        { kWSAehostdown, "Host is down" },
        { kWSAehostunreach, "No route to host" },
        { kWSAenotempty, "Directory not empty" },
        { kWSAeproclim, "EPROCLIM" },
        { kWSAeusers, "Too many users" },
        { kWSAedquot, "Quota exceeded" },
        { kWSAestale, "Stale NFS file handle" },
        { kWSAeremote, "Object is remote" },
        { kWSAsysnotready, "SYSNOTREADY" },
        { kWSAvernotsupported, "VERNOTSUPPORTED" },
        { kWSAnotinitialised, "Winsock not initialised" },
        { kWSAediscon, "EDISCON" },
        { kWSAenomore, "ENOMORE" },
        { kWSAecancelled, "Operation canceled" },
        { kWSAeinvalidproctable, "EINVALIDPROCTABLE" },
        { kWSAeinvalidprovider, "EINVALIDPROVIDER" },
        { kWSAeproviderfailedinit, "EPROVIDERFAILEDINIT" },
        { kWSAsyscallfailure, "System call failed" },
        { kWSAserviceNotFound, "SERVICE_NOT_FOUND" },
        { kWSAtypeNotFound, "TYPE_NOT_FOUND" },
        { kWSAENoMore, "E_NO_MORE" },
        { kWSAECancelled, "E_CANCELLED" },
        { kWSAerefused, "EREFUSED" },
        { kWSAhostNotFound, "No such host is known" },
        { kWSAtryAgain, "A temporary error occurred on an authoritative name server.  Try again later." },
        { kWSAnoRecovery, "No recovery" },
        { kWSAnoData, "No data" },
    };

#ifndef IL2CPP_DISABLE_FULL_MESSAGES
    ErrorDesc messages[] =
    {
        { kErrorInvalidFunction, "Invalid function" },
        { kErrorArenaTrashed, "Arena trashed" },
        { kErrorNotEnoughMemory, "Not enough memory" },
        { kErrorInvalidBlock, "Invalid block" },
        { kErrorBadEnvironment, "Bad environment" },
        { kErrorBadFormat, "Bad format" },
        { kErrorInvalidAccess, "Invalid access" },
        { kErrorInvalidDrive, "Invalid drive" },
        { kErrorCurrentDirectory, "Current directory" },
        { kErrorWriteProtect, "Write protect" },
        { kErrorBadUnit, "Bad unit" },
        { kErrorNotReady, "Not ready" },
        { kErrorBadCommand, "Bad command" },
        { kErrorCrc, "CRC" },
        { kErrorSeek, "Seek" },
        { kErrorNotDosDisk, "Not DOS disk" },
        { kErrorSectorNotFound, "Sector not found" },
        { kErrorOutOfPaper, "Out of paper" },
        { kErrorWriteFault, "Write fault" },
        { kErrorReadFault, "Read fault" },
        { kErrorWrongDisk, "Wrong disk" },
        { kErrorSharingBufferExceeded, "Sharing buffer exceeded" },
        { kErrorHandleEof, "Handle EOF" },
        { kErrorHandleDiskFull, "Handle disk full" },
        { kErrorRemNotList, "Rem not list" },
        { kErrorDupName, "Duplicate name" },
        { kErrorBadNetpath, "Bad netpath" },
        { kErrorNetworkBusy, "Network busy" },
        { kErrorDevNotExist, "Device does not exist" },
        { kErrorTooManyCmds, "Too many commands" },
        { kErrorAdapHdwErr, "ADAP HDW error" },
        { kErrorBadNetResp, "Bad net response" },
        { kErrorUnexpNetErr, "Unexpected net error" },
        { kErrorBadRemAdap, "Bad rem adap" },
        { kErrorPrintqFull, "Print queue full" },
        { kErrorNoSpoolSpace, "No spool space" },
        { kErrorPrintCancelled, "Print cancelled" },
        { kErrorNetnameDeleted, "Netname deleted" },
        { kErrorNetworkAccessDenied, "Network access denied" },
        { kErrorBadDevType, "Bad device type" },
        { kErrorBadNetName, "Bad net name" },
        { kErrorTooManyNames, "Too many names" },
        { kErrorTooManySess, "Too many sessions" },
        { kErrorSharingPaused, "Sharing paused" },
        { kErrorReqNotAccep, "Req not accep" },
        { kErrorRedirPaused, "Redir paused" },
        { kErrorFileExists, "File exists" },
        { kErrorCannotMake, "Cannot make" },
        { kErrorFailI24, "Fail i24" },
        { kErrorOutOfStructures, "Out of structures" },
        { kErrorAlreadyAssigned, "Already assigned" },
        { kErrorInvalidPassword, "Invalid password" },
        { kErrorNetWriteFault, "Net write fault" },
        { kErrorNoProcSlots, "No proc slots" },
        { kErrorTooManySemaphores, "Too many semaphores" },
        { kErrorExclSemAlreadyOwned, "Exclusive semaphore already owned" },
        { kErrorSemIsSet, "Semaphore is set" },
        { kErrorTooManySemRequests, "Too many semaphore requests" },
        { kErrorInvalidAtInterruptTime, "Invalid at interrupt time" },
        { kErrorSemOwnerDied, "Semaphore owner died" },
        { kErrorSemUserLimit, "Semaphore user limit" },
        { kErrorDiskChange, "Disk change" },
        { kErrorDriveLocked, "Drive locked" },
        { kErrorBrokenPipe, "Broken pipe" },
        { kErrorOpenFailed, "Open failed" },
        { kErrorBufferOverflow, "Buffer overflow" },
        { kErrorDiskFull, "Disk full" },
        { kErrorNoMoreSearchHandles, "No more search handles" },
        { kErrorInvalidTargetHandle, "Invalid target handle" },
        { kErrorInvalidCategory, "Invalid category" },
        { kErrorInvalidVerifySwitch, "Invalid verify switch" },
        { kErrorBadDriverLevel, "Bad driver level" },
        { kErrorSemTimeout, "Semaphore timeout" },
        { kErrorInsufficientBuffer, "Insufficient buffer" },
        { kErrorInvalidLevel, "Invalid level" },
        { kErrorNoVolumeLabel, "No volume label" },
        { kErrorModNotFound, "Module not found" },
        { kErrorWaitNoChildren, "Wait no children" },
        { kErrorChildNotComplete, "Child not complete" },
        { kErrorDirectAccessHandle, "Direct access handle" },
        { kErrorNegativeSeek, "Negative seek" },
        { kErrorSeekOnDevice, "Seek on device" },
        { kErrorIsJoinTarget, "Is join target" },
        { kErrorIsJoined, "Is joined" },
        { kErrorIsSubsted, "Is substed" },
        { kErrorNotJoined, "Not joined" },
        { kErrorNotSubsted, "Not substed" },
        { kErrorJoinToJoin, "Join to join" },
        { kErrorSubstToSubst, "Subst to subst" },
        { kErrorJoinToSubst, "Join to subst" },
        { kErrorSubstToJoin, "Subst to join" },
        { kErrorBusyDrive, "Busy drive" },
        { kErrorSameDrive, "Same drive" },
        { kErrorDirNotRoot, "Directory not root" },
        { kErrorDirNotEmpty, "Directory not empty" },
        { kErrorIsSubstPath, "Is subst path" },
        { kErrorIsJoinPath, "Is join path" },
        { kErrorPathBusy, "Path busy" },
        { kErrorIsSubstTarget, "Is subst target" },
        { kErrorSystemTrace, "System trace" },
        { kErrorInvalidEventCount, "Invalid event count" },
        { kErrorTooManyMuxwaiters, "Too many muxwaiters" },
        { kErrorInvalidListFormat, "Invalid list format" },
        { kErrorLabelTooLong, "Label too long" },
        { kErrorTooManyTcbs, "Too many TCBs" },
        { kErrorSignalRefused, "Signal refused" },
        { kErrorDiscarded, "Discarded" },
        { kErrorNotLocked, "Not locked" },
        { kErrorBadThreadidAddr, "Bad thread ID addr" },
        { kErrorBadArguments, "Bad arguments" },
        { kErrorBadPathname, "Bad pathname" },
        { kErrorSignalPending, "Signal pending" },
        { kErrorMaxThrdsReached, "Max thrds reached" },
        { kErrorLockFailed, "Lock failed" },
        { kErrorBusy, "Busy" },
        { kErrorCancelViolation, "Cancel violation" },
        { kErrorAtomicLocksNotSupported, "Atomic locks not supported" },
        { kErrorInvalidSegmentNumber, "Invalid segment number" },
        { kErrorInvalidOrdinal, "Invalid ordinal" },
        { kErrorInvalidFlagNumber, "Invalid flag number" },
        { kErrorSemNotFound, "Sem not found" },
        { kErrorInvalidStartingCodeseg, "Invalid starting codeseg" },
        { kErrorInvalidStackseg, "Invalid stackseg" },
        { kErrorInvalidModuletype, "Invalid moduletype" },
        { kErrorInvalidExeSignature, "Invalid exe signature" },
        { kErrorExeMarkedInvalid, "Exe marked invalid" },
        { kErrorBadExeFormat, "Bad exe format" },
        { kErrorIteratedDataExceeds64k, "Iterated data exceeds 64k (and that should be enough for anybody!)" },
        { kErrorInvalidMinallocsize, "Invalid minallocsize" },
        { kErrorDynlinkFromInvalidRing, "Dynlink from invalid ring" },
        { kErrorIoplNotEnabled, "IOPL not enabled" },
        { kErrorInvalidSegdpl, "Invalid segdpl" },
        { kErrorAutodatasegExceeds64k, "Autodataseg exceeds 64k" },
        { kErrorRing2segMustBeMovable, "Ring2seg must be movable" },
        { kErrorRelocChainXeedsSeglim, "Reloc chain exceeds seglim" },
        { kErrorInfloopInRelocChain, "Infloop in reloc chain" },
        { kErrorEnvvarNotFound, "Env var not found" },
        { kErrorNoSignalSent, "No signal sent" },
        { kErrorFilenameExcedRange, "Filename exceeds range" },
        { kErrorRing2StackInUse, "Ring2 stack in use" },
        { kErrorMetaExpansionTooLong, "Meta expansion too long" },
        { kErrorInvalidSignalNumber, "Invalid signal number" },
        { kErrorThread1Inactive, "Thread 1 inactive" },
        { kErrorLocked, "Locked" },
        { kErrorTooManyModules, "Too many modules" },
        { kErrorNestingNotAllowed, "Nesting not allowed" },
        { kErrorExeMachineTypeMismatch, "Exe machine type mismatch" },
        { kErrorBadPipe, "Bad pipe" },
        { kErrorPipeBusy, "Pipe busy" },
        { kErrorNoData, "No data" },
        { kErrorPipeNotConnected, "Pipe not connected" },
        { kErrorMoreData, "More data" },
        { kErrorVcDisconnected, "VC disconnected" },
        { kErrorInvalidEaName, "Invalid EA name" },
        { kErrorEaListInconsistent, "EA list inconsistent" },
        { kWaitTimeout, "Wait timeout" },
        { kErrorNoMoreItems, "No more items" },
        { kErrorCannotCopy, "Cannot copy" },
        { kErrorEasDidntFit, "EAS didnt fit" },
        { kErrorEaFileCorrupt, "EA file corrupt" },
        { kErrorEaTableFull, "EA table full" },
        { kErrorInvalidEaHandle, "Invalid EA handle" },
        { kErrorEasNotSupported, "EAs not supported" },
        { kErrorNotOwner, "Not owner" },
        { kErrorTooManyPosts, "Too many posts" },
        { kErrorPartialCopy, "Partial copy" },
        { kErrorOplockNotGranted, "Oplock not granted" },
        { kErrorInvalidOplockProtocol, "Invalid oplock protocol" },
        { kErrorDiskTooFragmented, "Disk too fragmented" },
        { kErrorDeletePending, "Delete pending" },
        { kErrorMrMidNotFound, "Mr Mid not found" },
        { kErrorInvalidAddress, "Invalid address" },
        { kErrorArithmeticOverflow, "Arithmetic overflow" },
        { kErrorPipeConnected, "Pipe connected" },
        { kErrorPipeListening, "Pipe listening" },
        { kErrorEaAccessDenied, "EA access denied" },
        { kErrorOperationAborted, "Operation aborted" },
        { kErrorIoIncomplete, "IO incomplete" },
        { kErrorIoPending, "IO pending" },
        { kErrorNoaccess, "No access" },
        { kErrorSwaperror, "Swap error" },
        { kErrorStackOverflow, "Stack overflow" },
        { kErrorInvalidMessage, "Invalid message" },
        { kErrorCanNotComplete, "Can not complete" },
        { kErrorInvalidFlags, "Invalid flags" },
        { kErrorUnrecognizedVolume, "Unrecognised volume" },
        { kErrorFileInvalid, "File invalid" },
        { kErrorFullscreenMode, "Full screen mode" },
        { kErrorNoToken, "No token" },
        { kErrorBaddb, "Bad DB" },
        { kErrorBadkey, "Bad key" },
        { kErrorCantopen, "Can't open" },
        { kErrorCantread, "Can't read" },
        { kErrorCantwrite, "Can't write" },
        { kErrorRegistryRecovered, "Registry recovered" },
        { kErrorRegistryCorrupt, "Registry corrupt" },
        { kErrorRegistryIoFailed, "Registry IO failed" },
        { kErrorNotRegistryFile, "Not registry file" },
        { kErrorKeyDeleted, "Key deleted" },
        { kErrorNoLogSpace, "No log space" },
        { kErrorKeyHasChildren, "Key has children" },
        { kErrorChildMustBeVolatile, "Child must be volatile" },
        { kErrorNotifyEnumDir, "Notify enum dir" },
        { kErrorDependentServicesRunning, "Dependent services running" },
        { kErrorInvalidServiceControl, "Invalid service control" },
        { kErrorServiceRequestTimeout, "Service request timeout" },
        { kErrorServiceNoThread, "Service no thread" },
        { kErrorServiceDatabaseLocked, "Service database locked" },
        { kErrorServiceAlreadyRunning, "Service already running" },
        { kErrorInvalidServiceAccount, "Invalid service account" },
        { kErrorServiceDisabled, "Service disabled" },
        { kErrorCircularDependency, "Circular dependency" },
        { kErrorServiceDoesNotExist, "Service does not exist" },
        { kErrorServiceCannotAcceptCtrl, "Service cannot accept ctrl" },
        { kErrorServiceNotActive, "Service not active" },
        { kErrorFailedServiceControllerConnect, "Failed service controller connect" },
        { kErrorExceptionInService, "Exception in service" },
        { kErrorDatabaseDoesNotExist, "Database does not exist" },
        { kErrorServiceSpecificError, "Service specific error" },
        { kErrorProcessAborted, "Process aborted" },
        { kErrorServiceDependencyFail, "Service dependency fail" },
        { kErrorServiceLogonFailed, "Service logon failed" },
        { kErrorServiceStartHang, "Service start hang" },
        { kErrorInvalidServiceLock, "Invalid service lock" },
        { kErrorServiceMarkedForDelete, "Service marked for delete" },
        { kErrorServiceExists, "Service exists" },
        { kErrorAlreadyRunningLkg, "Already running lkg" },
        { kErrorServiceDependencyDeleted, "Service dependency deleted" },
        { kErrorBootAlreadyAccepted, "Boot already accepted" },
        { kErrorServiceNeverStarted, "Service never started" },
        { kErrorDuplicateServiceName, "Duplicate service name" },
        { kErrorDifferentServiceAccount, "Different service account" },
        { kErrorCannotDetectDriverFailure, "Cannot detect driver failure" },
        { kErrorCannotDetectProcessAbort, "Cannot detect process abort" },
        { kErrorNoRecoveryProgram, "No recovery program" },
        { kErrorServiceNotInExe, "Service not in exe" },
        { kErrorNotSafebootService, "Not safeboot service" },
        { kErrorEndOfMedia, "End of media" },
        { kErrorFilemarkDetected, "Filemark detected" },
        { kErrorBeginningOfMedia, "Beginning of media" },
        { kErrorSetmarkDetected, "Setmark detected" },
        { kErrorNoDataDetected, "No data detected" },
        { kErrorPartitionFailure, "Partition failure" },
        { kErrorInvalidBlockLength, "Invalid block length" },
        { kErrorDeviceNotPartitioned, "Device not partitioned" },
        { kErrorUnableToLockMedia, "Unable to lock media" },
        { kErrorUnableToUnloadMedia, "Unable to unload media" },
        { kErrorMediaChanged, "Media changed" },
        { kErrorBusReset, "Bus reset" },
        { kErrorNoMediaInDrive, "No media in drive" },
        { kErrorNoUnicodeTranslation, "No unicode translation" },
        { kErrorDllInitFailed, "DLL init failed" },
        { kErrorShutdownInProgress, "Shutdown in progress" },
        { kErrorNoShutdownInProgress, "No shutdown in progress" },
        { kErrorIoDevice, "IO device" },
        { kErrorSerialNoDevice, "Serial IO device" },
        { kErrorIrqBusy, "IRQ busy" },
        { kErrorMoreWrites, "More writes" },
        { kErrorCounterTimeout, "Counter timeout" },
        { kErrorFloppyIdMarkNotFound, "Floppy ID mark not found" },
        { kErrorFloppyWrongCylinder, "Floppy wrong cylinder" },
        { kErrorFloppyUnknownError, "Floppy unknown error" },
        { kErrorFloppyBadRegisters, "Floppy bad registers" },
        { kErrorDiskRecalibrateFailed, "Disk recalibrate failed" },
        { kErrorDiskOperationFailed, "Disk operation failed" },
        { kErrorDiskResetFailed, "Disk reset failed" },
        { kErrorEomOverflow, "EOM overflow" },
        { kErrorNotEnoughServerMemory, "Not enough server memory" },
        { kErrorPossibleDeadlock, "Possible deadlock" },
        { kErrorMappedAlignment, "Mapped alignment" },
        { kErrorSetPowerStateVetoed, "Set power state vetoed" },
        { kErrorSetPowerStateFailed, "Set power state failed" },
        { kErrorTooManyLinks, "Too many links" },
        { kErrorOldWinVersion, "Old win version" },
        { kErrorAppWrongOs, "App wrong OS" },
        { kErrorSingleInstanceApp, "Single instance app" },
        { kErrorRmodeApp, "Rmode app" },
        { kErrorInvalidDll, "Invalid DLL" },
        { kErrorNoAssociation, "No association" },
        { kErrorDdeFail, "DDE fail" },
        { kErrorDllNotFound, "DLL not found" },
        { kErrorNoMoreUserHandles, "No more user handles" },
        { kErrorMessageSyncOnly, "Message sync only" },
        { kErrorSourceElementEmpty, "Source element empty" },
        { kErrorDestinationElementFull, "Destination element full" },
        { kErrorIllegalElementAddress, "Illegal element address" },
        { kErrorMagazineNotPresent, "Magazine not present" },
        { kErrorDeviceReinitializationNeeded, "Device reinitialization needed" },
        { kErrorDeviceRequiresCleaning, "Device requires cleaning" },
        { kErrorDeviceDoorOpen, "Device door open" },
        { kErrorDeviceNotConnected, "Device not connected" },
        { kErrorNotFound, "Not found" },
        { kErrorNoMatch, "No match" },
        { kErrorSetNotFound, "Set not found" },
        { kErrorPointNotFound, "Point not found" },
        { kErrorNoTrackingService, "No tracking service" },
        { kErrorNoVolumeId, "No volume ID" },
        { kErrorUnableToRemoveReplaced, "Unable to remove replaced" },
        { kErrorUnableToMoveReplacement, "Unable to move replacement" },
        { kErrorUnableToMoveReplacement2, "Unable to move replacement 2" },
        { kErrorJournalDeleteInProgress, "Journal delete in progress" },
        { kErrorJournalNotActive, "Journal not active" },
        { kErrorPotentialFileFound, "Potential file found" },
        { kErrorJournalEntryDeleted, "Journal entry deleted" },
        { kErrorBadDevice, "Bad device" },
        { kErrorConnectionUnavail, "Connection unavail" },
        { kErrorDeviceAlreadyRemembered, "Device already remembered" },
        { kErrorNoNetOrBadPath, "No net or bad path" },
        { kErrorBadProvider, "Bad provider" },
        { kErrorCannotOpenProfile, "Cannot open profile" },
        { kErrorBadProfile, "Bad profile" },
        { kErrorNotContainer, "Not container" },
        { kErrorExtendedError, "Extended error" },
        { kErrorInvalidGroupname, "Invalid group name" },
        { kErrorInvalidComputername, "Invalid computer name" },
        { kErrorInvalidEventname, "Invalid event name" },
        { kErrorInvalidDomainname, "Invalid domain name" },
        { kErrorInvalidServicename, "Invalid service name" },
        { kErrorInvalidNetname, "Invalid net name" },
        { kErrorInvalidSharename, "Invalid share name" },
        { kErrorInvalidPasswordname, "Invalid password name" },
        { kErrorInvalidMessagename, "Invalid message name" },
        { kErrorInvalidMessagedest, "Invalid message dest" },
        { kErrorSessionCredentialConflict, "Session credential conflict" },
        { kErrorRemoteSessionLimitExceeded, "Remote session limit exceeded" },
        { kErrorDupDomainname, "Dup domain name" },
        { kErrorNoNetwork, "No network" },
        { kErrorCancelled, "Cancelled" },
        { kErrorUserMappedFile, "User mapped file" },
        { kErrorConnectionRefused, "Connection refused" },
        { kErrorGracefulDisconnect, "Graceful disconnect" },
        { kErrorAddressAlreadyAssociated, "Address already associated" },
        { kErrorAddressNotAssociated, "Address not associated" },
        { kErrorConnectionInvalid, "Connected invalid" },
        { kErrorConnectionActive, "Connection active" },
        { kErrorNetworkUnreachable, "Network unreachable" },
        { kErrorHostUnreachable, "Host unreachable" },
        { kErrorProtocolUnreachable, "Protocol unreachable" },
        { kErrorPortUnreachable, "Port unreachable" },
        { kErrorRequestAborted, "Request aborted" },
        { kErrorConnectionAborted, "Connection aborted" },
        { kErrorRetry, "Retry" },
        { kErrorConnectionCountLimit, "Connection count limit" },
        { kErrorLoginTimeRestriction, "Login time restriction" },
        { kErrorLoginWkstaRestriction, "Login wksta restriction" },
        { kErrorIncorrectAddress, "Incorrect address" },
        { kErrorAlreadyRegistered, "Already registered" },
        { kErrorServiceNotFound, "Service not found" },
        { kErrorNotAuthenticated, "Not authenticated" },
        { kErrorNotLoggedOn, "Not logged on" },
        { kErrorContinue, "Continue" },
        { kErrorAlreadyInitialized, "Already initialised" },
        { kErrorNoMoreDevices, "No more devices" },
        { kErrorNoSuchSite, "No such site" },
        { kErrorDomainControllerExists, "Domain controller exists" },
        { kErrorOnlyIfConnected, "Only if connected" },
        { kErrorOverrideNochanges, "Override no changes" },
        { kErrorBadUserProfile, "Bad user profile" },
        { kErrorNotSupportedOnSbs, "Not supported on SBS" },
        { kErrorServerShutdownInProgress, "Server shutdown in progress" },
        { kErrorHostDown, "Host down" },
        { kErrorNonAccountSid, "Non account sid" },
        { kErrorNonDomainSid, "Non domain sid" },
        { kErrorApphelpBlock, "Apphelp block" },
        { kErrorAccessDisabledByPolicy, "Access disabled by policy" },
        { kErrorRegNatConsumption, "Reg nat consumption" },
        { kErrorCscshareOffline, "CSC share offline" },
        { kErrorPkinitFailure, "PK init failure" },
        { kErrorSmartcardSubsystemFailure, "Smartcard subsystem failure" },
        { kErrorDowngradeDetected, "Downgrade detected" },
        { kSecESmartcardCertRevoked, "Smartcard cert revoked" },
        { kSecEIssuingCaUntrusted, "Issuing CA untrusted" },
        { kSecERevocationOfflineC, "Revocation offline" },
        { kSecEPkinitClientFailur, "PK init client failure" },
        { kSecESmartcardCertExpired, "Smartcard cert expired" },
        { kErrorMachineLocked, "Machine locked" },
        { kErrorCallbackSuppliedInvalidData, "Callback supplied invalid data" },
        { kErrorSyncForegroundRefreshRequired, "Sync foreground refresh required" },
        { kErrorDriverBlocked, "Driver blocked" },
        { kErrorInvalidImportOfNonDll, "Invalid import of non DLL" },
        { kErrorNotAllAssigned, "Not all assigned" },
        { kErrorSomeNotMapped, "Some not mapped" },
        { kErrorNoQuotasForAccount, "No quotas for account" },
        { kErrorLocalUserSessionKey, "Local user session key" },
        { kErrorNullLmPassword, "Null LM password" },
        { kErrorUnknownRevision, "Unknown revision" },
        { kErrorRevisionMismatch, "Revision mismatch" },
        { kErrorInvalidOwner, "Invalid owner" },
        { kErrorInvalidPrimaryGroup, "Invalid primary group" },
        { kErrorNoImpersonationToken, "No impersonation token" },
        { kErrorCantDisableMandatory, "Can't disable mandatory" },
        { kErrorNoLogonServers, "No logon servers" },
        { kErrorNoSuchLogonSession, "No such logon session" },
        { kErrorNoSuchPrivilege, "No such privilege" },
        { kErrorPrivilegeNotHeld, "Privilege not held" },
        { kErrorInvalidAccountName, "Invalid account name" },
        { kErrorUserExists, "User exists" },
        { kErrorNoSuchUser, "No such user" },
        { kErrorGroupExists, "Group exists" },
        { kErrorNoSuchGroup, "No such group" },
        { kErrorMemberInGroup, "Member in group" },
        { kErrorMemberNotInGroup, "Member not in group" },
        { kErrorLastAdmin, "Last admin" },
        { kErrorWrongPassword, "Wrong password" },
        { kErrorIllFormedPassword, "Ill formed password" },
        { kErrorPasswordRestriction, "Password restriction" },
        { kErrorLogonFailure, "Logon failure" },
        { kErrorAccountRestriction, "Account restriction" },
        { kErrorInvalidLogonHours, "Invalid logon hours" },
        { kErrorInvalidWorkstation, "Invalid workstation" },
        { kErrorPasswordExpired, "Password expired" },
        { kErrorAccountDisabled, "Account disabled" },
        { kErrorNoneMapped, "None mapped" },
        { kErrorTooManyLuidsRequested, "Too many LUIDs requested" },
        { kErrorLuidsExhausted, "LUIDs exhausted" },
        { kErrorInvalidSubAuthority, "Invalid sub authority" },
        { kErrorInvalidAcl, "Invalid ACL" },
        { kErrorInvalidSid, "Invalid SID" },
        { kErrorInvalidSecurityDescr, "Invalid security descr" },
        { kErrorBadInheritanceAcl, "Bad inheritance ACL" },
        { kErrorServerDisabled, "Server disabled" },
        { kErrorServerNotDisabled, "Server not disabled" },
        { kErrorInvalidIdAuthority, "Invalid ID authority" },
        { kErrorAllottedSpaceExceeded, "Allotted space exceeded" },
        { kErrorInvalidGroupAttributes, "Invalid group attributes" },
        { kErrorBadImpersonationLevel, "Bad impersonation level" },
        { kErrorCantOpenAnonymous, "Can't open anonymous" },
        { kErrorBadValidationClass, "Bad validation class" },
        { kErrorBadTokenType, "Bad token type" },
        { kErrorNoSecurityOnObject, "No security on object" },
        { kErrorCantAccessDomainInfo, "Can't access domain info" },
        { kErrorInvalidServerState, "Invalid server state" },
        { kErrorInvalidDomainState, "Invalid domain state" },
        { kErrorInvalidDomainRole, "Invalid domain role" },
        { kErrorNoSuchDomain, "No such domain" },
        { kErrorDomainExists, "Domain exists" },
        { kErrorDomainLimitExceeded, "Domain limit exceeded" },
        { kErrorInternalDbCorruption, "Internal DB corruption" },
        { kErrorInternalError, "Internal error" },
        { kErrorGenericNotMapped, "Generic not mapped" },
        { kErrorBadDescriptorFormat, "Bad descriptor format" },
        { kErrorNotLogonProcess, "Not logon process" },
        { kErrorLogonSessionExists, "Logon session exists" },
        { kErrorNoSuchPackage, "No such package" },
        { kErrorBadLogonSessionState, "Bad logon session state" },
        { kErrorLogonSessionCollision, "Logon session collision" },
        { kErrorInvalidLogonType, "Invalid logon type" },
        { kErrorCannotImpersonate, "Cannot impersonate" },
        { kErrorRxactInvalidState, "Rxact invalid state" },
        { kErrorRxactCommitFailure, "Rxact commit failure" },
        { kErrorSpecialAccount, "Special account" },
        { kErrorSpecialGroup, "Special group" },
        { kErrorSpecialUser, "Special user" },
        { kErrorMembersPrimaryGroup, "Members primary group" },
        { kErrorTokenAlreadyInUse, "Token already in use" },
        { kErrorNoSuchAlias, "No such alias" },
        { kErrorMemberNotInAlias, "Member not in alias" },
        { kErrorMemberInAlias, "Member in alias" },
        { kErrorAliasExists, "Alias exists" },
        { kErrorLogonNotGranted, "Logon not granted" },
        { kErrorTooManySecrets, "Too many secrets" },
        { kErrorSecretTooLong, "Secret too long" },
        { kErrorInternalDbError, "Internal DB error" },
        { kErrorTooManyContextIds, "Too many context IDs" },
        { kErrorLogonTypeNotGranted, "Logon type not granted" },
        { kErrorNtCrossEncryptionRequired, "NT cross encryption required" },
        { kErrorNoSuchMember, "No such member" },
        { kErrorInvalidMember, "Invalid member" },
        { kErrorTooManySids, "Too many SIDs" },
        { kErrorLmCrossEncryptionRequired, "LM cross encryption required" },
        { kErrorNoInheritance, "No inheritance" },
        { kErrorFileCorrupt, "File corrupt" },
        { kErrorDiskCorrupt, "Disk corrupt" },
        { kErrorNoUserSessionKey, "No user session key" },
        { kErrorLicenseQuotaExceeded, "Licence quota exceeded" },
        { kErrorWrongTargetName, "Wrong target name" },
        { kErrorMutualAuthFailed, "Mutual auth failed" },
        { kErrorTimeSkew, "Time skew" },
        { kErrorCurrentDomainNotAllowed, "Current domain not allowed" },
        { kErrorInvalidWindowHandle, "Invalid window handle" },
        { kErrorInvalidMenuHandle, "Invalid menu handle" },
        { kErrorInvalidCursorHandle, "Invalid cursor handle" },
        { kErrorInvalidAccelHandle, "Invalid accel handle" },
        { kErrorInvalidHookHandle, "Invalid hook handle" },
        { kErrorInvalidDwpHandle, "Invalid DWP handle" },
        { kErrorTlwWithWschild, "TLW with wschild" },
        { kErrorCannotFindWndClass, "Cannot find WND class" },
        { kErrorWindowOfOtherThread, "Window of other thread" },
        { kErrorHotkeyAlreadyRegistered, "Hotkey already registered" },
        { kErrorClassAlreadyExists, "Class already exists" },
        { kErrorClassDoesNotExist, "Class does not exist" },
        { kErrorClassHasWindows, "Class has windows" },
        { kErrorInvalidIndex, "Invalid index" },
        { kErrorInvalidIconHandle, "Invalid icon handle" },
        { kErrorPrivateDialogIndex, "Private dialog index" },
        { kErrorListboxIdNotFound, "Listbox ID not found" },
        { kErrorNoWildcardCharacters, "No wildcard characters" },
        { kErrorClipboardNotOpen, "Clipboard not open" },
        { kErrorHotkeyNotRegistered, "Hotkey not registered" },
        { kErrorWindowNotDialog, "Window not dialog" },
        { kErrorControlIdNotFound, "Control ID not found" },
        { kErrorInvalidComboboxMessage, "Invalid combobox message" },
        { kErrorWindowNotCombobox, "Window not combobox" },
        { kErrorInvalidEditHeight, "Invalid edit height" },
        { kErrorDcNotFound, "DC not found" },
        { kErrorInvalidHookFilter, "Invalid hook filter" },
        { kErrorInvalidFilterProc, "Invalid filter proc" },
        { kErrorHookNeedsHmod, "Hook needs HMOD" },
        { kErrorGlobalOnlyHook, "Global only hook" },
        { kErrorJournalHookSet, "Journal hook set" },
        { kErrorHookNotInstalled, "Hook not installed" },
        { kErrorInvalidLbMessage, "Invalid LB message" },
        { kErrorSetcountOnBadLb, "Setcount on bad LB" },
        { kErrorLbWithoutTabstops, "LB without tabstops" },
        { kErrorDestroyObjectOfOtherThread, "Destroy object of other thread" },
        { kErrorChildWindowMenu, "Child window menu" },
        { kErrorNoSystemMenu, "No system menu" },
        { kErrorInvalidMsgboxStyle, "Invalid msgbox style" },
        { kErrorInvalidSpiValue, "Invalid SPI value" },
        { kErrorScreenAlreadyLocked, "Screen already locked" },
        { kErrorHwndsHaveDiffParent, "HWNDs have different parent" },
        { kErrorNotChildWindow, "Not child window" },
        { kErrorInvalidGwCommand, "Invalid GW command" },
        { kErrorInvalidThreadId, "Invalid thread ID" },
        { kErrorNonMdichildWindow, "Non MDI child window" },
        { kErrorPopupAlreadyActive, "Popup already active" },
        { kErrorNoScrollbars, "No scrollbars" },
        { kErrorInvalidScrollbarRange, "Invalid scrollbar range" },
        { kErrorInvalidShowwinCommand, "Invalid showwin command" },
        { kErrorNoSystemResources, "No system resources" },
        { kErrorNonpagedSystemResources, "Nonpaged system resources" },
        { kErrorPagedSystemResources, "Paged system resources" },
        { kErrorWorkingSetQuota, "Working set quota" },
        { kErrorPagefileQuota, "Pagefile quota" },
        { kErrorCommitmentLimit, "Commitment limit" },
        { kErrorMenuItemNotFound, "Menu item not found" },
        { kErrorInvalidKeyboardHandle, "Invalid keyboard handle" },
        { kErrorHookTypeNotAllowed, "Hook type not allowed" },
        { kErrorRequiresInteractiveWindowstation, "Requires interactive windowstation" },
        { kErrorTimeout, "Timeout" },
        { kErrorInvalidMonitorHandle, "Invalid monitor handle" },
        { kErrorEventlogFileCorrupt, "Eventlog file corrupt" },
        { kErrorEventlogCantStart, "Eventlog can't start" },
        { kErrorLogFileFull, "Log file full" },
        { kErrorEventlogFileChanged, "Eventlog file changed" },
        { kErrorInstallServiceFailure, "Install service failure" },
        { kErrorInstallUserexit, "Install userexit" },
        { kErrorInstallFailure, "Install failure" },
        { kErrorInstallSuspend, "Install suspend" },
        { kErrorUnknownProduct, "Unknown product" },
        { kErrorUnknownFeature, "Unknown feature" },
        { kErrorUnknownComponent, "Unknown component" },
        { kErrorUnknownProperty, "Unknown property" },
        { kErrorInvalidHandleState, "Invalid handle state" },
        { kErrorBadConfiguration, "Bad configuration" },
        { kErrorIndexAbsent, "Index absent" },
        { kErrorInstallSourceAbsent, "Install source absent" },
        { kErrorInstallPackageVersion, "Install package version" },
        { kErrorProductUninstalled, "Product uninstalled" },
        { kErrorBadQuerySyntax, "Bad query syntax" },
        { kErrorInvalidField, "Invalid field" },
        { kErrorDeviceRemoved, "Device removed" },
        { kErrorInstallAlreadyRunning, "Install already running" },
        { kErrorInstallPackageOpenFailed, "Install package open failed" },
        { kErrorInstallPackageInvalid, "Install package invalid" },
        { kErrorInstallUiFailure, "Install UI failure" },
        { kErrorInstallLogFailure, "Install log failure" },
        { kErrorInstallLanguageUnsupported, "Install language unsupported" },
        { kErrorInstallTransformFailure, "Install transform failure" },
        { kErrorInstallPackageRejected, "Install package rejected" },
        { kErrorFunctionNotCalled, "Function not called" },
        { kErrorFunctionFailed, "Function failed" },
        { kErrorInvalidTable, "Invalid table" },
        { kErrorDatatypeMismatch, "Datatype mismatch" },
        { kErrorUnsupportedType, "Unsupported type" },
        { kErrorCreateFailed, "Create failed" },
        { kErrorInstallTempUnwritable, "Install temp unwritable" },
        { kErrorInstallPlatformUnsupported, "Install platform unsupported" },
        { kErrorInstallNotused, "Install notused" },
        { kErrorPatchPackageOpenFailed, "Patch package open failed" },
        { kErrorPatchPackageInvalid, "Patch package invalid" },
        { kErrorPatchPackageUnsupported, "Patch package unsupported" },
        { kErrorProductVersion, "Product version" },
        { kErrorInvalidCommandLine, "Invalid command line" },
        { kErrorInstallRemoteDisallowed, "Install remote disallowed" },
        { kErrorSuccessRebootInitiated, "Success reboot initiated" },
        { kErrorPatchTargetNotFound, "Patch target not found" },
        { kErrorPatchPackageRejected, "Patch package rejected" },
        { kErrorInstallTransformRejected, "Install transform rejected" },
        { kRpcSInvalidStringBinding, "RPC S Invalid string binding" },
        { kRpcSWrongKindOfBinding, "RPC S Wrong kind of binding" },
        { kRpcSInvalidBinding, "RPC S Invalid binding" },
        { kRpcSProtseqNotSupported, "RPC S Protseq not supported" },
        { kRpcSInvalidRpcProtseq, "RPC S Invalid RPC protseq" },
        { kRpcSInvalidStringUuid, "RPC S Invalid string UUID" },
        { kRpcSInvalidEndpointFormat, "RPC S Invalid endpoint format" },
        { kRpcSInvalidNetAddr, "RPC S Invalid net addr" },
        { kRpcSNoEndpointFound, "RPC S No endpoint found" },
        { kRpcSInvalidTimeout, "RPC S Invalid timeout" },
        { kRpcSObjectNotFound, "RPC S Object not found" },
        { kRpcSAlreadyRegistered, "RPC S Already registered" },
        { kRpcSTypeAlreadyRegistered, "RPC S Type already registered" },
        { kRpcSAlreadyListening, "RPC S Already listening" },
        { kRpcSNoProtseqsRegistered, "RPC S Not protseqs registered" },
        { kRpcSNotListening, "RPC S Not listening" },
        { kRpcSUnknownMgrType, "RPC S Unknown mgr type" },
        { kRpcSUnknownIf, "RPC S Unknown IF" },
        { kRpcSNoBindings, "RPC S No bindings" },
        { kRpcSNoProtseqs, "RPC S Not protseqs" },
        { kRpcSCantCreateEndpoint, "RPC S Can't create endpoint" },
        { kRpcSOutOfResources, "RPC S Out of resources" },
        { kRpcSServerUnavailable, "RPC S Server unavailable" },
        { kRpcSServerTooBusy, "RPC S Server too busy" },
        { kRpcSInvalidNetworkOptions, "RPC S Invalid network options" },
        { kRpcSNoCallActive, "RPC S No call active" },
        { kRpcSCallFailed, "RPC S Call failed" },
        { kRpcSCallFailedDne, "RPC S Call failed DNE" },
        { kRpcSProtocolError, "RPC S Protocol error" },
        { kRpcSUnsupportedTransSyn, "RPC S Unsupported trans syn" },
        { kRpcSUnsupportedType, "RPC S Unsupported type" },
        { kRpcSInvalidTag, "RPC S Invalid tag" },
        { kRpcSInvalidBound, "RPC S Invalid bound" },
        { kRpcSNoEntryName, "RPC S No entry name" },
        { kRpcSInvalidNameSyntax, "RPC S Invalid name syntax" },
        { kRpcSUnsupportedNameSyntax, "RPC S Unsupported name syntax" },
        { kRpcSUuidNoAddress, "RPC S UUID no address" },
        { kRpcSDuplicateEndpoint, "RPC S Duplicate endpoint" },
        { kRpcSUnknownAuthnType, "RPC S Unknown authn type" },
        { kRpcSMaxCallsTooSmall, "RPC S Max calls too small" },
        { kRpcSStringTooLong, "RPC S String too long" },
        { kRpcSProtseqNotFound, "RPC S Protseq not found" },
        { kRpcSProcnumOutOfRange, "RPC S Procnum out of range" },
        { kRpcSBindingHasNoAuth, "RPC S Binding has no auth" },
        { kRpcSUnknownAuthnService, "RPC S Unknown authn service" },
        { kRpcSUnknownAuthnLevel, "RPC S Unknown authn level" },
        { kRpcSInvalidAuthIdentity, "RPC S Invalid auth identity" },
        { kRpcSUnknownAuthzService, "RPC S Unknown authz service" },
        { kEptSInvalidEntry, "EPT S Invalid entry" },
        { kEptSCantPerformOp, "EPT S Can't perform op" },
        { kEptSNotRegistered, "EPT S Not registered" },
        { kRpcSNothingToExport, "RPC S Nothing to export" },
        { kRpcSIncompleteName, "RPC S Incomplete name" },
        { kRpcSInvalidVersOption, "RPC S Invalid vers option" },
        { kRpcSNoMoreMembers, "RPC S No more members" },
        { kRpcSNotAllObjsUnexported, "RPC S Not all objs unexported" },
        { kRpcSInterfaceNotFound, "RPC S Interface not found" },
        { kRpcSEntryAlreadyExists, "RPC S Entry already exists" },
        { kRpcSEntryNotFound, "RPC S Entry not found" },
        { kRpcSNameServiceUnavailable, "RPC S Name service unavailable" },
        { kRpcSInvalidNafId, "RPC S Invalid naf ID" },
        { kRpcSCannotSupport, "RPC S Cannot support" },
        { kRpcSNoContextAvailable, "RPC S No context available" },
        { kRpcSInternalError, "RPC S Internal error" },
        { kRpcSZeroDivide, "RPC S Zero divide" },
        { kRpcSAddressError, "RPC S Address error" },
        { kRpcSFpDivZero, "RPC S FP div zero" },
        { kRpcSFpUnderflow, "RPC S FP Underflow" },
        { kRpcSFpOverflow, "RPC S Overflow" },
        { kRpcXNoMoreEntries, "RPC X No more entries" },
        { kRpcXSsCharTransOpenFail, "RPC X SS char trans open fail" },
        { kRpcXSsCharTransShortFile, "RPC X SS char trans short file" },
        { kRpcXSsInNullContext, "RPC S SS in null context" },
        { kRpcXSsContextDamaged, "RPC X SS context damaged" },
        { kRpcXSsHandlesMismatch, "RPC X SS handles mismatch" },
        { kRpcXSsCannotGetCallHandle, "RPC X SS cannot get call handle" },
        { kRpcXNullRefPointer, "RPC X Null ref pointer" },
        { kRpcXEnumValueOutOfRange, "RPC X enum value out of range" },
        { kRpcXByteCountTooSmall, "RPC X byte count too small" },
        { kRpcXBadStubData, "RPC X bad stub data" },
        { kErrorInvalidUserBuffer, "Invalid user buffer" },
        { kErrorUnrecognizedMedia, "Unrecognised media" },
        { kErrorNoTrustLsaSecret, "No trust lsa secret" },
        { kErrorNoTrustSamAccount, "No trust sam account" },
        { kErrorTrustedDomainFailure, "Trusted domain failure" },
        { kErrorTrustedRelationshipFailure, "Trusted relationship failure" },
        { kErrorTrustFailure, "Trust failure" },
        { kRpcSCallInProgress, "RPC S call in progress" },
        { kErrorNetlogonNotStarted, "Error netlogon not started" },
        { kErrorAccountExpired, "Account expired" },
        { kErrorRedirectorHasOpenHandles, "Redirector has open handles" },
        { kErrorPrinterDriverAlreadyInstalled, "Printer driver already installed" },
        { kErrorUnknownPort, "Unknown port" },
        { kErrorUnknownPrinterDriver, "Unknown printer driver" },
        { kErrorUnknownPrintprocessor, "Unknown printprocessor" },
        { kErrorInvalidSeparatorFile, "Invalid separator file" },
        { kErrorInvalidPriority, "Invalid priority" },
        { kErrorInvalidPrinterName, "Invalid printer name" },
        { kErrorPrinterAlreadyExists, "Printer already exists" },
        { kErrorInvalidPrinterCommand, "Invalid printer command" },
        { kErrorInvalidDatatype, "Invalid datatype" },
        { kErrorInvalidEnvironment, "Invalid environment" },
        { kRpcSNoMoreBindings, "RPC S no more bindings" },
        { kErrorNologonInterdomainTrustAccount, "Nologon interdomain trust account" },
        { kErrorNologonWorkstationTrustAccount, "Nologon workstation trust account" },
        { kErrorNologonServerTrustAccount, "Nologon server trust account" },
        { kErrorDomainTrustInconsistent, "Domain trust inconsistent" },
        { kErrorServerHasOpenHandles, "Server has open handles" },
        { kErrorResourceDataNotFound, "Resource data not found" },
        { kErrorResourceTypeNotFound, "Resource type not found" },
        { kErrorResourceNameNotFound, "Resource name not found" },
        { kErrorResourceLangNotFound, "Resource lang not found" },
        { kErrorNotEnoughQuota, "Not enough quota" },
        { kRpcSNoInterfaces, "RPC S no interfaces" },
        { kRpcSCallCancelled, "RPC S Call cancelled" },
        { kRpcSBindingIncomplete, "RPC S Binding incomplete" },
        { kRpcSCommFailure, "RPC S Comm failure" },
        { kRpcSUnsupportedAuthnLevel, "RPC S Unsupported authn level" },
        { kRpcSNoPrincName, "RPC S No princ name" },
        { kRpcSNotRpcError, "RPC S Not RPC error" },
        { kRpcSUuidLocalOnly, "RPC U UUID local only" },
        { kRpcSSecPkgError, "RPC S Sec pkg error" },
        { kRpcSNotCancelled, "RPC S Not cancelled" },
        { kRpcXInvalidEsAction, "RPC X Invalid ES action" },
        { kRpcXWrongEsVersion, "RPC X Wrong ES version" },
        { kRpcXWrongStubVersion, "RPC X Wrong stub version" },
        { kRpcXInvalidPipeObject, "RPC X Invalid pipe object" },
        { kRpcXWrongPipeOrder, "RPC X Wrong pipe order" },
        { kRpcXWrongPipeVersion, "RPC X Wrong pipe version" },
        { kRpcSGroupMemberNotFound, "RPC S group member not found" },
        { kEptSCantCreate, "EPT S Can't create" },
        { kRpcSInvalidObject, "RPC S Invalid object" },
        { kErrorInvalidTime, "Invalid time" },
        { kErrorInvalidFormName, "Invalid form name" },
        { kErrorInvalidFormSize, "Invalid form size" },
        { kErrorAlreadyWaiting, "Already waiting" },
        { kErrorPrinterDeleted, "Printer deleted" },
        { kErrorInvalidPrinterState, "Invalid printer state" },
        { kErrorPasswordMustChange, "Password must change" },
        { kErrorDomainControllerNotFound, "Domain controller not found" },
        { kErrorAccountLockedOut, "Account locked out" },
        { kOrInvalidOxid, "OR Invalid OXID" },
        { kOrInvalidOid, "OR Invalid OID" },
        { kOrInvalidSet, "OR Invalid set" },
        { kRpcSSendIncomplete, "RPC S Send incomplete" },
        { kRpcSInvalidAsyncHandle, "RPC S Invalid async handle" },
        { kRpcSInvalidAsyncCall, "RPC S Invalid async call" },
        { kRpcXPipeClosed, "RPC X Pipe closed" },
        { kRpcXPipeDisciplineError, "RPC X Pipe discipline error" },
        { kRpcXPipeEmpty, "RPC X Pipe empty" },
        { kErrorNoSitename, "No sitename" },
        { kErrorCantAccessFile, "Can't access file" },
        { kErrorCantResolveFilename, "Can't resolve filename" },
        { kRpcSEntryTypeMismatch, "RPC S Entry type mismatch" },
        { kRpcSNotAllObjsExported, "RPC S Not all objs exported" },
        { kRpcSInterfaceNotExported, "RPC S Interface not exported" },
        { kRpcSProfileNotAdded, "RPC S Profile not added" },
        { kRpcSPrfEltNotAdded, "RPC S PRF ELT not added" },
        { kRpcSPrfEltNotRemoved, "RPC S PRF ELT not removed" },
        { kRpcSGrpEltNotAdded, "RPC S GRP ELT not added" },
        { kRpcSGrpEltNotRemoved, "RPC S GRP ELT not removed" },
        { kErrorKmDriverBlocked, "KM driver blocked" },
        { kErrorContextExpired, "Context expired" },
        { kErrorInvalidPixelFormat, "Invalid pixel format" },
        { kErrorBadDriver, "Bad driver" },
        { kErrorInvalidWindowStyle, "Invalid window style" },
        { kErrorMetafileNotSupported, "Metafile not supported" },
        { kErrorTransformNotSupported, "Transform not supported" },
        { kErrorClippingNotSupported, "Clipping not supported" },
        { kErrorInvalidCmm, "Invalid CMM" },
        { kErrorInvalidProfile, "Invalid profile" },
        { kErrorTagNotFound, "Tag not found" },
        { kErrorTagNotPresent, "Tag not present" },
        { kErrorDuplicateTag, "Duplicate tag" },
        { kErrorProfileNotAssociatedWithDevice, "Profile not associated with device" },
        { kErrorProfileNotFound, "Profile not found" },
        { kErrorInvalidColorspace, "Invalid colorspace" },
        { kErrorIcmNotEnabled, "ICM not enabled" },
        { kErrorDeletingIcmXform, "Deleting ICM xform" },
        { kErrorInvalidTransform, "Invalid transform" },
        { kErrorColorspaceMismatch, "Colorspace mismatch" },
        { kErrorInvalidColorindex, "Invalid colorindex" },
        { kErrorConnectedOtherPassword, "Connected other password" },
        { kErrorConnectedOtherPasswordDefault, "Connected other password default" },
        { kErrorBadUsername, "Bad username" },
        { kErrorNotConnected, "Not connected" },
        { kErrorOpenFiles, "Open files" },
        { kErrorActiveConnections, "Active connections" },
        { kErrorDeviceInUse, "Device in use" },
        { kErrorUnknownPrintMonitor, "Unknown print monitor" },
        { kErrorPrinterDriverInUse, "Printer driver in use" },
        { kErrorSpoolFileNotFound, "Spool file not found" },
        { kErrorSplNoStartdoc, "SPL no startdoc" },
        { kErrorSplNoAddjob, "SPL no addjob" },
        { kErrorPrintProcessorAlreadyInstalled, "Print processor already installed" },
        { kErrorPrintMonitorAlreadyInstalled, "Print monitor already installed" },
        { kErrorInvalidPrintMonitor, "Invalid print monitor" },
        { kErrorPrintMonitorInUse, "Print monitor in use" },
        { kErrorPrinterHasJobsQueued, "Printer has jobs queued" },
        { kErrorSuccessRebootRequired, "Success reboot required" },
        { kErrorSuccessRestartRequired, "Success restart required" },
        { kErrorPrinterNotFound, "Printer not found" },
        { kErrorPrinterDriverWarned, "Printer driver warned" },
        { kErrorPrinterDriverBlocked, "Printer driver blocked" },
        { kErrorWinsInternal, "Wins internal" },
        { kErrorCanNotDelLocalWins, "Can not del local wins" },
        { kErrorStaticInit, "Static init" },
        { kErrorIncBackup, "Inc backup" },
        { kErrorFullBackup, "Full backup" },
        { kErrorRecNonExistent, "Rec not existent" },
        { kErrorRplNotAllowed, "RPL not allowed" },
        { kErrorDhcpAddressConflict, "DHCP address conflict" },
        { kErrorWmiGuidNotFound, "WMU GUID not found" },
        { kErrorWmiInstanceNotFound, "WMI instance not found" },
        { kErrorWmiItemidNotFound, "WMI ItemID not found" },
        { kErrorWmiTryAgain, "WMI try again" },
        { kErrorWmiDpNotFound, "WMI DP not found" },
        { kErrorWmiUnresolvedInstanceRef, "WMI unresolved instance ref" },
        { kErrorWmiAlreadyEnabled, "WMU already enabled" },
        { kErrorWmiGuidDisconnected, "WMU GUID disconnected" },
        { kErrorWmiServerUnavailable, "WMI server unavailable" },
        { kErrorWmiDpFailed, "WMI DP failed" },
        { kErrorWmiInvalidMof, "WMI invalid MOF" },
        { kErrorWmiInvalidReginfo, "WMI invalid reginfo" },
        { kErrorWmiAlreadyDisabled, "WMI already disabled" },
        { kErrorWmiReadOnly, "WMI read only" },
        { kErrorWmiSetFailure, "WMI set failure" },
        { kErrorInvalidMedia, "Invalid media" },
        { kErrorInvalidLibrary, "Invalid library" },
        { kErrorInvalidMediaPool, "Invalid media pool" },
        { kErrorDriveMediaMismatch, "Drive media mismatch" },
        { kErrorMediaOffline, "Media offline" },
        { kErrorLibraryOffline, "Library offline" },
        { kErrorEmpty, "Empty" },
        { kErrorNotEmpty, "Not empty" },
        { kErrorMediaUnavailable, "Media unavailable" },
        { kErrorResourceDisabled, "Resource disabled" },
        { kErrorInvalidCleaner, "Invalid cleaner" },
        { kErrorUnableToClean, "Unable to clean" },
        { kErrorObjectNotFound, "Object not found" },
        { kErrorDatabaseFailure, "Database failure" },
        { kErrorDatabaseFull, "Database full" },
        { kErrorMediaIncompatible, "Media incompatible" },
        { kErrorResourceNotPresent, "Resource not present" },
        { kErrorInvalidOperation, "Invalid operation" },
        { kErrorMediaNotAvailable, "Media not available" },
        { kErrorDeviceNotAvailable, "Device not available" },
        { kErrorRequestRefused, "Request refused" },
        { kErrorInvalidDriveObject, "Invalid drive object" },
        { kErrorLibraryFull, "Library full" },
        { kErrorMediumNotAccessible, "Medium not accessible" },
        { kErrorUnableToLoadMedium, "Unable to load medium" },
        { kErrorUnableToInventoryDrive, "Unable to inventory drive" },
        { kErrorUnableToInventorySlot, "Unable to inventory slot" },
        { kErrorUnableToInventoryTransport, "Unable to inventory transport" },
        { kErrorTransportFull, "Transport full" },
        { kErrorControllingIeport, "Controlling ieport" },
        { kErrorUnableToEjectMountedMedia, "Unable to eject mounted media" },
        { kErrorCleanerSlotSet, "Cleaner slot set" },
        { kErrorCleanerSlotNotSet, "Cleaner slot not set" },
        { kErrorCleanerCartridgeSpent, "Cleaner cartridge spent" },
        { kErrorUnexpectedOmid, "Unexpected omid" },
        { kErrorCantDeleteLastItem, "Can't delete last item" },
        { kErrorMessageExceedsMaxSize, "Message exceeds max size" },
        { kErrorVolumeContainsSysFiles, "Volume contains sys files" },
        { kErrorIndigenousType, "Indigenous type" },
        { kErrorNoSupportingDrives, "No supporting drives" },
        { kErrorCleanerCartridgeInstalled, "Cleaner cartridge installed" },
        { kErrorFileOffline, "Fill offline" },
        { kErrorRemoteStorageNotActive, "Remote storage not active" },
        { kErrorRemoteStorageMediaError, "Remote storage media error" },
        { kErrorNotAReparsePoint, "Not a reparse point" },
        { kErrorReparseAttributeConflict, "Reparse attribute conflict" },
        { kErrorInvalidReparseData, "Invalid reparse data" },
        { kErrorReparseTagInvalid, "Reparse tag invalid" },
        { kErrorReparseTagMismatch, "Reparse tag mismatch" },
        { kErrorVolumeNotSisEnabled, "Volume not sis enabled" },
        { kErrorDependentResourceExists, "Dependent resource exists" },
        { kErrorDependencyNotFound, "Dependency not found" },
        { kErrorDependencyAlreadyExists, "Dependency already exists" },
        { kErrorResourceNotOnline, "Resource not online" },
        { kErrorHostNodeNotAvailable, "Host node not available" },
        { kErrorResourceNotAvailable, "Resource not available" },
        { kErrorResourceNotFound, "Resource not found" },
        { kErrorShutdownCluster, "Shutdown cluster" },
        { kErrorCantEvictActiveNode, "Can't evict active node" },
        { kErrorObjectAlreadyExists, "Object already exists" },
        { kErrorObjectInList, "Object in list" },
        { kErrorGroupNotAvailable, "Group not available" },
        { kErrorGroupNotFound, "Group not found" },
        { kErrorGroupNotOnline, "Group not online" },
        { kErrorHostNodeNotResourceOwner, "Host node not resource owner" },
        { kErrorHostNodeNotGroupOwner, "Host node not group owner" },
        { kErrorResmonCreateFailed, "Resmon create failed" },
        { kErrorResmonOnlineFailed, "Resmon online failed" },
        { kErrorResourceOnline, "Resource online" },
        { kErrorQuorumResource, "Quorum resource" },
        { kErrorNotQuorumCapable, "Not quorum capable" },
        { kErrorClusterShuttingDown, "Cluster shutting down" },
        { kErrorInvalidState, "Invalid state" },
        { kErrorResourcePropertiesStored, "Resource properties stored" },
        { kErrorNotQuorumClass, "Not quorum class" },
        { kErrorCoreResource, "Core resource" },
        { kErrorQuorumResourceOnlineFailed, "Quorum resource online failed" },
        { kErrorQuorumlogOpenFailed, "Quorumlog open failed" },
        { kErrorClusterlogCorrupt, "Clusterlog corrupt" },
        { kErrorClusterlogRecordExceedsMaxsize, "Clusterlog record exceeds maxsize" },
        { kErrorClusterlogExceedsMaxsize, "Clusterlog exceeds maxsize" },
        { kErrorClusterlogChkpointNotFound, "Clusterlog chkpoint not found" },
        { kErrorClusterlogNotEnoughSpace, "Clusterlog not enough space" },
        { kErrorQuorumOwnerAlive, "Quorum owner alive" },
        { kErrorNetworkNotAvailable, "Network not available" },
        { kErrorNodeNotAvailable, "Node not available" },
        { kErrorAllNodesNotAvailable, "All nodes not available" },
        { kErrorResourceFailed, "Resource failed" },
        { kErrorClusterInvalidNode, "Cluster invalid node" },
        { kErrorClusterNodeExists, "Cluster node exists" },
        { kErrorClusterJoinInProgress, "Cluster join in progress" },
        { kErrorClusterNodeNotFound, "Cluster node not found" },
        { kErrorClusterLocalNodeNotFound, "Cluster local node not found" },
        { kErrorClusterNetworkExists, "Cluster network exists" },
        { kErrorClusterNetworkNotFound, "Cluster network not found" },
        { kErrorClusterNetinterfaceExists, "Cluster netinterface exists" },
        { kErrorClusterNetinterfaceNotFound, "Cluster netinterface not found" },
        { kErrorClusterInvalidRequest, "Cluster invalid request" },
        { kErrorClusterInvalidNetworkProvider, "Cluster invalid network provider" },
        { kErrorClusterNodeDown, "Cluster node down" },
        { kErrorClusterNodeUnreachable, "Cluster node unreachable" },
        { kErrorClusterNodeNotMember, "Cluster node not member" },
        { kErrorClusterJoinNotInProgress, "Cluster join not in progress" },
        { kErrorClusterInvalidNetwork, "Cluster invalid network" },
        { kErrorClusterNodeUp, "Cluster node up" },
        { kErrorClusterIpaddrInUse, "Cluster ipaddr in use" },
        { kErrorClusterNodeNotPaused, "Cluster node not paused" },
        { kErrorClusterNoSecurityContext, "Cluster no security context" },
        { kErrorClusterNetworkNotInternal, "Cluster network not internal" },
        { kErrorClusterNodeAlreadyUp, "Cluster node already up" },
        { kErrorClusterNodeAlreadyDown, "Cluster node already down" },
        { kErrorClusterNetworkAlreadyOnline, "Cluster network already online" },
        { kErrorClusterNetworkAlreadyOffline, "Cluster network already offline" },
        { kErrorClusterNodeAlreadyMember, "Cluster node already member" },
        { kErrorClusterLastInternalNetwork, "Cluster last internal network" },
        { kErrorClusterNetworkHasDependents, "Cluster network has dependents" },
        { kErrorInvalidOperationOnQuorum, "Invalid operation on quorum" },
        { kErrorDependencyNotAllowed, "Dependency not allowed" },
        { kErrorClusterNodePaused, "Cluster node paused" },
        { kErrorNodeCantHostResource, "Node can't host resource" },
        { kErrorClusterNodeNotReady, "Cluster node not ready" },
        { kErrorClusterNodeShuttingDown, "Cluster node shutting down" },
        { kErrorClusterJoinAborted, "Cluster join aborted" },
        { kErrorClusterIncompatibleVersions, "Cluster incompatible versions" },
        { kErrorClusterMaxnumOfResourcesExceeded, "Cluster maxnum of resources exceeded" },
        { kErrorClusterSystemConfigChanged, "Cluster system config changed" },
        { kErrorClusterResourceTypeNotFound, "Cluster resource type not found" },
        { kErrorClusterRestypeNotSupported, "Cluster restype not supported" },
        { kErrorClusterResnameNotFound, "Cluster resname not found" },
        { kErrorClusterNoRpcPackagesRegistered, "Cluster no RPC packages registered" },
        { kErrorClusterOwnerNotInPreflist, "Cluster owner not in preflist" },
        { kErrorClusterDatabaseSeqmismatch, "Cluster database seqmismatch" },
        { kErrorResmonInvalidState, "Resmon invalid state" },
        { kErrorClusterGumNotLocker, "Cluster gum not locker" },
        { kErrorQuorumDiskNotFound, "Quorum disk not found" },
        { kErrorDatabaseBackupCorrupt, "Database backup corrupt" },
        { kErrorClusterNodeAlreadyHasDfsRoot, "Cluster node already has DFS root" },
        { kErrorResourcePropertyUnchangeable, "Resource property unchangeable" },
        { kErrorClusterMembershipInvalidState, "Cluster membership invalid state" },
        { kErrorClusterQuorumlogNotFound, "Cluster quorumlog not found" },
        { kErrorClusterMembershipHalt, "Cluster membership halt" },
        { kErrorClusterInstanceIdMismatch, "Cluster instance ID mismatch" },
        { kErrorClusterNetworkNotFoundForIp, "Cluster network not found for IP" },
        { kErrorClusterPropertyDataTypeMismatch, "Cluster property data type mismatch" },
        { kErrorClusterEvictWithoutCleanup, "Cluster evict without cleanup" },
        { kErrorClusterParameterMismatch, "Cluster parameter mismatch" },
        { kErrorNodeCannotBeClustered, "Node cannot be clustered" },
        { kErrorClusterWrongOsVersion, "Cluster wrong OS version" },
        { kErrorClusterCantCreateDupClusterName, "Cluster can't create dup cluster name" },
        { kErrorDecryptionFailed, "Decryption failed" },
        { kErrorFileEncrypted, "File encrypted" },
        { kErrorNoRecoveryPolicy, "No recovery policy" },
        { kErrorNoEfs, "No EFS" },
        { kErrorWrongEfs, "Wrong EFS" },
        { kErrorNoUserKeys, "No user keys" },
        { kErrorFileNotEncrypted, "File not encryped" },
        { kErrorNotExportFormat, "Not export format" },
        { kErrorFileReadOnly, "File read only" },
        { kErrorDirEfsDisallowed, "Dir EFS disallowed" },
        { kErrorEfsServerNotTrusted, "EFS server not trusted" },
        { kErrorBadRecoveryPolicy, "Bad recovery policy" },
        { kErrorEfsAlgBlobTooBig, "ETS alg blob too big" },
        { kErrorVolumeNotSupportEfs, "Volume not support EFS" },
        { kErrorEfsDisabled, "EFS disabled" },
        { kErrorEfsVersionNotSupport, "EFS version not support" },
        { kErrorNoBrowserServersFound, "No browser servers found" },
        { kSchedEServiceNotLocalsystem, "Sched E service not localsystem" },
        { kErrorCtxWinstationNameInvalid, "Ctx winstation name invalid" },
        { kErrorCtxInvalidPd, "Ctx invalid PD" },
        { kErrorCtxPdNotFound, "Ctx PD not found" },
        { kErrorCtxWdNotFound, "Ctx WD not found" },
        { kErrorCtxCannotMakeEventlogEntry, "Ctx cannot make eventlog entry" },
        { kErrorCtxServiceNameCollision, "Ctx service name collision" },
        { kErrorCtxClosePending, "Ctx close pending" },
        { kErrorCtxNoOutbuf, "Ctx no outbuf" },
        { kErrorCtxModemInfNotFound, "Ctx modem inf not found" },
        { kErrorCtxInvalidModemname, "Ctx invalid modemname" },
        { kErrorCtxModemResponseError, "Ctx modem response error" },
        { kErrorCtxModemResponseTimeout, "Ctx modem response timeout" },
        { kErrorCtxModemResponseNoCarrier, "Ctx modem response no carrier" },
        { kErrorCtxModemResponseNoDialtone, "Ctx modem response no dial tone" },
        { kErrorCtxModemResponseBusy, "Ctx modem response busy" },
        { kErrorCtxModemResponseVoice, "Ctx modem response voice" },
        { kErrorCtxTdError, "Ctx TD error" },
        { kErrorCtxWinstationNotFound, "Ctx winstation not found" },
        { kErrorCtxWinstationAlreadyExists, "Ctx winstation already exists" },
        { kErrorCtxWinstationBusy, "Ctx winstation busy" },
        { kErrorCtxBadVideoMode, "Ctx bad video mode" },
        { kErrorCtxGraphicsInvalid, "Ctx graphics invalid" },
        { kErrorCtxLogonDisabled, "Ctx logon disabled" },
        { kErrorCtxNotConsole, "Ctx not console" },
        { kErrorCtxClientQueryTimeout, "Ctx client query timeout" },
        { kErrorCtxConsoleDisconnect, "Ctx console disconnect" },
        { kErrorCtxConsoleConnect, "Ctx console connect" },
        { kErrorCtxShadowDenied, "Ctx shadow denied" },
        { kErrorCtxWinstationAccessDenied, "Ctx winstation access denied" },
        { kErrorCtxInvalidWd, "Ctx invalid WD" },
        { kErrorCtxShadowInvalid, "Ctx shadow invalid" },
        { kErrorCtxShadowDisabled, "Ctx shadow disabled" },
        { kErrorCtxClientLicenseInUse, "Ctx client licence in use" },
        { kErrorCtxClientLicenseNotSet, "Ctx client licence not set" },
        { kErrorCtxLicenseNotAvailable, "Ctx licence not available" },
        { kErrorCtxLicenseClientInvalid, "Ctx licence client invalid" },
        { kErrorCtxLicenseExpired, "Ctx licence expired" },
        { kErrorCtxShadowNotRunning, "Ctx shadow not running" },
        { kErrorCtxShadowEndedByModeChange, "Ctx shadow ended by mode change" },
        { kFrsErrInvalidApiSequence, "FRS err invalid API sequence" },
        { kFrsErrStartingService, "FRS err starting service" },
        { kFrsErrStoppingService, "FRS err stopping service" },
        { kFrsErrInternalApi, "FRS err internal API" },
        { kFrsErrInternal, "FRS err internal" },
        { kFrsErrServiceComm, "FRS err service comm" },
        { kFrsErrInsufficientPriv, "FRS err insufficient priv" },
        { kFrsErrAuthentication, "FRS err authentication" },
        { kFrsErrParentInsufficientPriv, "FRS err parent insufficient priv" },
        { kFrsErrParentAuthentication, "FRS err parent authentication" },
        { kFrsErrChildToParentComm, "FRS err child to parent comm" },
        { kFrsErrParentToChildComm, "FRS err parent to child comm" },
        { kFrsErrSysvolPopulate, "FRS err sysvol populate" },
        { kFrsErrSysvolPopulateTimeout, "FRS err sysvol populate timeout" },
        { kFrsErrSysvolIsBusy, "FRS err sysvol is busy" },
        { kFrsErrSysvolDemote, "FRS err sysvol demote" },
        { kFrsErrInvalidServiceParameter, "FRS err invalid service parameter" },
        { kErrorDsNotInstalled, "DS not installed" },
        { kErrorDsMembershipEvaluatedLocally, "DS membership evaluated locally" },
        { kErrorDsNoAttributeOrValue, "DS no attribute or value" },
        { kErrorDsInvalidAttributeSyntax, "DS invalid attribute syntax" },
        { kErrorDsAttributeTypeUndefined, "DS attribute type undefined" },
        { kErrorDsAttributeOrValueExists, "DS attribute or value exists" },
        { kErrorDsBusy, "DS busy" },
        { kErrorDsUnavailable, "DS unavailable" },
        { kErrorDsNoRidsAllocated, "DS no rids allocated" },
        { kErrorDsNoMoreRids, "DS no more rids" },
        { kErrorDsIncorrectRoleOwner, "DS incorrect role owner" },
        { kErrorDsRidmgrInitError, "DS ridmgr init error" },
        { kErrorDsObjClassViolation, "DS obj class violation" },
        { kErrorDsCantOnNonLeaf, "DS can't on non leaf" },
        { kErrorDsCantOnRdn, "DS can't on rnd" },
        { kErrorDsCantModObjClass, "DS can't mod obj class" },
        { kErrorDsCrossDomMoveError, "DS cross dom move error" },
        { kErrorDsGcNotAvailable, "DS GC not available" },
        { kErrorSharedPolicy, "Shared policy" },
        { kErrorPolicyObjectNotFound, "Policy object not found" },
        { kErrorPolicyOnlyInDs, "Policy only in DS" },
        { kErrorPromotionActive, "Promotion active" },
        { kErrorNoPromotionActive, "No promotion active" },
        { kErrorDsOperationsError, "DS operations error" },
        { kErrorDsProtocolError, "DS protocol error" },
        { kErrorDsTimelimitExceeded, "DS timelimit exceeded" },
        { kErrorDsSizelimitExceeded, "DS sizelimit exceeded" },
        { kErrorDsAdminLimitExceeded, "DS admin limit exceeded" },
        { kErrorDsCompareFalse, "DS compare false" },
        { kErrorDsCompareTrue, "DS compare true" },
        { kErrorDsAuthMethodNotSupported, "DS auth method not supported" },
        { kErrorDsStrongAuthRequired, "DS strong auth required" },
        { kErrorDsInappropriateAuth, "DS inappropriate auth" },
        { kErrorDsAuthUnknown, "DS auth unknown" },
        { kErrorDsReferral, "DS referral" },
        { kErrorDsUnavailableCritExtension, "DS unavailable crit extension" },
        { kErrorDsConfidentialityRequired, "DS confidentiality required" },
        { kErrorDsInappropriateMatching, "DS inappropriate matching" },
        { kErrorDsConstraintViolation, "DS constraint violation" },
        { kErrorDsNoSuchObject, "DS no such object" },
        { kErrorDsAliasProblem, "DS alias problem" },
        { kErrorDsInvalidDnSyntax, "DS invalid dn syntax" },
        { kErrorDsIsLeaf, "DS is leaf" },
        { kErrorDsAliasDerefProblem, "DS alias deref problem" },
        { kErrorDsUnwillingToPerform, "DS unwilling to perform" },
        { kErrorDsLoopDetect, "DS loop detect" },
        { kErrorDsNamingViolation, "DS naming violation" },
        { kErrorDsObjectResultsTooLarge, "DS object results too large" },
        { kErrorDsAffectsMultipleDsas, "DS affects multiple dsas" },
        { kErrorDsServerDown, "DS server down" },
        { kErrorDsLocalError, "DS local error" },
        { kErrorDsEncodingError, "DS encoding error" },
        { kErrorDsDecodingError, "DS decoding error" },
        { kErrorDsFilterUnknown, "DS filter unknown" },
        { kErrorDsParamError, "DS param error" },
        { kErrorDsNotSupported, "DS not supported" },
        { kErrorDsNoResultsReturned, "DS no results returned" },
        { kErrorDsControlNotFound, "DS control not found" },
        { kErrorDsClientLoop, "DS client loop" },
        { kErrorDsReferralLimitExceeded, "DS referral limit exceeded" },
        { kErrorDsSortControlMissing, "DS sort control missing" },
        { kErrorDsOffsetRangeError, "DS offset range error" },
        { kErrorDsRootMustBeNc, "DS root must be nc" },
        { kErrorDsAddReplicaInhibited, "DS and replica inhibited" },
        { kErrorDsAttNotDefInSchema, "DS att not def in schema" },
        { kErrorDsMaxObjSizeExceeded, "DS max obj size exceeded" },
        { kErrorDsObjStringNameExists, "DS obj string name exists" },
        { kErrorDsNoRdnDefinedInSchema, "DS no rdn defined in schema" },
        { kErrorDsRdnDoesntMatchSchema, "DS rdn doesn't match schema" },
        { kErrorDsNoRequestedAttsFound, "DS no requested atts found" },
        { kErrorDsUserBufferToSmall, "DS user buffer too small" },
        { kErrorDsAttIsNotOnObj, "DS att is not on obj" },
        { kErrorDsIllegalModOperation, "DS illegal mod operation" },
        { kErrorDsObjTooLarge, "DS obj too large" },
        { kErrorDsBadInstanceType, "DS bad instance type" },
        { kErrorDsMasterdsaRequired, "DS masterdsa required" },
        { kErrorDsObjectClassRequired, "DS object class required" },
        { kErrorDsMissingRequiredAtt, "DS missing required att" },
        { kErrorDsAttNotDefForClass, "DS att not def for class" },
        { kErrorDsAttAlreadyExists, "DS att already exists" },
        { kErrorDsCantAddAttValues, "DS can't add att values" },
        { kErrorDsSingleValueConstraint, "DS single value constraint" },
        { kErrorDsRangeConstraint, "DS range constraint" },
        { kErrorDsAttValAlreadyExists, "DS att val already exists" },
        { kErrorDsCantRemMissingAtt, "DS can't rem missing att" },
        { kErrorDsCantRemMissingAttVal, "DS can't rem missing att val" },
        { kErrorDsRootCantBeSubref, "DS root can't be subref" },
        { kErrorDsNoChaining, "DS no chaining" },
        { kErrorDsNoChainedEval, "DS no chained eval" },
        { kErrorDsNoParentObject, "DS no parent object" },
        { kErrorDsParentIsAnAlias, "DS parent is an alias" },
        { kErrorDsCantMixMasterAndReps, "DS can't mix master and reps" },
        { kErrorDsChildrenExist, "DS children exist" },
        { kErrorDsObjNotFound, "DS obj not found" },
        { kErrorDsAliasedObjMissing, "DS aliased obj missing" },
        { kErrorDsBadNameSyntax, "DS bad name syntax" },
        { kErrorDsAliasPointsToAlias, "DS alias points to alias" },
        { kErrorDsCantDerefAlias, "DS can't redef alias" },
        { kErrorDsOutOfScope, "DS out of scope" },
        { kErrorDsObjectBeingRemoved, "DS object being removed" },
        { kErrorDsCantDeleteDsaObj, "DS can't delete dsa obj" },
        { kErrorDsGenericError, "DS generic error" },
        { kErrorDsDsaMustBeIntMaster, "DS dsa must be int master" },
        { kErrorDsClassNotDsa, "DS class not dsa" },
        { kErrorDsInsuffAccessRights, "DS insuff access rights" },
        { kErrorDsIllegalSuperior, "DS illegal superior" },
        { kErrorDsAttributeOwnedBySam, "DS attribute owned by sam" },
        { kErrorDsNameTooManyParts, "DS name too many parts" },
        { kErrorDsNameTooLong, "DS name too long" },
        { kErrorDsNameValueTooLong, "DS name value too long" },
        { kErrorDsNameUnparseable, "DS name unparseable" },
        { kErrorDsNameTypeUnknown, "DS name type unknown" },
        { kErrorDsNotAnObject, "DS not an object" },
        { kErrorDsSecDescTooShort, "DS sec desc too short" },
        { kErrorDsSecDescInvalid, "DS sec desc invalid" },
        { kErrorDsNoDeletedName, "DS no deleted name" },
        { kErrorDsSubrefMustHaveParent, "DS subref must have parent" },
        { kErrorDsNcnameMustBeNc, "DS ncname must be nc" },
        { kErrorDsCantAddSystemOnly, "DS can't add system only" },
        { kErrorDsClassMustBeConcrete, "DS class must be concrete" },
        { kErrorDsInvalidDmd, "DS invalid dmd" },
        { kErrorDsObjGuidExists, "DS obj GUID exists" },
        { kErrorDsNotOnBacklink, "DS not on backlink" },
        { kErrorDsNoCrossrefForNc, "DS no crossref for nc" },
        { kErrorDsShuttingDown, "DS shutting down" },
        { kErrorDsUnknownOperation, "DS unknown operation" },
        { kErrorDsInvalidRoleOwner, "DS invalid role owner" },
        { kErrorDsCouldntContactFsmo, "DS couldn't contact fsmo" },
        { kErrorDsCrossNcDnRename, "DS cross nc dn rename" },
        { kErrorDsCantModSystemOnly, "DS can't mod system only" },
        { kErrorDsReplicatorOnly, "DS replicator only" },
        { kErrorDsObjClassNotDefined, "DS obj class not defined" },
        { kErrorDsObjClassNotSubclass, "DS obj class not subclass" },
        { kErrorDsNameReferenceInvalid, "DS name reference invalid" },
        { kErrorDsCrossRefExists, "DS cross ref exists" },
        { kErrorDsCantDelMasterCrossref, "DS can't del master crossref" },
        { kErrorDsSubtreeNotifyNotNcHead, "DS subtree notify not nc head" },
        { kErrorDsNotifyFilterTooComplex, "DS notify filter too complex" },
        { kErrorDsDupRdn, "DS dup rdn" },
        { kErrorDsDupOid, "DS dup oid" },
        { kErrorDsDupMapiId, "DS dup mapi ID" },
        { kErrorDsDupSchemaIdGuid, "DS dup schema ID GUID" },
        { kErrorDsDupLdapDisplayName, "DS dup LDAP display name" },
        { kErrorDsSemanticAttTest, "DS semantic att test" },
        { kErrorDsSyntaxMismatch, "DS syntax mismatch" },
        { kErrorDsExistsInMustHave, "DS exists in must have" },
        { kErrorDsExistsInMayHave, "DS exists in may have" },
        { kErrorDsNonexistentMayHave, "DS nonexistent may have" },
        { kErrorDsNonexistentMustHave, "DS nonexistent must have" },
        { kErrorDsAuxClsTestFail, "DS aux cls test fail" },
        { kErrorDsNonexistentPossSup, "DS nonexistent poss sup" },
        { kErrorDsSubClsTestFail, "DS sub cls test fail" },
        { kErrorDsBadRdnAttIdSyntax, "DS bad rdn att ID syntax" },
        { kErrorDsExistsInAuxCls, "DS exists in aux cls" },
        { kErrorDsExistsInSubCls, "DS exists in sub cls" },
        { kErrorDsExistsInPossSup, "DS exists in poss sup" },
        { kErrorDsRecalcschemaFailed, "DS recalcschema failed" },
        { kErrorDsTreeDeleteNotFinished, "DS tree delete not finished" },
        { kErrorDsCantDelete, "DS can't delete" },
        { kErrorDsAttSchemaReqId, "DS att schema req ID" },
        { kErrorDsBadAttSchemaSyntax, "DS bad att schema syntax" },
        { kErrorDsCantCacheAtt, "DS can't cache att" },
        { kErrorDsCantCacheClass, "DS can't cache class" },
        { kErrorDsCantRemoveAttCache, "DS can't remove att cache" },
        { kErrorDsCantRemoveClassCache, "DS can't remove class cache" },
        { kErrorDsCantRetrieveDn, "DS can't retrieve DN" },
        { kErrorDsMissingSupref, "DS missing supref" },
        { kErrorDsCantRetrieveInstance, "DS can't retrieve instance" },
        { kErrorDsCodeInconsistency, "DS code inconsistency" },
        { kErrorDsDatabaseError, "DS database error" },
        { kErrorDsGovernsidMissing, "DS governsid missing" },
        { kErrorDsMissingExpectedAtt, "DS missing expected att" },
        { kErrorDsNcnameMissingCrRef, "DS ncname missing cr ref" },
        { kErrorDsSecurityCheckingError, "DS security checking error" },
        { kErrorDsSchemaNotLoaded, "DS schema not loaded" },
        { kErrorDsSchemaAllocFailed, "DS schema alloc failed" },
        { kErrorDsAttSchemaReqSyntax, "DS att schema req syntax" },
        { kErrorDsGcverifyError, "DS gcverify error" },
        { kErrorDsDraSchemaMismatch, "DS dra schema mismatch" },
        { kErrorDsCantFindDsaObj, "DS can't find dsa obj" },
        { kErrorDsCantFindExpectedNc, "DS can't find expected nc" },
        { kErrorDsCantFindNcInCache, "DS can't find nc in cache" },
        { kErrorDsCantRetrieveChild, "DS can't retrieve child" },
        { kErrorDsSecurityIllegalModify, "DS security illegal modify" },
        { kErrorDsCantReplaceHiddenRec, "DS can't replace hidden rec" },
        { kErrorDsBadHierarchyFile, "DS bad hierarchy file" },
        { kErrorDsBuildHierarchyTableFailed, "DS build hierarchy table failed" },
        { kErrorDsConfigParamMissing, "DS config param missing" },
        { kErrorDsCountingAbIndicesFailed, "DS counting ab indices failed" },
        { kErrorDsHierarchyTableMallocFailed, "DS hierarchy table malloc failed" },
        { kErrorDsInternalFailure, "DS internal failure" },
        { kErrorDsUnknownError, "DS unknown error" },
        { kErrorDsRootRequiresClassTop, "DS root requires class top" },
        { kErrorDsRefusingFsmoRoles, "DS refusing fmso roles" },
        { kErrorDsMissingFsmoSettings, "DS missing fmso settings" },
        { kErrorDsUnableToSurrenderRoles, "DS unable to surrender roles" },
        { kErrorDsDraGeneric, "DS dra generic" },
        { kErrorDsDraInvalidParameter, "DS dra invalid parameter" },
        { kErrorDsDraBusy, "DS dra busy" },
        { kErrorDsDraBadDn, "DS dra bad dn" },
        { kErrorDsDraBadNc, "DS dra bad nc" },
        { kErrorDsDraDnExists, "DS dra dn exists" },
        { kErrorDsDraInternalError, "DS dra internal error" },
        { kErrorDsDraInconsistentDit, "DS dra inconsistent dit" },
        { kErrorDsDraConnectionFailed, "DS dra connection failed" },
        { kErrorDsDraBadInstanceType, "DS dra bad instance type" },
        { kErrorDsDraOutOfMem, "DS dra out of mem" },
        { kErrorDsDraMailProblem, "DS dra mail problem" },
        { kErrorDsDraRefAlreadyExists, "DS dra ref already exists" },
        { kErrorDsDraRefNotFound, "DS dra ref not found" },
        { kErrorDsDraObjIsRepSource, "DS dra obj is rep source" },
        { kErrorDsDraDbError, "DS dra db error" },
        { kErrorDsDraNoReplica, "DS dra no replica" },
        { kErrorDsDraAccessDenied, "DS dra access denied" },
        { kErrorDsDraNotSupported, "DS dra not supported" },
        { kErrorDsDraRpcCancelled, "DS dra RPC cancelled" },
        { kErrorDsDraSourceDisabled, "DS dra source disabled" },
        { kErrorDsDraSinkDisabled, "DS dra sink disabled" },
        { kErrorDsDraNameCollision, "DS dra name collision" },
        { kErrorDsDraSourceReinstalled, "DS dra source reinstalled" },
        { kErrorDsDraMissingParent, "DS dra missing parent" },
        { kErrorDsDraPreempted, "DS dra preempted" },
        { kErrorDsDraAbandonSync, "DS dra abandon sync" },
        { kErrorDsDraShutdown, "DS dra shutdown" },
        { kErrorDsDraIncompatiblePartialSet, "DS dra incompatible partial set" },
        { kErrorDsDraSourceIsPartialReplica, "DS dra source is partial replica" },
        { kErrorDsDraExtnConnectionFailed, "DS dra extn connection failed" },
        { kErrorDsInstallSchemaMismatch, "DS install schema mismatch" },
        { kErrorDsDupLinkId, "DS dup link ID" },
        { kErrorDsNameErrorResolving, "DS name error resolving" },
        { kErrorDsNameErrorNotFound, "DS name error not found" },
        { kErrorDsNameErrorNotUnique, "DS name error not unique" },
        { kErrorDsNameErrorNoMapping, "DS name error no mapping" },
        { kErrorDsNameErrorDomainOnly, "DS name error domain only" },
        { kErrorDsNameErrorNoSyntacticalMapping, "DS name error no syntactical mapping" },
        { kErrorDsConstructedAttMod, "DS constructed att mod" },
        { kErrorDsWrongOmObjClass, "DS wrong om obj class" },
        { kErrorDsDraReplPending, "DS dra repl pending" },
        { kErrorDsDsRequired, "DS ds required" },
        { kErrorDsInvalidLdapDisplayName, "DS invalid LDAP display name" },
        { kErrorDsNonBaseSearch, "DS non base search" },
        { kErrorDsCantRetrieveAtts, "DS can't retrieve atts" },
        { kErrorDsBacklinkWithoutLink, "DS backlink without link" },
        { kErrorDsEpochMismatch, "DS epoch mismatch" },
        { kErrorDsSrcNameMismatch, "DS src name mismatch" },
        { kErrorDsSrcAndDstNcIdentical, "DS src and dst nc identical" },
        { kErrorDsDstNcMismatch, "DS dst nc mismatch" },
        { kErrorDsNotAuthoritiveForDstNc, "DS not authoritive for dst nc" },
        { kErrorDsSrcGuidMismatch, "DS src GUID mismatch" },
        { kErrorDsCantMoveDeletedObject, "DS can't move deleted object" },
        { kErrorDsPdcOperationInProgress, "DS pdc operation in progress" },
        { kErrorDsCrossDomainCleanupReqd, "DS cross domain cleanup reqd" },
        { kErrorDsIllegalXdomMoveOperation, "DS illegal xdom move operation" },
        { kErrorDsCantWithAcctGroupMembershps, "DS can't with acct group membershps" },
        { kErrorDsNcMustHaveNcParent, "DS nc must have nc parent" },
        { kErrorDsDstDomainNotNative, "DS dst domain not native" },
        { kErrorDsMissingInfrastructureContainer, "DS missing infrastructure container" },
        { kErrorDsCantMoveAccountGroup, "DS can't move account group" },
        { kErrorDsCantMoveResourceGroup, "DS can't move resource group" },
        { kErrorDsInvalidSearchFlag, "DS invalid search flag" },
        { kErrorDsNoTreeDeleteAboveNc, "DS no tree delete above nc" },
        { kErrorDsCouldntLockTreeForDelete, "DS couldn't lock tree for delete" },
        { kErrorDsCouldntIdentifyObjectsForTreeDelete, "DS couldn't identify objects for tree delete" },
        { kErrorDsSamInitFailure, "DS sam init failure" },
        { kErrorDsSensitiveGroupViolation, "DS sensitive group violation" },
        { kErrorDsCantModPrimarygroupid, "DS can't mod primarygroupid" },
        { kErrorDsIllegalBaseSchemaMod, "DS illegal base schema mod" },
        { kErrorDsNonsafeSchemaChange, "DS nonsafe schema change" },
        { kErrorDsSchemaUpdateDisallowed, "DS schema update disallowed" },
        { kErrorDsCantCreateUnderSchema, "DS can't create under schema" },
        { kErrorDsInstallNoSrcSchVersion, "DS install no src sch version" },
        { kErrorDsInstallNoSchVersionInInifile, "DS install no sch version in inifile" },
        { kErrorDsInvalidGroupType, "DS invalid group type" },
        { kErrorDsNoNestGlobalgroupInMixeddomain, "DS no nest globalgroup in mixeddomain" },
        { kErrorDsNoNestLocalgroupInMixeddomain, "DS no nest localgroup in mixeddomain" },
        { kErrorDsGlobalCantHaveLocalMember, "DS global can't have local member" },
        { kErrorDsGlobalCantHaveUniversalMember, "DS global can't have universal member" },
        { kErrorDsUniversalCantHaveLocalMember, "DS universal can't have local member" },
        { kErrorDsGlobalCantHaveCrossdomainMember, "DS global can't have crossdomain member" },
        { kErrorDsLocalCantHaveCrossdomainLocalMember, "DS local can't have crossdomain local member" },
        { kErrorDsHavePrimaryMembers, "DS have primary members" },
        { kErrorDsStringSdConversionFailed, "DS string sd conversion failed" },
        { kErrorDsNamingMasterGc, "DS naming master gc" },
        { kErrorDsLookupFailure, "DS lookup failure" },
        { kErrorDsCouldntUpdateSpns, "DS couldn't update spns" },
        { kErrorDsCantRetrieveSd, "DS can't retrieve sd" },
        { kErrorDsKeyNotUnique, "DS key not unique" },
        { kErrorDsWrongLinkedAttSyntax, "DS wrong linked att syntax" },
        { kErrorDsSamNeedBootkeyPassword, "DS sam need bootkey password" },
        { kErrorDsSamNeedBootkeyFloppy, "DS sam need bootkey floppy" },
        { kErrorDsCantStart, "DS can't start" },
        { kErrorDsInitFailure, "DS init failure" },
        { kErrorDsNoPktPrivacyOnConnection, "DS no pkt privacy on connection" },
        { kErrorDsSourceDomainInForest, "DS source domain in forest" },
        { kErrorDsDestinationDomainNotInForest, "DS destination domain not in forest" },
        { kErrorDsDestinationAuditingNotEnabled, "DS destination auditing not enabled" },
        { kErrorDsCantFindDcForSrcDomain, "DS can't find dc for src domain" },
        { kErrorDsSrcObjNotGroupOrUser, "DS src obj not group or user" },
        { kErrorDsSrcSidExistsInForest, "DS src sid exists in forest" },
        { kErrorDsSrcAndDstObjectClassMismatch, "DS src and dst object class mismatch" },
        { kErrorSamInitFailure, "Sam init failure" },
        { kErrorDsDraSchemaInfoShip, "DS dra schema info ship" },
        { kErrorDsDraSchemaConflict, "DS dra schema conflict" },
        { kErrorDsDraEarlierSchemaConlict, "DS dra earlier schema conflict" },
        { kErrorDsDraObjNcMismatch, "DS dra obj nc mismatch" },
        { kErrorDsNcStillHasDsas, "DS nc still has dsas" },
        { kErrorDsGcRequired, "DS gc required" },
        { kErrorDsLocalMemberOfLocalOnly, "DS local member of local only" },
        { kErrorDsNoFpoInUniversalGroups, "DS no fpo in universal groups" },
        { kErrorDsCantAddToGc, "DS can't add to gc" },
        { kErrorDsNoCheckpointWithPdc, "DS no checkpoint with pdc" },
        { kErrorDsSourceAuditingNotEnabled, "DS source auditing not enabled" },
        { kErrorDsCantCreateInNondomainNc, "DS can't create in nondomain nc" },
        { kErrorDsInvalidNameForSpn, "DS invalid name for spn" },
        { kErrorDsFilterUsesContructedAttrs, "DS filter uses constructed attrs" },
        { kErrorDsUnicodepwdNotInQuotes, "DS unicodepwd not in quotes" },
        { kErrorDsMachineAccountQuotaExceeded, "DS machine account quota exceeded" },
        { kErrorDsMustBeRunOnDstDc, "DS must be run on dst dc" },
        { kErrorDsSrcDcMustBeSp4OrGreater, "DS src dc must be sp4 or greater" },
        { kErrorDsCantTreeDeleteCriticalObj, "DS can't tree delete critical obj" },
        { kErrorDsInitFailureConsole, "DS init failure console" },
        { kErrorDsSamInitFailureConsole, "DS sam init failure console" },
        { kErrorDsForestVersionTooHigh, "DS forest version too high" },
        { kErrorDsDomainVersionTooHigh, "DS domain version too high" },
        { kErrorDsForestVersionTooLow, "DS forest version too low" },
        { kErrorDsDomainVersionTooLow, "DS domain version too low" },
        { kErrorDsIncompatibleVersion, "DS incompatible version" },
        { kErrorDsLowDsaVersion, "DS low dsa version" },
        { kErrorDsNoBehaviorVersionInMixeddomain, "DS no behaviour version in mixeddomain" },
        { kErrorDsNotSupportedSortOrder, "DS not supported sort order" },
        { kErrorDsNameNotUnique, "DS name not unique" },
        { kErrorDsMachineAccountCreatedPrent4, "DS machine account created prent4" },
        { kErrorDsOutOfVersionStore, "DS out of version store" },
        { kErrorDsIncompatibleControlsUsed, "DS incompatible controls used" },
        { kErrorDsNoRefDomain, "DS no ref domain" },
        { kErrorDsReservedLinkId, "DS reserved link ID" },
        { kErrorDsLinkIdNotAvailable, "DS link ID not available" },
        { kErrorDsAgCantHaveUniversalMember, "DS ag can't have universal member" },
        { kErrorDsModifydnDisallowedByInstanceType, "DS modifydn disallowed by instance type" },
        { kErrorDsNoObjectMoveInSchemaNc, "DS no object move in schema nc" },
        { kErrorDsModifydnDisallowedByFlag, "DS modifydn disallowed by flag" },
        { kErrorDsModifydnWrongGrandparent, "DS modifydn wrong grandparent" },
        { kErrorDsNameErrorTrustReferral, "DS name error trust referral" },
        { kErrorNotSupportedOnStandardServer, "Not supported on standard server" },
        { kErrorDsCantAccessRemotePartOfAd, "DS can't access remote part of ad" },
        { kErrorDsCrImpossibleToValidate, "DS cr impossible to validate" },
        { kErrorDsThreadLimitExceeded, "DS thread limit exceeded" },
        { kErrorDsNotClosest, "DS not closest" },
        { kErrorDsCantDeriveSpnWithoutServerRef, "DS can't derive spn without server ref" },
        { kErrorDsSingleUserModeFailed, "DS single user mode failed" },
        { kErrorDsNtdscriptSyntaxError, "DS ntdscript syntax error" },
        { kErrorDsNtdscriptProcessError, "DS ntdscript process error" },
        { kErrorDsDifferentReplEpochs, "DS different repl epochs" },
        { kErrorDsDrsExtensionsChanged, "DS drs extensions changed" },
        { kErrorDsReplicaSetChangeNotAllowedOnDisabledCr, "DS replica set change not allowed on disabled cr" },
        { kErrorDsNoMsdsIntid, "DS no msds intid" },
        { kErrorDsDupMsdsIntid, "DS dup msds intid" },
        { kErrorDsExistsInRdnattid, "DS exists in rdnattid" },
        { kErrorDsAuthorizationFailed, "DS authorisation failed" },
        { kErrorDsInvalidScript, "DS invalid script" },
        { kErrorDsRemoteCrossrefOpFailed, "DS remote crossref op failed" },
        { kDnsErrorRcodeFormatError, "DNS error rcode format error" },
        { kDnsErrorRcodeServerFailure, "DNS error rcode server failure" },
        { kDnsErrorRcodeNameError, "DNS error rcode name error" },
        { kDnsErrorRcodeNotImplemented, "DNS error rcode not implemented" },
        { kDnsErrorRcodeRefused, "DNS error rcode refused" },
        { kDnsErrorRcodeYxdomain, "DNS error rcode yxdomain" },
        { kDnsErrorRcodeYxrrset, "DNS error rcode yxrrset" },
        { kDnsErrorRcodeNxrrset, "DNS error rcode nxrrset" },
        { kDnsErrorRcodeNotauth, "DNS error rcode notauth" },
        { kDnsErrorRcodeNotzone, "DNS error rcode notzone" },
        { kDnsErrorRcodeBadsig, "DNS error rcode badsig" },
        { kDnsErrorRcodeBadkey, "DNS error rcode badkey" },
        { kDnsErrorRcodeBadtime, "DNS error rcode badtime" },
        { kDnsInfoNoRecords, "DNS info no records" },
        { kDnsErrorBadPacket, "DNS error bad packet" },
        { kDnsErrorNoPacket, "DNS error no packet" },
        { kDnsErrorRcode, "DNS error rcode" },
        { kDnsErrorUnsecurePacket, "DNS error unsecure packet" },
        { kDnsErrorInvalidType, "DNS error invalid type" },
        { kDnsErrorInvalidIpAddress, "DNS error invalid IP address" },
        { kDnsErrorInvalidProperty, "DNS error invalid property" },
        { kDnsErrorTryAgainLater, "DNS error try again later" },
        { kDnsErrorNotUnique, "DNS error not unique" },
        { kDnsErrorNonRfcName, "DNS error non RFC name" },
        { kDnsStatusFqdn, "DNS status FQDN" },
        { kDnsStatusDottedName, "DNS status dotted name" },
        { kDnsStatusSinglePartName, "DNS status single part name" },
        { kDnsErrorInvalidNameChar, "DNS error invalid name char" },
        { kDnsErrorNumericName, "DNS error numeric name" },
        { kDnsErrorNotAllowedOnRootServer, "DNS error not allowed on root server" },
        { kDnsErrorZoneDoesNotExist, "DNS error zone does not exist" },
        { kDnsErrorNoZoneInfo, "DNS error not zone info" },
        { kDnsErrorInvalidZoneOperation, "DNS error invalid zone operation" },
        { kDnsErrorZoneConfigurationError, "DNS error zone configuration error" },
        { kDnsErrorZoneHasNoSoaRecord, "DNS error zone has not SOA record" },
        { kDnsErrorZoneHasNoNsRecords, "DNS error zone has no NS records" },
        { kDnsErrorZoneLocked, "DNS error zone locked" },
        { kDnsErrorZoneCreationFailed, "DNS error zone creation failed" },
        { kDnsErrorZoneAlreadyExists, "DNS error zone already exists" },
        { kDnsErrorAutozoneAlreadyExists, "DNS error autozone already exists" },
        { kDnsErrorInvalidZoneType, "DNS error invalid zone type" },
        { kDnsErrorSecondaryRequiresMasterIp, "DNS error secondary requires master IP" },
        { kDnsErrorZoneNotSecondary, "DNS error zone not secondary" },
        { kDnsErrorNeedSecondaryAddresses, "DNS error need secondary addresses" },
        { kDnsErrorWinsInitFailed, "DNS error wins init failed" },
        { kDnsErrorNeedWinsServers, "DNS error need wins servers" },
        { kDnsErrorNbstatInitFailed, "DNS error nbstat init failed" },
        { kDnsErrorSoaDeleteInvalid, "DNS error SOA delete invalid" },
        { kDnsErrorForwarderAlreadyExists, "DNS error forwarder already exists" },
        { kDnsErrorZoneRequiresMasterIp, "DNS error zone requires master IP" },
        { kDnsErrorZoneIsShutdown, "DNS error zone is shutdown" },
        { kDnsErrorPrimaryRequiresDatafile, "DNS error primary requires datafile" },
        { kDnsErrorInvalidDatafileName, "DNS error invalid datafile name" },
        { kDnsErrorDatafileOpenFailure, "DNS error datafile open failure" },
        { kDnsErrorFileWritebackFailed, "DNS error file writeback failed" },
        { kDnsErrorDatafileParsing, "DNS error datafile parsing" },
        { kDnsErrorRecordDoesNotExist, "DNS error record does not exist" },
        { kDnsErrorRecordFormat, "DNS error record format" },
        { kDnsErrorNodeCreationFailed, "DNS error node creation failed" },
        { kDnsErrorUnknownRecordType, "DNS error unknown record type" },
        { kDnsErrorRecordTimedOut, "DNS error record timed out" },
        { kDnsErrorNameNotInZone, "DNS error name not in zone" },
        { kDnsErrorCnameLoop, "DNS error CNAME loop" },
        { kDnsErrorNodeIsCname, "DNS error node is CNAME" },
        { kDnsErrorCnameCollision, "DNS error CNAME collision" },
        { kDnsErrorRecordOnlyAtZoneRoot, "DNS error record only at zone root" },
        { kDnsErrorRecordAlreadyExists, "DNS error record already exists" },
        { kDnsErrorSecondaryData, "DNS error secondary data" },
        { kDnsErrorNoCreateCacheData, "DNS error no create cache data" },
        { kDnsErrorNameDoesNotExist, "DNS error name does not exist" },
        { kDnsWarningPtrCreateFailed, "DNS warning PTR create failed" },
        { kDnsWarningDomainUndeleted, "DNS warning domain undeleted" },
        { kDnsErrorDsUnavailable, "DNS error ds unavailable" },
        { kDnsErrorDsZoneAlreadyExists, "DNS error ds zone already exists" },
        { kDnsErrorNoBootfileIfDsZone, "DNS error no bootfile if ds zone" },
        { kDnsInfoAxfrComplete, "DNS info AXFR complete" },
        { kDnsErrorAxfr, "DNS error AXFR" },
        { kDnsInfoAddedLocalWins, "DNS info added local wins" },
        { kDnsStatusContinueNeeded, "DNS status continue needed" },
        { kDnsErrorNoTcpip, "DNS error no TCPIP" },
        { kDnsErrorNoDnsServers, "DNS error no DNS servers" },
        { kDnsErrorDpDoesNotExist, "DNS error dp does not exist" },
        { kDnsErrorDpAlreadyExists, "DNS error dp already exists" },
        { kDnsErrorDpNotEnlisted, "DNS error dp not enlisted" },
        { kDnsErrorDpAlreadyEnlisted, "DNS error dp already enlisted" },
        { kWSAQosReceivers, "QOS receivers" },
        { kWSAQosSenders, "QOS senders" },
        { kWSAQosNoSenders, "QOS no senders" },
        { kWSAQosNoReceivers, "QOS no receivers" },
        { kWSAQosRequestConfirmed, "QOS request confirmed" },
        { kWSAQosAdmissionFailure, "QOS admission failure" },
        { kWSAQosPolicyFailure, "QOS policy failure" },
        { kWSAQosBadStyle, "QOS bad style" },
        { kWSAQosBadObject, "QOS bad object" },
        { kWSAQosTrafficCtrlError, "QOS traffic ctrl error" },
        { kWSAQosGenericError, "QOS generic error" },
        { kWSAQosEservicetype, "QOS eservicetype" },
        { kWSAQosEflowspec, "QOS eflowspec" },
        { kWSAQosEprovspecbuf, "QOS eprovspecbuf" },
        { kWSAQosEfilterstyle, "QOS efilterstyle" },
        { kWSAQosEfiltertype, "QOS efiltertype" },
        { kWSAQosEfiltercount, "QOS efiltercount" },
        { kWSAQosEobjlength, "QOS eobjlength" },
        { kWSAQosEflowcount, "QOS eflowcount" },
        { kWSAQosEunknownpsobj, "QOS eunknownpsobj" },
        { kWSAQosEpolicyobj, "QOS epolicyobj" },
        { kWSAQosEflowdesc, "QOS eflowdesc" },
        { kWSAQosEpsflowspec, "QOS epsflowspec" },
        { kWSAQosEpsfilterspec, "QOS epsfilterspec" },
        { kWSAQosEsdmodeobj, "QOS esdmodeobj" },
        { kWSAQosEshaperateobj, "QOS eshaperateobj" },
        { kWSAQosReservedPetype, "QOS reserved petype" },
        { kErrorIpsecQmPolicyExists, "IPSEC qm policy exists" },
        { kErrorIpsecQmPolicyNotFound, "IPSEC qm policy not found" },
        { kErrorIpsecQmPolicyInUse, "IPSEC qm policy in use" },
        { kErrorIpsecMmPolicyExists, "IPSEC mm policy exists" },
        { kErrorIpsecMmPolicyNotFound, "IPSEC mm policy not found" },
        { kErrorIpsecMmPolicyInUse, "IPSEC mm policy in use" },
        { kErrorIpsecMmFilterExists, "IPSEC mm filter exists" },
        { kErrorIpsecMmFilterNotFound, "IPSEC mm filter not found" },
        { kErrorIpsecTransportFilterExists, "IPSEC transport filter exists" },
        { kErrorIpsecTransportFilterNotFound, "IPSEC transport filter not found" },
        { kErrorIpsecMmAuthExists, "IPSEC mm auth exists" },
        { kErrorIpsecMmAuthNotFound, "IPSEC mm auth not found" },
        { kErrorIpsecMmAuthInUse, "IPSEC mm auth in use" },
        { kErrorIpsecDefaultMmPolicyNotFound, "IPSEC default mm policy not found" },
        { kErrorIpsecDefaultMmAuthNotFound, "IPSEC default mm auth not found" },
        { kErrorIpsecDefaultQmPolicyNotFound, "IPSEC default qm policy not found" },
        { kErrorIpsecTunnelFilterExists, "IPSEC tunnel filter exists" },
        { kErrorIpsecTunnelFilterNotFound, "IPSEC tunnel filter not found" },
        { kErrorIpsecMmFilterPendingDeletion, "IPSEC mm filter pending deletion" },
        { kErrorIpsecTransportFilterPendingDeletion, "IPSEC transport filter pending deletion" },
        { kErrorIpsecTunnelFilterPendingDeletion, "IPSEC tunnel filter pending deletion" },
        { kErrorIpsecMmPolicyPendingDeletion, "IPSEC mm policy pending deletion" },
        { kErrorIpsecMmAuthPendingDeletion, "IPSEC mm auth pending deletion" },
        { kErrorIpsecQmPolicyPendingDeletion, "IPSEC qm policy pending deletion" },
        { kErrorIpsecIkeAuthFail, "IPSEC IKE auth fail" },
        { kErrorIpsecIkeAttribFail, "IPSEC IKE attrib fail" },
        { kErrorIpsecIkeNegotiationPending, "IPSEC IKE negotiation pending" },
        { kErrorIpsecIkeGeneralProcessingError, "IPSEC IKE general processing error" },
        { kErrorIpsecIkeTimedOut, "IPSEC IKE timed out" },
        { kErrorIpsecIkeNoCert, "IPSEC IKE no cert" },
        { kErrorIpsecIkeSaDeleted, "IPSEC IKE sa deleted" },
        { kErrorIpsecIkeSaReaped, "IPSEC IKE sa reaped" },
        { kErrorIpsecIkeMmAcquireDrop, "IPSEC IKE mm acquire drop" },
        { kErrorIpsecIkeQmAcquireDrop, "IPSEC IKE qm acquire drop" },
        { kErrorIpsecIkeQueueDropMm, "IPSEC IKE queue drop mm" },
        { kErrorIpsecIkeQueueDropNoMm, "IPSEC IKE queue drop no mm" },
        { kErrorIpsecIkeDropNoResponse, "IPSEC IKE drop no response" },
        { kErrorIpsecIkeMmDelayDrop, "IPSEC IKE mm delay drop" },
        { kErrorIpsecIkeQmDelayDrop, "IPSEC IKE qm delay drop" },
        { kErrorIpsecIkeError, "IPSEC IKE error" },
        { kErrorIpsecIkeCrlFailed, "IPSEC IKE crl failed" },
        { kErrorIpsecIkeInvalidKeyUsage, "IPSEC IKE invalid key usage" },
        { kErrorIpsecIkeInvalidCertType, "IPSEC IKE invalid cert type" },
        { kErrorIpsecIkeNoPrivateKey, "IPSEC IKE no private key" },
        { kErrorIpsecIkeDhFail, "IPSEC IKE dh fail" },
        { kErrorIpsecIkeInvalidHeader, "IPSEC IKE invalid header" },
        { kErrorIpsecIkeNoPolicy, "IPSEC IKE no policy" },
        { kErrorIpsecIkeInvalidSignature, "IPSEC IKE invalid signature" },
        { kErrorIpsecIkeKerberosError, "IPSEC IKE kerberos error" },
        { kErrorIpsecIkeNoPublicKey, "IPSEC IKE no public key" },
        { kErrorIpsecIkeProcessErr, "IPSEC IKE process err" },
        { kErrorIpsecIkeProcessErrSa, "IPSEC IKE process err sa" },
        { kErrorIpsecIkeProcessErrProp, "IPSEC IKE process err prop" },
        { kErrorIpsecIkeProcessErrTrans, "IPSEC IKE process err trans" },
        { kErrorIpsecIkeProcessErrKe, "IPSEC IKE process err ke" },
        { kErrorIpsecIkeProcessErrId, "IPSEC IKE process err ID" },
        { kErrorIpsecIkeProcessErrCert, "IPSEC IKE process err cert" },
        { kErrorIpsecIkeProcessErrCertReq, "IPSEC IKE process err cert req" },
        { kErrorIpsecIkeProcessErrHash, "IPSEC IKE process err hash" },
        { kErrorIpsecIkeProcessErrSig, "IPSEC IKE process err sig" },
        { kErrorIpsecIkeProcessErrNonce, "IPSEC IKE process err nonce" },
        { kErrorIpsecIkeProcessErrNotify, "IPSEC IKE process err notify" },
        { kErrorIpsecIkeProcessErrDelete, "IPSEC IKE process err delete" },
        { kErrorIpsecIkeProcessErrVendor, "IPSEC IKE process err vendor" },
        { kErrorIpsecIkeInvalidPayload, "IPSEC IKE invalid payload" },
        { kErrorIpsecIkeLoadSoftSa, "IPSEC IKE load soft sa" },
        { kErrorIpsecIkeSoftSaTornDown, "IPSEC IKE soft sa torn down" },
        { kErrorIpsecIkeInvalidCookie, "IPSEC IKE invalid cookie" },
        { kErrorIpsecIkeNoPeerCert, "IPSEC IKE no peer cert" },
        { kErrorIpsecIkePeerCrlFailed, "IPSEC IKE peer CRL failed" },
        { kErrorIpsecIkePolicyChange, "IPSEC IKE policy change" },
        { kErrorIpsecIkeNoMmPolicy, "IPSEC IKE no mm policy" },
        { kErrorIpsecIkeNotcbpriv, "IPSEC IKE notcbpriv" },
        { kErrorIpsecIkeSecloadfail, "IPSEC IKE secloadfail" },
        { kErrorIpsecIkeFailsspinit, "IPSEC IKE failsspinit" },
        { kErrorIpsecIkeFailqueryssp, "IPSEC IKE failqueryssp" },
        { kErrorIpsecIkeSrvacqfail, "IPSEC IKE srvacqfail" },
        { kErrorIpsecIkeSrvquerycred, "IPSEC IKE srvquerycred" },
        { kErrorIpsecIkeGetspifail, "IPSEC IKE getspifail" },
        { kErrorIpsecIkeInvalidFilter, "IPSEC IKE invalid filter" },
        { kErrorIpsecIkeOutOfMemory, "IPSEC IKE out of memory" },
        { kErrorIpsecIkeAddUpdateKeyFailed, "IPSEC IKE add update key failed" },
        { kErrorIpsecIkeInvalidPolicy, "IPSEC IKE invalid policy" },
        { kErrorIpsecIkeUnknownDoi, "IPSEC IKE unknown doi" },
        { kErrorIpsecIkeInvalidSituation, "IPSEC IKE invalid situation" },
        { kErrorIpsecIkeDhFailure, "IPSEC IKE dh failure" },
        { kErrorIpsecIkeInvalidGroup, "IPSEC IKE invalid group" },
        { kErrorIpsecIkeEncrypt, "IPSEC IKE encrypt" },
        { kErrorIpsecIkeDecrypt, "IPSEC IKE decrypt" },
        { kErrorIpsecIkePolicyMatch, "IPSEC IKE policy match" },
        { kErrorIpsecIkeUnsupportedId, "IPSEC IKE unsupported ID" },
        { kErrorIpsecIkeInvalidHash, "IPSEC IKE invalid hash" },
        { kErrorIpsecIkeInvalidHashAlg, "IPSEC IKE invalid hash alg" },
        { kErrorIpsecIkeInvalidHashSize, "IPSEC IKE invalid hash size" },
        { kErrorIpsecIkeInvalidEncryptAlg, "IPSEC IKE invalid encrypt alg" },
        { kErrorIpsecIkeInvalidAuthAlg, "IPSEC IKE invalid auth alg" },
        { kErrorIpsecIkeInvalidSig, "IPSEC IKE invalid sig" },
        { kErrorIpsecIkeLoadFailed, "IPSEC IKE load failed" },
        { kErrorIpsecIkeRpcDelete, "IPSEC IKE rpc delete" },
        { kErrorIpsecIkeBenignReinit, "IPSEC IKE benign reinit" },
        { kErrorIpsecIkeInvalidResponderLifetimeNotify, "IPSEC IKE invalid responder lifetime notify" },
        { kErrorIpsecIkeInvalidCertKeylen, "IPSEC IKE invalid cert keylen" },
        { kErrorIpsecIkeMmLimit, "IPSEC IKE mm limit" },
        { kErrorIpsecIkeNegotiationDisabled, "IPSEC IKE negotiation disabled" },
        { kErrorIpsecIkeNegStatusEnd, "IPSEC IKE neg status end" },
        { kErrorSxsSectionNotFound, "Sxs section not found" },
        { kErrorSxsCantGenActctx, "Sxs can't gen actctx" },
        { kErrorSxsInvalidActctxdataFormat, "Sxs invalid actctxdata format" },
        { kErrorSxsAssemblyNotFound, "Sxs assembly not found" },
        { kErrorSxsManifestFormatError, "Sxs manifest format error" },
        { kErrorSxsManifestParseError, "Sxs manifest parse error" },
        { kErrorSxsActivationContextDisabled, "Sxs activation context disabled" },
        { kErrorSxsKeyNotFound, "Sxs key not found" },
        { kErrorSxsVersionConflict, "Sxs version conflict" },
        { kErrorSxsWrongSectionType, "Sxs wrong section type" },
        { kErrorSxsThreadQueriesDisabled, "Sxs thread queries disabled" },
        { kErrorSxsProcessDefaultAlreadySet, "Sxs process default already set" },
        { kErrorSxsUnknownEncodingGroup, "Sxs unknown encoding group" },
        { kErrorSxsUnknownEncoding, "Sxs unknown encoding" },
        { kErrorSxsInvalidXmlNamespaceUri, "Sxs invalid XML namespace URI" },
        { kErrorSxsRootManifestDependencyNotInstalled, "Sxs root manifest dependency not installed" },
        { kErrorSxsLeafManifestDependencyNotInstalled, "Sxs leaf manifest dependency not installed" },
        { kErrorSxsInvalidAssemblyIdentityAttribute, "Sxs invalid assembly indentity attribute" },
        { kErrorSxsManifestMissingRequiredDefaultNamespace, "Sxs manifest missing required default namespace" },
        { kErrorSxsManifestInvalidRequiredDefaultNamespace, "Sxs manifest invalid required default namespace" },
        { kErrorSxsPrivateManifestCrossPathWithReparsePoint, "Sxs private manifest cross path with reparse point" },
        { kErrorSxsDuplicateDllName, "Sxs duplicate dll name" },
        { kErrorSxsDuplicateWindowclassName, "Sxs duplicate windowclass name" },
        { kErrorSxsDuplicateClsid, "Sxs duplicate clsid" },
        { kErrorSxsDuplicateIid, "Sxs duplicate iid" },
        { kErrorSxsDuplicateTlbid, "Sxs duplicate tlbid" },
        { kErrorSxsDuplicateProgid, "Sxs duplicate progid" },
        { kErrorSxsDuplicateAssemblyName, "Sxs duplicate assembly name" },
        { kErrorSxsFileHashMismatch, "Sxs file hash mismatch" },
        { kErrorSxsPolicyParseError, "Sxs policy parse error" },
        { kErrorSxsXmlEMissingquote, "Sxs XML e missingquote" },
        { kErrorSxsXmlECommentsyntax, "Sxs XML e commentsyntax" },
        { kErrorSxsXmlEBadstartnamechar, "Sxs XML e badstartnamechar" },
        { kErrorSxsXmlEBadnamechar, "Sxs XML e badnamechar" },
        { kErrorSxsXmlEBadcharinstring, "Sxs XML e badcharinstring" },
        { kErrorSxsXmlEXmldeclsyntax, "Sxs XML e xmldeclsyntax" },
        { kErrorSxsXmlEBadchardata, "Sxs XML e badchardata" },
        { kErrorSxsXmlEMissingwhitespace, "Sxs XML e missingwhitespace" },
        { kErrorSxsXmlEExpectingtagend, "Sxs XML e expectingtagend" },
        { kErrorSxsXmlEMissingsemicolon, "Sxs XML e missingsemicolon" },
        { kErrorSxsXmlEUnbalancedparen, "Sxs XML e unbalancedparen" },
        { kErrorSxsXmlEInternalerror, "Sxs XML e internalerror" },
        { kErrorSxsXmlEUnexpectedWhitespace, "Sxs XML e unexpected whitespace" },
        { kErrorSxsXmlEIncompleteEncoding, "Sxs XML e incomplete encoding" },
        { kErrorSxsXmlEMissingParen, "Sxs XML e missing paren" },
        { kErrorSxsXmlEExpectingclosequote, "Sxs XML e expectingclosequote" },
        { kErrorSxsXmlEMultipleColons, "Sxs XML e multiple colons" },
        { kErrorSxsXmlEInvalidDecimal, "Sxs XML e invalid decimal" },
        { kErrorSxsXmlEInvalidHexidecimal, "Sxs XML e invalid hexidecimal" },
        { kErrorSxsXmlEInvalidUnicode, "Sxs XML e invalid unicode" },
        { kErrorSxsXmlEWhitespaceorquestionmark, "Sxs XML e whitespaceorquestionmark" },
        { kErrorSxsXmlEUnexpectedendtag, "Sxs XML e unexpectedendtag" },
        { kErrorSxsXmlEUnclosedtag, "Sxs XML e unclosedtag" },
        { kErrorSxsXmlEDuplicateattribute, "Sxs XML e duplicateattribute" },
        { kErrorSxsXmlEMultipleroots, "Sxs XML e multipleroots" },
        { kErrorSxsXmlEInvalidatrootlevel, "Sxs XML e invalidatrootlevel" },
        { kErrorSxsXmlEBadxmldecl, "Sxs XML e badxmldecl" },
        { kErrorSxsXmlEMissingroot, "Sxs XML e missingroot" },
        { kErrorSxsXmlEUnexpectedeof, "Sxs XML e unexpectedeof" },
        { kErrorSxsXmlEBadperefinsubset, "Sxs XML e badperefinsubset" },
        { kErrorSxsXmlEUnclosedstarttag, "Sxs XML e unclosedstarttag" },
        { kErrorSxsXmlEUnclosedendtag, "Sxs XML e unclosedendtag" },
        { kErrorSxsXmlEUnclosedstring, "Sxs XML e unclosedstring" },
        { kErrorSxsXmlEUnclosedcomment, "Sxs XML e unclosedcomment" },
        { kErrorSxsXmlEUncloseddecl, "Sxs XML e uncloseddecl" },
        { kErrorSxsXmlEUnclosedcdata, "Sxs XML e unclosedcdata" },
        { kErrorSxsXmlEReservednamespace, "Sxs XML e reservednamespace" },
        { kErrorSxsXmlEInvalidencoding, "Sxs XML e invalidencoding" },
        { kErrorSxsXmlEInvalidswitch, "Sxs XML e invalidswitch" },
        { kErrorSxsXmlEBadxmlcase, "Sxs XML e badxmlcase" },
        { kErrorSxsXmlEInvalidStandalone, "Sxs XML e invalid standalone" },
        { kErrorSxsXmlEUnexpectedStandalone, "Sxs XML e unexpected standalone" },
        { kErrorSxsXmlEInvalidVersion, "Sxs XML e invalid version" },
        { kErrorSxsXmlEMissingequals, "Sxs XML e missingequals" },
        { kErrorSxsProtectionRecoveryFailed, "Sxs protection recovery failed" },
        { kErrorSxsProtectionPublicKeyTooShort, "Sxs protection public key too short" },
        { kErrorSxsProtectionCatalogNotValid, "Sxs protection catalog not valid" },
        { kErrorSxsUntranslatableHresult, "Sxs untranslatable hresult" },
        { kErrorSxsProtectionCatalogFileMissing, "Sxs protection catalog file missing" },
        { kErrorSxsMissingAssemblyIdentityAttribute, "Sxs missing assembly identity attribute" },
        { kErrorSxsInvalidAssemblyIdentityAttributeName, "Sxs invalid assembly identity attribute name" },
    };
#endif /* IL2CPP_DISABLE_FULL_MESSAGES */


    static int32_t compare_message(const void *first, const void *second)
    {
        ErrorDesc *efirst = (ErrorDesc*)first;
        ErrorDesc *esecond = (ErrorDesc*)second;

        return (int32_t)efirst->code - (int32_t)esecond->code;
    }

    static const char *find_message(ErrorCode code, ErrorDesc *list, int32_t count)
    {
        ErrorDesc key = { code, "" };
        ErrorDesc *result = (ErrorDesc*)bsearch(&key, list, count, sizeof(ErrorDesc), compare_message);
        return result ? result->message : NULL;
    }

    static const char *find_message_linear(ErrorCode code, ErrorDesc *list, int32_t count)
    {
        int32_t prev = -1;

        for (int32_t i = 0; i < count; ++i)
        {
            if (list[i].code > prev)
                prev = list[i].code;
            else
            {
                // static int error_shown;
                // if (!error_shown){
                //      error_shown = 1;
                //      fprintf (stderr, "Mono: Incorrect message sorted in io-layer/messages.c at index %d (msg=%s)\n", i, list [i].txt);
                // }
            }

            if (list[i].code == code)
            {
                // static int error_shown;
                // if (!error_shown){
                //      error_shown = 1;
                //      fprintf (stderr, "Mono: Error %d with text %s is improperly sorted in io-layer/messages.c\n", id, list [i].txt);
                // }
                return list[i].message;
            }
        }
        return NULL;
    }

    std::string Messages::FromCode(ErrorCode code)
    {
        const char *message = find_message(code, common_messages, N_ELEMENTS(common_messages));
        if (message != NULL)
            return message;

#ifndef IL2CPP_DISABLE_FULL_MESSAGES
        message = find_message(code, messages, N_ELEMENTS(messages));
        if (message != NULL)
            return message;
#endif

        // Linear search, in case someone adds an error message and does not add it
        // to the list in a sorted position, this will be catched during development.

        message = find_message_linear(code, common_messages, N_ELEMENTS(common_messages));
        if (message != NULL)
            return message;

#ifndef IL2CPP_DISABLE_FULL_MESSAGES
        message = find_message_linear(code, messages, N_ELEMENTS(messages));
        if (message != NULL)
            return message;
#endif

        return std::string();
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Messages.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Mutex.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Mutex.h"

#if IL2CPP_SUPPORT_THREADS

#include "os/Atomic.h"
#if IL2CPP_THREADS_WIN32 || IL2CPP_THREADS_PTHREAD
    #if IL2CPP_THREADS_WIN32
        #include "os/Win32/MutexImpl.h"
    #elif IL2CPP_THREADS_PTHREAD
        #include "os/Posix/MutexImpl.h"
    #endif
#include "os/Generic/MutexImpl.h"
#elif IL2CPP_TARGET_PSP2
#include "os/PSP2/MutexImpl.h"
#else
#include "os/MutexImpl.h"
#endif

namespace il2cpp
{
namespace os
{
    Mutex::Mutex(bool initiallyOwned)
        : m_Mutex(new MutexImpl())
    {
        if (initiallyOwned)
            Lock();
    }

    Mutex::~Mutex()
    {
        delete m_Mutex;
    }

    void Mutex::Lock(bool interruptible)
    {
        m_Mutex->Lock(interruptible);
    }

    bool Mutex::TryLock(uint32_t milliseconds, bool interruptible)
    {
        return m_Mutex->TryLock(milliseconds, interruptible);
    }

    void Mutex::Unlock()
    {
        m_Mutex->Unlock();
    }

    void* Mutex::GetOSHandle()
    {
        return m_Mutex->GetOSHandle();
    }

    FastMutex::FastMutex()
        : m_Impl(new FastMutexImpl())
    {
    }

    FastMutex::~FastMutex()
    {
        delete m_Impl;
    }

    void FastMutex::Lock()
    {
        m_Impl->Lock();
    }

    void FastMutex::Unlock()
    {
        m_Impl->Unlock();
    }

    FastMutexImpl* FastMutex::GetImpl()
    {
        return m_Impl;
    }
}
}

#else

namespace il2cpp
{
namespace os
{
    Mutex::Mutex(bool initiallyOwned)
    {
    }

    Mutex::~Mutex()
    {
    }

    void Mutex::Lock(bool interruptible)
    {
    }

    bool Mutex::TryLock(uint32_t milliseconds, bool interruptible)
    {
        return true;
    }

    void Mutex::Unlock()
    {
    }

    void* Mutex::GetOSHandle()
    {
        return NULL;
    }

    FastMutex::FastMutex()
    {
    }

    FastMutex::~FastMutex()
    {
    }

    void FastMutex::Lock()
    {
    }

    void FastMutex::Unlock()
    {
    }

    FastMutexImpl* FastMutex::GetImpl()
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return NULL;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Mutex.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Path.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Path.h"
#include <string>

#if IL2CPP_USE_GENERIC_ENVIRONMENT
#include "os/Path.h"
#include <string>

namespace il2cpp
{
namespace os
{
    std::string Path::GetExecutablePath()
    {
        return std::string("<NotImplemented>");
    }

    std::string Path::GetApplicationFolder()
    {
        return std::string("<NotImplemented>");
    }

    std::string Path::GetTempPath()
    {
        return std::string("<NotImplemented>");
    }

    bool Path::IsAbsolute(const std::string& path)
    {
        return false;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Path.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ReaderWriterLock.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/ReaderWriterLock.h"

#if IL2CPP_SUPPORT_THREADS

#if IL2CPP_THREADS_WIN32
#include "os/Win32/ReaderWriterLockImpl.h"
#elif IL2CPP_THREADS_PTHREAD
#include "os/Posix/ReaderWriterLockImpl.h"
#else
#include "os/ReaderWriterLockImpl.h"
#endif

namespace il2cpp
{
namespace os
{
    ReaderWriterLock::ReaderWriterLock()
        : m_Impl(new ReaderWriterLockImpl())
    {
    }

    ReaderWriterLock::~ReaderWriterLock()
    {
        delete m_Impl;
    }

    void ReaderWriterLock::LockExclusive()
    {
        m_Impl->LockExclusive();
    }

    void ReaderWriterLock::LockShared()
    {
        m_Impl->LockShared();
    }

    void ReaderWriterLock::ReleaseExclusive()
    {
        m_Impl->ReleaseExclusive();
    }

    void ReaderWriterLock::ReleaseShared()
    {
        m_Impl->ReleaseShared();
    }

    ReaderWriterLockImpl* ReaderWriterLock::GetImpl()
    {
        return m_Impl;
    }
}
}

#else

#include <stddef.h>

namespace il2cpp
{
namespace os
{
    ReaderWriterLock::ReaderWriterLock()
    {
    }

    ReaderWriterLock::~ReaderWriterLock()
    {
    }

    void ReaderWriterLock::LockExclusive()
    {
    }

    void ReaderWriterLock::LockShared()
    {
    }

    void ReaderWriterLock::ReleaseExclusive()
    {
    }

    void ReaderWriterLock::ReleaseShared()
    {
    }

    ReaderWriterLockImpl* ReaderWriterLock::GetImpl()
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return NULL;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ReaderWriterLock.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Semaphore.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"
#include "os/Semaphore.h"

#if IL2CPP_SUPPORT_THREADS

#include "os/Atomic.h"
#if IL2CPP_TARGET_WINDOWS || IL2CPP_TARGET_POSIX
#include "os/Generic/SemaphoreImpl.h"
#else
#include "os/SemaphoreImpl.h"
#endif

namespace il2cpp
{
namespace os
{
    Semaphore::Semaphore(int32_t initialValue, int32_t maximumValue)
        : m_Semaphore(new SemaphoreImpl(initialValue, maximumValue))
    {
    }

    Semaphore::~Semaphore()
    {
        delete m_Semaphore;
    }

    bool Semaphore::Post(int32_t releaseCount, int32_t* previousCount)
    {
        return m_Semaphore->Post(releaseCount, previousCount);
    }

    WaitStatus Semaphore::Wait(bool interruptible)
    {
        return m_Semaphore->Wait(interruptible);
    }

    WaitStatus Semaphore::Wait(uint32_t ms, bool interruptible)
    {
        return m_Semaphore->Wait(ms, interruptible);
    }

    void* Semaphore::GetOSHandle()
    {
        return m_Semaphore->GetOSHandle();
    }
}
}

#else

namespace il2cpp
{
namespace os
{
    Semaphore::Semaphore(int32_t initialValue, int32_t maximumValue)
    {
    }

    Semaphore::~Semaphore()
    {
    }

    bool Semaphore::Post(int32_t releaseCount, int32_t* previousCount)
    {
        return true;
    }

    WaitStatus Semaphore::Wait(bool interruptible)
    {
        return kWaitStatusSuccess;
    }

    WaitStatus Semaphore::Wait(uint32_t ms, bool interruptible)
    {
        return kWaitStatusSuccess;
    }

    void* Semaphore::GetOSHandle()
    {
        return NULL;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Semaphore.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Socket.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_SUPPORT_SOCKETS

#include <map>

#include "os/Socket.h"
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "utils/Expected.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

#if IL2CPP_TARGET_POSIX || IL2CPP_SUPPORT_SOCKETS_POSIX_API
# include "os/Posix/SocketImpl.h"
#elif IL2CPP_TARGET_WINDOWS
# include "os/Win32/SocketImpl.h"
#elif IL2CPP_TARGET_SWITCH
# include "os/SocketImpl.h"
#else
# include "os/Generic/SocketImpl.h"
#endif


namespace il2cpp
{
namespace os
{
    typedef std::map<SocketHandle, Socket&> SocketHandleTable;

    baselib::ReentrantLock g_SocketHandleTableMutex;
    SocketHandleTable g_SocketHandleTable;

    SocketHandle CreateSocketHandle(Socket* socket)
    {
        // Get the handle from the socket file descripter.
        SocketHandle newHandle = (SocketHandle)socket->GetDescriptor();

        // If the descripter is invalid we revert to the old method
        if (newHandle == kInvalidSocketHandle)
        {
            IL2CPP_ASSERT(0 && "Attempted to get an invalid socket handle. Should not be in this method.");
            return kInvalidSocketHandle;
        }

        // Add to table.
        {
            FastAutoLock lock(&g_SocketHandleTableMutex);
            auto insertRes = g_SocketHandleTable.insert(SocketHandleTable::value_type(newHandle, *socket));
            IL2CPP_ASSERT(insertRes.second && "Attempted to add a handle to the map that was already there.");
        }

        return newHandle;
    }

    Socket* AcquireSocketHandle(SocketHandle handle)
    {
        if (handle == kInvalidSocketHandle)
            return NULL;

        FastAutoLock lock(&g_SocketHandleTableMutex);

        // Look up in table.
        SocketHandleTable::iterator iter = g_SocketHandleTable.find(handle);
        if (iter == g_SocketHandleTable.end())
            return NULL;

        // Increase reference count.
        Socket& socket = iter->second;
        ++socket.m_RefCount;

        return &socket;
    }

    void ReleaseSocketHandle(SocketHandle handle, Socket* socketToRelease, bool forceTableRemove)
    {
        if (handle == kInvalidSocketHandle || !socketToRelease)
        {
            IL2CPP_ASSERT(0 && "Invalid argument in ReleaseSocketHandle");
            return;
        }

        Socket* socketToDelete = NULL;
        {
            FastAutoLock lock(&g_SocketHandleTableMutex);

            IL2CPP_ASSERT(socketToRelease->m_RefCount && "Invalid ref count for Socket");
            --socketToRelease->m_RefCount;

            // Look up in table.
            SocketHandleTable::iterator iter = g_SocketHandleTable.find(handle);
            if (iter != g_SocketHandleTable.end() &&
                ((socketToRelease == &iter->second && !socketToRelease->m_RefCount) || forceTableRemove))
            {
                g_SocketHandleTable.erase(iter);
            }

            if (!socketToRelease->m_RefCount)
            {
                // Kill socket. Should be the only place where we directly delete sockets that
                // have made it past the creation step.
                socketToDelete = socketToRelease;
            }
        }

        // Perform the deletion after we have released the lock so we don't unnecessarily
        // prevent other threads from accessing the table.
        if (socketToDelete)
            delete socketToDelete;
    }

    void Socket::Startup()
    {
        return SocketImpl::Startup();
    }

    void Socket::Cleanup()
    {
        return SocketImpl::Cleanup();
    }

    WaitStatus Socket::GetHostName(std::string &name)
    {
        return SocketImpl::GetHostName(name);
    }

    WaitStatus Socket::GetHostByAddr(const std::string &address, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addr_list)
    {
        return SocketImpl::GetHostByAddr(address, name, aliases, addr_list);
    }

    WaitStatus Socket::GetHostByName(const std::string &host, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addresses)
    {
        return SocketImpl::GetHostByName(host, name, aliases, addresses);
    }

    WaitStatus Socket::GetHostByName(const std::string &host, std::string &name, int32_t &family, std::vector<std::string> &aliases, std::vector<void*> &addr_list, int32_t &addr_size)
    {
        return SocketImpl::GetHostByName(host, name, family, aliases, addr_list, addr_size);
    }

    Socket::Socket(ThreadStatusCallback thread_status_callback)
        : m_Socket(new SocketImpl(thread_status_callback)), m_RefCount(1)
    {
    }

    Socket::~Socket()
    {
        if (!IsClosed())
            Close();

        delete m_Socket;
        m_Socket = 0;
    }

    int64_t Socket::GetDescriptor()
    {
        if (IsClosed())
            return -1;

        return m_Socket->GetDescriptor();
    }

    WaitStatus Socket::Create(int64_t fd, int32_t family, int32_t type, int32_t protocol)
    {
        return m_Socket->Create((SocketImpl::SocketDescriptor)fd, family, type, protocol);
    }

    WaitStatus Socket::Create(AddressFamily family, SocketType type, ProtocolType protocol)
    {
        return m_Socket->Create(family, type, protocol);
    }

    bool Socket::IsClosed()
    {
        return m_Socket->IsClosed();
    }

    void Socket::Close()
    {
        m_Socket->Close();
    }

    ErrorCode Socket::GetLastError() const
    {
        return m_Socket->GetLastError();
    }

    WaitStatus Socket::SetBlocking(bool blocking)
    {
        return m_Socket->SetBlocking(blocking);
    }

    WaitStatus Socket::Bind(const char *path)
    {
        return m_Socket->Bind(path);
    }

    WaitStatus Socket::Bind(uint32_t address, uint16_t port)
    {
        return m_Socket->Bind(address, port);
    }

    WaitStatus Socket::Bind(const char *address, uint16_t port)
    {
        return m_Socket->Bind(address, port);
    }

    utils::Expected<WaitStatus> Socket::Bind(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
        return m_Socket->Bind(address, scope, port);
    }

    WaitStatus Socket::Connect(const char *path)
    {
        return m_Socket->Connect(path);
    }

    WaitStatus Socket::Connect(uint32_t address, uint16_t port)
    {
        return m_Socket->Connect(address, port);
    }

    utils::Expected<WaitStatus> Socket::Connect(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
        return m_Socket->Connect(address, scope, port);
    }

    WaitStatus Socket::Disconnect(bool reuse)
    {
        return m_Socket->Disconnect(reuse);
    }

    WaitStatus Socket::Shutdown(int32_t how)
    {
        return m_Socket->Shutdown(how);
    }

    WaitStatus Socket::GetLocalEndPointInfo(EndPointInfo &info)
    {
        return m_Socket->GetLocalEndPointInfo(info);
    }

    WaitStatus Socket::GetRemoteEndPointInfo(EndPointInfo &info)
    {
        return m_Socket->GetRemoteEndPointInfo(info);
    }

    WaitStatus Socket::Listen(int32_t backlog)
    {
        return m_Socket->Listen(backlog);
    }

    WaitStatus Socket::Accept(Socket **socket)
    {
        return m_Socket->Accept(socket);
    }

    WaitStatus Socket::Receive(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        return m_Socket->Receive(data, count, flags, len);
    }

    WaitStatus Socket::ReceiveArray(WSABuf *wsabufs, int32_t count, int32_t *len, SocketFlags c_flags)
    {
        return m_Socket->ReceiveArray(wsabufs, count, len, c_flags);
    }

    WaitStatus Socket::Send(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        return m_Socket->Send(data, count, flags, len);
    }

    WaitStatus Socket::SendArray(WSABuf *wsabufs, int32_t count, int32_t *sent, SocketFlags c_flags)
    {
        return m_Socket->SendArray(wsabufs, count, sent, c_flags);
    }

    WaitStatus Socket::SendTo(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        return m_Socket->SendTo(address, port, data, count, flags, len);
    }

    utils::Expected<WaitStatus> Socket::SendTo(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        return m_Socket->SendTo(path, data, count, flags, len);
    }

    utils::Expected<WaitStatus> Socket::SendTo(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        return m_Socket->SendTo(address, scope, port, data, count, flags, len);
    }

    WaitStatus Socket::RecvFrom(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        return m_Socket->RecvFrom(address, port, data, count, flags, len, ep);
    }

    utils::Expected<WaitStatus> Socket::RecvFrom(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        return m_Socket->RecvFrom(path, data, count, flags, len, ep);
    }

    utils::Expected<WaitStatus> Socket::RecvFrom(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        return m_Socket->RecvFrom(address, scope, port, data, count, flags, len, ep);
    }

    WaitStatus Socket::Available(int32_t *amount)
    {
        return m_Socket->Available(amount);
    }

    WaitStatus Socket::Ioctl(int32_t command, const uint8_t *in_data, int32_t in_len, uint8_t *out_data, int32_t out_len, int32_t *written)
    {
        return m_Socket->Ioctl(command, in_data, in_len, out_data, out_len, written);
    }

    WaitStatus Socket::GetSocketOption(SocketOptionLevel level, SocketOptionName name, uint8_t *buffer, int32_t *length)
    {
        return m_Socket->GetSocketOption(level, name, buffer, length);
    }

    WaitStatus Socket::GetSocketOptionFull(SocketOptionLevel level, SocketOptionName name, int32_t *first, int32_t *second)
    {
        return m_Socket->GetSocketOptionFull(level, name, first, second);
    }

    WaitStatus Socket::Poll(std::vector<PollRequest> &requests, int32_t count, int32_t timeout, int32_t *result, int32_t *error)
    {
        return SocketImpl::Poll(requests, count, timeout, result, error);
    }

    WaitStatus Socket::Poll(std::vector<PollRequest> &requests, int32_t timeout, int32_t *result, int32_t *error)
    {
        return SocketImpl::Poll(requests, timeout, result, error);
    }

    WaitStatus Socket::Poll(PollRequest& request, int32_t timeout, int32_t *result, int32_t *error)
    {
        return SocketImpl::Poll(request, timeout, result, error);
    }

    WaitStatus Socket::SetSocketOption(SocketOptionLevel level, SocketOptionName name, int32_t value)
    {
        return m_Socket->SetSocketOption(level, name, value);
    }

    WaitStatus Socket::SetSocketOptionLinger(SocketOptionLevel level, SocketOptionName name, bool enabled, int32_t seconds)
    {
        return m_Socket->SetSocketOptionLinger(level, name, enabled, seconds);
    }

    WaitStatus Socket::SetSocketOptionArray(SocketOptionLevel level, SocketOptionName name, const uint8_t *buffer, int32_t length)
    {
        return m_Socket->SetSocketOptionArray(level, name, buffer, length);
    }

    WaitStatus Socket::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, uint32_t group_address, uint32_t local_address)
    {
        return m_Socket->SetSocketOptionMembership(level, name, group_address, local_address);
    }

#if IL2CPP_SUPPORT_IPV6
    WaitStatus Socket::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, IPv6Address ipv6, uint64_t interfaceOffset)
    {
        return m_Socket->SetSocketOptionMembership(level, name, ipv6, interfaceOffset);
    }

#endif

#if IL2CPP_SUPPORT_IPV6_SUPPORT_QUERY
    bool Socket::IsIPv6Supported()
    {
        return SocketImpl::IsIPv6Supported();
    }

#endif

    WaitStatus Socket::SendFile(const char *filename, TransmitFileBuffers *buffers, TransmitFileOptions options)
    {
        return m_Socket->SendFile(filename, buffers, options);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Socket.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\StackTrace.cpp---------------
.
.
#include "il2cpp-config.h"

#include "StackTrace.h"

namespace il2cpp
{
namespace os
{
    static Il2CppBacktraceFunc s_StackBacktraceFunc = 0;

    void StackTrace::WalkStack(WalkStackCallback callback, void* context, WalkOrder walkOrder)
    {
        if (s_StackBacktraceFunc == 0)
        {
            StackTrace::WalkStackNative(callback, context, walkOrder);
            return;
        }
        const int kMaxStackFrames = 128;
        Il2CppMethodPointer addrs[kMaxStackFrames];
        size_t size = s_StackBacktraceFunc(addrs, kMaxStackFrames);
        for (size_t i = 0; i < size; ++i)
        {
            const size_t index = (walkOrder == os::StackTrace::kFirstCalledToLastCalled) ? (size - i - 1) : i;
            if (!callback(addrs[index], context))
                break;
        }
    }

    void StackTrace::OverrideStackBacktrace(Il2CppBacktraceFunc stackBacktraceFunc)
    {
        s_StackBacktraceFunc = stackBacktraceFunc;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\StackTrace.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Thread.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"
#include "os/Thread.h"

#if IL2CPP_SUPPORT_THREADS

#include "os/Mutex.h"
#include "os/ThreadLocalValue.h"
#if IL2CPP_THREADS_STD
#include "os/Std/ThreadImpl.h"
#elif IL2CPP_TARGET_WINDOWS
#include "os/Win32/ThreadImpl.h"
#elif IL2CPP_THREADS_PTHREAD
#include "os/Posix/ThreadImpl.h"
#else
#include "os/ThreadImpl.h"
#endif

#include "utils/dynamic_array.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

#include <limits>

namespace il2cpp
{
namespace os
{
/// TLS variable referring to current thread.
    static ThreadLocalValue s_CurrentThread;

    // TLS variable referring to whether this thread is currently executing Thread::Shutdown
    // It is thread local for thread safety
    static ThreadLocalValue s_IsCleaningUpThreads;

    struct ThreadContext
    {
        baselib::ReentrantLock m_AliveThreadsMutex;
        il2cpp::utils::dynamic_array<Thread*> m_AliveThreads;
    };

    ThreadContext* s_ThreadContext = nullptr;

    int64_t Thread::s_DefaultAffinityMask = kThreadAffinityAll;

    static bool GetIsCleaningUpThreads()
    {
        void* value = NULL;
        s_IsCleaningUpThreads.GetValue(&value);
        return reinterpret_cast<intptr_t>(value) != 0;
    }

    static void SetIsCleaningUpThreads(bool value)
    {
        s_IsCleaningUpThreads.SetValue(reinterpret_cast<void*>(static_cast<intptr_t>(value)));
    }

    Thread::Thread()
        : m_Thread(new ThreadImpl())
        , m_State(kThreadCreated)
        , m_ThreadExitedEvent(true) // Manual reset event
        , m_CleanupFunc(NULL)
        , m_CleanupFuncArg(NULL)
    {
        FastAutoLock lock(&s_ThreadContext->m_AliveThreadsMutex);
        s_ThreadContext->m_AliveThreads.push_back(this);
    }

    Thread::Thread(ThreadImpl* thread)
        : m_Thread(thread)
        , m_State(kThreadRunning)
        , m_ThreadExitedEvent(true) // Manual reset event
        , m_CleanupFunc(NULL)
        , m_CleanupFuncArg(NULL)
    {
        FastAutoLock lock(&s_ThreadContext->m_AliveThreadsMutex);
        s_ThreadContext->m_AliveThreads.push_back(this);
    }

    Thread::~Thread()
    {
        delete m_Thread;

        if (!GetIsCleaningUpThreads())
        {
            FastAutoLock lock(&s_ThreadContext->m_AliveThreadsMutex);
            size_t count = s_ThreadContext->m_AliveThreads.size();
            for (size_t i = 0; i < count; i++)
            {
                if (s_ThreadContext->m_AliveThreads[i] == this)
                {
                    s_ThreadContext->m_AliveThreads.erase_swap_back(&s_ThreadContext->m_AliveThreads[i]);
                    break;
                }
            }
        }
    }

    void Thread::Init()
    {
        il2cpp::os::ThreadImpl::AllocateStaticData();

        s_ThreadContext = new ThreadContext();

        Thread* thread = GetOrCreateCurrentThread();
        if (thread->GetApartment() == kApartmentStateUnknown)
            thread->SetApartment(kApartmentStateInMTA);
    }

    void Thread::Shutdown()
    {
        Thread* currentThread = GetCurrentThread();
        currentThread->SetApartment(kApartmentStateUnknown);

        SetIsCleaningUpThreads(true);

        {
            FastAutoLock lock(&s_ThreadContext->m_AliveThreadsMutex);
            size_t count = s_ThreadContext->m_AliveThreads.size();
            for (size_t i = 0; i < count; i++)
            {
                // If this is not the current thread, wait a bit for it to exit. This will avoid an
                // infinite wait on shutdown, but it should give the thread enough time to complete its
                // use of the os::Thread object before we delete it. Note that we don't call Join here,
                // as we want to explicitly do a non-interruptable wait because we are pretty late in
                // the shutdown process. The VM thread code should have already caused any running
                // threads to get a thread abort exception, meaning that any running OS threads will
                // be exiting soon, with no need to check for APCs.
                if (s_ThreadContext->m_AliveThreads[i] != currentThread)
                {
                    s_ThreadContext->m_AliveThreads[i]->m_ThreadExitedEvent.Wait(10, false);
                    delete s_ThreadContext->m_AliveThreads[i];
                }
            }

            // Wait to delete the current thread last, as waiting on an event may need to access the current thread
            delete currentThread;

            s_ThreadContext->m_AliveThreads.clear();
        }

        SetIsCleaningUpThreads(false);
#if IL2CPP_ENABLE_RELOAD
        s_CurrentThread.SetValue(NULL);
#endif
        delete s_ThreadContext;
        s_ThreadContext = nullptr;

        il2cpp::os::ThreadImpl::FreeStaticData();
    }

    Thread::ThreadId Thread::Id()
    {
        return m_Thread->Id();
    }

    void Thread::SetName(const char* name)
    {
        m_Thread->SetName(name);
    }

    void Thread::SetPriority(ThreadPriority priority)
    {
        m_Thread->SetPriority(priority);
    }

    ThreadPriority Thread::GetPriority()
    {
        return m_Thread->GetPriority();
    }

    void Thread::SetStackSize(size_t stackSize)
    {
        m_Thread->SetStackSize(stackSize);
    }

    int Thread::GetMaxStackSize()
    {
        return ThreadImpl::GetMaxStackSize();
    }

    struct StartData
    {
        Thread* thread;
        Thread::StartFunc startFunction;
        void* startFunctionArgument;
    };

/// Wrapper for the user's thread start function. Sets s_CurrentThread.
    void Thread::RunWrapper(void* arg)
    {
        StartData* data = reinterpret_cast<StartData*>(arg);

        // Store thread reference.
        Thread* thread = data->thread;

        const ApartmentState apartment = thread->GetExplicitApartment();
        if (apartment != kApartmentStateUnknown)
        {
            thread->SetExplicitApartment(kApartmentStateUnknown);
            thread->SetApartment(apartment);
        }

        s_CurrentThread.SetValue(thread);

        // Get rid of StartData.
        StartFunc startFunction = data->startFunction;
        void* startFunctionArgument = data->startFunctionArgument;
        delete data;

        // Make sure thread exit event is not signaled.
        thread->m_ThreadExitedEvent.Reset();

        // Run user thread start function.
        thread->m_State = kThreadRunning;
        startFunction(startFunctionArgument);
        thread->m_State = kThreadExited;

        thread->SetApartment(kApartmentStateUnknown);

        CleanupFunc cleanupFunc = thread->m_CleanupFunc;
        void* cleanupFuncArg = thread->m_CleanupFuncArg;

        // Signal that we've finished execution.
        thread->m_ThreadExitedEvent.Set();

        if (cleanupFunc)
            cleanupFunc(cleanupFuncArg);
    }

    ErrorCode Thread::Run(StartFunc func, void* arg)
    {
        IL2CPP_ASSERT(m_State == kThreadCreated || m_State == kThreadExited);

        StartData* startData = new StartData;
        startData->startFunction = func;
        startData->startFunctionArgument = arg;
        startData->thread = this;

        return m_Thread->Run(RunWrapper, startData, s_DefaultAffinityMask);
    }

    WaitStatus Thread::Join()
    {
        IL2CPP_ASSERT(this != GetCurrentThread() && "Trying to join the current thread will deadlock");
        return Join(std::numeric_limits<uint32_t>::max());
    }

    WaitStatus Thread::Join(uint32_t ms)
    {
        // Wait for thread exit event.
        if (m_ThreadExitedEvent.Wait(ms, true) != kWaitStatusSuccess)
            return kWaitStatusFailure;

        return kWaitStatusSuccess;
    }

    void Thread::QueueUserAPC(APCFunc func, void* context)
    {
        m_Thread->QueueUserAPC(func, context);
    }

    ApartmentState Thread::GetApartment()
    {
#if IL2CPP_THREAD_IMPL_HAS_COM_APARTMENTS
        return m_Thread->GetApartment();
#else
        return kApartmentStateUnknown;
#endif
    }

    ApartmentState Thread::GetExplicitApartment()
    {
#if IL2CPP_THREAD_IMPL_HAS_COM_APARTMENTS
        return m_Thread->GetExplicitApartment();
#else
        return kApartmentStateUnknown;
#endif
    }

    ApartmentState Thread::SetApartment(ApartmentState state)
    {
#if IL2CPP_THREAD_IMPL_HAS_COM_APARTMENTS
        return m_Thread->SetApartment(state);
#else
        NO_UNUSED_WARNING(state);
        return GetApartment();
#endif
    }

    void Thread::SetExplicitApartment(ApartmentState state)
    {
#if IL2CPP_THREAD_IMPL_HAS_COM_APARTMENTS
        m_Thread->SetExplicitApartment(state);
#else
        NO_UNUSED_WARNING(state);
#endif
    }

    void Thread::Sleep(uint32_t milliseconds, bool interruptible)
    {
        ThreadImpl::Sleep(milliseconds, interruptible);
    }

    size_t Thread::CurrentThreadId()
    {
        return ThreadImpl::CurrentThreadId();
    }

    Thread* Thread::GetCurrentThread()
    {
        void* value;
        s_CurrentThread.GetValue(&value);
        IL2CPP_ASSERT(value != NULL);
        return reinterpret_cast<Thread*>(value);
    }

    bool Thread::HasCurrentThread()
    {
        void* value;
        s_CurrentThread.GetValue(&value);
        return value != NULL;
    }

    Thread* Thread::GetOrCreateCurrentThread()
    {
        Thread* thread = NULL;
        s_CurrentThread.GetValue(reinterpret_cast<void**>(&thread));
        if (thread)
            return thread;

        // The os::Thread object is deallocated in the InternalThread::Thread_free_internal icall, which
        // is called from the managed thread finalizer.
        thread = new Thread(ThreadImpl::CreateForCurrentThread());
        s_CurrentThread.SetValue(thread);

        return thread;
    }

    void Thread::DetachCurrentThread()
    {
        // PTHREAD cleanup isn't deterministic: it could be that our thread local variables get cleaned up before thread clean up routine runs
#if IL2CPP_DEBUG && !IL2CPP_THREADS_PTHREAD
        void* value;
        s_CurrentThread.GetValue(&value);
        IL2CPP_ASSERT(value != NULL);
#endif

        s_CurrentThread.SetValue(NULL);
    }

    bool Thread::YieldInternal()
    {
        return ThreadImpl::YieldInternal();
    }

    void Thread::SetDefaultAffinityMask(int64_t affinityMask)
    {
        s_DefaultAffinityMask = affinityMask;
    }

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP

    void Thread::SetNativeThreadCleanup(ThreadCleanupFunc cleanupFunction)
    {
        ThreadImpl::SetNativeThreadCleanup(cleanupFunction);
    }

    void Thread::RegisterCurrentThreadForCleanup(void* arg)
    {
        ThreadImpl::RegisterCurrentThreadForCleanup(arg);
    }

    void Thread::UnregisterCurrentThreadForCleanup()
    {
        ThreadImpl::UnregisterCurrentThreadForCleanup();
    }

    void Thread::SignalExited()
    {
        m_ThreadExitedEvent.Set();
    }

#endif
}
}

#else

#include <limits.h>

namespace il2cpp
{
namespace os
{
    int64_t Thread::s_DefaultAffinityMask = -1;

    Thread::Thread()
    {
    }

    Thread::~Thread()
    {
    }

    void Thread::Init()
    {
    }

    void Thread::Shutdown()
    {
    }

    Thread::ThreadId Thread::Id()
    {
        return 0;
    }

    void Thread::SetName(const char* name)
    {
    }

    void Thread::SetPriority(ThreadPriority priority)
    {
    }

    ThreadPriority Thread::GetPriority()
    {
        return kThreadPriorityLowest;
    }

    void Thread::SetStackSize(size_t stackSize)
    {
    }

    int Thread::GetMaxStackSize()
    {
        return INT_MAX;
    }

    void Thread::RunWrapper(void* arg)
    {
    }

    ErrorCode Thread::Run(StartFunc func, void* arg)
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return kErrorCodeSuccess;
    }

    WaitStatus Thread::Join()
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return kWaitStatusSuccess;
    }

    WaitStatus Thread::Join(uint32_t ms)
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return kWaitStatusSuccess;
    }

    void Thread::QueueUserAPC(APCFunc func, void* context)
    {
    }

    ApartmentState Thread::GetApartment()
    {
        return kApartmentStateUnknown;
    }

    ApartmentState Thread::GetExplicitApartment()
    {
        return kApartmentStateUnknown;
    }

    ApartmentState Thread::SetApartment(ApartmentState state)
    {
        return kApartmentStateUnknown;
    }

    void Thread::SetExplicitApartment(ApartmentState state)
    {
    }

    void Thread::Sleep(uint32_t milliseconds, bool interruptible)
    {
    }

    size_t Thread::CurrentThreadId()
    {
        return 0;
    }

    Thread* Thread::GetCurrentThread()
    {
        return NULL;
    }

    Thread* Thread::GetOrCreateCurrentThread()
    {
        return NULL;
    }

    void Thread::DetachCurrentThread()
    {
    }

    bool Thread::YieldInternal()
    {
        return false;
    }

    void Thread::SetDefaultAffinityMask(int64_t affinityMask)
    {
        s_DefaultAffinityMask = affinityMask;
    }

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP

    void Thread::SetNativeThreadCleanup(ThreadCleanupFunc cleanupFunction)
    {
    }

    void Thread::RegisterCurrentThreadForCleanup(void* arg)
    {
    }

    void Thread::UnregisterCurrentThreadForCleanup()
    {
    }

    void Thread::SignalExited()
    {
    }

#endif
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\ConsoleExtension.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_ANDROID

#include "utils/StringUtils.h"

#include <jni.h>
#include <android/log.h>

namespace il2cpp
{
namespace os
{
namespace ConsoleExtension
{
    void Write(const char* buffer)
    {
        __android_log_print(ANDROID_LOG_INFO, "IL2CPP", "%s", buffer);
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\ConsoleExtension.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\Initialize.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_ANDROID

#include <string>

#include "os/Initialize.h"
#include "os/LibraryLoader.h"
#include "utils/Logging.h"

#include <jni.h>
#include <android/log.h>

static void AndroidLogCallback(const char* message)
{
    __android_log_print(ANDROID_LOG_INFO, "IL2CPP", "%s", message);
}

JavaVM *sJavaVM = nullptr;

static const Il2CppNativeChar* AndroidLoadLibrary(const Il2CppNativeChar* libName)
{
    if (sJavaVM == nullptr)
    {
        __android_log_print(ANDROID_LOG_INFO, "IL2CPP", "Java VM not initialized");
        return libName;
    }

    if (libName != nullptr)
    {
        JNIEnv* env = nullptr;
        bool detached = sJavaVM->GetEnv((void**)&env, JNI_VERSION_1_2) == JNI_EDETACHED;
        if (detached)
        {
            sJavaVM->AttachCurrentThread(&env, NULL);
        }
        env->ExceptionClear();

        jclass systemClass = env->FindClass("java/lang/System");
        if (systemClass != nullptr)
        {
            jmethodID loadLibrary = env->GetStaticMethodID(systemClass, "loadLibrary", "(Ljava/lang/String;)V");
            if (loadLibrary != nullptr)
            {
                jstring jstr = env->NewStringUTF(libName);
                env->CallStaticVoidMethod(systemClass, loadLibrary, jstr);
                if (env->ExceptionCheck())
                {
                    env->ExceptionClear();

                    // try without lib prefix
                    if (std::string(libName).find("lib") == 0)
                    {
                        jstr = env->NewStringUTF(libName + 3);
                        env->CallStaticVoidMethod(systemClass, loadLibrary, jstr);
                    }
                }
            }
        }
        if (env->ExceptionCheck())
        {
            env->ExceptionClear();
        }
        if (detached)
        {
            sJavaVM->DetachCurrentThread();
        }
    }

    return libName;
}

extern "C"
JNIEXPORT jint JNI_OnLoad(JavaVM *jvm, void *reserved)
{
    __android_log_print(ANDROID_LOG_INFO, "IL2CPP", "JNI_OnLoad");
    sJavaVM = jvm;
    il2cpp::os::LibraryLoader::SetFindPluginCallback(AndroidLoadLibrary);
    return JNI_VERSION_1_6;
}

extern "C"
JNIEXPORT void JNI_OnUnload(JavaVM *jvm, void *reserved)
{
    __android_log_print(ANDROID_LOG_INFO, "IL2CPP", "JNI_OnUnload");
    sJavaVM = nullptr;
}

void il2cpp::os::Initialize()
{
    if (!utils::Logging::IsLogCallbackSet())
        utils::Logging::SetLogCallback(AndroidLogCallback);
}

void il2cpp::os::Uninitialize()
{
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\Initialize.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\Locale.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_ANDROID

#include <string>
#include <android/log.h>
#include <jni.h>

extern JavaVM *sJavaVM;

namespace il2cpp
{
namespace os
{
    std::string AndroidGetLocale()
    {
        std::string locale;
        if (sJavaVM == nullptr)
        {
            __android_log_print(ANDROID_LOG_INFO, "IL2CPP", "Java VM not initialized");
            return locale;
        }
        JNIEnv* env = nullptr;
        bool detached = sJavaVM->GetEnv((void**)&env, JNI_VERSION_1_2) == JNI_EDETACHED;
        if (detached)
        {
            sJavaVM->AttachCurrentThread(&env, NULL);
        }

        jclass localeClass = env->FindClass("java/util/Locale");
        if (localeClass != nullptr)
        {
            jmethodID getDefault = env->GetStaticMethodID(localeClass, "getDefault", "()Ljava/util/Locale;");
            if (getDefault != nullptr)
            {
                jobject def = env->CallStaticObjectMethod(localeClass, getDefault);
                jmethodID toLanguageTag = env->GetMethodID(localeClass, "toLanguageTag", "()Ljava/lang/String;");
                // toLanguageTag is available since API 21 only, so returning default locale for Android 4.4
                if (toLanguageTag != nullptr)
                {
                    jstring tag = (jstring)env->CallObjectMethod(def, toLanguageTag);
                    const char *nativeTag = env->GetStringUTFChars(tag, nullptr);
                    __android_log_print(ANDROID_LOG_INFO, "IL2CPP", "Locale %s", nativeTag);
                    locale = nativeTag;
                    env->ReleaseStringUTFChars(tag, nativeTag);
                }
            }
        }
        if (env->ExceptionCheck())
        {
            env->ExceptionClear();
        }

        if (detached)
            sJavaVM->DetachCurrentThread();
        return locale;
    }
} /* namespace os */
} /* namespace il2cpp */

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\Locale.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\StackTrace.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_ANDROID

#include "os/StackTrace.h"
#include "os/Image.h"

#include <unwind.h>
#include <dlfcn.h>
#include <link.h>
#include <pthread.h>
#include <string.h>

namespace il2cpp
{
namespace os
{
    const int kMaxStackFrames = 128;

namespace
{
    extern "C" char end;

    uintptr_t s_BaseAddress;
    uintptr_t s_EndAddress;
    uintptr_t s_LibUnityBaseAddress;
    uintptr_t s_LibUnityEndAddress;
    pthread_once_t s_InitKnownSymbolInfoOnceFlag = PTHREAD_ONCE_INIT;

    static int
    libUnityLookupCallback(struct dl_phdr_info *info, size_t size, void *data)
    {
        int j;
        uintptr_t endAddr;

        // dlpi_name can have different values depending on Android OS:
        // Google Pixel 2 Android 10, dlpi_name will be "/data/app/com.unity.stopaskingforpackagename-uRHSDLXYA4cnHxyTNT30-g==/lib/arm/libunity.so"
        // Samsung GT-I9505 Android 5, dlpi_name will be "libunity.so"
        if (info->dlpi_name == NULL || strstr(info->dlpi_name, "libunity.so") == NULL)
            return 0;

        s_LibUnityBaseAddress = s_LibUnityEndAddress = info->dlpi_addr;

        for (j = 0; j < info->dlpi_phnum; j++)
        {
            endAddr = (uintptr_t)(((char*)info->dlpi_addr) + info->dlpi_phdr[j].p_vaddr + info->dlpi_phdr[j].p_memsz);
            if (s_LibUnityEndAddress < endAddr)
                s_LibUnityEndAddress = endAddr;
        }
        return 0;
    }

    static void InitKnownSymbolInfo()
    {
        s_BaseAddress = reinterpret_cast<uintptr_t>(os::Image::GetImageBase());
        s_EndAddress = reinterpret_cast<uintptr_t>(&end);

        dl_iterate_phdr(libUnityLookupCallback, NULL);
    }

    static bool KnownSymbol(const uintptr_t addr)
    {
        pthread_once(&s_InitKnownSymbolInfoOnceFlag, &InitKnownSymbolInfo);

        if (addr >= s_BaseAddress && addr <= s_EndAddress)
            return true;

        if (addr >= s_LibUnityBaseAddress && addr <= s_LibUnityEndAddress)
            return true;

        return false;
    }

    struct AndroidStackTrace
    {
        size_t size;
        Il2CppMethodPointer addrs[kMaxStackFrames];

        bool PushStackFrameAddress(const uintptr_t addr)
        {
            if (size >= kMaxStackFrames)
                return false;

            addrs[size++] = reinterpret_cast<Il2CppMethodPointer>(addr);
            return true;
        }

        static _Unwind_Reason_Code Callback(struct _Unwind_Context* context, void* self)
        {
            const uintptr_t addr = _Unwind_GetIP(context);

            // Workaround to avoid crash when generating stack trace in some third-party libraries
            if (!KnownSymbol(addr))
                return _URC_END_OF_STACK;

            if (static_cast<AndroidStackTrace*>(self)->PushStackFrameAddress(addr))
                return _URC_NO_REASON;
            else
                return _URC_END_OF_STACK;
        }
    };
}

    void StackTrace::WalkStackNative(WalkStackCallback callback, void* context, WalkOrder walkOrder)
    {
        AndroidStackTrace callstack = {};
        _Unwind_Backtrace(AndroidStackTrace::Callback, &callstack);
        for (size_t i = 0; i < callstack.size; ++i)
        {
            const size_t index = (walkOrder == kFirstCalledToLastCalled) ? (callstack.size - i - 1) : i;
            if (!callback(callstack.addrs[index], context))
                break;
        }
    }

    std::string StackTrace::NativeStackTrace()
    {
        return std::string();
    }

    const void* StackTrace::GetStackPointer()
    {
        return __builtin_frame_address(0);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Android\StackTrace.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Allocator.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Allocator.h"

static allocate_func s_AllocatorFunc;
static free_func s_ReleaseFunc;

extern "C"
{
    void register_allocator(allocate_func allocator, free_func release)
    {
        s_AllocatorFunc = allocator;
        s_ReleaseFunc = release;
    }

    void free_memory(void* memory)
    {
        Allocator::Free(memory);
    }
}

void* Allocator::Allocate(size_t size)
{
    IL2CPP_ASSERT(s_AllocatorFunc);
    return s_AllocatorFunc(size);
}

void Allocator::Free(void* memory)
{
    IL2CPP_ASSERT(s_ReleaseFunc);
    s_ReleaseFunc(memory);
}

char* Allocator::CopyToAllocatedStringBuffer(const std::string& input)
{
    size_t size = input.size();
    char* buffer = (char*)Allocator::Allocate(size + 1);
    input.copy(buffer, size);
    buffer[size] = '\0';
    return buffer;
}

char* Allocator::CopyToAllocatedStringBuffer(const char* input)
{
    size_t size = strlen(input);
    char* buffer = (char*)Allocator::Allocate(size + 1);
    strcpy(buffer, input);
    return buffer;
}

void Allocator::CopyStringVectorToNullTerminatedArray(const std::vector<std::string>& input, void*** output)
{
    if (output != NULL)
    {
        size_t numberOfAddresses = input.size();
        *output = (void**)Allocate(sizeof(void*) * (numberOfAddresses + 1));
        for (size_t i = 0; i < numberOfAddresses; ++i)
            (*output)[i] = CopyToAllocatedStringBuffer(input[i].c_str());

        (*output)[numberOfAddresses] = NULL;
    }
}

void Allocator::CopyDataVectorToNullTerminatedArray(const std::vector<void*>& input, void*** output, int32_t elementSize)
{
    if (output != NULL)
    {
        size_t numberOfEntries = input.size();
        *output = (void**)Allocate(sizeof(void*) * (numberOfEntries + 1));
        for (size_t i = 0; i < numberOfEntries; ++i)
        {
            (*output)[i] = (void*)Allocate(elementSize);
            memcpy((*output)[i], input[i], elementSize);
        }

        (*output)[numberOfEntries] = NULL;
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Allocator.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Directory.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#include "os/Directory.h"
#include "os/c-api/Directory-c-api.h"
#include "Allocator.h"
#include "utils/StringUtils.h"
#include "utils/StringViewUtils.h"

#include <string>

extern "C"
{
    const char* UnityPalDirectoryGetCurrent(int* error)
    {
        return Allocator::CopyToAllocatedStringBuffer(il2cpp::os::Directory::GetCurrent(error));
    }

    UnityPalFindHandle* UnityPalDirectoryFindHandleNew(const char* searchPathWithPattern)
    {
        Il2CppNativeString pattern(il2cpp::utils::StringUtils::Utf8ToNativeString(searchPathWithPattern));
        return new il2cpp::os::Directory::FindHandle(STRING_TO_STRINGVIEW(pattern));
    }

    void UnityPalDirectoryFindHandleDelete(UnityPalFindHandle* object)
    {
        IL2CPP_ASSERT(object);
        delete object;
    }

    int32_t UnityPalDirectoryCloseOSHandle(UnityPalFindHandle* object)
    {
        IL2CPP_ASSERT(object);
        return object->CloseOSHandle();
    }

    UnityPalErrorCode UnityPalDirectoryFindFirstFile(UnityPalFindHandle* findHandle, const char* searchPathWithPattern, char** resultFileName, int32_t* resultAttributes)
    {
        Il2CppNativeString pattern(il2cpp::utils::StringUtils::Utf8ToNativeString(searchPathWithPattern));
        Il2CppNativeString nativeFileName;
        UnityPalErrorCode retVal = il2cpp::os::Directory::FindFirstFile(findHandle, STRING_TO_STRINGVIEW(pattern), &nativeFileName, resultAttributes);
        *resultFileName = Allocator::CopyToAllocatedStringBuffer(il2cpp::utils::StringUtils::NativeStringToUtf8(nativeFileName));
        return retVal;
    }

    UnityPalErrorCode UnityPalDirectoryFindNextFile(UnityPalFindHandle*  findHandle, char** resultFileName, int32_t* resultAttributes)
    {
        Il2CppNativeString nativeFileName;
        UnityPalErrorCode retVal = il2cpp::os::Directory::FindNextFile(findHandle, &nativeFileName, resultAttributes);
        *resultFileName = Allocator::CopyToAllocatedStringBuffer(il2cpp::utils::StringUtils::NativeStringToUtf8(nativeFileName));
        return retVal;
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Directory.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Environment.cpp---------------
.
.
#include "il2cpp-config.h"

#include "os/Environment.h"
#include "os/c-api/Environment-c-api.h"
#include "Allocator.h"

extern "C"
{
    char* UnityPalGetOsUserName()
    {
        return Allocator::CopyToAllocatedStringBuffer(il2cpp::os::Environment::GetOsUserName());
    }

    char* UnityPalGetEnvironmentVariable(const char* name)
    {
        std::string name_string = name;
        std::string variable = il2cpp::os::Environment::GetEnvironmentVariable(name_string);
        if (variable.empty())
            return NULL;
        return Allocator::CopyToAllocatedStringBuffer(variable);
    }

    void UnityPalSetEnvironmentVariable(const char* name, const char* value)
    {
        std::string name_string = name;
        std::string value_string = value;
        il2cpp::os::Environment::SetEnvironmentVariable(name, value);
    }

    char* UnityPalGetHomeDirectory()
    {
        std::string home_directory = il2cpp::os::Environment::GetHomeDirectory();
        if (home_directory.empty())
            return NULL;
        return Allocator::CopyToAllocatedStringBuffer(home_directory);
    }

    int32_t UnityPalGetProcessorCount()
    {
        return il2cpp::os::Environment::GetProcessorCount();
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Environment.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Error.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#include "os/Error.h"
#include "os/c-api/Error-c-api.h"

extern "C"
{
    int32_t UnityPalSuccess(UnityPalErrorCode code)
    {
        return (int32_t)(code == il2cpp::os::kErrorCodeSuccess);
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Error.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\File.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#include "os/File.h"
#include "os/c-api/File-c-api.h"
#include "os/c-api/Allocator.h"

extern "C"
{
    UnityPalFileAttributes UnityPalGetFileAttributes(const char* path, int* error)
    {
        return il2cpp::os::File::GetFileAttributes(path, error);
    }

    int32_t UnityPalGetFileStat(const char* path, UnityPalFileStat * stat, int* error)
    {
        il2cpp::os::FileStat cppStat;
        bool result = il2cpp::os::File::GetFileStat(path, &cppStat, error);

        stat->name = Allocator::CopyToAllocatedStringBuffer(cppStat.name);
        stat->attributes = cppStat.attributes;
        stat->creation_time = cppStat.creation_time;
        stat->last_access_time = cppStat.last_access_time;
        stat->last_write_time = cppStat.last_write_time;
        stat->length = cppStat.length;

        return result;
    }

    UnityPalFileHandle* UnityPalOpen(const char* path, int openMode, int accessMode, int shareMode, int options, int *error)
    {
        int localError;
        il2cpp::os::FileHandle* handle = il2cpp::os::File::Open(path, openMode, accessMode, shareMode, options, &localError);
        if (error != NULL)
            *error = localError;

        if (localError != il2cpp::os::kErrorCodeSuccess)
            return NULL;

        return handle;
    }

    int32_t UnityPalClose(UnityPalFileHandle* handle, int *error)
    {
        return il2cpp::os::File::Close(handle, error);
    }

    int UnityPalRead(UnityPalFileHandle* handle, char *dest, int count, int *error)
    {
        return il2cpp::os::File::Read(handle, dest, count, error);
    }

    int32_t UnityPalIsExecutable(const char* filename)
    {
        return il2cpp::os::File::IsExecutable(filename).Get();
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\File.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Locale.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/c-api/il2cpp-config-platforms.h"

#include "os/Locale.h"
#include "Allocator.h"

#include <string>

extern "C"
{
    void UnityPalLocaleInitialize()
    {
        il2cpp::os::Locale::Initialize();
    }

    char* UnityPalGetLocale()
    {
        return Allocator::CopyToAllocatedStringBuffer(il2cpp::os::Locale::GetLocale());
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Locale.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Path.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#include "os/Path.h"
#include "utils/PathUtils.h"
#include "Allocator.h"

extern "C"
{
    const char* UnityPalGetTempPath()
    {
        return Allocator::CopyToAllocatedStringBuffer(il2cpp::os::Path::GetTempPath());
    }

    int32_t UnityPalIsAbsolutePath(const char* path)
    {
        if (path == NULL)
            return 0;
        std::string path_string = path;
        return il2cpp::os::Path::IsAbsolute(path_string);
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Path.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Socket.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#include "os/c-api/Socket-c-api.h"
#include "os/c-api/Allocator.h"
#include "os/Socket.h"
#include "utils/Memory.h"
#include <string>
#include <vector>

UnityPalWaitStatus UnityPalGetHostByName(const char* host, char** name, int32_t* family, char*** aliases, void*** address_list, int32_t* address_size)
{
    std::string palName;
    int32_t palFamily;
    std::vector<std::string> palAliases;
    std::vector<void*> palAddressList;
    int32_t palAddressSize;
    il2cpp::os::WaitStatus result = il2cpp::os::Socket::GetHostByName(host, palName, palFamily, palAliases, palAddressList, palAddressSize);

    if (name != NULL)
        *name = Allocator::CopyToAllocatedStringBuffer(palName.c_str());

    if (family != NULL)
        *family = palFamily;

    Allocator::CopyStringVectorToNullTerminatedArray(palAliases, (void***)aliases);
    Allocator::CopyDataVectorToNullTerminatedArray(palAddressList, address_list, palAddressSize);

    if (address_size != NULL)
        *address_size = palAddressSize;

    for (size_t i = 0; i < palAddressList.size(); ++i)
        il2cpp::utils::Memory::Free(palAddressList[i]);

    return result;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Socket.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Thread.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#include "Thread-c-api.h"
#include "os/Thread.h"

void UnityPalSleep(uint32_t milliseconds)
{
    il2cpp::os::Thread::Sleep(milliseconds, false);
}

UnityPalThreadId UnityPalGetCurrentThreadId()
{
    return il2cpp::os::Thread::GetCurrentThread()->Id();
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Time.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#include "os/Time.h"

#include <stdint.h>
#include <time.h>

extern "C"
{
    uint32_t UnityPalGetTicksMillisecondsMonotonic()
    {
        return il2cpp::os::Time::GetTicksMillisecondsMonotonic();
    }

    int64_t UnityPalGetTicks100NanosecondsDateTime()
    {
        return il2cpp::os::Time::GetTicks100NanosecondsDateTime();
    }

    int64_t STDCALL UnityPalGetTicks100NanosecondsMonotonic()
    {
        return il2cpp::os::Time::GetTicks100NanosecondsMonotonic();
    }

    int64_t STDCALL UnityPalGetSystemTimeAsFileTime()
    {
        return il2cpp::os::Time::GetSystemTimeAsFileTime();
    }
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\c-api\Time.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_errno.cpp---------------
.
.
#include "il2cpp-config.h"
#include "pal_platform.h"

#if IL2CPP_USES_POSIX_CLASS_LIBRARY_PAL

#include <errno.h>

extern "C"
{
    // Items needed by mscorlib
    IL2CPP_EXPORT int32_t SystemNative_ConvertErrorPlatformToPal(int32_t platformErrno);
    IL2CPP_EXPORT const char* SystemNative_StrErrorR(int32_t platformErrno, char* buffer, int32_t bufferSize);
    IL2CPP_EXPORT int32_t SystemNative_ConvertErrorPalToPlatform(int32_t error);
}

/**
 * Error codes returned via ConvertErrno.
 *
 * Only the names (without the PAL_ prefix) are specified by POSIX.
 *
 * The values chosen below are simply assigned arbitrarily (originally
 * in alphabetical order they appear in the spec, but they can't change so
 * add new values to the end!).
 *
 * Also, the values chosen are deliberately outside the range of
 * typical UNIX errnos (small numbers), HRESULTs (negative for errors)
 * and Win32 errors (0x0000 - 0xFFFF). This isn't required for
 * correctness, but may help debug a caller that is interpreting a raw
 * int incorrectly.
 *
 * Wherever the spec says "x may be the same value as y", we do use
 * the same value so that callers cannot not take a dependency on
 * being able to distinguish between them.
 */
enum Error
{
    Error_SUCCESS = 0,

    Error_E2BIG = 0x10001,           // Argument list too long.
    Error_EACCES = 0x10002,          // Permission denied.
    Error_EADDRINUSE = 0x10003,      // Address in use.
    Error_EADDRNOTAVAIL = 0x10004,   // Address not available.
    Error_EAFNOSUPPORT = 0x10005,    // Address family not supported.
    Error_EAGAIN = 0x10006,          // Resource unavailable, try again (same value as EWOULDBLOCK),
    Error_EALREADY = 0x10007,        // Connection already in progress.
    Error_EBADF = 0x10008,           // Bad file descriptor.
    Error_EBADMSG = 0x10009,         // Bad message.
    Error_EBUSY = 0x1000A,           // Device or resource busy.
    Error_ECANCELED = 0x1000B,       // Operation canceled.
    Error_ECHILD = 0x1000C,          // No child processes.
    Error_ECONNABORTED = 0x1000D,    // Connection aborted.
    Error_ECONNREFUSED = 0x1000E,    // Connection refused.
    Error_ECONNRESET = 0x1000F,      // Connection reset.
    Error_EDEADLK = 0x10010,         // Resource deadlock would occur.
    Error_EDESTADDRREQ = 0x10011,    // Destination address required.
    Error_EDOM = 0x10012,            // Mathematics argument out of domain of function.
    Error_EDQUOT = 0x10013,          // Reserved.
    Error_EEXIST = 0x10014,          // File exists.
    Error_EFAULT = 0x10015,          // Bad address.
    Error_EFBIG = 0x10016,           // File too large.
    Error_EHOSTUNREACH = 0x10017,    // Host is unreachable.
    Error_EIDRM = 0x10018,           // Identifier removed.
    Error_EILSEQ = 0x10019,          // Illegal byte sequence.
    Error_EINPROGRESS = 0x1001A,     // Operation in progress.
    Error_EINTR = 0x1001B,           // Interrupted function.
    Error_EINVAL = 0x1001C,          // Invalid argument.
    Error_EIO = 0x1001D,             // I/O error.
    Error_EISCONN = 0x1001E,         // Socket is connected.
    Error_EISDIR = 0x1001F,          // Is a directory.
    Error_ELOOP = 0x10020,           // Too many levels of symbolic links.
    Error_EMFILE = 0x10021,          // File descriptor value too large.
    Error_EMLINK = 0x10022,          // Too many links.
    Error_EMSGSIZE = 0x10023,        // Message too large.
    Error_EMULTIHOP = 0x10024,       // Reserved.
    Error_ENAMETOOLONG = 0x10025,    // Filename too long.
    Error_ENETDOWN = 0x10026,        // Network is down.
    Error_ENETRESET = 0x10027,       // Connection aborted by network.
    Error_ENETUNREACH = 0x10028,     // Network unreachable.
    Error_ENFILE = 0x10029,          // Too many files open in system.
    Error_ENOBUFS = 0x1002A,         // No buffer space available.
    Error_ENODEV = 0x1002C,          // No such device.
    Error_ENOENT = 0x1002D,          // No such file or directory.
    Error_ENOEXEC = 0x1002E,         // Executable file format error.
    Error_ENOLCK = 0x1002F,          // No locks available.
    Error_ENOLINK = 0x10030,         // Reserved.
    Error_ENOMEM = 0x10031,          // Not enough space.
    Error_ENOMSG = 0x10032,          // No message of the desired type.
    Error_ENOPROTOOPT = 0x10033,     // Protocol not available.
    Error_ENOSPC = 0x10034,          // No space left on device.
    Error_ENOSYS = 0x10037,          // Function not supported.
    Error_ENOTCONN = 0x10038,        // The socket is not connected.
    Error_ENOTDIR = 0x10039,         // Not a directory or a symbolic link to a directory.
    Error_ENOTEMPTY = 0x1003A,       // Directory not empty.
    Error_ENOTRECOVERABLE = 0x1003B, // State not recoverable.
    Error_ENOTSOCK = 0x1003C,        // Not a socket.
    Error_ENOTSUP = 0x1003D,         // Not supported (same value as EOPNOTSUP).
    Error_ENOTTY = 0x1003E,          // Inappropriate I/O control operation.
    Error_ENXIO = 0x1003F,           // No such device or address.
    Error_EOVERFLOW = 0x10040,       // Value too large to be stored in data type.
    Error_EOWNERDEAD = 0x10041,      // Previous owner died.
    Error_EPERM = 0x10042,           // Operation not permitted.
    Error_EPIPE = 0x10043,           // Broken pipe.
    Error_EPROTO = 0x10044,          // Protocol error.
    Error_EPROTONOSUPPORT = 0x10045, // Protocol not supported.
    Error_EPROTOTYPE = 0x10046,      // Protocol wrong type for socket.
    Error_ERANGE = 0x10047,          // Result too large.
    Error_EROFS = 0x10048,           // Read-only file system.
    Error_ESPIPE = 0x10049,          // Invalid seek.
    Error_ESRCH = 0x1004A,           // No such process.
    Error_ESTALE = 0x1004B,          // Reserved.
    Error_ETIMEDOUT = 0x1004D,       // Connection timed out.
    Error_ETXTBSY = 0x1004E,         // Text file busy.
    Error_EXDEV = 0x1004F,           // Cross-device link.
    Error_ESOCKTNOSUPPORT = 0x1005E, // Socket type not supported.
    Error_EPFNOSUPPORT = 0x10060,    // Protocol family not supported.
    Error_ESHUTDOWN = 0x1006C,       // Socket shutdown.
    Error_EHOSTDOWN = 0x10070,       // Host is down.
    Error_ENODATA = 0x10071,         // No data available.

    // POSIX permits these to have the same value and we make them
    // always equal so that we cannot introduce a dependency on
    // distinguishing between them that would not work on all
    // platforms.
    Error_EOPNOTSUPP = Error_ENOTSUP, // Operation not supported on socket
    Error_EWOULDBLOCK = Error_EAGAIN, // Operation would block

    // This one is not part of POSIX, but is a catch-all for the case
    // where we cannot convert the raw errno value to something above.
    Error_ENONSTANDARD = 0x1FFFF,
};

// Items needed by mscorlib

int32_t SystemNative_ConvertErrorPlatformToPal(int32_t platformErrno)
{
    switch (platformErrno)
    {
        case 0:
            return Error_SUCCESS;
        case E2BIG:
            return Error_E2BIG;
        case EACCES:
            return Error_EACCES;
        case EADDRINUSE:
            return Error_EADDRINUSE;
        case EADDRNOTAVAIL:
            return Error_EADDRNOTAVAIL;
        case EAFNOSUPPORT:
            return Error_EAFNOSUPPORT;
        case EAGAIN:
            return Error_EAGAIN;
        case EALREADY:
            return Error_EALREADY;
        case EBADF:
            return Error_EBADF;
        case EBADMSG:
            return Error_EBADMSG;
        case EBUSY:
            return Error_EBUSY;
        case ECANCELED:
            return Error_ECANCELED;
        case ECHILD:
            return Error_ECHILD;
        case ECONNABORTED:
            return Error_ECONNABORTED;
        case ECONNREFUSED:
            return Error_ECONNREFUSED;
        case ECONNRESET:
            return Error_ECONNRESET;
        case EDEADLK:
            return Error_EDEADLK;
        case EDESTADDRREQ:
            return Error_EDESTADDRREQ;
        case EDOM:
            return Error_EDOM;
        case EDQUOT:
            return Error_EDQUOT;
        case EEXIST:
            return Error_EEXIST;
        case EFAULT:
            return Error_EFAULT;
        case EFBIG:
            return Error_EFBIG;
        case EHOSTUNREACH:
            return Error_EHOSTUNREACH;
        case EIDRM:
            return Error_EIDRM;
        case EILSEQ:
            return Error_EILSEQ;
        case EINPROGRESS:
            return Error_EINPROGRESS;
        case EINTR:
            return Error_EINTR;
        case EINVAL:
            return Error_EINVAL;
        case EIO:
            return Error_EIO;
        case EISCONN:
            return Error_EISCONN;
        case EISDIR:
            return Error_EISDIR;
        case ELOOP:
            return Error_ELOOP;
        case EMFILE:
            return Error_EMFILE;
        case EMLINK:
            return Error_EMLINK;
        case EMSGSIZE:
            return Error_EMSGSIZE;
        case EMULTIHOP:
            return Error_EMULTIHOP;
        case ENAMETOOLONG:
            return Error_ENAMETOOLONG;
        case ENETDOWN:
            return Error_ENETDOWN;
        case ENETRESET:
            return Error_ENETRESET;
        case ENETUNREACH:
            return Error_ENETUNREACH;
        case ENFILE:
            return Error_ENFILE;
        case ENOBUFS:
            return Error_ENOBUFS;
        case ENODEV:
            return Error_ENODEV;
        case ENOENT:
            return Error_ENOENT;
        case ENOEXEC:
            return Error_ENOEXEC;
        case ENOLCK:
            return Error_ENOLCK;
        case ENOLINK:
            return Error_ENOLINK;
        case ENOMEM:
            return Error_ENOMEM;
        case ENOMSG:
            return Error_ENOMSG;
        case ENOPROTOOPT:
            return Error_ENOPROTOOPT;
        case ENOSPC:
            return Error_ENOSPC;
        case ENOSYS:
            return Error_ENOSYS;
        case ENOTCONN:
            return Error_ENOTCONN;
        case ENOTDIR:
            return Error_ENOTDIR;
#if ENOTEMPTY != EEXIST // AIX defines this
        case ENOTEMPTY:
            return Error_ENOTEMPTY;
#endif
#ifdef ENOTRECOVERABLE // not available in NetBSD
        case ENOTRECOVERABLE:
            return Error_ENOTRECOVERABLE;
#endif
        case ENOTSOCK:
            return Error_ENOTSOCK;
        case ENOTSUP:
            return Error_ENOTSUP;
        case ENOTTY:
            return Error_ENOTTY;
        case ENXIO:
            return Error_ENXIO;
        case EOVERFLOW:
            return Error_EOVERFLOW;
#ifdef EOWNERDEAD // not available in NetBSD
        case EOWNERDEAD:
            return Error_EOWNERDEAD;
#endif
        case EPERM:
            return Error_EPERM;
        case EPIPE:
            return Error_EPIPE;
        case EPROTO:
            return Error_EPROTO;
        case EPROTONOSUPPORT:
            return Error_EPROTONOSUPPORT;
        case EPROTOTYPE:
            return Error_EPROTOTYPE;
        case ERANGE:
            return Error_ERANGE;
        case EROFS:
            return Error_EROFS;
        case ESPIPE:
            return Error_ESPIPE;
        case ESRCH:
            return Error_ESRCH;
        case ESTALE:
            return Error_ESTALE;
        case ETIMEDOUT:
            return Error_ETIMEDOUT;
        case ETXTBSY:
            return Error_ETXTBSY;
        case EXDEV:
            return Error_EXDEV;
#ifdef ESOCKTNOSUPPORT
        case ESOCKTNOSUPPORT:
            return Error_ESOCKTNOSUPPORT;
#endif
        case EPFNOSUPPORT:
            return Error_EPFNOSUPPORT;
        case ESHUTDOWN:
            return Error_ESHUTDOWN;
        case EHOSTDOWN:
            return Error_EHOSTDOWN;
        case ENODATA:
            return Error_ENODATA;

// #if because these will trigger duplicate case label warnings when
// they have the same value, which is permitted by POSIX and common.
#if EOPNOTSUPP != ENOTSUP
        case EOPNOTSUPP:
            return Error_EOPNOTSUPP;
#endif
#if EWOULDBLOCK != EAGAIN
        case EWOULDBLOCK:
            return Error_EWOULDBLOCK;
#endif
    }

    return Error_ENONSTANDARD;
}

const char* SystemNative_StrErrorR(int32_t platformErrno, char* buffer, int32_t bufferSize)
{
    IL2CPP_ASSERT(buffer != NULL);
    IL2CPP_ASSERT(bufferSize > 0);

    if (bufferSize < 0)
        return NULL;

// Note that we must use strerror_r because plain strerror is not
// thread-safe.
//
// However, there are two versions of strerror_r:
//    - GNU:   char* strerror_r(int, char*, size_t);
//    - POSIX: int   strerror_r(int, char*, size_t);
//
// The former may or may not use the supplied buffer, and returns
// the error message string. The latter stores the error message
// string into the supplied buffer and returns an error code.

#if IL2CPP_HAVE_GNU_STRERROR_R
    const char* message = strerror_r(platformErrno, buffer, (uint32_t)bufferSize);
    IL2CPP_ASSERT(message != NULL);
    return message;
#else
    int error = strerror_r(platformErrno, buffer, (uint32_t)bufferSize);
    if (error == ERANGE)
    {
        // Buffer is too small to hold the entire message, but has
        // still been filled to the extent possible and null-terminated.
        return NULL;
    }

    // The only other valid error codes are 0 for success or EINVAL for
    // an unknown error, but in the latter case a reasonable string (e.g
    // "Unknown error: 0x123") is returned.
    IL2CPP_ASSERT((error == 0 || error == EINVAL) && "invalid error");
    return buffer;
#endif
}

int32_t SystemNative_ConvertErrorPalToPlatform(int32_t error)
{
    switch (error)
    {
        case Error_SUCCESS:
            return 0;
        case Error_E2BIG:
            return E2BIG;
        case Error_EACCES:
            return EACCES;
        case Error_EADDRINUSE:
            return EADDRINUSE;
        case Error_EADDRNOTAVAIL:
            return EADDRNOTAVAIL;
        case Error_EAFNOSUPPORT:
            return EAFNOSUPPORT;
        case Error_EAGAIN:
            return EAGAIN;
        case Error_EALREADY:
            return EALREADY;
        case Error_EBADF:
            return EBADF;
        case Error_EBADMSG:
            return EBADMSG;
        case Error_EBUSY:
            return EBUSY;
        case Error_ECANCELED:
            return ECANCELED;
        case Error_ECHILD:
            return ECHILD;
        case Error_ECONNABORTED:
            return ECONNABORTED;
        case Error_ECONNREFUSED:
            return ECONNREFUSED;
        case Error_ECONNRESET:
            return ECONNRESET;
        case Error_EDEADLK:
            return EDEADLK;
        case Error_EDESTADDRREQ:
            return EDESTADDRREQ;
        case Error_EDOM:
            return EDOM;
        case Error_EDQUOT:
            return EDQUOT;
        case Error_EEXIST:
            return EEXIST;
        case Error_EFAULT:
            return EFAULT;
        case Error_EFBIG:
            return EFBIG;
        case Error_EHOSTUNREACH:
            return EHOSTUNREACH;
        case Error_EIDRM:
            return EIDRM;
        case Error_EILSEQ:
            return EILSEQ;
        case Error_EINPROGRESS:
            return EINPROGRESS;
        case Error_EINTR:
            return EINTR;
        case Error_EINVAL:
            return EINVAL;
        case Error_EIO:
            return EIO;
        case Error_EISCONN:
            return EISCONN;
        case Error_EISDIR:
            return EISDIR;
        case Error_ELOOP:
            return ELOOP;
        case Error_EMFILE:
            return EMFILE;
        case Error_EMLINK:
            return EMLINK;
        case Error_EMSGSIZE:
            return EMSGSIZE;
        case Error_EMULTIHOP:
            return EMULTIHOP;
        case Error_ENAMETOOLONG:
            return ENAMETOOLONG;
        case Error_ENETDOWN:
            return ENETDOWN;
        case Error_ENETRESET:
            return ENETRESET;
        case Error_ENETUNREACH:
            return ENETUNREACH;
        case Error_ENFILE:
            return ENFILE;
        case Error_ENOBUFS:
            return ENOBUFS;
        case Error_ENODEV:
            return ENODEV;
        case Error_ENOENT:
            return ENOENT;
        case Error_ENOEXEC:
            return ENOEXEC;
        case Error_ENOLCK:
            return ENOLCK;
        case Error_ENOLINK:
            return ENOLINK;
        case Error_ENOMEM:
            return ENOMEM;
        case Error_ENOMSG:
            return ENOMSG;
        case Error_ENOPROTOOPT:
            return ENOPROTOOPT;
        case Error_ENOSPC:
            return ENOSPC;
        case Error_ENOSYS:
            return ENOSYS;
        case Error_ENOTCONN:
            return ENOTCONN;
        case Error_ENOTDIR:
            return ENOTDIR;
        case Error_ENOTEMPTY:
            return ENOTEMPTY;
#ifdef ENOTRECOVERABLE // not available in NetBSD
        case Error_ENOTRECOVERABLE:
            return ENOTRECOVERABLE;
#endif
        case Error_ENOTSOCK:
            return ENOTSOCK;
        case Error_ENOTSUP:
            return ENOTSUP;
        case Error_ENOTTY:
            return ENOTTY;
        case Error_ENXIO:
            return ENXIO;
        case Error_EOVERFLOW:
            return EOVERFLOW;
#ifdef EOWNERDEAD // not available in NetBSD
        case Error_EOWNERDEAD:
            return EOWNERDEAD;
#endif
        case Error_EPERM:
            return EPERM;
        case Error_EPIPE:
            return EPIPE;
        case Error_EPROTO:
            return EPROTO;
        case Error_EPROTONOSUPPORT:
            return EPROTONOSUPPORT;
        case Error_EPROTOTYPE:
            return EPROTOTYPE;
        case Error_ERANGE:
            return ERANGE;
        case Error_EROFS:
            return EROFS;
        case Error_ESPIPE:
            return ESPIPE;
        case Error_ESRCH:
            return ESRCH;
        case Error_ESTALE:
            return ESTALE;
        case Error_ETIMEDOUT:
            return ETIMEDOUT;
        case Error_ETXTBSY:
            return ETXTBSY;
        case Error_EXDEV:
            return EXDEV;
        case Error_EPFNOSUPPORT:
            return EPFNOSUPPORT;
#ifdef ESOCKTNOSUPPORT
        case Error_ESOCKTNOSUPPORT:
            return ESOCKTNOSUPPORT;
#endif
        case Error_ESHUTDOWN:
            return ESHUTDOWN;
        case Error_EHOSTDOWN:
            return EHOSTDOWN;
        case Error_ENODATA:
            return ENODATA;
        case Error_ENONSTANDARD:
            break; // fall through to assert
    }

    // We should not use this function to round-trip platform -> pal
    // -> platform. It's here only to synthesize a platform number
    // from the fixed set above. Note that the assert is outside the
    // switch rather than in a default case block because not
    // having a default will trigger a warning (as error) if there's
    // an enum value we haven't handled. Should that trigger, make
    // note that there is probably a corresponding missing case in the
    // other direction above, but the compiler can't warn in that case
    // because the platform values are not part of an enum.
    IL2CPP_ASSERT(0 && "Unknown error code");
    return -1;
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_errno.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_io.cpp---------------
.
.
#include "il2cpp-config.h"
#include "pal_platform.h"

#if IL2CPP_USES_POSIX_CLASS_LIBRARY_PAL

#include "os/ClassLibraryPAL/pal_mirror_structs.h"
#include "os/File.h"
#include "os/Posix/FileHandle.h"

#include <stdlib.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>

#if IL2CPP_HAVE_FCOPYFILE
#include <copyfile.h>
#endif

struct DirectoryEntry;

extern "C"
{
    struct DIRWrapper
    {
        DIR* dir;
        DirectoryEntry* result;
        size_t curIndex;
        size_t numEntries;
#if !IL2CPP_HAVE_REWINDDIR
        char* dirPath;
#endif
    };
    // Items needed by mscorlib
    IL2CPP_EXPORT int32_t SystemNative_Stat2(const char* path, struct FileStatus* output); // 179
    IL2CPP_EXPORT int32_t SystemNative_LStat2(const char* path, struct FileStatus* output); // 207
    IL2CPP_EXPORT int32_t SystemNative_Unlink(const char* path); // 305
    IL2CPP_EXPORT int32_t SystemNative_GetReadDirRBufferSize(void); // 371
    IL2CPP_EXPORT int32_t SystemNative_ReadDirR(struct DIRWrapper* dirWrapper, uint8_t* buffer, int32_t bufferSize, struct DirectoryEntry* outputEntry); // 388
    IL2CPP_EXPORT struct DIRWrapper* SystemNative_OpenDir(const char* path); // 468
    IL2CPP_EXPORT int32_t SystemNative_CloseDir(struct DIRWrapper* dirWrapper); // 473
    IL2CPP_EXPORT int32_t SystemNative_MkDir(const char* path, int32_t mode); // 592
    IL2CPP_EXPORT int32_t SystemNative_ChMod(const char* path, int32_t mode); // 599
    IL2CPP_EXPORT int32_t SystemNative_Link(const char* source, const char* linkTarget); // 660
    IL2CPP_EXPORT int32_t SystemNative_Symlink(const char* target, const char* linkPath);
    IL2CPP_EXPORT int32_t SystemNative_ReadLink(const char* path, char* buffer, int32_t bufferSize); // 1142
    IL2CPP_EXPORT int32_t SystemNative_Rename(const char* oldPath, const char* newPath); // 1159
    IL2CPP_EXPORT int32_t SystemNative_RmDir(const char* path); // 1166
    IL2CPP_EXPORT int32_t SystemNative_CopyFile(intptr_t sourceFd, intptr_t destinationFd); // 1251
    IL2CPP_EXPORT int32_t SystemNative_LChflags(const char* path, uint32_t flags);
    IL2CPP_EXPORT int32_t SystemNative_LChflagsCanSetHiddenFlag(); // 1482
}


/* Provide consistent access to nanosecond fields, if they exist. */
/* Seconds are always available through st_atime, st_mtime, st_ctime. */

#if IL2CPP_HAVE_STAT_TIMESPEC

#define ST_ATIME_NSEC(statstruct) ((statstruct)->st_atimespec.tv_nsec)
#define ST_MTIME_NSEC(statstruct) ((statstruct)->st_mtimespec.tv_nsec)
#define ST_CTIME_NSEC(statstruct) ((statstruct)->st_ctimespec.tv_nsec)

#else /* HAVE_STAT_TIMESPEC */

#if IL2CPP_HAVE_STAT_TIM

#define ST_ATIME_NSEC(statstruct) ((statstruct)->st_atim.tv_nsec)
#define ST_MTIME_NSEC(statstruct) ((statstruct)->st_mtim.tv_nsec)
#define ST_CTIME_NSEC(statstruct) ((statstruct)->st_ctim.tv_nsec)

#else /* HAVE_STAT_TIM */

#if IL2CPP_HAVE_STAT_NSEC

#define ST_ATIME_NSEC(statstruct) ((statstruct)->st_atimensec)
#define ST_MTIME_NSEC(statstruct) ((statstruct)->st_mtimensec)
#define ST_CTIME_NSEC(statstruct) ((statstruct)->st_ctimensec)

#else /* HAVE_STAT_NSEC */

#define ST_ATIME_NSEC(statstruct) 0
#define ST_MTIME_NSEC(statstruct) 0
#define ST_CTIME_NSEC(statstruct) 0

#endif /* HAVE_STAT_NSEC */
#endif /* HAVE_STAT_TIM */
#endif /* HAVE_STAT_TIMESPEC */

/**
 * Constants for interpreting FileStatus.Flags.
 */
enum
{
    FILESTATUS_FLAGS_NONE = 0,
    FILESTATUS_FLAGS_HAS_BIRTHTIME = 1,
};

/**
 * Constants for interpreting FileStatus.UserFlags.
 */
enum
{
    PAL_UF_HIDDEN = 0x8000
};

/**
 * Constants from dirent.h for the inode type returned from readdir variants
 */
enum NodeType
{
    PAL_DT_UNKNOWN = 0, // Unknown file type
    PAL_DT_FIFO = 1,    // Named Pipe
    PAL_DT_CHR = 2,     // Character Device
    PAL_DT_DIR = 4,     // Directory
    PAL_DT_BLK = 6,     // Block Device
    PAL_DT_REG = 8,     // Regular file
    PAL_DT_LNK = 10,    // Symlink
    PAL_DT_SOCK = 12,   // Socket
    PAL_DT_WHT = 14     // BSD Whiteout
};

/**
 * Our intermediate dirent struct that only gives back the data we need
 */
struct DirectoryEntry
{
    char* Name;   // Address of the name of the inode
    int32_t NameLength; // Length (in chars) of the inode name
    int32_t InodeType; // The inode type as described in the NodeType enum
};

static void ConvertFileStatus(const struct stat_* src, struct FileStatus* dst)
{
    dst->Dev = (int64_t)src->st_dev;
    dst->Ino = (int64_t)src->st_ino;
    dst->Flags = FILESTATUS_FLAGS_NONE;
    dst->Mode = (int32_t)src->st_mode;
    dst->Uid = src->st_uid;
    dst->Gid = src->st_gid;
    dst->Size = src->st_size;

    dst->ATime = src->st_atime;
    dst->MTime = src->st_mtime;
    dst->CTime = src->st_ctime;

    dst->ATimeNsec = ST_ATIME_NSEC(src);
    dst->MTimeNsec = ST_MTIME_NSEC(src);
    dst->CTimeNsec = ST_CTIME_NSEC(src);

#if IL2CPP_HAVE_STAT_BIRTHTIME
    dst->BirthTime = src->st_birthtimespec.tv_sec;
    dst->BirthTimeNsec = src->st_birthtimespec.tv_nsec;
    dst->Flags |= FILESTATUS_FLAGS_HAS_BIRTHTIME;
#else
    // Linux path: until we use statx() instead
    dst->BirthTime = 0;
    dst->BirthTimeNsec = 0;
#endif

#if defined(IL2CPP_HAVE_STAT_FLAGS) && defined(UF_HIDDEN)
    dst->UserFlags = ((src->st_flags & UF_HIDDEN) == UF_HIDDEN) ? PAL_UF_HIDDEN : 0;
#else
    dst->UserFlags = 0;
#endif
}

#if IL2CPP_HAVE_REMAP_PATH
    #define REMAP_PATH(path) pal_remap_path(path).c_str()
#else
    #define REMAP_PATH(path) path
#endif

// CoreCLR expects the "2" suffixes on these: they should be cleaned up in our
// next coordinated System.Native changes
int32_t SystemNative_Stat2(const char* path, struct FileStatus* output)
{
    struct stat_ result = {};
    int ret;
    while ((ret = stat_(REMAP_PATH(path), &result)) < 0 && errno == EINTR)
        ;

    if (ret == 0)
    {
        ConvertFileStatus(&result, output);
    }

    return ret;
}

int32_t SystemNative_LStat2(const char* path, struct FileStatus* output)
{
    struct stat_ result = {};
    int ret = lstat_(REMAP_PATH(path), &result);

    if (ret == 0)
    {
        ConvertFileStatus(&result, output);
    }

    return ret;
}

int32_t SystemNative_Unlink(const char* path)
{
    int32_t result = 0;
    while ((result = unlink(REMAP_PATH(path))) < 0 && errno == EINTR)
        ;
    return result;
}

static void ConvertDirent(const struct dirent* entry, struct DirectoryEntry* outputEntry)
{
    // We use Marshal.PtrToStringAnsi on the managed side, which takes a pointer to
    // the start of the unmanaged string. Give the caller back a pointer to the
    // location of the start of the string that exists in their own byte buffer.
    outputEntry->Name = strdup(entry->d_name);
    IL2CPP_ASSERT(outputEntry->Name != NULL);
#if !defined(DT_UNKNOWN)
    // AIX has no d_type, and since we can't get the directory that goes with
    // the filename from ReadDir, we can't stat the file. Return unknown and
    // hope that managed code can properly stat the file.
    outputEntry->InodeType = PAL_DT_UNKNOWN;
#else
    outputEntry->InodeType = (int32_t)entry->d_type;
#endif

#if IL2CPP_HAVE_DIRENT_NAME_LEN
#if !defined(IL2CPP_DIRENT_MEMBER_NAME_LEN)
    outputEntry->NameLength = entry->d_namlen;
#else
    outputEntry->NameLength = entry->IL2CPP_DIRENT_MEMBER_NAME_LEN;
#endif
#else
    outputEntry->NameLength = -1; // sentinel value to mean we have to walk to find the first \0
#endif
}

#if IL2CPP_HAVE_READDIR_R_DEPRECATED_DO_NOT_USE
// struct dirent typically contains 64-bit numbers (e.g. d_ino), so we align it at 8-byte.
static const size_t dirent_alignment = 8;
#endif

int32_t SystemNative_GetReadDirRBufferSize(void)
{
#if IL2CPP_HAVE_READDIR_R_DEPRECATED_DO_NOT_USE
    // dirent should be under 2k in size
    IL2CPP_ASSERT(sizeof(struct dirent) < 2048);
    // add some extra space so we can align the buffer to dirent.
    return sizeof(struct dirent) + dirent_alignment - 1;
#else
    return 0;
#endif
}

static int CompareByName(const void *p1, const void *p2)
{
    auto directoryEntry1 = ((struct DirectoryEntry*)p1);
    auto directoryEntry2 = ((struct DirectoryEntry*)p2);

    // Sort NULL values to the end of the array. This can happen when
    // a file is deleted while GetFiles is called.
    if (directoryEntry1->Name == directoryEntry2->Name)
        return 0;
    if (directoryEntry1->Name == NULL)
        return 1;
    if (directoryEntry2->Name == NULL)
        return -1;

    return strcmp(directoryEntry1->Name, directoryEntry2->Name);
}

// To reduce the number of string copies, the caller of this function is responsible to ensure the memory
// referenced by outputEntry remains valid until it is read.
// If the platform supports readdir_r, the caller provides a buffer into which the data is read.
// If the platform uses readdir, the caller must ensure no calls are made to readdir/closedir since those will invalidate
// the current dirent. We assume the platform supports concurrent readdir calls to different DIRs.
int32_t SystemNative_ReadDirR(struct DIRWrapper* dirWrapper, uint8_t* buffer, int32_t bufferSize, struct DirectoryEntry* outputEntry)
{
    IL2CPP_ASSERT(dirWrapper != NULL);
    IL2CPP_ASSERT(dirWrapper->dir != NULL);
    IL2CPP_ASSERT(outputEntry != NULL);

#if IL2CPP_HAVE_READDIR_R_DEPRECATED_DO_NOT_USE
    IL2CPP_ASSERT(buffer != NULL);

    // align to dirent
    struct dirent* entry = (struct dirent*)((size_t)(buffer + dirent_alignment - 1) & ~(dirent_alignment - 1));

    // check there is dirent size available at entry
    if ((buffer + bufferSize) < ((uint8_t*)entry + sizeof(struct dirent)))
    {
        IL2CPP_ASSERT(false && "Buffer size too small; use GetReadDirRBufferSize to get required buffer size");
        return ERANGE;
    }

    struct dirent* result = NULL;
#ifdef _AIX
    // AIX returns 0 on success, but bizarrely, it returns 9 for both error and
    // end-of-directory. result is NULL for both cases. The API returns the
    // same thing for EOD/error, so disambiguation between the two is nearly
    // impossible without clobbering errno for yourself and seeing if the API
    // changed it. See:
    // https://www.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.basetrf2/readdir_r.htm

    errno = 0; // create a success condition for the API to clobber
    int error = readdir_r(dir, entry, &result);

    if (error == 9)
    {
        memset(outputEntry, 0, sizeof(*outputEntry)); // managed out param must be initialized
        return errno == 0 ? -1 : errno;
    }
#else
    int error = readdir_r(dir, entry, &result);

    // positive error number returned -> failure
    if (error != 0)
    {
        IL2CPP_ASSERT(error > 0);
        memset(outputEntry, 0, sizeof(*outputEntry)); // managed out param must be initialized
        return error;
    }

    // 0 returned with null result -> end-of-stream
    if (result == NULL)
    {
        memset(outputEntry, 0, sizeof(*outputEntry)); // managed out param must be initialized
        return -1;         // shim convention for end-of-stream
    }
#endif

    // 0 returned with non-null result (guaranteed to be set to entry arg) -> success
    IL2CPP_ASSERT(result == entry);
#else
    (void)buffer;     // unused
    (void)bufferSize; // unused
    errno = 0;
    bool endOfEntries = false;

    if (!dirWrapper->result)
    {
        struct dirent* entry;
        size_t numEntries = 0;
        while ((entry = readdir(dirWrapper->dir)))
            numEntries++;
        if (numEntries)
        {
            // Use calloc to ensure the array is zero-initialized.
            dirWrapper->result = (DirectoryEntry*)calloc(numEntries, sizeof(struct DirectoryEntry));
            dirWrapper->curIndex = 0;
#if IL2CPP_HAVE_REWINDDIR
            rewinddir(dirWrapper->dir);
#else
            closedir(dirWrapper->dir);
            dirWrapper->dir = opendir(dirWrapper->dirPath);
#endif

            // If we iterate fewer entries than exist because some files were deleted
            // since the time we computed numEntries above, that will be fine. Those
            // extra entries will be zero-initialized and will be sorted to the end
            // of the array by the qsort below.
            size_t index = 0;
            while ((entry = readdir(dirWrapper->dir)) && index < numEntries)
            {
                ConvertDirent(entry, &dirWrapper->result[index]);
                index++;
            }

            qsort(dirWrapper->result, numEntries, sizeof(struct DirectoryEntry), CompareByName);
            dirWrapper->numEntries = index;
        }
    }

    if (dirWrapper->curIndex < dirWrapper->numEntries)
    {
        *outputEntry = dirWrapper->result[dirWrapper->curIndex];
        dirWrapper->curIndex++;
    }
    else
    {
        endOfEntries = true;
    }

    // 0 returned with null result -> end-of-stream
    if (endOfEntries)
    {
        memset(outputEntry, 0, sizeof(*outputEntry)); // managed out param must be initialized

        //  kernel set errno -> failure
        if (errno != 0)
        {
            IL2CPP_ASSERT(errno == EBADF && "Invalid directory stream descriptor dir" && errno);
            return errno;
        }
        return -1;
    }
#endif
    return 0;
}

struct DIRWrapper* SystemNative_OpenDir(const char* path)
{
    const char* remapped_path = NULL;

#if IL2CPP_HAVE_REMAP_PATH
    auto remapped_path_string = pal_remap_path(path);
    remapped_path = remapped_path_string.c_str();
#else
    remapped_path = path;
#endif

    DIR* dir = opendir(remapped_path);

    if (dir == NULL)
        return NULL;

    struct DIRWrapper* ret = (struct DIRWrapper*)malloc(sizeof(struct DIRWrapper));
    ret->dir = dir;
    ret->result = NULL;
    ret->curIndex = 0;
    ret->numEntries = 0;
#if !IL2CPP_HAVE_REWINDDIR
    ret->dirPath = strdup(remapped_path);
#endif
    return ret;
}

int32_t SystemNative_CloseDir(struct DIRWrapper* dirWrapper)
{
    IL2CPP_ASSERT(dirWrapper != NULL);
    int32_t ret = closedir(dirWrapper->dir);
    if (dirWrapper->result)
    {
        for (int i = 0; i < dirWrapper->numEntries; i++)
            free(dirWrapper->result[i].Name);
        free(dirWrapper->result);
    }
    dirWrapper->result = NULL;
#if !IL2CPP_HAVE_REWINDDIR
    if (dirWrapper->dirPath)
        free(dirWrapper->dirPath);
#endif
    free(dirWrapper);

    return ret;
}

int32_t SystemNative_MkDir(const char* path, int32_t mode)
{
    int32_t result = 0;
    while ((result = mkdir(REMAP_PATH(path), (mode_t)mode)) < 0 && errno == EINTR)
        ;
    return result;
}

int32_t SystemNative_ChMod(const char* path, int32_t mode)
{
    int32_t result = 0;
    while ((result = chmod_(REMAP_PATH(path), (mode_t)mode)) < 0 && errno == EINTR)
        ;
    return result;
}

int32_t SystemNative_Link(const char* source, const char* linkTarget)
{
    int32_t result = 0;
    while ((result = link_(REMAP_PATH(source), REMAP_PATH(linkTarget))) < 0 && errno == EINTR)
        ;
    return result;
}

int32_t SystemNative_Symlink(const char* target, const char* linkPath)
{
    return symlink_(REMAP_PATH(target), REMAP_PATH(linkPath));
}

int32_t SystemNative_ReadLink(const char* path, char* buffer, int32_t bufferSize)
{
    IL2CPP_ASSERT(buffer != NULL || bufferSize == 0);
    IL2CPP_ASSERT(bufferSize >= 0);

    if (bufferSize <= 0)
    {
        errno = EINVAL;
        return -1;
    }

    ssize_t count = readlink_(REMAP_PATH(path), buffer, (size_t)bufferSize);
    IL2CPP_ASSERT(count >= -1 && count <= bufferSize);

    return (int32_t)count;
}

int32_t SystemNative_Rename(const char* oldPath, const char* newPath)
{
    int32_t result;
    while ((result = rename(REMAP_PATH(oldPath), REMAP_PATH(newPath))) < 0 && errno == EINTR)
        ;
    return result;
}

int32_t SystemNative_RmDir(const char* path)
{
    int32_t result = 0;
    while ((result = rmdir(REMAP_PATH(path))) < 0 && errno == EINTR)
        ;
    return result;
}

#if !IL2CPP_HAVE_FCOPYFILE
// Read all data from inFd and write it to outFd
static int32_t CopyFile_ReadWrite(int inFd, int outFd)
{
    // Allocate a buffer
    const int BufferLength = 80 * 1024 * sizeof(char);
    char* buffer = (char*)malloc(BufferLength);
    if (buffer == NULL)
    {
        return -1;
    }

    // Repeatedly read from the source and write to the destination
    while (true)
    {
        // Read up to what will fit in our buffer.  We're done if we get back 0 bytes.
        ssize_t bytesRead;
        while ((bytesRead = read(inFd, buffer, BufferLength)) < 0 && errno == EINTR)
            ;
        if (bytesRead == -1)
        {
            int tmp = errno;
            free(buffer);
            errno = tmp;
            return -1;
        }
        if (bytesRead == 0)
        {
            break;
        }
        IL2CPP_ASSERT(bytesRead > 0);

        // Write what was read.
        ssize_t offset = 0;
        while (bytesRead > 0)
        {
            ssize_t bytesWritten;
            while ((bytesWritten = write(outFd, buffer + offset, (size_t)bytesRead)) < 0 && errno == EINTR)
                ;
            if (bytesWritten == -1)
            {
                int tmp = errno;
                free(buffer);
                errno = tmp;
                return -1;
            }
            IL2CPP_ASSERT(bytesWritten >= 0);
            bytesRead -= bytesWritten;
            offset += bytesWritten;
        }
    }

    free(buffer);
    return 0;
}

#endif // !IL2CPP_HAVE_FCOPYFILE

int32_t SystemNative_CopyFile(intptr_t sourceFd, intptr_t destinationFd)
{
#if IL2CPP_HAVE_CUSTOM_COPYFILE
    return pal_custom_copy_file(sourceFd, destinationFd);
#else
    int inFd, outFd;

    inFd = il2cpp::os::File::IsHandleOpenFileHandle(sourceFd) ? reinterpret_cast<il2cpp::os::FileHandle*>(sourceFd)->fd : static_cast<int>(sourceFd);
    outFd = il2cpp::os::File::IsHandleOpenFileHandle(destinationFd) ? reinterpret_cast<il2cpp::os::FileHandle*>(destinationFd)->fd : static_cast<int>(destinationFd);

#if IL2CPP_HAVE_FCOPYFILE
    // If fcopyfile is available (OS X), try to use it, as the whole copy
    // can be performed in the kernel, without lots of unnecessary copying.
    // Copy data and metadata.
    return fcopyfile(inFd, outFd, NULL, COPYFILE_ALL) == 0 ? 0 : -1;
#else
    // Get the stats on the source file.
    int ret;
    struct stat_ sourceStat;
    bool copied = false;

    // First, stat the source file.
    while ((ret = fstat_(inFd, &sourceStat)) < 0 && errno == EINTR)
        ;
    if (ret != 0)
    {
        // If we can't stat() it, then we likely don't have permission to read it.
        return -1;
    }

    // Copy permissions.  This fchmod() needs to happen prior to writing anything into
    // the file to avoid possibly leaking any private data.
    while ((ret = fchmod(outFd, sourceStat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))) < 0 && errno == EINTR)
        ;
#if !IL2CPP_CANNOT_MODIFY_FILE_PERMISSIONS
    if (ret != 0)
    {
        return -1;
    }
#endif

#if IL2CPP_HAVE_SENDFILE_4
    // If sendfile is available (Linux), try to use it, as the whole copy
    // can be performed in the kernel, without lots of unnecessary copying.

    // On 32-bit, if you use 64-bit offsets, the last argument of `sendfile' will be a
    // `size_t' a 32-bit integer while the `st_size' field of the stat structure will be off64_t.
    // So `size' will have to be `uint64_t'. In all other cases, it will be `size_t'.
    uint64_t size = (uint64_t)sourceStat.st_size;

    // Note that per man page for large files, you have to iterate until the
    // whole file is copied (Linux has a limit of 0x7ffff000 bytes copied).
    while (size > 0)
    {
        ssize_t sent = sendfile(outFd, inFd, NULL, (size >= SSIZE_MAX ? SSIZE_MAX : (size_t)size));
        if (sent < 0)
        {
            if (errno != EINVAL && errno != ENOSYS)
            {
                return -1;
            }
            else
            {
                break;
            }
        }
        else
        {
            IL2CPP_ASSERT((size_t)sent <= size);
            size -= (size_t)sent;
        }
    }
    if (size == 0)
    {
        copied = true;
    }
    // sendfile couldn't be used; fall back to a manual copy below. This could happen
    // if we're on an old kernel, for example, where sendfile could only be used
    // with sockets and not regular files.
#endif // IL2CPP_HAVE_SENDFILE_4

    // Manually read all data from the source and write it to the destination.
    if (!copied && CopyFile_ReadWrite(inFd, outFd) != 0)
    {
        return -1;
    }

    // Now that the data from the file has been copied, copy over metadata
    // from the source file.  First copy the file times.
    // If futimes nor futimes are available on this platform, file times will
    // not be copied over.
#if IL2CPP_HAVE_FUTIMENS
    // futimens is prefered because it has a higher resolution.
    struct timespec origTimes[2];
    origTimes[0].tv_sec = (time_t)sourceStat.st_atime;
    origTimes[0].tv_nsec = ST_ATIME_NSEC(&sourceStat);
    origTimes[1].tv_sec = (time_t)sourceStat.st_mtime;
    origTimes[1].tv_nsec = ST_MTIME_NSEC(&sourceStat);
    while ((ret = futimens(outFd, origTimes)) < 0 && errno == EINTR)
        ;
#elif IL2CPP_HAVE_FUTIMES
    struct timeval origTimes[2];
    origTimes[0].tv_sec = sourceStat.st_atime;
    origTimes[0].tv_usec = ST_ATIME_NSEC(&sourceStat) / 1000;
    origTimes[1].tv_sec = sourceStat.st_mtime;
    origTimes[1].tv_usec = ST_MTIME_NSEC(&sourceStat) / 1000;
    while ((ret = futimes(outFd, origTimes)) < 0 && errno == EINTR)
        ;
#endif

#if !IL2CPP_CANNOT_MODIFY_FILE_PERMISSIONS
    if (ret != 0)
    {
        return -1;
    }
#endif

    return 0;
#endif // IL2CPP_HAVE_FCOPYFILE
#endif // IL2CPP_HAVE_CUSTOM_COPYFILE
}

int32_t SystemNative_LChflags(const char* path, uint32_t flags)
{
#if defined(UF_HIDDEN) && defined(IL2CPP_HAVE_STAT_FLAGS) && defined(IL2CPP_HAVE_LCHFLAGS)
    int32_t result;
    while ((result = lchflags(path, flags)) < 0 && errno == EINTR)
        ;
    return result;
#else
    return -1;
#endif
}

int32_t SystemNative_LChflagsCanSetHiddenFlag(void)
{
#if defined(UF_HIDDEN) && defined(IL2CPP_HAVE_STAT_FLAGS) && defined(IL2CPP_HAVE_LCHFLAGS)
    return true;
#else
    return false;
#endif
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_io.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_networking.cpp---------------
.
.
#include "il2cpp-config.h"
#include "pal_platform.h"

#if IL2CPP_USES_POSIX_CLASS_LIBRARY_PAL

#if IL2CPP_HAVE_SYS_UN
#include <sys/un.h>
#endif

extern "C"
{
    IL2CPP_EXPORT void SystemNative_GetDomainSocketSizes(int32_t* pathOffset, int32_t* pathSize, int32_t* addressSize);
}

void SystemNative_GetDomainSocketSizes(int32_t* pathOffset, int32_t* pathSize, int32_t* addressSize)
{
    IL2CPP_ASSERT(pathOffset != NULL);
    IL2CPP_ASSERT(pathSize != NULL);
    IL2CPP_ASSERT(addressSize != NULL);

#if IL2CPP_HAVE_SYS_UN
    struct sockaddr_un domainSocket;

    *pathOffset = offsetof(struct sockaddr_un, sun_path);
    *pathSize = sizeof(domainSocket.sun_path);
    *addressSize = sizeof(domainSocket);
#else
    *pathOffset = 0;
    *pathSize = 0;
    *addressSize = 0;
#endif
}

#endif // IL2CPP_USES_POSIX_CLASS_LIBRARY_PAL
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_networking.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_random.cpp---------------
.
.
#include "il2cpp-config.h"
#include "pal_platform.h"

#if IL2CPP_USES_POSIX_CLASS_LIBRARY_PAL

#define IL2CPP_HAVE_O_CLOEXEC 1

#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>

extern "C"
{
    // Items needed by mscorlib
    IL2CPP_EXPORT void SystemNative_GetNonCryptographicallySecureRandomBytes(uint8_t* buffer, int32_t bufferLength);
}

void SystemNative_GetNonCryptographicallySecureRandomBytes(uint8_t* buffer, int32_t bufferLength)
{
    IL2CPP_ASSERT(buffer != NULL);

#if IL2CPP_HAVE_ARC4RANDOM_BUF
    arc4random_buf(buffer, (size_t)bufferLength);
#else
    static volatile int rand_des = -1;
    long num = 0;
    static bool sMissingDevURandom;
    static bool sInitializedMRand;

    if (!sMissingDevURandom)
    {
        if (rand_des == -1)
        {
            int fd;

            do
            {
#if IL2CPP_HAVE_O_CLOEXEC
                fd = open("/dev/urandom", O_RDONLY, O_CLOEXEC);
#else
                fd = open("/dev/urandom", O_RDONLY);
                fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
            }
            while ((fd == -1) && (errno == EINTR));

            if (fd != -1)
            {
                if (!__sync_bool_compare_and_swap(&rand_des, -1, fd))
                {
                    // Another thread has already set the rand_des
                    close(fd);
                }
            }
            else if (errno == ENOENT)
            {
                sMissingDevURandom = true;
            }
        }

        if (rand_des != -1)
        {
            int32_t offset = 0;
            do
            {
                ssize_t n = read(rand_des, buffer + offset , (size_t)(bufferLength - offset));
                if (n == -1)
                {
                    if (errno == EINTR)
                    {
                        continue;
                    }

                    IL2CPP_ASSERT(false && "read from /dev/urandom has failed");
                    break;
                }

                offset += n;
            }
            while (offset != bufferLength);
        }
    }

    if (!sInitializedMRand)
    {
        srand48(time(NULL));
        sInitializedMRand = true;
    }

    // always xor srand48 over the whole buffer to get some randomness
    // in case /dev/urandom is not really random

    for (int i = 0; i < bufferLength; i++)
    {
        if (i % 4 == 0)
        {
            num = lrand48();
        }

        *(buffer + i) ^= num;
        num >>= 8;
    }
#endif // IL2CPP_HAVE_ARC4RANDOM_BUF
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_random.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_sizecheck.cpp---------------
.
.
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_sizecheck.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_time.cpp---------------
.
.
#include "il2cpp-config.h"
#include "pal_platform.h"

#if IL2CPP_USES_POSIX_CLASS_LIBRARY_PAL

struct TimeValPair;
#include <sys/time.h>
#include <errno.h>

extern "C"
{
    // Items needed by mscorlib
    IL2CPP_EXPORT int32_t SystemNative_UTimes(const char* path, TimeValPair* times);
}

typedef struct TimeValPair
{
    int64_t AcTimeSec;
    int64_t AcTimeUSec;
    int64_t ModTimeSec;
    int64_t ModTimeUSec;
} TimeValPair;

static void ConvertTimeValPair(const TimeValPair* pal, struct timeval native[2])
{
    native[0].tv_sec = (long)(pal->AcTimeSec);
    native[0].tv_usec = (long)(pal->AcTimeUSec);
    native[1].tv_sec = (long)(pal->ModTimeSec);
    native[1].tv_usec = (long)(pal->ModTimeUSec);
}

template<typename TInt>
static inline bool CheckInterrupted(TInt result)
{
    return result < 0 && errno == EINTR;
}

int32_t SystemNative_UTimes(const char* path, TimeValPair* times)
{
    IL2CPP_ASSERT(times != NULL);

    struct timeval temp[2];
    ConvertTimeValPair(times, temp);

    int32_t result;
    while (CheckInterrupted(result = utimes_(path, temp)))
        ;
    return result;
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_time.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_uid.cpp---------------
.
.
#include "il2cpp-config.h"
#include "pal_platform.h"

#if IL2CPP_USES_POSIX_CLASS_LIBRARY_PAL

#include "pal_platform.h"

#include <unistd.h>

extern "C"
{
    // Items needed by mscorlib
    IL2CPP_EXPORT uint32_t SystemNative_GetEUid(void);
    IL2CPP_EXPORT uint32_t SystemNative_GetEGid(void);
}

uint32_t SystemNative_GetEUid(void)
{
    return geteuid_();
}

uint32_t SystemNative_GetEGid()
{
    return getegid_();
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_uid.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_unused.cpp---------------
.
.
#include "il2cpp-config.h"
#include "pal_platform.h"
#include "vm/Exception.h"

extern "C"
{
    // Items defined in, but never used by mscorlib
    // We ensure that we implement all System.Native P/Invokes internally so we need implementations, but they don't have to do anything
    IL2CPP_EXPORT void mono_pal_init();
    IL2CPP_EXPORT int32_t SystemNative_FStat2(intptr_t fd, struct FileStatus* output);
    IL2CPP_EXPORT int32_t SystemNative_UTime(const char* path, void* time);
    IL2CPP_EXPORT int32_t GlobalizationNative_GetTimeZoneDisplayName(Il2CppChar* localeName, Il2CppChar* timeZoneId, int32_t type, Il2CppChar* result, int32_t resultLength);
}

void mono_pal_init()
{
}

int32_t SystemNative_FStat2(intptr_t fd, struct FileStatus* output)
{
    IL2CPP_NOT_IMPLEMENTED(SystemNative_FStat2);
    NOT_SUPPORTED_IL2CPP(SystemNative_FStat2, Not implemented);
    return -1;
}

int32_t SystemNative_UTime(const char* path, /* UTimBuf* */ void* time)
{
    IL2CPP_NOT_IMPLEMENTED(SystemNative_UTime);
    NOT_SUPPORTED_IL2CPP(SystemNative_UTime, Not implemented);
    return -1;
}

int32_t GlobalizationNative_GetTimeZoneDisplayName(Il2CppChar* localeName, Il2CppChar* timeZoneId, int32_t type, Il2CppChar* result, int32_t resultLength)
{
    IL2CPP_NOT_IMPLEMENTED(GlobalizationNative_GetTimeZoneDisplayName);
    NOT_SUPPORTED_IL2CPP(GlobalizationNative_GetTimeZoneDisplayName, Not implemented);
    return -1;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\ClassLibraryPAL\pal_unused.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Emscripten\SocketBridge.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_JAVASCRIPT
#include "os/SocketBridge.h"

#ifdef __EMSCRIPTEN_PTHREADS__
#include <emscripten/threading.h>
#include <emscripten/posix_socket.h>
#endif // __EMSCRIPTEN_PTHREADS__

namespace il2cpp
{
namespace os
{
    void SocketBridge::WaitForInitialization()
    {
#ifdef __EMSCRIPTEN_PTHREADS__
        EMSCRIPTEN_WEBSOCKET_T bridgeSocket = emscripten_init_websocket_to_posix_socket_bridge("ws://localhost:6690");
        // Synchronously wait until connection has been established
        uint16_t readyState = 0;
        do
        {
            emscripten_websocket_get_ready_state(bridgeSocket, &readyState);
            emscripten_thread_sleep(100);
        }
        while (readyState == 0);
#endif // __EMSCRIPTEN_PTHREADS__
    }
}
}

#endif // IL2CPP_TARGET_JAVASCRIPT
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Emscripten\SocketBridge.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Assert.cpp---------------
.
.
#include "os/Assert.h"

#if IL2CPP_DEBUG

#if IL2CPP_USE_GENERIC_ASSERT

#include <cstdio>
#include <cstdlib>

void il2cpp_assert(const char* assertion, const char* file, unsigned int line)
{
    printf("Assertion failed: %s, file %s, line %u\n", assertion, file, line);
    abort();
}

#endif // IL2CPP_USE_GENERIC_ASSERT

#endif // IL2CPP_DEBUG
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Assert.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\BrokeredFileSystem.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_SUPPORTS_BROKERED_FILESYSTEM

#include "os/BrokeredFileSystem.h"

namespace il2cpp
{
namespace os
{
    int BrokeredFileSystem::CreateDirectoryW(const UTF16String& path)
    {
        return os::kErrorCodeAccessDenied;
    }

    int BrokeredFileSystem::RemoveDirectoryW(const UTF16String& path)
    {
        return os::kErrorCodeAccessDenied;
    }

    std::set<std::string> BrokeredFileSystem::GetFileSystemEntries(const UTF16String& path, const UTF16String& pathWithPattern, int32_t attributes, int32_t attributeMask, int* error)
    {
        *error = os::kErrorCodeAccessDenied;
        return std::set<std::string>();
    }

    os::ErrorCode BrokeredFileSystem::FindFirstFileW(Directory::FindHandle* findHandle, const utils::StringView<Il2CppNativeChar>& searchPathWithPattern, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
        return os::kErrorCodeAccessDenied;
    }

    os::ErrorCode BrokeredFileSystem::FindNextFileW(Directory::FindHandle* findHandle, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
        return os::kErrorCodeAccessDenied;
    }

    os::ErrorCode BrokeredFileSystem::FindClose(void* osHandle)
    {
        return os::kErrorCodeAccessDenied;
    }

    bool BrokeredFileSystem::CopyFileW(const UTF16String& source, const UTF16String& destination, bool overwrite, int* error)
    {
        *error = os::kErrorCodeAccessDenied;
        return false;
    }

    bool BrokeredFileSystem::MoveFileW(const UTF16String& source, const UTF16String& destination, int* error)
    {
        *error = os::kErrorCodeAccessDenied;
        return false;
    }

    int BrokeredFileSystem::DeleteFileW(const UTF16String& path)
    {
        return os::kErrorCodeAccessDenied;
    }

    UnityPalFileAttributes BrokeredFileSystem::GetFileAttributesW(const UTF16String& path, int* error)
    {
        *error = os::kErrorCodeAccessDenied;
        return kFileAttributeReadOnly;
    }

    bool BrokeredFileSystem::SetFileAttributesW(const UTF16String& path, UnityPalFileAttributes attributes, int* error)
    {
        return false;
    }

    bool BrokeredFileSystem::GetFileStat(const std::string& utf8Path, const UTF16String& path, FileStat* stat, int* error)
    {
        return false;
    }

    FileHandle* BrokeredFileSystem::Open(const UTF16String& path, uint32_t desiredAccess, uint32_t shareMode, uint32_t creationDisposition, uint32_t flagsAndAttributes, int* error)
    {
        *error = os::kErrorCodeAccessDenied;
        return NULL;
    }

    void BrokeredFileSystem::CleanupStatics()
    {
    }
}
}

#endif // !IL2CPP_SUPPORTS_BROKERED_FILESYSTEM
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\BrokeredFileSystem.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\COM.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/COM.h"

#if IL2CPP_USE_GENERIC_COM

namespace il2cpp
{
namespace os
{
    il2cpp_hresult_t COM::CreateInstance(const Il2CppGuid& clsid, Il2CppIUnknown** object)
    {
        NO_UNUSED_WARNING(clsid);
        IL2CPP_ASSERT(object);
        *object = NULL;
        return IL2CPP_REGDB_E_CLASSNOTREG;
    }

    il2cpp_hresult_t COM::CreateFreeThreadedMarshaler(Il2CppIUnknown* outer, Il2CppIUnknown** marshal)
    {
        NO_UNUSED_WARNING(outer);
        IL2CPP_ASSERT(marshal);
        *marshal = NULL;
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }
}
}

#endif


#if IL2CPP_USE_GENERIC_COM_SAFEARRAYS

namespace il2cpp
{
namespace os
{
// variant

    void COM::VariantInit(Il2CppVariant* variant)
    {
        NO_UNUSED_WARNING(variant);
    }

    il2cpp_hresult_t COM::VariantClear(Il2CppVariant* variant)
    {
        NO_UNUSED_WARNING(variant);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

// safe array

    Il2CppSafeArray* COM::SafeArrayCreate(uint16_t type, uint32_t dimension_count, Il2CppSafeArrayBound* bounds)
    {
        NO_UNUSED_WARNING(type);
        NO_UNUSED_WARNING(dimension_count);
        NO_UNUSED_WARNING(bounds);
        return NULL;
    }

    il2cpp_hresult_t COM::SafeArrayDestroy(Il2CppSafeArray* safeArray)
    {
        NO_UNUSED_WARNING(safeArray);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t COM::SafeArrayAccessData(Il2CppSafeArray* safeArray, void** data)
    {
        NO_UNUSED_WARNING(safeArray);
        IL2CPP_ASSERT(data);
        *data = NULL;
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t COM::SafeArrayUnaccessData(Il2CppSafeArray* safeArray)
    {
        NO_UNUSED_WARNING(safeArray);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t COM::SafeArrayGetVartype(Il2CppSafeArray* safeArray, uint16_t* type)
    {
        NO_UNUSED_WARNING(safeArray);
        IL2CPP_ASSERT(type);
        *type = 0;
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    uint32_t COM::SafeArrayGetDim(Il2CppSafeArray* safeArray)
    {
        NO_UNUSED_WARNING(safeArray);
        return 0;
    }

    il2cpp_hresult_t COM::SafeArrayGetLBound(Il2CppSafeArray* safeArray, uint32_t dimention, int32_t* bound)
    {
        NO_UNUSED_WARNING(safeArray);
        NO_UNUSED_WARNING(dimention);
        IL2CPP_ASSERT(bound);
        *bound = 0;
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t COM::SafeArrayGetUBound(Il2CppSafeArray* safeArray, uint32_t dimention, int32_t* bound)
    {
        NO_UNUSED_WARNING(safeArray);
        NO_UNUSED_WARNING(dimention);
        IL2CPP_ASSERT(bound);
        *bound = 0;
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\COM.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\CpuInfo.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"
#if !IL2CPP_PLATFORM_SUPPORTS_CPU_INFO

#include "os/CpuInfo.h"

namespace il2cpp
{
namespace os
{
    void* CpuInfo::Create()
    {
        return NULL;
    }

    int32_t CpuInfo::Usage(void* previous)
    {
        return 0;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\CpuInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\CrashHelpers.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_CRASH_HELPERS

#include "os/CrashHelpers.h"

#include <cstdlib>

namespace il2cpp
{
namespace os
{
    void CrashHelpers::CrashImpl()
    {
        abort();
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\CrashHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Debug.cpp---------------
.
.
// Generic implementation for platforms that don't have this implemented
#include "il2cpp-config.h"
#include "os/Debug.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace os
{
#if !IL2CPP_PLATFORM_SUPPORTS_DEBUGGER_PRESENT
    bool Debug::IsDebuggerPresent()
    {
        return false;
    }

#endif

#if IL2CPP_USE_GENERIC_DEBUG_LOG
    void Debug::WriteString(const utils::StringView<Il2CppNativeChar>& message)
    {
        il2cpp::utils::StringUtils::Printf(message.Str());
    }

#endif
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Debug.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Environment.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_ENVIRONMENT
#include "os/Environment.h"

#include <cstdlib>

namespace il2cpp
{
namespace os
{
    std::string Environment::GetMachineName()
    {
        return "il2cpp";
    }

    int32_t Environment::GetProcessorCount()
    {
        return 1;
    }

    std::string Environment::GetOsVersionString()
    {
        return "0.0.0.0";
    }

    std::string Environment::GetOsUserName()
    {
        return "Unknown";
    }

    std::string Environment::GetEnvironmentVariable(const std::string& name)
    {
        return std::string("<NotImplemented>");
    }

    void Environment::SetEnvironmentVariable(const std::string& name, const std::string& value)
    {
    }

    std::vector<std::string> Environment::GetEnvironmentVariableNames()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Environment::GetEnvironmentVariableNames);
        return std::vector<std::string>();
    }

    std::string Environment::GetHomeDirectory()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Environment::GetHomeDirectory);
        return std::string();
    }

    std::vector<std::string> Environment::GetLogicalDrives()
    {
        return std::vector<std::string>();
    }

    void Environment::Exit(int result)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Environment::Exit);
    }

    NORETURN void Environment::Abort()
    {
        abort();
    }

    utils::Expected<bool> Environment::Is64BitOs()
    {
        return false;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Environment.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\File.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_FILE
#include "os/File.h"

namespace il2cpp
{
namespace os
{
    bool File::Truncate(FileHandle* handle, int *error)
    {
        NO_UNUSED_WARNING(handle);
        NO_UNUSED_WARNING(error);
        return false;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\File.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Handle.cpp---------------
.
.
#include "il2cpp-config.h"

#include "os/Handle.h"

#if IL2CPP_SUPPORT_THREADS

#include <algorithm>
#include "os/Thread.h"

namespace il2cpp
{
namespace os
{
    int32_t Handle::WaitAny(const std::vector<Handle*>& handles, int32_t ms)
    {
        int timeWaitedMs = 0;
        while (ms == -1 || timeWaitedMs <= ms)
        {
            int32_t numberOfOsHandles = (int32_t)handles.size();
            for (int32_t i = 0; i < numberOfOsHandles; ++i)
            {
                if (handles[i]->Wait(0U))
                    return i;
            }

            os::Thread::Sleep(m_waitIntervalMs, true);
            timeWaitedMs += m_waitIntervalMs;
        }

        return 258; // WAIT_TIMEOUT value
    }

    bool Handle::WaitAll(std::vector<Handle*>& handles, int32_t ms)
    {
        int timeWaitedMs = 0;
        while (ms == -1 || timeWaitedMs <= ms)
        {
            size_t numberOfOsHandles = handles.size();
            std::vector<Handle*> signaledHandles;
            for (size_t i = 0; i < numberOfOsHandles; ++i)
            {
                if (handles[i]->Wait(0U))
                    signaledHandles.push_back(handles[i]);
            }

            if (signaledHandles.size() == numberOfOsHandles)
                return true; // All handles have been signaled

            for (size_t i = 0; i < signaledHandles.size(); ++i)
                handles.erase(std::remove(handles.begin(), handles.end(), signaledHandles[i]), handles.end());

            os::Thread::Sleep(m_waitIntervalMs, true);
            timeWaitedMs += m_waitIntervalMs;
        }

        return false; // Timed out waiting for all handles to be signaled
    }
} // namespace os
} // naemspace il2cpp

#else

namespace il2cpp
{
namespace os
{
    int32_t Handle::WaitAny(const std::vector<Handle*>& handles, int32_t ms)
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return 0;
    }

    bool Handle::WaitAll(std::vector<Handle*>& handles, int32_t ms)
    {
        IL2CPP_ASSERT(0 && "Threads are not enabled for this platform.");
        return false;
    }
} // namespace os
} // naemspace il2cpp

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Handle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Initialize.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Initialize.h"

#if !(IL2CPP_TARGET_WINDOWS || IL2CPP_TARGET_ANDROID || IL2CPP_TARGET_PS4 || IL2CPP_TARGET_PS5)

void il2cpp::os::Initialize()
{
}

void il2cpp::os::Uninitialize()
{
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Initialize.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\LibraryLoader.cpp---------------
.
.
#include "il2cpp-config.h"


#if !IL2CPP_TARGET_WINDOWS

#include "os/LibraryLoader.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace os
{
    bool LibraryLoader::EntryNameMatches(const il2cpp::utils::StringView<char>& hardcodedEntryPoint, const il2cpp::utils::StringView<char>& entryPoint)
    {
        return hardcodedEntryPoint.Length() == entryPoint.Length() && strncmp(hardcodedEntryPoint.Str(), entryPoint.Str(), entryPoint.Length()) == 0;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\LibraryLoader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\MarshalStringAlloc.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_COM
#include "os/MarshalStringAlloc.h"

namespace il2cpp
{
namespace os
{
    il2cpp_hresult_t MarshalStringAlloc::AllocateBStringLength(const Il2CppChar* text, int32_t length, Il2CppChar** bstr)
    {
        NO_UNUSED_WARNING(text);
        NO_UNUSED_WARNING(length);
        IL2CPP_ASSERT(bstr);
        *bstr = NULL;
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t MarshalStringAlloc::GetBStringLength(const Il2CppChar* bstr, int32_t* length)
    {
        NO_UNUSED_WARNING(bstr);
        IL2CPP_ASSERT(length);
        *length = 0;
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t MarshalStringAlloc::FreeBString(Il2CppChar* bstr)
    {
        NO_UNUSED_WARNING(bstr);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\MarshalStringAlloc.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\MemoryMappedFile.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_MEMORY_MAPPED_FILE
#include "os/File.h"
#include "os/MemoryMappedFile.h"
#include "os/Mutex.h"
#include "utils/dynamic_array.h"
#include "utils/Memory.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace os
{
    struct MemoryFileData
    {
        MemoryFileData(const char* name, int64_t dataSize)
            : size(dataSize)
        {
            size_t nameSize = strlen(name);
            mapName = (char*)IL2CPP_MALLOC(nameSize  + 1);
            strcpy(mapName, name);

            handle = IL2CPP_MALLOC_ZERO((size_t)dataSize);
        }

        ~MemoryFileData()
        {
            IL2CPP_FREE(mapName);
            IL2CPP_FREE(handle);
        }

        char* mapName;
        void* handle;
        int64_t size;
    };


    struct MemoryFilesContext
    {
        baselib::ReentrantLock m_Mutex;
        il2cpp::utils::dynamic_array<MemoryFileData*> m_MemoryFiles;
        il2cpp::utils::dynamic_array<void*> m_MemoryFileViews;
    };

    MemoryFilesContext* s_MemoryFilesContext = nullptr;

    static bool IsMemoryFile(void* possibleMemoryFile)
    {
        os::FastAutoLock lock(&s_MemoryFilesContext->m_Mutex);
        for (il2cpp::utils::dynamic_array<MemoryFileData*>::const_iterator it = s_MemoryFilesContext->m_MemoryFiles.begin(); it != s_MemoryFilesContext->m_MemoryFiles.end(); ++it)
        {
            if ((*it)->handle == possibleMemoryFile)
                return true;
        }

        return false;
    }

    static MemoryFileData* FindMemoryFile(void* possibleMemoryFile)
    {
        for (il2cpp::utils::dynamic_array<MemoryFileData*>::iterator it = s_MemoryFilesContext->m_MemoryFiles.begin(); it != s_MemoryFilesContext->m_MemoryFiles.end(); ++it)
        {
            if ((*it)->handle == possibleMemoryFile)
            {
                return *it;
            }
        }

        return NULL;
    }

    static MemoryFileData* FindMemoryFile(const char* mapName)
    {
        for (il2cpp::utils::dynamic_array<MemoryFileData*>::iterator it = s_MemoryFilesContext->m_MemoryFiles.begin(); it != s_MemoryFilesContext->m_MemoryFiles.end(); ++it)
        {
            if (strcmp((*it)->mapName, mapName) == 0)
            {
                return *it;
            }
        }

        return NULL;
    }

    static bool IsMemoryFileView(void* possibleMemoryFile)
    {
        os::FastAutoLock lock(&s_MemoryFilesContext->m_Mutex);
        return std::find(s_MemoryFilesContext->m_MemoryFileViews.begin(), s_MemoryFilesContext->m_MemoryFileViews.end(), possibleMemoryFile) != s_MemoryFilesContext->m_MemoryFileViews.end();
    }

    void MemoryMappedFile::AllocateStaticData()
    {
        s_MemoryFilesContext = new MemoryFilesContext();
    }

    void MemoryMappedFile::FreeStaticData()
    {
        delete s_MemoryFilesContext;
        s_MemoryFilesContext = nullptr;
    }

    FileHandle* MemoryMappedFile::Create(FileHandle* file, const char* mapName, int32_t mode, int64_t *capacity, MemoryMappedFileAccess access, int32_t options, MemoryMappedFileError* error)
    {
        if (file == NULL)
        {
            if (mapName != NULL)
            {
                os::FastAutoLock lock(&s_MemoryFilesContext->m_Mutex);

                const MemoryFileData* memoryFileData = FindMemoryFile(mapName);

                if (memoryFileData != NULL)
                {
                    file = (FileHandle*)memoryFileData->handle;
                }
                else
                {
                    MemoryFileData* memoryFileData = new MemoryFileData(mapName, *capacity);
                    s_MemoryFilesContext->m_MemoryFiles.push_back(memoryFileData);

                    file = (FileHandle*)memoryFileData->handle;
                }
            }
        }

        return file;
    }

    static MemoryMappedFile::MemoryMappedFileHandle ViewRealFile(FileHandle* mappedFileHandle, int64_t* length, int64_t offset, MemoryMappedFileAccess access, MemoryMappedFileError* error)
    {
        int fileError = 0;
        if (*length == 0)
        {
            *length = os::File::GetLength(mappedFileHandle, &fileError);
            if (fileError != 0)
            {
                if (error != NULL)
                    *error = COULD_NOT_MAP_MEMORY;
                return NULL;
            }
        }

        void* buffer = IL2CPP_MALLOC_ZERO((size_t)*length);

        os::File::Seek(mappedFileHandle, offset, 0, &fileError);
        if (fileError != 0)
        {
            IL2CPP_FREE(buffer);
            if (error != NULL)
                *error = COULD_NOT_MAP_MEMORY;
            return NULL;
        }

        int bytesRead = File::Read(mappedFileHandle, (char*)buffer, (int)*length, &fileError);
        if (bytesRead != *length || fileError != 0)
        {
            IL2CPP_FREE(buffer);
            if (error != NULL)
                *error = COULD_NOT_MAP_MEMORY;
            return NULL;
        }

        return buffer;
    }

    static MemoryMappedFile::MemoryMappedFileHandle ViewMemoryFile(void* mappedFileHandle, int64_t* length, int64_t offset, MemoryMappedFileAccess access, MemoryMappedFileError* error)
    {
        os::FastAutoLock lock(&s_MemoryFilesContext->m_Mutex);
        const MemoryFileData* memoryFileData = FindMemoryFile(mappedFileHandle);
        IL2CPP_ASSERT(memoryFileData != NULL);

        if (*length == 0)
            *length = memoryFileData->size;

        if (*length > memoryFileData->size)
        {
            if (error != NULL)
                *error = COULD_NOT_MAP_MEMORY;
            return NULL;
        }

        void* memoryMappedFileView = (uint8_t*)memoryFileData->handle + offset;

        s_MemoryFilesContext->m_MemoryFileViews.push_back(memoryMappedFileView);

        return memoryMappedFileView;
    }

    MemoryMappedFile::MemoryMappedFileHandle MemoryMappedFile::View(FileHandle* mappedFileHandle, int64_t* length, int64_t offset, MemoryMappedFileAccess access, int64_t* actualOffset, MemoryMappedFileError* error)
    {
        IL2CPP_ASSERT(actualOffset != NULL);

        *actualOffset = offset;
        if (IsMemoryFile((void*)mappedFileHandle))
            return ViewMemoryFile((void*)mappedFileHandle, length, offset, access, error);
        else
            return ViewRealFile(mappedFileHandle, length, offset, access, error);
    }

    void MemoryMappedFile::Flush(MemoryMappedFileHandle memoryMappedFileData, int64_t length)
    {
    }

    bool MemoryMappedFile::UnmapView(MemoryMappedFileHandle memoryMappedFileData, int64_t length)
    {
        if (IsMemoryFileView(memoryMappedFileData))
            s_MemoryFilesContext->m_MemoryFileViews.erase_swap_back(&memoryMappedFileData);
        else if (!IsMemoryFile(memoryMappedFileData))
            IL2CPP_FREE(memoryMappedFileData);
        return true;
    }

    bool MemoryMappedFile::Close(FileHandle* file)
    {
        os::FastAutoLock lock(&s_MemoryFilesContext->m_Mutex);
        MemoryFileData* memoryFileData = FindMemoryFile((void*)file);
        if (memoryFileData != NULL)
        {
            delete memoryFileData;
            s_MemoryFilesContext->m_MemoryFiles.erase_swap_back(&memoryFileData);
        }
        return true;
    }

    void MemoryMappedFile::ConfigureHandleInheritability(FileHandle* file, bool inheritability)
    {
    }

    bool MemoryMappedFile::OwnsDuplicatedFileHandle(FileHandle* file)
    {
        return true;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\MemoryMappedFile.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\SocketBridge.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_SOCKET_BRIDGE
#include "os/SocketBridge.h"

namespace il2cpp
{
namespace os
{
    void SocketBridge::WaitForInitialization()
    {
        // Do nothing in the generic case, as there is no socket bridge to wait for.
    }
}
}

#endif // IL2CPP_USE_GENERIC_SOCKET_BRIDGE
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\SocketBridge.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\SocketImpl.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_SOCKET_IMPL && IL2CPP_SUPPORT_SOCKETS

#include "os/Generic/SocketImpl.h"

#define SOCKET_NOT_IMPLEMENTED \
    IL2CPP_ASSERT(0 && "The target platform does not support Sockets");

namespace il2cpp
{
namespace os
{
    void SocketImpl::Startup()
    {
    }

    void SocketImpl::Cleanup()
    {
    }

    WaitStatus SocketImpl::GetHostName(std::string &name)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetHostByAddr(const std::string &address, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addr_list)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetHostByName(const std::string &host, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addresses)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetHostByName(const std::string &host, std::string &name, int32_t &family, std::vector<std::string> &aliases, std::vector<void*> &addr_list, int32_t &addr_size)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    SocketImpl::SocketImpl(ThreadStatusCallback thread_status_callback)
    {
        SOCKET_NOT_IMPLEMENTED
    }

    SocketImpl::~SocketImpl()
    {
    }

    WaitStatus SocketImpl::Create(AddressFamily family, SocketType type, ProtocolType protocol)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Create(SocketDescriptor fd, int32_t family, int32_t type, int32_t protocol)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Close()
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SetBlocking(bool blocking)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    ErrorCode SocketImpl::GetLastError() const
    {
        SOCKET_NOT_IMPLEMENTED

        return (ErrorCode) - 1;
    }

    WaitStatus SocketImpl::Bind(const char *path)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Bind(const char *address, uint16_t port)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Bind(uint32_t address, uint16_t port)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Bind(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Connect(const char *path)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Shutdown(int32_t how)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Disconnect(bool reuse)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Connect(uint32_t address, uint16_t port)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Connect(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetLocalEndPointInfo(EndPointInfo &info)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetRemoteEndPointInfo(EndPointInfo &info)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Listen(int32_t backlog)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Accept(os::Socket **socket)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Receive(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Send(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SendArray(WSABuf *wsabufs, int32_t count, int32_t *sent, SocketFlags c_flags)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::ReceiveArray(WSABuf *wsabufs, int32_t count, int32_t *len, SocketFlags flags)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SendTo(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SendTo(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SendTo(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::RecvFrom(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::RecvFrom(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::RecvFrom(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Available(int32_t *amount)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Ioctl(int32_t command, const uint8_t *in_data, int32_t in_len, uint8_t *out_data, int32_t out_len, int32_t *written)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetSocketOption(SocketOptionLevel level, SocketOptionName name, uint8_t *buffer, int32_t *length)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetSocketOptionFull(SocketOptionLevel level, SocketOptionName name, int32_t *first, int32_t *second)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Poll(std::vector<PollRequest> &requests, int32_t count, int32_t timeout, int32_t *result, int32_t *error)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Poll(std::vector<PollRequest> &requests, int32_t timeout, int32_t *result, int32_t *error)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Poll(PollRequest& request, int32_t timeout, int32_t *result, int32_t *error)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SetSocketOption(SocketOptionLevel level, SocketOptionName name, int32_t value)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SetSocketOptionLinger(SocketOptionLevel level, SocketOptionName name, bool enabled, int32_t seconds)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SetSocketOptionArray(SocketOptionLevel level, SocketOptionName name, const uint8_t *buffer, int32_t length)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, uint32_t group_address, uint32_t local_address)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

#if IL2CPP_SUPPORT_IPV6
    WaitStatus SocketImpl::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, IPv6Address ipv6, uint64_t interfaceOffset)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }

#endif

    WaitStatus SocketImpl::SendFile(const char *filename, TransmitFileBuffers *buffers, TransmitFileOptions options)
    {
        SOCKET_NOT_IMPLEMENTED

        return kWaitStatusFailure;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\SocketImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\SystemCertificates.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#if !IL2CPP_PLATFORM_SUPPORTS_SYSTEM_CERTIFICATES
#include "os/SystemCertificates.h"

namespace il2cpp
{
namespace os
{
    void* SystemCertificates::OpenSystemRootStore()
    {
        return 0;
    }

    int SystemCertificates::EnumSystemCertificates(void* certStore, void** iter, int *format, int* size, void** data)
    {
        return 0;
    }

    void SystemCertificates::CloseSystemRootStore(void* cStore)
    {
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\SystemCertificates.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Thread.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_USE_GENERIC_THREAD

#include "os/Thread.h"

namespace il2cpp
{
namespace os
{
    bool Thread::GetCurrentThreadStackBounds(void** low, void** high)
    {
        return false;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\WaitObject.cpp---------------
.
.
#include "il2cpp-config.h"

#if (IL2CPP_THREADS_PTHREAD || IL2CPP_THREADS_WIN32)

#include "WaitObject.h"
#include "os/Time.h"
#if IL2CPP_THREADS_WIN32
#include "os/Win32/ThreadImpl.h"
#else
#include "os/Posix/ThreadImpl.h"
#endif


// Notes:
// ************************************ Old notes here ************************************
// - Situation
//   - None of the pthread APIs are interruptible (they all explicitly forbid returning EINTR).
//   - We cannot do any non-local transfers of control from signal handlers safely (C++ exceptions
//     or longjmp). Thus we cannot use signals to inject interruptions into a thread.
//   - Very few of the system APIs we have available support timeouts (at least not on all platforms).
// - Ergo: we need to roll our own synchronization primitives based on pthread condition variables
//     (they support timeouts and have the functionality needed to model the other primitives).
// - BUT: the condition variables still involve mutexes which we cannot lock in way that allows
//     interruptions. This means that there will be time windows where threads will wait and just
//     block and not allow interruption.
//
// ************************************ Old notes above ************************************
/*
    Pthread api functions has been replaced by baselib sync primitives

    Condition variable is simulated by using a baselib capped semaphore in the thread itself and a baselib lock
    which is part of our sync primitive. If a thread waits for a condition we first take the lock and tell
    current thread to save 'us' as a wait object and then go into the simulated condition variable.
    Our condition variable first registers the thread as a waiter to be used when waking up threads.
    This list is a shared resource but we already have acquired the lock. Then we acquire the capped semaphore
    on the thread side of things that will either put us to sleep or carry on as normal if the semaphore has been signalled already.
    Once the thread wakes up, either from an APC or otherwise, it will re-acquire the lock and check for pending APCs
    and then if the condition itself (m_Count is 0) has been met.

    If an APC is queued we save the request (a callback and context) on the thread side and release/signal the semaphore to wakeup the thread. Once awake we
    call into the thread to process the APC by invoking the callback which once done will throw an exception which is then caught by WaitObject::Wait()
    and we exit the wait.

*/


namespace il2cpp
{
namespace os
{
    WaitObject::WaitObject(Type type)
        : m_Type(type)
        , m_Count(0)
        , m_WaitingThreadCount(0)
    {
    }

    WaitObject::~WaitObject()
    {
    }

    WaitStatus WaitObject::Wait(bool interruptible)
    {
        return Wait(kNoTimeout, interruptible);
    }

    WaitStatus WaitObject::Wait(uint32_t timeoutMS, bool interruptible)
    {
        // IMPORTANT: This function must be exception-safe! APCs may throw.

        ThreadImpl* currentThread = ThreadImpl::GetCurrentThread();

        // Do up-front check about pending APC except this is a zero-timeout
        // wait (i.e. a wait that is never supposed to block and thus go into
        // an interruptible state).
        if (interruptible && timeoutMS != 0)
            currentThread->CheckForUserAPCAndHandle();

        // Lock object. We release this mutex during waiting.
        ReleaseOnDestroy lock(m_Mutex);

        // See if the object is in a state where we can acquire it right away.
        if (m_Count == 0)
        {
            // No, hasn't. If we're not supposed to wait, we're done.
            if (timeoutMS == 0)
                return kWaitStatusTimeout;

            try
            {
                // We should wait. Let the world know this thread is now waiting
                // on this object.
                if (interruptible)
                    currentThread->SetWaitObject(this);

                // Check APC queue again to avoid race condition.
                if (interruptible)
                    currentThread->CheckForUserAPCAndHandle();

                // Go into wait until we either have a release or timeout or otherwise fail.
                int32_t remainingWaitTime = (int32_t)timeoutMS;
                WaitStatus waitStatus = kWaitStatusSuccess;
                while (m_Count == 0)
                {
                    if (timeoutMS == kNoTimeout)
                    {
                        // Infinite wait. Can only be interrupted by APC.
                        ++m_WaitingThreadCount; // No synchronization necessary; we hold the mutex.
                        ConditionWait(currentThread);
                        --m_WaitingThreadCount;
                    }
                    else
                    {
                        // Timed wait. Can be interrupted by APC or timeout.
                        const int64_t waitStartTime = Time::GetTicks100NanosecondsMonotonic();

                        ++m_WaitingThreadCount;
                        bool wait_timedout = ConditionTimedWait(currentThread, remainingWaitTime);
                        --m_WaitingThreadCount; ////TODO: make this atomic for when we fail to reacquire the mutex

                        if (wait_timedout == false)
                        {
                            waitStatus = kWaitStatusTimeout;
                            break;
                        }

                        // Update time we have have left to wait.
                        const int32_t waitTimeThisRound = (int32_t)(Time::GetTicks100NanosecondsMonotonic() - waitStartTime) / 10000;
                        if (waitTimeThisRound > remainingWaitTime)
                            remainingWaitTime = 0;
                        else
                            remainingWaitTime -= waitTimeThisRound;
                    }

                    // We've received a signal but it may be because of an APC and not because
                    // the semaphore got signaled. If so, handle the APC and go back to waiting.
                    if (interruptible)
                        currentThread->CheckForUserAPCAndHandle();
                }

                // We're done waiting so untie us from the current thread.
                // NOTE: A thread may have grabbed us and then got paused. If we return now and then our owner
                //       tries to delete us, we would pull the rug from under the other thread. This is prevented by
                //       having a central lock on wait object deletion which any thread trying to deal with wait
                //       objects from other threads has to acquire.
                if (interruptible)
                {
                    currentThread->SetWaitObject(NULL);

                    // Avoid race condition by checking APC queue again after unsetting wait object.
                    currentThread->CheckForUserAPCAndHandle();
                }

                // If we failed, bail out now.
                if (waitStatus != kWaitStatusSuccess)
                    return waitStatus;
            }
            catch (...)
            {
                if (interruptible)
                    currentThread->SetWaitObject(NULL);
                throw;
            }
        }

        // At this point, we should be in signaled state and have the lock on
        // the object.

        // Object has been released. Acquire it for this thread.
        IL2CPP_ASSERT(m_Count > 0);
        switch (m_Type)
        {
            case kManualResetEvent:
                // Nothing to do.
                break;

            case kMutex:
            case kAutoResetEvent:
                m_Count = 0;
                break;

            case kSemaphore:
                if (m_Count > 0) // Defensive.
                {
                    --m_Count;
                    if (m_Count > 0)
                    {
                        // There's more releases on the semaphore. Signal the next thread in line.
                        if (HaveWaitingThreads())
                            WakeupOneThread();
                    }
                }
                break;
        }

        return kWaitStatusSuccess;
    }

    // Register this thread as a waiter to be notified
    void WaitObject::PushThreadToWaitersList(WaitObject* owner, ThreadImpl* thread)
    {
        SThreadPairPosix pair(thread, owner);
        m_WaitingThreads.push_back(pair);
    }

    // Unregister this thread
    void WaitObject::PopThreadFromWaitersList(ThreadImpl* thread)
    {
        auto it = m_WaitingThreads.begin();
        while (it != m_WaitingThreads.end())
        {
            if ((*it).thread == thread)
            {
                m_WaitingThreads.erase_swap_back(it);
                break;
            }
            else
                ++it;
        }
    }

    void WaitObject::ConditionWait(ThreadImpl* thread)
    {
        PushThreadToWaitersList(this, thread);
        m_Mutex.Release();

        thread->AcquireSemaphore();

        m_Mutex.Acquire();
        PopThreadFromWaitersList(thread);
    }

    bool WaitObject::ConditionTimedWait(ThreadImpl* thread, uint32_t timeout)
    {
        PushThreadToWaitersList(this, thread);
        m_Mutex.Release();

        bool ret = thread->TryTimedAcquireSemaphore(timeout);

        m_Mutex.Acquire();
        PopThreadFromWaitersList(thread);
        return ret;
    }

    void WaitObject::WakeupThreads(bool wakeupOneThread)
    {
        // Wake up threads.
        // We do this by iterating the waiters list and check if the owner (the semaphore, event or mutex) matches 'this'
        // ie who is waiting for us specifically

        // Mutex must be locked already by caller, see EventImpl::Set(), SemaphoreImpl::Post() and EventImpl::Set()
        IL2CPP_ASSERT(m_Mutex.TryAcquire() == false);

        int threadsWaiting = (int)m_WaitingThreads.size();
        int threadsNotified = 0;

        for (int i = 0; i < threadsWaiting; i++)
        {
            SThreadPairPosix* object = &m_WaitingThreads[i];

            if (object->owner == this)
            {
                // a thread is stuck waiting for us, signal the thread semaphore
                object->thread->ReleaseSemaphore();

                // if only one wakeup is requested we exit here
                if (wakeupOneThread)
                    break;
            }
        }
    }

    void* WaitObject::GetOSHandle()
    {
        IL2CPP_ASSERT(0 && "This function is not implemented and should not be called");
        return NULL;
    }
}
}

#endif // IL2CPP_TARGET_POSIX
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\WaitObject.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\WindowsRuntime.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/WindowsRuntime.h"
#include "utils/Expected.h"
#include "utils/Il2CppError.h"

#if IL2CPP_USE_GENERIC_WINDOWSRUNTIME

namespace il2cpp
{
namespace os
{
    il2cpp_hresult_t WindowsRuntime::GetActivationFactory(Il2CppHString className, Il2CppIActivationFactory** activationFactory)
    {
        NO_UNUSED_WARNING(className);
        NO_UNUSED_WARNING(activationFactory);
        IL2CPP_ASSERT(className != NULL);
        IL2CPP_ASSERT(activationFactory != NULL);
        return IL2CPP_REGDB_E_CLASSNOTREG;
    }

    il2cpp_hresult_t WindowsRuntime::CreateHStringReference(const utils::StringView<Il2CppNativeChar>& str, Il2CppHStringHeader* header, Il2CppHString* hstring)
    {
        NO_UNUSED_WARNING(str);
        NO_UNUSED_WARNING(header);
        NO_UNUSED_WARNING(hstring);
        IL2CPP_ASSERT(header != NULL);
        IL2CPP_ASSERT(hstring != NULL);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t WindowsRuntime::CreateHString(const utils::StringView<Il2CppChar>& str, Il2CppHString* hstring)
    {
        NO_UNUSED_WARNING(str);
        NO_UNUSED_WARNING(hstring);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

#if !IL2CPP_TARGET_WINDOWS // Il2CppChar and Il2CppNativeChar are the same on Windows
    il2cpp_hresult_t WindowsRuntime::CreateHString(const utils::StringView<Il2CppNativeChar>& str, Il2CppHString* hstring)
    {
        NO_UNUSED_WARNING(str);
        NO_UNUSED_WARNING(hstring);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

#endif

    il2cpp_hresult_t WindowsRuntime::DuplicateHString(Il2CppHString hstring, Il2CppHString* duplicated)
    {
        NO_UNUSED_WARNING(hstring);
        NO_UNUSED_WARNING(duplicated);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    il2cpp_hresult_t WindowsRuntime::DeleteHString(Il2CppHString hstring)
    {
        NO_UNUSED_WARNING(hstring);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    utils::Expected<const Il2CppChar*> WindowsRuntime::GetHStringBuffer(Il2CppHString hstring, uint32_t* length)
    {
        NO_UNUSED_WARNING(hstring);
        NO_UNUSED_WARNING(length);
        return utils::Il2CppError(utils::ComError, IL2CPP_COR_E_PLATFORMNOTSUPPORTED);
    }

    utils::Expected<const Il2CppNativeChar*> WindowsRuntime::GetNativeHStringBuffer(Il2CppHString hstring, uint32_t* length)
    {
        NO_UNUSED_WARNING(hstring);
        NO_UNUSED_WARNING(length);
        return utils::Il2CppError(utils::ComError, IL2CPP_COR_E_PLATFORMNOTSUPPORTED);
    }

    utils::Expected<il2cpp_hresult_t> WindowsRuntime::PreallocateHStringBuffer(uint32_t length, Il2CppNativeChar** mutableBuffer, void** bufferHandle)
    {
        NO_UNUSED_WARNING(length);
        NO_UNUSED_WARNING(mutableBuffer);
        NO_UNUSED_WARNING(bufferHandle);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    utils::Expected<il2cpp_hresult_t> WindowsRuntime::PromoteHStringBuffer(void* bufferHandle, Il2CppHString* hstring)
    {
        NO_UNUSED_WARNING(bufferHandle);
        NO_UNUSED_WARNING(hstring);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    utils::Expected<il2cpp_hresult_t> WindowsRuntime::DeleteHStringBuffer(void* bufferHandle)
    {
        NO_UNUSED_WARNING(bufferHandle);
        return IL2CPP_COR_E_PLATFORMNOTSUPPORTED;
    }

    Il2CppIRestrictedErrorInfo* WindowsRuntime::GetRestrictedErrorInfo()
    {
        return NULL;
    }

    void WindowsRuntime::OriginateLanguageException(il2cpp_hresult_t hresult, Il2CppException* ex, Il2CppString* exceptionString, GetOrCreateFunc createCCWCallback)
    {
        NO_UNUSED_WARNING(ex);
        NO_UNUSED_WARNING(exceptionString);
        NO_UNUSED_WARNING(createCCWCallback);
    }

    void WindowsRuntime::EnableErrorReporting()
    {
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Generic\WindowsRuntime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\Image.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/Memory.h"

#if IL2CPP_TARGET_DARWIN

#include "os/Image.h"

#include <mach-o/dyld.h>
#include <mach-o/getsect.h>
#include <mach-o/ldsyms.h>
#include <dlfcn.h>
#include <vector>

namespace il2cpp
{
namespace os
{
namespace Image
{
    static void* s_ImageBase = NULL;

    static int GetImageIndex()
    {
        // OSX/iOS uses ASLR (address space layout randomization), so
        // find where the image is loaded. This is usually zero in the
        // debugger for an executable, but non-zero when a debugger is not
        // present.
        std::vector<char> path;
        uint32_t size = 0;
        int error = _NSGetExecutablePath(NULL, &size);
        IL2CPP_ASSERT(error == -1);
        if (error != -1)
            return -1;

        path.resize(size);
        error = _NSGetExecutablePath(&path[0], &size);
        IL2CPP_ASSERT(error == 0);
        if (error != 0)
            return -1;

        int gameAssemblyImageIndex = -1;
        int executableImageIndex = -1;
        int numberOfImages = _dyld_image_count();
        for (uint32_t i = 0; i < numberOfImages; i++)
        {
            const char* imageName = _dyld_get_image_name(i);
            if (strstr(imageName, "GameAssembly.dylib") != NULL || strstr(imageName, "UnityFramework.framework/UnityFramework") != NULL)
            {
                gameAssemblyImageIndex = i;
                break;
            }
            else if (strstr(imageName, &path[0]) != NULL)
            {
                executableImageIndex = i;
            }
        }

        if (gameAssemblyImageIndex != -1)
            return gameAssemblyImageIndex;
        else if (executableImageIndex != -1)
            return executableImageIndex;

        return -1;
    }

    static void InitializeImageBase()
    {
        // Gets info about the image containing InitializeImageBase
        Dl_info info;
        memset(&info, 0, sizeof(info));
        int error = dladdr((void*)&InitializeImageBase, &info);

        IL2CPP_ASSERT(error != 0);
        if (error == 0)
            return;

        s_ImageBase = info.dli_fbase;
    }

#if IL2CPP_SIZEOF_VOID_P == 8
    typedef struct mach_header_64 arch_header_t;
#else
    typedef struct mach_header arch_header_t;
#endif

    static uint8_t* SectionDataFor(int imageIndex, unsigned long* size)
    {
        return getsectiondata((const arch_header_t*)_dyld_get_image_header(imageIndex), "__TEXT", IL2CPP_BINARY_SECTION_NAME, size);
    }

    static void InitializeManagedSection()
    {
        int imageIndex = GetImageIndex();
        if (imageIndex == -1)
            return;

        unsigned long sectionSize = 0;
        uint8_t* sectionData = SectionDataFor(imageIndex, &sectionSize);
        if (sectionData == NULL)
        {
            // We did not find the managed section of the binary in the image where we
            // think it should live. Maybe Unity is being embedded in another application.
            // Let's search all of the images and find the first one that has our section
            // in the binary.
            //
            // This won't work correctly if more than one Unity binary is embedded, but we
            // don't support that case yet.
            int numberOfImages = _dyld_image_count();
            imageIndex = 0;
            while (sectionData == NULL && imageIndex < numberOfImages)
            {
                sectionData = SectionDataFor(imageIndex, &sectionSize);
                imageIndex++;
            }
        }

        if (sectionData != NULL)
        {
            void* start = (void*)sectionData;
            void* end = (uint8_t*)start + sectionSize;

            SetManagedSectionStartAndEnd(start, end);
        }
    }

    void Initialize()
    {
        InitializeImageBase();
        InitializeManagedSection();
    }

    void* GetImageBase()
    {
        return s_ImageBase;
    }

#if IL2CPP_ENABLE_NATIVE_INSTRUCTION_POINTER_EMISSION
    char* GetImageUUID()
    {
        int imageIndex = GetImageIndex();
        if (imageIndex == -1)
            return NULL;

        const struct mach_header_64* header = (mach_header_64*)_dyld_get_image_header(imageIndex);
        const uint8_t *command = (const uint8_t *)(header + 1);

        for (uint32_t idx = 0; idx < header->ncmds; ++idx)
        {
            if (((const struct load_command *)command)->cmd == LC_UUID)
            {
                command += sizeof(struct load_command);
                char* uuid = static_cast<char*>(IL2CPP_MALLOC(33));
                snprintf(uuid, 33, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                    command[0], command[1], command[2], command[3],
                    command[4], command[5], command[6], command[7],
                    command[8], command[9], command[10], command[11],
                    command[12], command[13], command[14], command[15]);
                return uuid;
            }
            else
            {
                command += ((const struct load_command *)command)->cmdsize;
            }
        }

        return NULL;
    }

    char* GetImageName()
    {
        const char* imageName = _dyld_get_image_name(GetImageIndex());
        size_t nameSize = strlen(imageName);
        char* imageNameCopy = (char*)IL2CPP_MALLOC(nameSize);
        strncpy(imageNameCopy, imageName, nameSize);
        return imageNameCopy;
    }

#endif
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\Image.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\Process.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_DARWIN

#include <sys/types.h>
#if !IL2CPP_TARGET_IOS
#include <libproc.h>
#endif
#include <unistd.h>
#include <stdlib.h>

#include "os/Process.h"
#include "utils/Il2CppError.h"

struct ProcessHandle
{
    pid_t pid;
};

namespace il2cpp
{
namespace os
{
    int Process::GetCurrentProcessId()
    {
        return getpid();
    }

    utils::Expected<ProcessHandle*> Process::GetProcess(int processId)
    {
        // If/when we implement the CreateProcess_internal icall we will likely
        // need to so something smarter here to find the process if we did
        // not create it and return a known pseudo-handle. For now this
        // is sufficient though.
        return (ProcessHandle*)(intptr_t)processId;
    }

    void Process::FreeProcess(ProcessHandle* handle)
    {
        // We have nothing to do here.
    }

    utils::Expected<std::string> Process::GetProcessName(ProcessHandle* handle)
    {
#if !IL2CPP_TARGET_IOS
        const size_t bufferLength = 256;
        char buf[bufferLength];
        int length = proc_name((int)((intptr_t)handle), buf, bufferLength);

        if (length <= 0)
            return std::string();

        return std::string(buf, length);
#else
        return utils::Il2CppError(utils::NotSupported, "GetProcessName is not supported for non-Windows/OSX/Linux desktop platforms");
#endif
    }

    intptr_t Process::GetMainWindowHandle(int32_t pid)
    {
        return 0;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\Process.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\SystemCertificates.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_OSX

#include "os/SystemCertificates.h"
#include <Security/SecTrust.h>
#include <Security/SecCertificate.h>
#include <Security/SecImportExport.h>

namespace il2cpp
{
namespace os
{
    void* SystemCertificates::OpenSystemRootStore()
    {
        CFArrayRef anchors = NULL;
        OSStatus s;

        s = SecTrustCopyAnchorCertificates(&anchors);

        IL2CPP_ASSERT(s == noErr);

        return (void*)anchors;
    }

    int SystemCertificates::EnumSystemCertificates(void* certStore, void** iter, int *format, int* size, void** data)
    {
        OSStatus s;
        CFDataRef certData;
        int numCerts = (int)CFArrayGetCount((CFArrayRef)certStore);
        *format = DATATYPE_STRING;
        // Order matters when it comes to certificates need to read in reverse
        int currentCert = numCerts;
        if (*iter != NULL)
        {
            currentCert = static_cast<int>(reinterpret_cast<intptr_t>(*iter));
        }

        SecCertificateRef cert = (SecCertificateRef)CFArrayGetValueAtIndex((CFArrayRef)certStore, (currentCert - 1));

        s = SecItemExport(cert, kSecFormatPEMSequence, kSecItemPemArmour, NULL, &certData);

        if (s == errSecSuccess)
        {
            char* certPEMStr = (char*)CFDataGetBytePtr(certData);
            *iter = reinterpret_cast<void*>(static_cast<intptr_t>((currentCert - 1)));
            *data = certPEMStr;
            *size = sizeof(certPEMStr);
            if ((currentCert - 1) > 0)
            {
                return TRUE;
            }
        }

        return FALSE;
    }

    void SystemCertificates::CloseSystemRootStore(void* cStore)
    {
        CFRelease((CFArrayRef)cStore);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\SystemCertificates.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\Thread.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_DARWIN

#include <sys/types.h>
#if !IL2CPP_TARGET_IOS
#include <libproc.h>
#endif
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

#include "os/Thread.h"

namespace il2cpp
{
namespace os
{
    bool Thread::GetCurrentThreadStackBounds(void** low, void** high)
    {
#if !IL2CPP_TARGET_IOS
        pthread_t self = pthread_self();
        *high = pthread_get_stackaddr_np(self);
        size_t stackSize = pthread_get_stacksize_np(self);

        *low = (void*)((uintptr_t)high - stackSize);

        return true;
#else
        return false;
#endif
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\OSX\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\ConditionVariableImpl.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"
#if IL2CPP_THREADS_PTHREAD

#include "os/Posix/MutexImpl.h"
#include "ConditionVariableImpl.h"
#include <time.h>
#include <sys/time.h>

namespace il2cpp
{
namespace os
{
    ConditionVariableImpl::ConditionVariableImpl()
    {
        pthread_cond_init(&m_ConditionVariable, NULL);
    }

    ConditionVariableImpl::~ConditionVariableImpl()
    {
        pthread_cond_destroy(&m_ConditionVariable);
    }

    int ConditionVariableImpl::Wait(FastMutexImpl* lock)
    {
        return pthread_cond_wait(&m_ConditionVariable, lock->GetOSHandle());
    }

    int ConditionVariableImpl::TimedWait(FastMutexImpl* lock, uint32_t timeout_ms)
    {
        struct timeval tv;
        struct timespec ts;
        int64_t usecs;
        int res;

        if (timeout_ms == (uint32_t)0xFFFFFFFF)
            return pthread_cond_wait(&m_ConditionVariable, lock->GetOSHandle());

        /* ms = 10^-3, us = 10^-6, ns = 10^-9 */

        gettimeofday(&tv, NULL);
        tv.tv_sec += timeout_ms / 1000;
        usecs = tv.tv_usec + ((timeout_ms % 1000) * 1000);
        if (usecs >= 1000000)
        {
            usecs -= 1000000;
            tv.tv_sec++;
        }
        ts.tv_sec = tv.tv_sec;
        ts.tv_nsec = usecs * 1000;

        return pthread_cond_timedwait(&m_ConditionVariable, lock->GetOSHandle(), &ts);
    }

    void ConditionVariableImpl::Broadcast()
    {
        pthread_cond_broadcast(&m_ConditionVariable);
    }

    void ConditionVariableImpl::Signal()
    {
        pthread_cond_signal(&m_ConditionVariable);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\ConditionVariableImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Console.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_CONSOLE

#include "os/Console.h"
#include "os/File.h"

#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/types.h>

namespace il2cpp
{
namespace os
{
namespace Console
{
    static bool setupComplete = false;
    static int32_t s_terminalSize;
    static struct termios s_initialAttr;
    static struct termios s_il2cppAttr;
    static std::string s_keypadXmit;
    static std::string s_teardown;
    static struct sigaction s_saveSigcont, s_saveSigint, s_saveSigwinch;

    static int32_t GetTerminalSize()
    {
        struct winsize ws;

        if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == 0)
            return (ws.ws_col << 16) | ws.ws_row;

        return -1;
    }

    static bool SetProperty(int32_t property, bool value)
    {
        struct termios attr;
        bool callset = false;
        bool check;

        if (tcgetattr(STDIN_FILENO, &attr) == -1)
            return false;

        check = (attr.c_lflag & property) != 0;
        if ((value || check) && !(value && check))
        {
            callset = true;
            if (value)
                attr.c_lflag |= property;
            else
                attr.c_lflag &= ~property;
        }

        if (!callset)
            return true;

        if (tcsetattr(STDIN_FILENO, TCSANOW, &attr) == -1)
            return true;

        s_il2cppAttr = attr;

        return true;
    }

    static void SetControlChars(uint8_t* control_chars, const uint8_t *cc)
    {
        // The index into the array comes from corlib/System/ControlCharacters.cs
#ifdef VINTR
        control_chars[0] = cc[VINTR];
#endif
#ifdef VQUIT
        control_chars[1] = cc[VQUIT];
#endif
#ifdef VERASE
        control_chars[2] = cc[VERASE];
#endif
#ifdef VKILL
        control_chars[3] = cc[VKILL];
#endif
#ifdef VEOF
        control_chars[4] = cc[VEOF];
#endif
#ifdef VTIME
        control_chars[5] = cc[VTIME];
#endif
#ifdef VMIN
        control_chars[6] = cc[VMIN];
#endif
#ifdef VSWTC
        control_chars[7] = cc[VSWTC];
#endif
#ifdef VSTART
        control_chars[8] = cc[VSTART];
#endif
#ifdef VSTOP
        control_chars[9] = cc[VSTOP];
#endif
#ifdef VSUSP
        control_chars[10] = cc[VSUSP];
#endif
#ifdef VEOL
        control_chars[11] = cc[VEOL];
#endif
#ifdef VREPRINT
        control_chars[12] = cc[VREPRINT];
#endif
#ifdef VDISCARD
        control_chars[13] = cc[VDISCARD];
#endif
#ifdef VWERASE
        control_chars[14] = cc[VWERASE];
#endif
#ifdef VLNEXT
        control_chars[15] = cc[VLNEXT];
#endif
#ifdef VEOL2
        control_chars[16] = cc[VEOL2];
#endif
    }

    static void CallDoConsoleCancelEvent()
    {
        // TODO: Call Console.cancel_handler delegate from another thread.
    }

    static void SigintHandler(int signo)
    {
        static bool insideSigint = false;

        if (insideSigint)
            return;

        insideSigint = true;
        CallDoConsoleCancelEvent();
        insideSigint = false;
    }

    static void SigcontHandler(int signo, siginfo_t *the_siginfo, void *data)
    {
        // Ignore error, there is not much we can do in the sigcont handler.
        tcsetattr(STDIN_FILENO, TCSANOW, &s_il2cppAttr);

        if (!s_keypadXmit.empty())
            write(STDOUT_FILENO, s_keypadXmit.c_str(), s_keypadXmit.length());

        // Call previous handler
        if (s_saveSigcont.sa_sigaction != NULL &&
            s_saveSigcont.sa_sigaction != (void*)SIG_DFL &&
            s_saveSigcont.sa_sigaction != (void*)SIG_IGN)
            (*s_saveSigcont.sa_sigaction)(signo, the_siginfo, data);
    }

    static void SigwinchHandler(int signo, siginfo_t *the_siginfo, void *data)
    {
        const int32_t size = GetTerminalSize();

        if (size != -1)
            s_terminalSize = size;

        // Call previous handler
        if (s_saveSigwinch.sa_sigaction != NULL &&
            s_saveSigwinch.sa_sigaction != (void*)SIG_DFL &&
            s_saveSigwinch.sa_sigaction != (void*)SIG_IGN)
            (*s_saveSigwinch.sa_sigaction)(signo, the_siginfo, data);
    }

    static void ConsoleSetupSignalHandler()
    {
        struct sigaction sigcont, sigint, sigwinch;

        memset(&sigcont, 0, sizeof(struct sigaction));
        memset(&sigint, 0, sizeof(struct sigaction));
        memset(&sigwinch, 0, sizeof(struct sigaction));

        // Continuing
        sigcont.sa_sigaction = SigcontHandler;
        sigcont.sa_flags = SA_SIGINFO;
        sigemptyset(&sigcont.sa_mask);
        sigaction(SIGCONT, &sigcont, &s_saveSigcont);

        // Interrupt handler
        sigint.sa_handler = SigintHandler;
        sigint.sa_flags = 0;
        sigemptyset(&sigint.sa_mask);
        sigaction(SIGINT, &sigint, &s_saveSigint);

        // Window size changed
        sigwinch.sa_sigaction = SigwinchHandler;
        sigwinch.sa_flags = SA_SIGINFO;
        sigemptyset(&sigwinch.sa_mask);
        sigaction(SIGWINCH, &sigwinch, &s_saveSigwinch);
    }

// Exists in Mono, but is unused.
    static void ConsoleRestoreSignalHandlers()
    {
        sigaction(SIGCONT, &s_saveSigcont, NULL);
        sigaction(SIGINT, &s_saveSigint, NULL);
        sigaction(SIGWINCH, &s_saveSigwinch, NULL);
    }

    int32_t InternalKeyAvailable(int32_t ms_timeout)
    {
        fd_set rfds;
        struct timeval tv;
        struct timeval *tvptr;
        div_t divvy;
        int32_t ret, nbytes;

        do
        {
            FD_ZERO(&rfds);
            FD_SET(STDIN_FILENO, &rfds);

            if (ms_timeout >= 0)
            {
                divvy = div(ms_timeout, 1000);
                tv.tv_sec = divvy.quot;
                tv.tv_usec = divvy.rem;
                tvptr = &tv;
            }
            else
            {
                tvptr = NULL;
            }

            ret = select(STDIN_FILENO + 1, &rfds, NULL, NULL, tvptr);
        }
        while (ret == -1 && errno == EINTR);

        if (ret > 0)
        {
            nbytes = 0;

            ret = ioctl(STDIN_FILENO, FIONREAD, &nbytes);

            if (ret >= 0)
                ret = nbytes;
        }

        return (ret > 0) ? ret : 0;
    }

    bool SetBreak(bool wantBreak)
    {
        return SetProperty(IGNBRK, !wantBreak);
    }

    bool SetEcho(bool wantEcho)
    {
        return SetProperty(ECHO, wantEcho);
    }

    static void TtyShutdown()
    {
        if (!setupComplete)
            return;

        if (!s_teardown.empty())
            write(STDOUT_FILENO, s_teardown.c_str(), s_teardown.length());

        tcflush(STDIN_FILENO, TCIFLUSH);
        tcsetattr(STDIN_FILENO, TCSANOW, &s_initialAttr);

        SetProperty(ECHO, true);

        setupComplete = false;
    }

    bool TtySetup(const std::string& keypadXmit, const std::string& teardown, uint8_t* control_characters, int32_t** size)
    {
        s_terminalSize = GetTerminalSize();

        if (s_terminalSize == -1)
        {
            int32_t cols = 0, rows = 0;

            const char *colsValue = getenv("COLUMNS");

            if (colsValue != NULL)
                cols = atoi(colsValue);

            const char *linesValue = getenv("LINES");

            if (linesValue != NULL)
                rows = atoi(linesValue);

            if (cols != 0 && rows != 0)
                s_terminalSize = (cols << 16) | rows;
            else
                s_terminalSize = -1;
        }

        *size = &s_terminalSize;

        if (tcgetattr(STDIN_FILENO, &s_initialAttr) == -1)
            return false;

        s_il2cppAttr = s_initialAttr;

        s_il2cppAttr.c_lflag &= ~(ICANON);
        s_il2cppAttr.c_iflag &= ~(IXON | IXOFF);
        s_il2cppAttr.c_cc[VMIN] = 1;
        s_il2cppAttr.c_cc[VTIME] = 0;

        if (tcsetattr(STDIN_FILENO, TCSANOW, &s_il2cppAttr) == -1)
            return false;

        s_keypadXmit = keypadXmit;

        SetControlChars(control_characters, s_il2cppAttr.c_cc);

        if (setupComplete)
            return true;

        ConsoleSetupSignalHandler();

        setupComplete = true;

        s_teardown = teardown;
        atexit(TtyShutdown);

        return true;
    }

    const char* NewLine()
    {
        return "\n";
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Console.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\CpuInfo.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"
#if IL2CPP_PLATFORM_SUPPORTS_CPU_INFO

#if IL2CPP_TARGET_POSIX

#include "os/CpuInfo.h"
#include <stdlib.h>
#include <stdio.h>
#include "utils/Memory.h"
#include "os/Time.h"
#include "os/Environment.h"


#include <sys/resource.h>
#include <sys/param.h>
#if IL2CPP_TARGET_DARWIN
#include <sys/sysctl.h>
#endif

#include <time.h>

#if IL2CPP_TARGET_LINUX
#include <sys/time.h>
#include <sys/resource.h>
#endif

struct Il2CppCpuUsageState
{
    int64_t kernel_time;
    int64_t user_time;
    int64_t current_time;
};

namespace il2cpp
{
namespace os
{
    void* CpuInfo::Create()
    {
        return IL2CPP_MALLOC_ZERO(sizeof(Il2CppCpuUsageState));
    }

    int32_t CpuInfo::Usage(void* previous)
    {
        Il2CppCpuUsageState* prev = (Il2CppCpuUsageState*)previous;
        int32_t cpu_usage = 0;
        int64_t cpu_total_time;
        int64_t cpu_busy_time;

        struct rusage resource_usage;
        int64_t current_time;
        int64_t kernel_time;
        int64_t user_time;

        if (getrusage(RUSAGE_SELF, &resource_usage) == -1)
        {
            return -1;
        }

        current_time = os::Time::GetTicks100NanosecondsMonotonic();
        kernel_time = resource_usage.ru_stime.tv_sec * 1000 * 1000 * 10 + resource_usage.ru_stime.tv_usec * 10;
        user_time = resource_usage.ru_utime.tv_sec * 1000 * 1000 * 10 + resource_usage.ru_utime.tv_usec * 10;

        cpu_busy_time = (user_time - (prev ? prev->user_time : 0)) + (kernel_time - (prev ? prev->kernel_time : 0));
        cpu_total_time = (current_time - (prev ? prev->current_time : 0)) * il2cpp::os::Environment::GetProcessorCount();

        if (prev)
        {
            prev->kernel_time = kernel_time;
            prev->user_time = user_time;
            prev->current_time = current_time;
        }

        if (cpu_total_time > 0 && cpu_busy_time > 0)
            cpu_usage = (int32_t)(cpu_busy_time * 100 / cpu_total_time);

        return cpu_usage;
    }
}
}

#endif
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\CpuInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\CrashHelpers.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/CrashHelpers.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_GENERIC_CRASH_HELPERS

namespace il2cpp
{
namespace os
{
    void CrashHelpers::CrashImpl()
    {
        __builtin_trap();
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\CrashHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Cryptography.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_CRYPTO

#include "os/Cryptography.h"
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>

#ifndef NAME_DEV_URANDOM
#define NAME_DEV_URANDOM "/dev/urandom"
#endif

static int64_t file = -1;

namespace il2cpp
{
namespace os
{
    void* Cryptography::GetCryptographyProvider()
    {
        return (file < 0) ? NULL : (void*)file;
    }

    bool Cryptography::OpenCryptographyProvider()
    {
#ifdef NAME_DEV_URANDOM
        file = open(NAME_DEV_URANDOM, O_RDONLY);
#endif

#ifdef NAME_DEV_RANDOM
        if (file < 0)
            file = open(NAME_DEV_RANDOM, O_RDONLY);
#endif
        return true;
    }

    void Cryptography::ReleaseCryptographyProvider(void* provider)
    {
    }

    bool Cryptography::FillBufferWithRandomBytes(void* provider, intptr_t length, unsigned char* data)
    {
        int count = 0;
        ssize_t err;

        // Make sure the provider is correct, or we may end up reading from the wrong file.
        // If provider happens to be 0 we will read from stdin and hang!
        if ((int64_t)provider != file)
            return false;

        do
        {
            err = read((int)(size_t)provider, data + count, length - count);
            if (err < 0)
            {
                if (errno == EINTR)
                    continue;
                break;
            }
            count += err;
        }
        while (count < length);

        return err >= 0;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Cryptography.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Directory.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_DIRECTORY

#include "os/Directory.h"
#include "os/ErrorCodes.h"
#include "os/File.h"
#include "os/Posix/Error.h"
#include "utils/DirectoryUtils.h"
#include "utils/Memory.h"
#include "utils/PathUtils.h"
#include "utils/StringUtils.h"
#include <errno.h>
#include <dirent.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#if IL2CPP_TARGET_QNX
    #include <errno.h>
#else
    #include <sys/errno.h>
#endif
#include <sys/stat.h>
#include <sys/types.h>

namespace il2cpp
{
namespace os
{
    std::string Directory::GetCurrent(int *error)
    {
        char buf[PATH_MAX + 1];
        // Note: not all implementations would allocate a buffer when passing 0 to getcwd, as we used to do.
        // this does *not* seem to be part of the POSIX spec:
        // http://pubs.opengroup.org/onlinepubs/000095399/functions/getcwd.html
        char* cwd = getcwd(buf, PATH_MAX + 1);

        if (cwd == NULL)
        {
            *error = FileErrnoToErrorCode(errno);
            return std::string();
        }

        std::string directory(cwd);

        *error = kErrorCodeSuccess;
        return directory;
    }

    bool Directory::SetCurrent(const std::string& path, int *error)
    {
        const int ret = chdir(path.c_str());

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    bool Directory::Create(const std::string& path, int *error)
    {
        const int ret = mkdir(path.c_str(), 0777);

        if (ret == -1)
        {
            *error = PathErrnoToErrorCode(path, errno);
            return false;
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    bool Directory::Remove(const std::string& path, int *error)
    {
        const int ret = rmdir(path.c_str());

        if (ret == -1)
        {
            *error = PathErrnoToErrorCode(path, errno);
            return false;
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    static void DirectoryGlob(DIR *dir, const std::string& pattern, std::set<std::string>& result)
    {
        if (pattern.empty())
            return;

        std::string matchPattern = il2cpp::utils::CollapseAdjacentStars(pattern);

        struct dirent *entry;

        while ((entry = readdir(dir)) != NULL)
        {
            const std::string filename(entry->d_name);

            if (!il2cpp::utils::Match(filename, matchPattern))
                continue;

            result.insert(filename);
        }
    }

    static bool DirectoryGlob(const std::string& directoryPath, const std::string& pattern, std::set<std::string>& result, int* error)
    {
        DIR* dir = opendir(directoryPath.c_str());

        if (dir == NULL)
        {
            *error = PathErrnoToErrorCode(directoryPath, errno);
            return false;
        }

        DirectoryGlob(dir, pattern, result);

        closedir(dir);

        return true;
    }

    std::set<std::string> Directory::GetFileSystemEntries(const std::string& path, const std::string& pathWithPattern, int32_t attributes, int32_t mask, int* error)
    {
        const std::string directoryPath(il2cpp::utils::PathUtils::DirectoryName(pathWithPattern));
        const std::string pattern(il2cpp::utils::PathUtils::Basename(pathWithPattern));

        std::set<std::string> globResult;

        if (DirectoryGlob(directoryPath, pattern, globResult, error) == false)
            return std::set<std::string>();

        std::set<std::string> result;

        for (std::set<std::string>::const_iterator it = globResult.begin(), end = globResult.end(); it != end; ++it)
        {
            const std::string& filename = *it;

            if (filename == "." || filename == "..")
                continue;

            const std::string path(directoryPath + IL2CPP_DIR_SEPARATOR + filename);

            int attributeError;
            const int32_t pathAttributes = static_cast<int32_t>(File::GetFileAttributes(path, &attributeError));

            if (attributeError != kErrorCodeSuccess)
                continue;

            if ((pathAttributes & mask) == attributes)
                result.insert(path);
        }


        *error = kErrorCodeSuccess;
        return result;
    }

    Directory::FindHandle::FindHandle(const utils::StringView<Il2CppNativeChar>& searchPathWithPattern) :
        osHandle(NULL),
        handleFlags(os::kNoFindHandleFlags)
    {
        directoryPath = il2cpp::utils::PathUtils::DirectoryName(searchPathWithPattern);
        pattern = il2cpp::utils::PathUtils::Basename(searchPathWithPattern);
        pattern = il2cpp::utils::CollapseAdjacentStars(pattern);
    }

    Directory::FindHandle::~FindHandle()
    {
        IL2CPP_ASSERT(osHandle == NULL);
    }

    int32_t Directory::FindHandle::CloseOSHandle()
    {
        int32_t result = os::kErrorCodeSuccess;

        if (osHandle != NULL)
        {
            int32_t ret = closedir(static_cast<DIR*>(osHandle));
            if (ret != 0)
                result = FileErrnoToErrorCode(errno);

            osHandle = NULL;
        }

        return result;
    }

    os::ErrorCode Directory::FindFirstFile(FindHandle* findHandle, const utils::StringView<Il2CppNativeChar>& searchPathWithPattern, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
        DIR* dir = opendir(findHandle->directoryPath.c_str());
        if (dir == NULL)
            return PathErrnoToErrorCode(findHandle->directoryPath, errno);

        findHandle->SetOSHandle(dir);
        return FindNextFile(findHandle, resultFileName, resultAttributes);
    }

    os::ErrorCode Directory::FindNextFile(FindHandle* findHandle, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
        errno = 0;

        dirent* entry;
        while ((entry = readdir(static_cast<DIR*>(findHandle->osHandle))) != NULL)
        {
            const Il2CppNativeString filename(entry->d_name);

            if (il2cpp::utils::Match(filename, findHandle->pattern))
            {
                const Il2CppNativeString path = utils::PathUtils::Combine(findHandle->directoryPath, filename);

                int attributeError;
                const int32_t pathAttributes = static_cast<int32_t>(File::GetFileAttributes(path, &attributeError));

                if (attributeError == kErrorCodeSuccess)
                {
                    *resultFileName = filename;
                    *resultAttributes = pathAttributes;
                    return os::kErrorCodeSuccess;
                }
            }
        }

        if (errno != 0)
            return FileErrnoToErrorCode(errno);

        return os::kErrorCodeNoMoreFiles;
    }

    int32_t Directory::CloseOSFindHandleDirectly(intptr_t osHandle)
    {
        IL2CPP_ASSERT(0 && "This function should be called for Windows only.");
        return 0;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Directory.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Encoding.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_ENVIRONMENT && IL2CPP_TARGET_POSIX

#include "os/Encoding.h"

#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif

namespace il2cpp
{
namespace os
{
namespace Encoding
{
    std::string GetCharSet()
    {
#if HAVE_LANGINFO_H
        return nl_langinfo(CODESET);
#else
        return "UTF-8";
#endif
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Encoding.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Environment.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_ENVIRONMENT && IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_ENVIRON
#include "il2cpp-class-internals.h"
#include "os/Environment.h"
#include "il2cpp-api.h"

#include <stdlib.h>
#include <unistd.h>
#include <sys/utsname.h>

#if defined(__APPLE__) && !defined(__arm__)
// Apple defines this in crt_externs.h but doesn't provide that header for
// arm-apple-darwin9.  We'll manually define the symbol on Apple as it does
// in fact exist on all implementations (so far)
extern "C" char*** _NSGetEnviron(void);
#define environ (*_NSGetEnviron())
#else
extern char **environ; // GNU C library
#endif

namespace il2cpp
{
namespace os
{
    int32_t Environment::GetProcessorCount()
    {
        int count = 1;
#ifdef _SC_NPROCESSORS_ONLN
        count = (int)sysconf(_SC_NPROCESSORS_ONLN);
        if (count > 0)
            return count;
#endif
#ifdef USE_SYSCTL
        {
            int mib[2];
            size_t len = sizeof(int);
            mib[0] = CTL_HW;
            mib[1] = HW_NCPU;
            if (sysctl(mib, 2, &count, &len, NULL, 0) == 0)
                return count;
        }
#endif
        return count;
    }

    std::string Environment::GetMachineName()
    {
        const int n = 512;
        char buf[n];

        if (gethostname(buf, sizeof(buf)) == 0)
        {
            buf[n - 1] = 0;
            int i;
            // try truncating the string at the first dot
            for (i = 0; i < n; i++)
            {
                if (buf[i] == '.')
                {
                    buf[i] = 0;
                    break;
                }
            }
            return buf;
        }

        return NULL;
    }

    std::string Environment::GetOsVersionString()
    {
        struct utsname name;

        if (uname(&name) >= 0)
            return name.release;

        return "0.0.0.0";
    }

    std::string Environment::GetOsUserName()
    {
        const std::string username(GetEnvironmentVariable("USER"));
        return username.empty() ? "Unknown" : username;
    }

    std::string Environment::GetEnvironmentVariable(const std::string& name)
    {
        const char* variable = getenv(name.c_str());
        return variable ? std::string(variable) : std::string();
    }

    void Environment::SetEnvironmentVariable(const std::string& name, const std::string& value)
    {
        if (value.empty())
        {
            unsetenv(name.c_str());
        }
        else
        {
            setenv(name.c_str(), value.c_str(), 1); // 1 means overwrite
        }
    }

    std::vector<std::string> Environment::GetEnvironmentVariableNames()
    {
        std::vector<std::string> result;

        for (char **envvar = environ; *envvar != NULL; ++envvar)
        {
            const char* equalAddress = strchr(*envvar, '=');

            if (equalAddress != NULL)
                result.push_back(std::string(*envvar, size_t(equalAddress - *envvar)));
        }

        return result;
    }

    std::string Environment::GetHomeDirectory()
    {
        static std::string homeDirectory;

        if (!homeDirectory.empty())
            return homeDirectory;

        homeDirectory = GetEnvironmentVariable("HOME");

        return homeDirectory.empty() ? "/" : homeDirectory;
    }

    std::vector<std::string> Environment::GetLogicalDrives()
    {
        std::vector<std::string> result;

        // This implementation is not correct according to the definition of this icall, but this is
        // the only "logical drive" that the Mono version in Unity returns for OSX.
        result.push_back("/");

        // TODO: Implement additional logic for Linux

        return result;
    }

    void Environment::Exit(int result)
    {
        exit(result);
    }

    NORETURN void Environment::Abort()
    {
        abort();
    }

    utils::Expected<std::string> Environment::GetWindowsFolderPath(int folder)
    {
        // This should only be called on Windows.
        return std::string();
    }

    utils::Expected<bool> Environment::Is64BitOs()
    {
        struct utsname name;

        if (uname(&name) >= 0)
        {
            return strcmp(name.machine, "x86_64") == 0 || strncmp(name.machine, "aarch64", 7) == 0 || strncmp(name.machine, "ppc64", 5) == 0;
        }

        return false;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Environment.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Error.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX || IL2CPP_SUPPORT_SOCKETS_POSIX_API

#include "Error.h"
#include "utils/PathUtils.h"

#include <cassert>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>

namespace il2cpp
{
namespace os
{
    ErrorCode SocketErrnoToErrorCode(int32_t code)
    {
        ErrorCode result = (ErrorCode) - 1;

        switch (code)
        {
            case 0: result = kErrorCodeSuccess; break;
            case EACCES: result = kWSAeacces; break;
    #ifdef EADDRINUSE
            case EADDRINUSE: result = kWSAeaddrinuse; break;
    #endif
    #ifdef EAFNOSUPPORT
            case EAFNOSUPPORT: result = kWSAeafnosupport; break;
    #endif
    #if EAGAIN != EWOULDBLOCK
            case EAGAIN: result = kWSAewouldblock; break;
    #endif
    #ifdef EALREADY
            case EALREADY: result = kWSAealready; break;
    #endif
            case EBADF: result = kWSAenotsock; break;
    #ifdef ECONNABORTED
            case ECONNABORTED: result = kWSAenetdown; break;
    #endif
    #ifdef ECONNREFUSED
            case ECONNREFUSED: result = kWSAeconnrefused; break;
    #endif
    #ifdef ECONNRESET
            case ECONNRESET: result = kWSAeconnreset; break;
    #endif
            case EFAULT: result = kWSAefault; break;
    #ifdef EHOSTUNREACH
            case EHOSTUNREACH: result = kWSAehostunreach; break;
    #endif
    #ifdef EINPROGRESS
            case EINPROGRESS: result = kWSAeinprogress; break;
    #endif
            case EINTR: result = kWSAeintr; break;
            case EINVAL: result = kWSAeinval; break;
                // FIXME: case EIO: result = WSAE????; break;
    #ifdef EISCONN
            case EISCONN: result = kWSAeisconn; break;
    #endif
            // FIXME: case ELOOP: result = WSA????; break;
            case EMFILE: result = kWSAemfile; break;
    #ifdef EMSGSIZE
            case EMSGSIZE: result = kWSAemsgsize; break;
    #endif
                // FIXME: case ENAMETOOLONG: result = kWSAeacces; break;
    #ifdef ENETUNREACH
            case ENETUNREACH: result = kWSAenetunreach; break;
    #endif
    #ifdef ENOBUFS
            case ENOBUFS: result = kWSAenobufs; break;
    #endif
            // case ENOENT: result = WSAE????; break;
            case ENOMEM: result = kWSAenobufs; break;
    #ifdef ENOPROTOOPT
            case ENOPROTOOPT: result = kWSAenoprotoopt; break;
    #endif
    #ifdef ENOSR
            case ENOSR: result = kWSAenetdown; break;
    #endif
    #ifdef ENOTCONN
            case ENOTCONN: result = kWSAenotconn; break;
    #endif
                // FIXME: case ENOTDIR: result = WSAE????; break;
    #ifdef ENOTSOCK
            case ENOTSOCK: result = kWSAenotsock; break;
    #endif
            case ENOTTY: result = kWSAenotsock; break;
    #ifdef EOPNOTSUPP
            case EOPNOTSUPP: result = kWSAeopnotsupp; break;
    #endif
            case EPERM: result = kWSAeacces; break;
            case EPIPE: result = kWSAeshutdown; break;
    #ifdef EPROTONOSUPPORT
            case EPROTONOSUPPORT: result = kWSAeprotonosupport; break;
    #endif
    #if ERESTARTSYS
            case ERESTARTSYS: result = kWSAenetdown; break;
    #endif
                // FIXME: case EROFS: result = WSAE????; break;
    #ifdef ESOCKTNOSUPPORT
            case ESOCKTNOSUPPORT: result = kWSAesocktnosupport; break;
    #endif
    #ifdef ETIMEDOUT
            case ETIMEDOUT: result = kWSAetimedout; break;
    #endif
    #ifdef EWOULDBLOCK
            case EWOULDBLOCK: result = kWSAewouldblock; break;
    #endif
    #ifdef EADDRNOTAVAIL
            case EADDRNOTAVAIL: result = kWSAeaddrnotavail; break;
    #endif
            case ENOENT: result = kWSAeconnrefused; break;
    #ifdef EDESTADDRREQ
            case EDESTADDRREQ: result = kWSAedestaddrreq; break;
    #endif
            case ENODEV: result = kWSAenetdown; break;
    #ifdef EHOSTDOWN
            case EHOSTDOWN: result = kWSAehostdown; break;
    #endif
    #ifdef ENXIO
            case ENXIO: result = kWSAhostNotFound; break;
    #endif
            default:
                result = kWSAsyscallfailure;
                break;
        }

        return result;
    }

    ErrorCode FileErrnoToErrorCode(int32_t code)
    {
        ErrorCode ret;
        /* mapping ideas borrowed from wine. they may need some work */

        switch (code)
        {
            case EACCES: case EPERM: case EROFS:
                ret = kErrorCodeAccessDenied;
                break;

            case EAGAIN:
                ret = kErrorCodeSharingViolation;
                break;

            case EBUSY:
                ret = kErrorCodeLockViolation;
                break;

            case EEXIST:
                ret = kErrorCodeFileExists;
                break;

            case EINVAL: case ESPIPE:
                ret = kErrorSeek;
                break;

            case EISDIR:
                ret = kErrorCodeCannotMake;
                break;

            case ENFILE: case EMFILE:
                ret = kErrorCodeTooManyOpenFiles;
                break;

            case ENOENT: case ENOTDIR:
                ret = kErrorCodeFileNotFound;
                break;

            case ENOSPC:
                ret = kErrorCodeHandleDiskFull;
                break;

            case ENOTEMPTY:
                ret = kErrorCodeDirNotEmpty;
                break;

            case ENOEXEC:
                ret = kErrorBadFormat;
                break;

            case ENAMETOOLONG:
                ret = kErrorCodeFileNameExcedRange;
                break;

#ifdef EINPROGRESS
            case EINPROGRESS:
                ret = kErrorIoPending;
                break;
#endif

            case ENOSYS:
                ret = kErrorNotSupported;
                break;

            case EBADF:
                ret = kErrorCodeInvalidHandle;
                break;

            case EIO:
                ret = kErrorCodeInvalidHandle;
                break;

            case EINTR:
                ret = kErrorIoPending;
                break;

            case EPIPE:
                ret = kErrorCodeWriteFault;
                break;

            default:
                ret = kErrorCodeGenFailure;
                break;
        }

        return ret;
    }

    ErrorCode PathErrnoToErrorCode(const std::string& path, int32_t code)
    {
        if (code == ENOENT)
        {
            const std::string dirname(il2cpp::utils::PathUtils::DirectoryName(path));
#if !IL2CPP_HAS_NOACCESS
            if (access(dirname.c_str(), F_OK) == 0)
                return kErrorCodeFileNotFound;
#else
            struct stat statInfo;
            if (stat(dirname.c_str(), &statInfo) == 0 && S_ISDIR(statInfo.st_mode))
                return kErrorCodeFileNotFound;
#endif
            else
                return kErrorCodePathNotFound;
        }
        else
        {
            return FileErrnoToErrorCode(code);
        }
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Error.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\File.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX

#include "FileHandle.h"

#if IL2CPP_USE_POSIX_FILE_PLATFORM_CONFIG
#include "FilePlatformConfig.h"
#endif

#include "os/ConsoleExtension.h"
#include "os/ErrorCodes.h"
#include "os/File.h"
#include "os/Mutex.h"
#include "os/Posix/Error.h"
#include "utils/Expected.h"
#include "utils/Il2CppError.h"
#include "utils/PathUtils.h"

#if IL2CPP_SUPPORT_THREADS
#include "Baselib.h"
#include "Cpp/ReentrantLock.h"
#endif

#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <utime.h>
#if IL2CPP_TARGET_QNX
    #include <errno.h>
#else
    #include <sys/errno.h>
#endif
#include <sys/stat.h>
#include <sys/types.h>
#include <string>

#define INVALID_FILE_HANDLE     (FileHandle*)-1
#define INVALID_FILE_ATTRIBUTES (UnityPalFileAttributes)((uint32_t)-1)
#define TIME_ZERO               116444736000000000ULL

namespace il2cpp
{
namespace os
{
// Head and tail of linked list.
    static FileHandle* s_fileHandleHead = NULL;
    static FileHandle* s_fileHandleTail = NULL;
#if IL2CPP_SUPPORT_THREADS
    static baselib::ReentrantLock s_fileHandleMutex;
#endif

    static void AddFileHandle(FileHandle *fileHandle)
    {
#if IL2CPP_SUPPORT_THREADS
        FastAutoLock autoLock(&s_fileHandleMutex);
#endif

        if (s_fileHandleHead == NULL)
        {
            IL2CPP_ASSERT(s_fileHandleTail == NULL);

            s_fileHandleHead = fileHandle;
            s_fileHandleTail = fileHandle;
        }
        else
        {
            IL2CPP_ASSERT(s_fileHandleTail != NULL);
            IL2CPP_ASSERT(s_fileHandleTail->next == NULL);

            s_fileHandleTail->next = fileHandle;
            fileHandle->prev = s_fileHandleTail;
            s_fileHandleTail = fileHandle;
        }
    }

    static void RemoveFileHandle(il2cpp::os::FileHandle *fileHandle)
    {
#if IL2CPP_SUPPORT_THREADS
        FastAutoLock autoLock(&s_fileHandleMutex);
#endif

        if (s_fileHandleHead == fileHandle)
            s_fileHandleHead = fileHandle->next;

        if (s_fileHandleTail == fileHandle)
            s_fileHandleTail = fileHandle->prev;

        if (fileHandle->prev)
            fileHandle->prev->next = fileHandle->next;

        if (fileHandle->next)
            fileHandle->next->prev = fileHandle->prev;
    }

    static const FileHandle* FindFileHandle(const struct stat& statBuf)
    {
#if IL2CPP_SUPPORT_THREADS
        FastAutoLock autoLock(&s_fileHandleMutex);
#endif

        const dev_t device = statBuf.st_dev;
        const ino_t inode = statBuf.st_ino;

        for (FileHandle *handle = s_fileHandleHead; handle != NULL; handle = handle->next)
        {
            if (handle->device == device && handle->inode == inode)
                return handle;
        }

        return NULL;
    }

    bool File::IsHandleOpenFileHandle(intptr_t lookup)
    {
#if IL2CPP_SUPPORT_THREADS
        FastAutoLock autoLock(&s_fileHandleMutex);
#endif

        for (FileHandle *handle = s_fileHandleHead; handle != NULL; handle = handle->next)
        {
            if (reinterpret_cast<intptr_t>(handle) == lookup)
                return true;
        }

        return false;
    }

// NOTE:
// Checking for file sharing violations only works for the current process.
//
// Mono implements this feature across processes by storing the file handles as
// a look up table in a shared file.

    static bool ShareAllowOpen(const struct stat& statBuf, int shareMode, int accessMode)
    {
        const FileHandle *fileHandle = FindFileHandle(statBuf);

        if (fileHandle == NULL) // File is not open
            return true;

        if (fileHandle->shareMode == kFileShareNone || shareMode == kFileShareNone)
            return false;

        if (((fileHandle->shareMode == kFileShareRead)  && (accessMode != kFileAccessRead)) ||
            ((fileHandle->shareMode == kFileShareWrite) && (accessMode != kFileAccessWrite)))
        {
            return false;
        }

        return true;
    }

    static UnityPalFileAttributes StatToFileAttribute(const std::string& path, struct stat& pathStat, struct stat* linkStat)
    {
        uint32_t fileAttributes = 0;

        if (S_ISSOCK(pathStat.st_mode))
            pathStat.st_mode &= ~S_IFSOCK; // don't consider socket protection

#if defined(__APPLE__) && defined(__MACH__)
        if ((pathStat.st_flags & UF_IMMUTABLE) || (pathStat.st_flags & SF_IMMUTABLE))
            fileAttributes |= kFileAttributeReadOnly;
#endif

        const std::string filename(il2cpp::utils::PathUtils::Basename(path));

        if (S_ISDIR(pathStat.st_mode))
        {
            fileAttributes = kFileAttributeDirectory;

            if (!(pathStat.st_mode & S_IWUSR) && !(pathStat.st_mode & S_IWGRP) && !(pathStat.st_mode & S_IWOTH))
                fileAttributes |= kFileAttributeReadOnly;

            if (filename[0] == '.')
                fileAttributes |= kFileAttributeHidden;
        }
        else
        {
            if (!(pathStat.st_mode & S_IWUSR) && !(pathStat.st_mode & S_IWGRP) && !(pathStat.st_mode & S_IWOTH))
            {
                fileAttributes = kFileAttributeReadOnly;

                if (filename[0] == '.')
                    fileAttributes |= kFileAttributeHidden;
            }
            else if (filename[0] == '.')
                fileAttributes = kFileAttributeHidden;
            else
                fileAttributes = kFileAttributeNormal;
        }

        if (linkStat != NULL && S_ISLNK(linkStat->st_mode))
            fileAttributes |= kFileAttributeReparse_point;

        return (UnityPalFileAttributes)fileAttributes;
    }

    static int GetStatAndLinkStat(const std::string& path, struct stat& pathStat, struct stat& linkStat)
    {
        const int statResult = stat(path.c_str(), &pathStat);

        if (statResult == -1 && errno == ENOENT && lstat(path.c_str(), &pathStat) != 0) // Might be a dangling symlink...
            return PathErrnoToErrorCode(path, errno);

        if (lstat(path.c_str(), &linkStat) != 0)
            return PathErrnoToErrorCode(path, errno);

        return kErrorCodeSuccess;
    }

    static uint64_t TimeToTicks(time_t timeval)
    {
        return ((uint64_t)timeval * 10000000) + TIME_ZERO;
    }

    static time_t TicksToTime(uint64_t ticks)
    {
        return (ticks - TIME_ZERO) / 10000000;
    }

    static bool InternalCopyFile(int srcFd, int destFd, const struct stat& srcStat, int *error)
    {
        const blksize_t preferedBlockSize = srcStat.st_blksize;
        const blksize_t bufferSize = preferedBlockSize < 8192 ? 8192 : (preferedBlockSize > 65536 ? 65536 : preferedBlockSize);

        char *buffer = new char[bufferSize];

        ssize_t readBytes;

        while ((readBytes = read(srcFd, buffer, bufferSize)) > 0)
        {
            char* writeBuffer = buffer;
            ssize_t writeBytes = readBytes;

            while (writeBytes > 0)
            {
                const ssize_t writtenBytes = write(destFd, writeBuffer, writeBytes);

                if (writtenBytes < 0)
                {
                    if (errno == EINTR)
                        continue;

                    delete[] buffer;

                    *error = FileErrnoToErrorCode(errno);
                    return false;
                }

                writeBytes -= writtenBytes;
                writeBuffer += writtenBytes;
            }
        }

        delete[] buffer;

        if (readBytes < 0)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        IL2CPP_ASSERT(readBytes == 0);

        return true;
    }

    utils::Expected<bool> File::Isatty(FileHandle* fileHandle)
    {
        return isatty(fileHandle->fd) == 1;
    }

#if !IL2CPP_PLATFORM_OVERRIDES_STD_FILE_HANDLES
    FileHandle* File::GetStdError()
    {
        static FileHandle* s_handle = NULL;
        if (s_handle)
            return s_handle;

        s_handle = new FileHandle();
        s_handle->fd = 2;
        s_handle->type = kFileTypeChar;
        s_handle->options = 0;
        s_handle->accessMode = kFileAccessReadWrite;
        s_handle->shareMode = -1; // Only used for files

        return s_handle;
    }

    FileHandle* File::GetStdInput()
    {
        static FileHandle* s_handle = NULL;
        if (s_handle)
            return s_handle;

        s_handle = new FileHandle();
        s_handle->fd = 0;
        s_handle->type = kFileTypeChar;
        s_handle->options = 0;
        s_handle->accessMode = kFileAccessRead;
        s_handle->shareMode = -1; // Only used for files

        return s_handle;
    }

    FileHandle* File::GetStdOutput()
    {
        static FileHandle* s_handle = NULL;
        if (s_handle)
            return s_handle;

        s_handle = new FileHandle();
        s_handle->fd = 1;
        s_handle->type = kFileTypeChar;
        s_handle->options = 0;
        s_handle->accessMode = kFileAccessReadWrite;
        s_handle->shareMode = -1; // Only used for files

        return s_handle;
    }

#endif

    utils::Expected<bool> File::CreatePipe(FileHandle** read_handle, FileHandle** write_handle)
    {
        int error;
        return File::CreatePipe(read_handle, write_handle, &error);
    }

    utils::Expected<bool> File::CreatePipe(FileHandle** read_handle, FileHandle** write_handle, int* error)
    {
        int fds[2];

        const int ret = pipe(fds);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        FileHandle *input = new FileHandle();
        input->fd = fds[0];
        input->type = kFileTypePipe;
        input->options = 0;
        input->accessMode = kFileAccessRead;
        input->shareMode = -1; // Only used for files

        FileHandle *output = new FileHandle();
        output->fd = fds[1];
        output->type = kFileTypePipe;
        output->options = 0;
        output->accessMode = kFileAccessReadWrite;
        output->shareMode = -1; // Only used for files

        *read_handle = input;
        *write_handle = output;

        return true;
    }

    UnityPalFileAttributes File::GetFileAttributes(const std::string& path, int *error)
    {
        struct stat pathStat, linkStat;

        *error = GetStatAndLinkStat(path, pathStat, linkStat);

        if (*error != kErrorCodeSuccess)
            return INVALID_FILE_ATTRIBUTES;

        return StatToFileAttribute(path, pathStat, &linkStat);
    }

    bool File::SetFileAttributes(const std::string& path, UnityPalFileAttributes attributes, int* error)
    {
        struct stat pathStat;

        int ret = stat(path.c_str(), &pathStat);

        if (ret != 0)
        {
            *error = PathErrnoToErrorCode(path, errno);
            return false;
        }

        if (attributes & kFileAttributeReadOnly)
            ret = chmod(path.c_str(), pathStat.st_mode & ~(S_IWUSR | S_IWOTH | S_IWGRP));
        else
            ret = chmod(path.c_str(), pathStat.st_mode | S_IWUSR);

        if (ret != 0)
        {
            *error = PathErrnoToErrorCode(path, errno);
            return false;
        }

        // Mono ignores all other attributes

        if (attributes & kFileAttributeInternalMonoExecutable)
        {
            mode_t exec_mask = 0;

            if ((pathStat.st_mode & S_IRUSR) != 0)
                exec_mask |= S_IXUSR;

            if ((pathStat.st_mode & S_IRGRP) != 0)
                exec_mask |= S_IXGRP;

            if ((pathStat.st_mode & S_IROTH) != 0)
                exec_mask |= S_IXOTH;

            ret = chmod(path.c_str(), pathStat.st_mode | exec_mask);

            if (ret != 0)
            {
                *error = PathErrnoToErrorCode(path, errno);
                return false;
            }
        }

        return true;
    }

    bool File::GetFileStat(const std::string& path, il2cpp::os::FileStat * stat, int* error)
    {
        struct stat pathStat, linkStat;

        *error = GetStatAndLinkStat(path, pathStat, linkStat);

        if (*error != kErrorCodeSuccess)
            return false;

        const std::string filename(il2cpp::utils::PathUtils::Basename(path));
        const time_t creationTime = pathStat.st_mtime < pathStat.st_ctime ? pathStat.st_mtime : pathStat.st_ctime;

        stat->name = filename;

        stat->attributes = StatToFileAttribute(path, pathStat, &linkStat);

        stat->length = (stat->attributes & kFileAttributeDirectory) > 0 ? 0 : pathStat.st_size;

        stat->creation_time = TimeToTicks(creationTime);
        stat->last_access_time = TimeToTicks(pathStat.st_atime);
        stat->last_write_time = TimeToTicks(pathStat.st_mtime);

        return true;
    }

    FileType File::GetFileType(FileHandle* handle)
    {
        return ((FileHandle*)handle)->type;
    }

    bool File::DeleteFile(const std::string& path, int *error)
    {
        const UnityPalFileAttributes attributes = GetFileAttributes(path, error);

        if (*error != kErrorCodeSuccess)
        {
            return false;
        }

        if (attributes & kFileAttributeReadOnly)
        {
            *error = kErrorCodeAccessDenied;
            return false;
        }

        const int ret = unlink(path.c_str());

        if (ret == -1)
        {
            *error = PathErrnoToErrorCode(path, errno);
            return false;
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    bool File::CopyFile(const std::string& src, const std::string& dest, bool overwrite, int* error)
    {
        const int srcFd = open(src.c_str(), O_RDONLY, 0);

        if (srcFd < 0)
        {
            *error = PathErrnoToErrorCode(src, errno);
            return false;
        }

        struct stat srcStat;

        if (fstat(srcFd, &srcStat) < 0)
        {
            *error = FileErrnoToErrorCode(errno);
            close(srcFd);
            return false;
        }

        int destFd;

        if (!overwrite)
        {
            destFd = open(dest.c_str(), O_WRONLY | O_CREAT | O_EXCL, srcStat.st_mode);
        }
        else
        {
            destFd = open(dest.c_str(), O_WRONLY | O_TRUNC, srcStat.st_mode);

            if (destFd < 0)
                destFd = open(dest.c_str(), O_WRONLY | O_CREAT | O_TRUNC, srcStat.st_mode);
            else
                *error = kErrorCodeAlreadyExists; // Apparently this error is set if we overwrite the dest file
        }

        if (destFd < 0)
        {
            *error = FileErrnoToErrorCode(errno);
            close(srcFd);
            return false;
        }

        const bool ret = InternalCopyFile(srcFd, destFd, srcStat, error);

        close(srcFd);
        close(destFd);

        return ret;
    }

    bool File::MoveFile(const std::string& src, const std::string& dest, int* error)
    {
        struct stat srcStat, destStat;

        if (stat(src.c_str(), &srcStat) < 0)
        {
            *error = PathErrnoToErrorCode(src.c_str(), errno);
            return false;
        }

        // In C# land we check for the existence of src, but not for dest.
        // We check it here and return the failure if dest exists and is not
        // the same file as src.
        if (stat(dest.c_str(), &destStat) == 0) // dest exists
        {
            if (destStat.st_dev != srcStat.st_dev || destStat.st_ino != srcStat.st_ino)
            {
                *error = kErrorCodeAlreadyExists;
                return false;
            }
        }

        if (!ShareAllowOpen(srcStat, kFileShareNone, kFileAccessWrite))
        {
            *error = kErrorCodeSuccess;
            return false;
        }

        const int ret = rename(src.c_str(), dest.c_str());

        if (ret == -1)
        {
            if (errno == EEXIST)
            {
                *error = kErrorCodeAlreadyExists;
                return false;
            }
            else if (errno == EXDEV)
            {
                if (S_ISDIR(srcStat.st_mode))
                {
                    *error = kErrorCodeNotSameDevice;
                    return false;
                }

                if (!CopyFile(src, dest, true, error))
                {
                    // CopyFile sets the error
                    return false;
                }

                return DeleteFile(src, error); // DeleteFile sets the error
            }
            else
            {
                *error = PathErrnoToErrorCode(src.c_str(), errno);
                return false;
            }
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    bool File::ReplaceFile(const std::string& sourceFileName, const std::string& destinationFileName, const std::string& destinationBackupFileName, bool ignoreMetadataErrors, int* error)
    {
        const bool backupFile = !destinationBackupFileName.empty();

        // Open the backup file for read so we can restore the file if an error occurs.
        const int backupFd = backupFile ? open(destinationBackupFileName.c_str(), O_RDONLY, 0) : -1;

        // dest -> backup
        if (backupFile)
        {
            const int retDest = rename(destinationFileName.c_str(), destinationBackupFileName.c_str());

            if (retDest == -1)
            {
                if (backupFd != -1)
                    close(backupFd);

                *error = PathErrnoToErrorCode(destinationFileName.c_str(), errno);
                return false;
            }
        }

        // source -> dest
        const int restSource = rename(sourceFileName.c_str(), destinationFileName.c_str());

        if (restSource == -1)
        {
            // backup -> dest
            if (backupFile)
                rename(destinationBackupFileName.c_str(), destinationFileName.c_str());

            // Copy backup data -> dest
            struct stat backupStat;
            if (backupFd != -1 && fstat(backupFd, &backupStat) == 0)
            {
                const int destFd = open(destinationBackupFileName.c_str(), O_WRONLY | O_CREAT | O_TRUNC, backupStat.st_mode);

                if (destFd != -1)
                {
                    int unusedCopyFileError;
                    InternalCopyFile(backupFd, destFd, backupStat, &unusedCopyFileError);
                    close(destFd);
                }
            }

            if (backupFd != -1)
                close(backupFd);

            *error = PathErrnoToErrorCode(sourceFileName.c_str(), errno);
            return false;
        }

        if (backupFd != -1)
            close(backupFd);

        *error = kErrorCodeSuccess;

        return true;
    }

    static int ConvertFlags(int fileaccess, int createmode)
    {
        int flags;

        switch (fileaccess)
        {
            case kFileAccessRead:
                flags = O_RDONLY;
                break;
            case kFileAccessWrite:
                flags = O_WRONLY;
                break;
            case kFileAccessReadWrite:
                flags = O_RDWR;
                break;
            default:
                flags = 0;
                break;
        }

        switch (createmode)
        {
            case kFileModeCreateNew:
                flags |= O_CREAT | O_EXCL;
                break;
            case kFileModeCreate:
                flags |= O_CREAT | O_TRUNC;
                break;
            case kFileModeOpen:
                break;
            case kFileModeOpenOrCreate:
            case kFileModeAppend:
                flags |= O_CREAT;
                break;
            case kFileModeTruncate:
                flags |= O_TRUNC;
                break;
            default:
                flags = 0;
                break;
        }

        return flags;
    }

#ifndef S_ISFIFO
#define S_ISFIFO(m) ((m & S_IFIFO) != 0)
#endif

    FileHandle* File::Open(const std::string& path, int mode, int accessMode, int shareMode, int options, int *error)
    {
        const int flags = ConvertFlags(accessMode, mode);

        /* we don't use sharemode, because that relates to sharing of
         * the file when the file is open and is already handled by
         * other code, perms instead are the on-disk permissions and
         * this is a sane default.
         */
        const mode_t perms = options & kFileOptionsTemporary ? 0600 : 0666;

        int fd = open(path.c_str(), flags, perms);

        /* If we were trying to open a directory with write permissions
         * (e.g. O_WRONLY or O_RDWR), this call will fail with
         * EISDIR. However, this is a bit bogus because calls to
         * manipulate the directory (e.g. SetFileTime) will still work on
         * the directory because they use other API calls
         * (e.g. utime()). Hence, if we failed with the EISDIR error, try
         * to open the directory again without write permission.
         */

        // Try again but don't try to make it writable
        if (fd == -1)
        {
            if (errno == EISDIR)
            {
                fd = open(path.c_str(), flags & ~(O_RDWR | O_WRONLY), perms);

                if (fd == -1)
                {
                    *error = PathErrnoToErrorCode(path, errno);
                    return INVALID_FILE_HANDLE;
                }
            }
            else
            {
                *error = PathErrnoToErrorCode(path, errno);
                return INVALID_FILE_HANDLE;
            }
        }

        struct stat statbuf;
        const int ret = fstat(fd, &statbuf);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            close(fd);
            return INVALID_FILE_HANDLE;
        }

        if (!ShareAllowOpen(statbuf, shareMode, accessMode))
        {
            *error = kErrorCodeSharingViolation;
            close(fd);
            return INVALID_FILE_HANDLE;
        }

        FileHandle* fileHandle = new FileHandle();
        fileHandle->fd = fd;
        fileHandle->path = path;
        fileHandle->options = options;
        fileHandle->accessMode = accessMode;
        fileHandle->shareMode = shareMode;

        fileHandle->device = statbuf.st_dev;
        fileHandle->inode = statbuf.st_ino;

        // Add to linked list
        AddFileHandle(fileHandle);

#ifdef HAVE_POSIX_FADVISE
        if (options & kFileOptionsSequentialScan)
            posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);
        if (options & kFileOptionsRandomAccess)
            posix_fadvise(fd, 0, 0, POSIX_FADV_RANDOM);
#endif

        if (S_ISFIFO(statbuf.st_mode))
            fileHandle->type = kFileTypePipe;
        else if (S_ISCHR(statbuf.st_mode))
            fileHandle->type = kFileTypeChar;
        else
            fileHandle->type = kFileTypeDisk;

        *error = kErrorCodeSuccess;

        return fileHandle;
    }

    bool File::Close(FileHandle* handle, int *error)
    {
        if (handle->type == kFileTypeDisk && handle->options & kFileOptionsDeleteOnClose)
            unlink(handle->path.c_str());

        close(handle->fd);

        // Remove from linked list
        RemoveFileHandle(handle);

        delete handle;

        *error = kErrorCodeSuccess;

        return true;
    }

    bool File::SetFileTime(FileHandle* handle, int64_t creation_time, int64_t last_access_time, int64_t last_write_time, int* error)
    {
        if ((handle->accessMode & kFileAccessWrite) == 0)
        {
            *error = kErrorCodeAccessDenied;
            return false;
        }

        struct stat statbuf;
        const int ret = fstat(handle->fd, &statbuf);

        if (ret == -1)
        {
            *error = kErrorCodeInvalidParameter;
            return false;
        }

        struct utimbuf utbuf;

        // Setting creation time is not implemented in Mono and not supported by utime.

        if (last_access_time >= 0)
        {
            if (last_access_time < TIME_ZERO)
            {
                *error = kErrorCodeInvalidParameter;
                return false;
            }

            utbuf.actime = TicksToTime(last_access_time);
        }
        else
        {
            utbuf.actime = statbuf.st_atime;
        }

        if (last_write_time >= 0)
        {
            if (last_write_time < TIME_ZERO)
            {
                *error = kErrorCodeInvalidParameter;
                return false;
            }

            utbuf.modtime = TicksToTime(last_write_time);
        }
        else
        {
            utbuf.modtime = statbuf.st_mtime;
        }

        const int utimeRet = utime(handle->path.c_str(), &utbuf);

        if (utimeRet == -1)
        {
            *error = kErrorCodeInvalidParameter;
            return false;
        }

        *error = kErrorCodeSuccess;

        return true;
    }

    int64_t File::GetLength(FileHandle* handle, int *error)
    {
        if (handle->type != kFileTypeDisk)
        {
            *error = kErrorCodeInvalidHandle;
            return false;
        }

        struct stat statbuf;

        const int ret = fstat(handle->fd, &statbuf);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return -1;
        }

        *error = kErrorCodeSuccess;

        return statbuf.st_size;
    }

    bool File::SetLength(FileHandle* handle, int64_t length, int *error)
    {
        if (handle->type != kFileTypeDisk)
        {
            *error = kErrorCodeInvalidHandle;
            return false;
        }

        // Save current position
        const off_t currentPosition = lseek(handle->fd, 0, SEEK_CUR);

        if (currentPosition == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        const off_t setLength = lseek(handle->fd, length, SEEK_SET);

        if (setLength == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        int ret = 0;

        do
        {
            ret = ftruncate(handle->fd, length);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        const off_t oldPosition = lseek(handle->fd, currentPosition, SEEK_SET);

        if (oldPosition == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        *error = kErrorCodeSuccess;

        return true;
    }

#if !IL2CPP_USE_GENERIC_FILE
    bool File::Truncate(FileHandle* handle, int *error)
    {
        off_t currentPosition = lseek(handle->fd, (off_t)0, SEEK_CUR);
        int32_t ret = 0;
        *error = kErrorCodeSuccess;

        if (currentPosition == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        do
        {
            ret = ftruncate(handle->fd, currentPosition);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        return true;
    }

#endif // IL2CPP_USE_GENERIC_FILE

    int64_t File::Seek(FileHandle* handle, int64_t offset, int origin, int *error)
    {
        if (handle->type != kFileTypeDisk)
        {
            *error = kErrorCodeInvalidHandle;
            return false;
        }

        int whence;

        switch (origin)
        {
            case kFileSeekOriginBegin:
                whence = SEEK_SET;
                break;
            case kFileSeekOriginCurrent:
                whence = SEEK_CUR;
                break;
            case kFileSeekOriginEnd:
                whence = SEEK_END;
                break;
            default:
            {
                *error = kErrorCodeInvalidParameter;
                return -1;
            }
        }

        const off_t position = lseek(handle->fd, offset, whence);

        if (position == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return -1;
        }

        *error = kErrorCodeSuccess;

        return position;
    }

    int File::Read(FileHandle* handle, char *dest, int count, int *error)
    {
        if (handle == NULL || handle == INVALID_FILE_HANDLE)
        {
            *error = kErrorCodeInvalidHandle;
            return 0;
        }

        if ((handle->accessMode & kFileAccessRead) == 0)
        {
            *error = kErrorCodeAccessDenied;
            return 0;
        }

        int ret;

        do
        {
            ret = (int)read(handle->fd, dest, count);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return 0;
        }

        return ret;
    }

    int32_t File::Write(FileHandle* handle, const char* buffer, int count, int *error)
    {
        if ((handle->accessMode & kFileAccessWrite) == 0)
        {
            *error = kErrorCodeAccessDenied;
            return -1;
        }

        int ret;

        do
        {
            ret = (int32_t)write(handle->fd, buffer, count);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return -1;
        }

#if IL2CPP_SUPPORTS_CONSOLE_EXTENSION
        if (handle == GetStdOutput() || handle == GetStdError())
            os::ConsoleExtension::Write(buffer);
#endif
        return ret;
    }

    bool File::Flush(FileHandle* handle, int* error)
    {
        if (handle->type != kFileTypeDisk)
        {
            *error = kErrorCodeInvalidHandle;
            return false;
        }

        const int ret = fsync(handle->fd);

        if (ret == -1)
        {
            *error = FileErrnoToErrorCode(errno);
            return false;
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    void File::Lock(FileHandle* handle, int64_t position, int64_t length, int* error)
    {
        struct flock lock_data;
        int ret;

        lock_data.l_type = F_WRLCK;
        lock_data.l_whence = SEEK_SET;
        lock_data.l_start = position;
        lock_data.l_len = length;

        do
        {
            ret = fcntl(handle->fd, F_SETLK, &lock_data);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            /*
             * if locks are not available (NFS for example),
             * ignore the error
             */
            if (errno == ENOLCK
#ifdef EOPNOTSUPP
                || errno == EOPNOTSUPP
#endif
#ifdef ENOTSUP
                || errno == ENOTSUP
#endif
            )
            {
                *error = kErrorCodeSuccess;
                return;
            }

            *error = FileErrnoToErrorCode(errno);
            return;
        }

        *error = kErrorCodeSuccess;
    }

    void File::Unlock(FileHandle* handle, int64_t position, int64_t length, int* error)
    {
        struct flock lock_data;
        int ret;

        lock_data.l_type = F_UNLCK;
        lock_data.l_whence = SEEK_SET;
        lock_data.l_start = position;
        lock_data.l_len = length;

        do
        {
            ret = fcntl(handle->fd, F_SETLK, &lock_data);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            /*
             * if locks are not available (NFS for example),
             * ignore the error
             */
            if (errno == ENOLCK
#ifdef EOPNOTSUPP
                || errno == EOPNOTSUPP
#endif
#ifdef ENOTSUP
                || errno == ENOTSUP
#endif
            )
            {
                *error = kErrorCodeSuccess;
                return;
            }

            *error = FileErrnoToErrorCode(errno);
            return;
        }

        *error = kErrorCodeSuccess;
    }

    utils::Expected<bool> File::DuplicateHandle(FileHandle* source_process_handle, FileHandle* source_handle, FileHandle* target_process_handle,
        FileHandle** target_handle, int access, int inhert, int options, int* error)
    {
        return utils::Il2CppError(utils::NotSupported, "This platform does not support file handle duplication.");
    }

    utils::Expected<bool> File::IsExecutable(const std::string& path)
    {
#if IL2CPP_CAN_CHECK_EXECUTABLE
        return access(path.c_str(), X_OK) == 0;
#else
        return utils::Il2CppError(utils::NotSupported, "This platform cannot check for executable permissions.");
#endif
    }

    bool File::Cancel(FileHandle* handle)
    {
        return false;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\File.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\FileSystemWatcher.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_ENVIRONMENT && IL2CPP_TARGET_POSIX

#include <cassert>
#include "os/FileSystemWatcher.h"

namespace il2cpp
{
namespace os
{
namespace FileSystemWatcher
{
    int IsSupported()
    {
        return 0;
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\FileSystemWatcher.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Image.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/Memory.h"

#if (IL2CPP_TARGET_JAVASCRIPT || IL2CPP_TARGET_LINUX || IL2CPP_TARGET_QNX) || IL2CPP_TARGET_ANDROID
#include "os/Image.h"

#if IL2CPP_TARGET_JAVASCRIPT
#include <emscripten/emscripten.h>
#else
#include <dlfcn.h>
#endif

#if IL2CPP_ENABLE_NATIVE_INSTRUCTION_POINTER_EMISSION && (IL2CPP_TARGET_ANDROID || IL2CPP_TARGET_LINUX || IL2CPP_TARGET_QNX)
#include <elf.h>

#if __x86_64__ || __aarch64__
#  define ElfW(type) Elf64_##type
#else
#  define ElfW(type) Elf32_##type
#endif

#endif

#include <cstdio>

extern char __start_il2cpp;
extern char __stop_il2cpp;

namespace il2cpp
{
namespace os
{
namespace Image
{
    static void* s_ImageBase = NULL;

    void* GetImageBase()
    {
#if IL2CPP_TARGET_JAVASCRIPT
        emscripten_log(EM_LOG_NO_PATHS | EM_LOG_CONSOLE | EM_LOG_ERROR | EM_LOG_JS_STACK, "Warning: libil2cpp/os/Posix/Image.cpp: GetImageBase() called, but dynamic libraries are not available.");
        return NULL;
#else
        return s_ImageBase;
#endif
    }

    static IL2CPP_METHOD_ATTR void NoGeneratedCodeWorkaround()
    {
    }

    static void InitializeImageBase()
    {
#if !IL2CPP_TARGET_JAVASCRIPT
        // Gets info about the image containing InitializeImageBase
        Dl_info info;
        memset(&info, 0, sizeof(info));
        int error = dladdr((void*)&InitializeImageBase, &info);

        IL2CPP_ASSERT(error != 0);
        if (error == 0)
            return;

        s_ImageBase = info.dli_fbase;
#endif
    }

    void InitializeManagedSection()
    {
        NoGeneratedCodeWorkaround();
        // Since the native linker creates the __start_il2cpp and __stop_il2cpp
        // globals, we can only use them when IL2CPP_PLATFORM_SUPPORTS_CUSTOM_SECTIONS
        // is defined. Otherwise, they will not exist, and this usage of them will cause
        // an unresolved external error in the native linker. This should be the only
        // place in runtime code that IL2CPP_PLATFORM_SUPPORTS_CUSTOM_SECTIONS is used.
#if IL2CPP_PLATFORM_SUPPORTS_CUSTOM_SECTIONS
        SetManagedSectionStartAndEnd(&__start_il2cpp, &__stop_il2cpp);
#endif
    }

    void Initialize()
    {
        InitializeImageBase();
        InitializeManagedSection();
    }

#if IL2CPP_ENABLE_NATIVE_INSTRUCTION_POINTER_EMISSION
#if IL2CPP_TARGET_ANDROID || IL2CPP_TARGET_LINUX
    char* GetELFImageBuildID()
    {
        size_t imageBase = (size_t)GetImageBase();
        ElfW(Ehdr) * ehdr = (ElfW(Ehdr) *)imageBase;
        ElfW(Phdr) * phdr = (ElfW(Phdr) *)(imageBase + ehdr->e_phoff);

        // Bug fix requires the lowest PT_LOAD address, not the lowest PT_LOAD offset
        // https://unix.stackexchange.com/questions/669237/how-to-tell-whether-the-p-vaddr-in-elf-program-header-is-the-real-memory-address
        ElfW(Addr) pt_load_low = SIZE_MAX;          // Set the max value, if it's not changed, assume a zero offset
        for (int i = 0; i < ehdr->e_phnum; i++)
        {
            if (phdr[i].p_type == PT_LOAD && phdr[i].p_vaddr < pt_load_low)
            {
                pt_load_low = phdr[i].p_vaddr;
            }
        }
        pt_load_low = (pt_load_low == SIZE_MAX) ? 0 : pt_load_low;

        for (int i = 0; i < ehdr->e_phnum; i++)
        {
            if (phdr[i].p_type == PT_NOTE)
            {
                size_t nhdr_ptr = phdr[i].p_vaddr + imageBase - pt_load_low;
                size_t nhdr_end = nhdr_ptr + phdr[i].p_memsz;
                int j = 0;
                while (nhdr_ptr < nhdr_end)
                {
                    ElfW(Nhdr) * nhdr = (ElfW(Nhdr) *)nhdr_ptr;
                    if (nhdr->n_type == NT_GNU_BUILD_ID)
                    {
                        uint8_t* image_build_id = (uint8_t *)((size_t)nhdr + sizeof(ElfW(Nhdr)) + nhdr->n_namesz);
                        char* build_id = static_cast<char*>(IL2CPP_MALLOC(41));
                        for (int j = 0; j < nhdr->n_descsz; j++)
                        {
                            snprintf(&build_id[j * 2], 3, "%02x", image_build_id[j]);
                        }
                        return build_id;
                    }
                    nhdr_ptr += sizeof(ElfW(Nhdr)) + nhdr->n_descsz + nhdr->n_namesz;
                }
                break;
            }
        }

        return NULL;
    }

#endif

    char* GetImageUUID()
    {
#if IL2CPP_TARGET_ANDROID || IL2CPP_TARGET_LINUX
        return GetELFImageBuildID();
#else
#error Implement GetImageUUID for this platform
#endif
    }

    char* GetImageName()
    {
#if IL2CPP_TARGET_ANDROID || IL2CPP_TARGET_LINUX
        Dl_info info;
        void* const anySymbol = reinterpret_cast<void*>(&GetImageBase);
        if (dladdr(anySymbol, &info))
        {
            size_t nameSize = strlen(info.dli_fname);
            char* imageName = (char*)IL2CPP_MALLOC(nameSize);
            strncpy(imageName, info.dli_fname, nameSize);
            return imageName;
        }
        else
            return NULL;
#else
#error Implement GetImageName for this platform
#endif
    }

#endif
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Image.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\LastError.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX

#include <errno.h>

#include "os/LastError.h"

namespace il2cpp
{
namespace os
{
    uint32_t LastError::GetLastError()
    {
        return errno;
    }
} /* namespace os */
} /* namespace il2cpp*/

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\LastError.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\LibraryLoader.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_LIBRARYLOADER

#include <dlfcn.h>
#include <string>
#include <set>
#if IL2CPP_TARGET_LINUX
#include <unistd.h>
#include <gnu/lib-names.h>
#endif

#include "il2cpp-runtime-metadata.h"
#include "os/LibraryLoader.h"
#include "utils/PathUtils.h"
#include "utils/StringUtils.h"
#include "utils/Environment.h"

namespace il2cpp
{
namespace os
{
    struct LibraryNamePrefixAndSuffix
    {
        LibraryNamePrefixAndSuffix(const char* prefix_, const char* suffix_)
        {
            prefix = std::string(prefix_);
            suffix = std::string(suffix_);
        }

        std::string prefix;
        std::string suffix;
    };

    static LibraryNamePrefixAndSuffix LibraryNamePrefixAndSuffixVariations[8] =
    {
        LibraryNamePrefixAndSuffix("", ".so"),
        LibraryNamePrefixAndSuffix("", ".dll"),
        LibraryNamePrefixAndSuffix("", ".dylib"),
        LibraryNamePrefixAndSuffix("", ".bundle"),
        LibraryNamePrefixAndSuffix("lib", ".so"),
        LibraryNamePrefixAndSuffix("lib", ".dll"),
        LibraryNamePrefixAndSuffix("lib", ".dylib"),
        LibraryNamePrefixAndSuffix("lib", ".bundle")
    };

    const HardcodedPInvokeDependencyLibrary* LibraryLoader::HardcodedPInvokeDependencies = NULL;
    const size_t LibraryLoader::HardcodedPInvokeDependenciesCount = 0;

    static Baselib_DynamicLibrary_Handle LoadLibraryWithName(const char* name, std::string& detailedError)
    {
#if IL2CPP_TARGET_IOS
        std::string dirName;
        if (utils::Environment::GetNumMainArgs() > 0)
        {
            std::string main = utils::StringUtils::Utf16ToUtf8(utils::Environment::GetMainArgs()[0]);
            dirName = utils::PathUtils::DirectoryName(main);
        }

        std::string libPath = utils::StringUtils::Printf("%s/%s", dirName.c_str(), name);
        auto errorState = Baselib_ErrorState_Create();
        auto handle = LibraryLoader::TryOpeningLibrary(libPath.c_str(), detailedError);
        if (handle != Baselib_DynamicLibrary_Handle_Invalid)
            return handle;

        // Fallback to just using the name. This might be a system dylib.
        return LibraryLoader::TryOpeningLibrary(name, detailedError);
#else
        return LibraryLoader::TryOpeningLibrary(name, detailedError);
#endif
    }

#if IL2CPP_TARGET_LINUX
    static Baselib_DynamicLibrary_Handle LoadLibraryRelativeToExecutableDirectory(const char* name, std::string& detailedError)
    {
        if (name == NULL || name[0] == '/')
            return Baselib_DynamicLibrary_Handle_Invalid;

        char exePath[PATH_MAX + 1];
        int len;

        if ((len = readlink("/proc/self/exe", exePath, sizeof(exePath))) == -1)
        {
            return Baselib_DynamicLibrary_Handle_Invalid;
        }
        exePath[len] = '\0'; // readlink does not terminate buffer
        while (len > 0 && exePath[len] != '/')
            len--;
        exePath[len] = '\0';
        std::string libPath = utils::StringUtils::Printf("%s/%s", exePath, name);

        return LibraryLoader::TryOpeningLibrary(libPath.c_str(), detailedError);
    }

#endif

    static Baselib_DynamicLibrary_Handle CheckLibraryVariations(const char* name, std::string& detailedError)
    {
        const int numberOfVariations = sizeof(LibraryNamePrefixAndSuffixVariations) / sizeof(LibraryNamePrefixAndSuffixVariations[0]);
        for (int i = 0; i < numberOfVariations; ++i)
        {
            std::string libraryName = LibraryNamePrefixAndSuffixVariations[i].prefix + name + LibraryNamePrefixAndSuffixVariations[i].suffix;
            auto handle = LoadLibraryWithName(libraryName.c_str(), detailedError);
            if (handle != Baselib_DynamicLibrary_Handle_Invalid)
                return handle;
#if IL2CPP_TARGET_LINUX
            // Linux does not search current directory by default
            handle = LoadLibraryRelativeToExecutableDirectory(libraryName.c_str(), detailedError);
            if (handle != Baselib_DynamicLibrary_Handle_Invalid)
                return handle;
#endif
        }

        return Baselib_DynamicLibrary_Handle_Invalid;
    }

    Baselib_DynamicLibrary_Handle LibraryLoader::ProbeForLibrary(const Il2CppNativeChar* libraryName, const size_t libraryNameLength, std::string& detailedError)
    {
        auto handle = Baselib_DynamicLibrary_Handle_Invalid;

#if IL2CPP_TARGET_LINUX
        // Workaround the fact that on Linux, libc is actually named libc.so.6 instead of libc.so.
        // mscorlib P/Invokes into plain libc, so we need this for those P/Invokes to succeed
        if (strncasecmp(libraryName, "libc", libraryNameLength) == 0)
            handle = LoadLibraryWithName(LIBC_SO, detailedError);
#endif

        if (handle == Baselib_DynamicLibrary_Handle_Invalid)
            handle = LoadLibraryWithName(libraryName, detailedError);

        if (handle == Baselib_DynamicLibrary_Handle_Invalid)
            handle = CheckLibraryVariations(libraryName, detailedError);

        if (handle == Baselib_DynamicLibrary_Handle_Invalid)
        {
            const size_t lengthWithoutDotDll = libraryNameLength - 4;
            if (strncmp(libraryName + lengthWithoutDotDll, ".dll", 4) == 0)
            {
                char* nativeDynamicLibraryWithoutExtension = static_cast<char*>(alloca((lengthWithoutDotDll + 1) * sizeof(char)));
                memcpy(nativeDynamicLibraryWithoutExtension, libraryName, lengthWithoutDotDll);
                nativeDynamicLibraryWithoutExtension[lengthWithoutDotDll] = 0;

                handle = CheckLibraryVariations(nativeDynamicLibraryWithoutExtension, detailedError);
            }
        }

        return handle;
    }

    Baselib_DynamicLibrary_Handle LibraryLoader::OpenProgramHandle(Baselib_ErrorState& errorState, bool& /*needsClosing*/)
    {
        return Baselib_DynamicLibrary_OpenProgramHandle(&errorState);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\LibraryLoader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Locale.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_LOCALE

#include <clocale>
#include <locale.h>
#if IL2CPP_TARGET_DARWIN
#include <xlocale.h>
#include <CoreFoundation/CoreFoundation.h>
#endif
#include "os/Locale.h"
#include "utils/Memory.h"

namespace il2cpp
{
namespace os
{
#if IL2CPP_TARGET_ANDROID
    std::string AndroidGetLocale();
#endif

#if IL2CPP_TARGET_DARWIN
    static std::string DarwinGetLocale()
    {
        char *darwin_locale = NULL;
        CFLocaleRef locale = NULL;
        CFStringRef locale_language = NULL;
        CFStringRef locale_country = NULL;
        CFStringRef locale_script = NULL;
        CFStringRef locale_cfstr = NULL;
        CFIndex bytes_converted;
        CFIndex bytes_written;
        CFIndex len;

        locale = CFLocaleCopyCurrent();

        if (locale)
        {
            locale_language = (CFStringRef)CFLocaleGetValue(locale, kCFLocaleLanguageCode);
            if (locale_language != NULL && CFStringGetBytes(locale_language, CFRangeMake(0, CFStringGetLength(locale_language)), kCFStringEncodingMacRoman, 0, FALSE, NULL, 0, &bytes_converted) > 0)
            {
                len = bytes_converted + 1;

                locale_country = (CFStringRef)CFLocaleGetValue(locale, kCFLocaleCountryCode);
                if (locale_country != NULL && CFStringGetBytes(locale_country, CFRangeMake(0, CFStringGetLength(locale_country)), kCFStringEncodingMacRoman, 0, FALSE, NULL, 0, &bytes_converted) > 0)
                {
                    len += bytes_converted + 1;

                    locale_script = (CFStringRef)CFLocaleGetValue(locale, kCFLocaleScriptCode);
                    if (locale_script != NULL && CFStringGetBytes(locale_script, CFRangeMake(0, CFStringGetLength(locale_script)), kCFStringEncodingMacRoman, 0, FALSE, NULL, 0, &bytes_converted) > 0)
                    {
                        len += bytes_converted + 1;
                    }

                    darwin_locale = (char *)IL2CPP_MALLOC(len + 1);
                    CFStringGetBytes(locale_language, CFRangeMake(0, CFStringGetLength(locale_language)), kCFStringEncodingMacRoman, 0, FALSE, (UInt8 *)darwin_locale, len, &bytes_converted);

                    darwin_locale[bytes_converted] = '-';
                    bytes_written = bytes_converted + 1;
                    if (locale_script != NULL && CFStringGetBytes(locale_script, CFRangeMake(0, CFStringGetLength(locale_script)), kCFStringEncodingMacRoman, 0, FALSE, (UInt8 *)&darwin_locale[bytes_written], len - bytes_written, &bytes_converted) > 0)
                    {
                        darwin_locale[bytes_written + bytes_converted] = '-';
                        bytes_written += bytes_converted + 1;
                    }

                    CFStringGetBytes(locale_country, CFRangeMake(0, CFStringGetLength(locale_country)), kCFStringEncodingMacRoman, 0, FALSE, (UInt8 *)&darwin_locale[bytes_written], len - bytes_written, &bytes_converted);
                    darwin_locale[bytes_written + bytes_converted] = '\0';
                }
            }

            if (darwin_locale == NULL)
            {
                locale_cfstr = CFLocaleGetIdentifier(locale);

                if (locale_cfstr)
                {
                    len = CFStringGetMaximumSizeForEncoding(CFStringGetLength(locale_cfstr), kCFStringEncodingMacRoman) + 1;
                    darwin_locale = (char *)IL2CPP_MALLOC(len);
                    if (!CFStringGetCString(locale_cfstr, darwin_locale, len, kCFStringEncodingMacRoman))
                    {
                        IL2CPP_FREE(darwin_locale);
                        CFRelease(locale);
                        return std::string();
                    }

                    for (int i = 0; i < strlen(darwin_locale); i++)
                        if (darwin_locale[i] == '_')
                            darwin_locale[i] = '-';
                }
            }

            CFRelease(locale);
        }

        std::string result(darwin_locale);
        IL2CPP_FREE(darwin_locale);

        return result;
    }

#endif

/*
* The following method is modified from the ICU source code. (http://oss.software.ibm.com/icu)
* Copyright (c) 1995-2003 International Business Machines Corporation and others
* All rights reserved.
*/
    static std::string PosixGetLocale()
    {
        const char* posix_locale = NULL;

        posix_locale = getenv("LC_ALL");
        if (posix_locale == 0)
        {
            posix_locale = getenv("LANG");
            if (posix_locale == 0)
            {
#ifdef IL2CPP_TARGET_QNX
                // QNX version of setlocale has limited functionality (compared to Linux) and doesn't accept NULL as an argument:
                // https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/s/setlocale.html
                // https://www.qnx.com/developers/docs/8.0/com.qnx.doc.neutrino.lib_ref/topic/s/setlocale.html
                posix_locale = setlocale(LC_ALL, "C");
#else
                posix_locale = setlocale(LC_ALL, NULL);
#endif
            }
        }

        if (posix_locale == NULL)
            return std::string();

#if IL2CPP_TARGET_JAVASCRIPT || IL2CPP_TARGET_ANDROID
        // This code is here due to a few factors:
        //   1. Emscripten and Android give us a "C" locale (the POSIX default).
        //   2. The Mono class library code uses managed exceptions for flow control.
        //   3. We need to support Emscripten builds with exceptions disabled.
        //   4. Our localization tables don't have any entry for the "C" locale.
        // These factors mean that with Emscripten, the class library code _always_
        // throws a managed exception to due CultureInfo processing. To make this
        // work without exceptions enabled, let's map "C" -> "en-us" for Emscripten.
        if (strcmp(posix_locale, "C.UTF-8") == 0)
            posix_locale = "en-us";
#endif

        if ((strcmp("C", posix_locale) == 0) || (strchr(posix_locale, ' ') != NULL)
            || (strchr(posix_locale, '/') != NULL))
        {
            /*
            * HPUX returns 'C C C C C C C'
            * Solaris can return /en_US/C/C/C/C/C on the second try.
            * Maybe we got some garbage.
            */
            return std::string();
        }

        return std::string(posix_locale);
    }

    std::string Locale::GetLocale()
    {
        std::string locale;
#if IL2CPP_TARGET_DARWIN
        locale = DarwinGetLocale();
#elif IL2CPP_TARGET_ANDROID
        locale = AndroidGetLocale();
#endif
        if (locale.empty())
            locale = PosixGetLocale();

        return locale;
    }

#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
    static locale_t s_cLocale = NULL;
#endif

    void Locale::Initialize()
    {
#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
        s_cLocale = newlocale(LC_ALL_MASK, "", NULL);
#endif
    }

    void Locale::UnInitialize()
    {
#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
        if (s_cLocale)
            freelocale(s_cLocale);
        s_cLocale = NULL;
#endif
    }

#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
    double Locale::DoubleParseLocaleIndependentImpl(char *ptr, char** endptr)
    {
        return strtod_l(ptr, endptr, s_cLocale);
    }

#endif
} /* namespace os */
} /* namespace il2cpp */

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Locale.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\MarshalAlloc.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX || IL2CPP_TARGET_SWITCH

#include "os/MarshalAlloc.h"
#include <stdlib.h>

namespace il2cpp
{
namespace os
{
    void* MarshalAlloc::Allocate(size_t size)
    {
        return malloc(size);
    }

    void* MarshalAlloc::ReAlloc(void* ptr, size_t size)
    {
        return realloc(ptr, size);
    }

    void MarshalAlloc::Free(void* ptr)
    {
        free(ptr);
    }

    void* MarshalAlloc::AllocateHGlobal(size_t size)
    {
        return malloc(size);
    }

    void* MarshalAlloc::ReAllocHGlobal(void* ptr, size_t size)
    {
        return realloc(ptr, size);
    }

    void MarshalAlloc::FreeHGlobal(void* ptr)
    {
        free(ptr);
    }
} /* namespace os */
} /* namespace il2cpp*/

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\MarshalAlloc.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Memory.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX || IL2CPP_TARGET_N3DS

#include "os/Memory.h"
#include <stdint.h>
#include <stdlib.h>

namespace il2cpp
{
namespace os
{
namespace Memory
{
    void* AlignedAlloc(size_t size, size_t alignment)
    {
#if IL2CPP_TARGET_ANDROID || IL2CPP_TARGET_PSP2
        return memalign(alignment, size);
#else
        void* ptr = NULL;
        posix_memalign(&ptr, alignment, size);
        return ptr;
#endif
    }

    void* AlignedReAlloc(void* memory, size_t newSize, size_t alignment)
    {
        void* newMemory = realloc(memory, newSize);

        // Fast path: realloc returned aligned memory
        if ((reinterpret_cast<uintptr_t>(newMemory) & (alignment - 1)) == 0)
            return newMemory;

        // Slow path: realloc returned non-aligned memory
        void* alignedMemory = AlignedAlloc(newSize, alignment);
        memcpy(alignedMemory, newMemory, newSize);
        free(newMemory);
        return alignedMemory;
    }

    void AlignedFree(void* memory)
    {
        free(memory);
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Memory.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\MemoryMappedFile.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_MEMORY_MAPPED_FILE && IL2CPP_TARGET_POSIX

#include <sys/mman.h>
#include <map>
#include "os/File.h"
#include "os/MemoryMappedFile.h"
#include "os/Mutex.h"
#include "utils/Memory.h"
#include "FileHandle.h"
#include <unistd.h>
#include <fcntl.h>

#ifdef DEFFILEMODE
#define DEFAULT_FILEMODE DEFFILEMODE
#else
#define DEFAULT_FILEMODE 0666
#endif

#ifndef MAP_32BIT
#define MAP_32BIT 0
#endif

namespace il2cpp
{
namespace os
{
    enum MemoryMappedFileFlags
    {
        /* protection */
        MONO_MMAP_NONE = 0,
        MONO_MMAP_READ    = 1 << 0,
        MONO_MMAP_WRITE   = 1 << 1,
        MONO_MMAP_EXEC    = 1 << 2,
        /* make the OS discard the dirty data and fill with 0 */
        MONO_MMAP_DISCARD = 1 << 3,
        /* other flags (add commit, sync) */
        MONO_MMAP_PRIVATE = 1 << 4,
        MONO_MMAP_SHARED  = 1 << 5,
        MONO_MMAP_ANON    = 1 << 6,
        MONO_MMAP_FIXED   = 1 << 7,
        MONO_MMAP_32BIT   = 1 << 8
    };

    static bool IsSpecialZeroSizeFile(struct stat *buf)
    {
        return buf->st_size == 0 && (buf->st_mode & (S_IFCHR | S_IFBLK | S_IFIFO | S_IFSOCK)) != 0;
    }

    static int64_t GetPageSize()
    {
        static int64_t page_size = getpagesize();

        return page_size;
    }

    static int64_t AlignUpToPageSize(int64_t size)
    {
        const int64_t page_size = GetPageSize();
        return (size + page_size - 1) & ~(page_size - 1);
    }

    static int64_t AlignDownToPageSize(int64_t size)
    {
        const int64_t page_size = GetPageSize();
        return size & ~(page_size - 1);
    }

    static int ConvertAccessToMemoryMappedFileFlags(int access)
    {
        switch (access)
        {
            case MMAP_FILE_ACCESS_READ_WRITE:
                return MONO_MMAP_WRITE | MONO_MMAP_READ | MONO_MMAP_SHARED;

            case MMAP_FILE_ACCESS_WRITE:
                return MONO_MMAP_WRITE | MONO_MMAP_SHARED;

            case MMAP_FILE_ACCESS_COPY_ON_WRITE:
                return MONO_MMAP_WRITE | MONO_MMAP_READ | MONO_MMAP_PRIVATE;

            case MMAP_FILE_ACCESS_READ_EXECUTE:
                return MONO_MMAP_EXEC | MONO_MMAP_PRIVATE | MONO_MMAP_SHARED;

            case MMAP_FILE_ACCESS_READ_WRITE_EXECUTE:
                return MONO_MMAP_WRITE | MONO_MMAP_READ | MONO_MMAP_EXEC | MONO_MMAP_SHARED;

            case MMAP_FILE_ACCESS_READ:
                return MONO_MMAP_READ | MONO_MMAP_SHARED;
            default:
                IL2CPP_ASSERT("unknown MemoryMappedFileAccess");
        }

        return 0;
    }

    static int ConvertFileModeToUnix(int mode)
    {
        switch (mode)
        {
            case FILE_MODE_CREATE_NEW:
                return O_CREAT | O_EXCL;
            case FILE_MODE_CREATE:
                return O_CREAT | O_TRUNC;
            case FILE_MODE_OPEN:
                return 0;
            case FILE_MODE_OPEN_OR_CREATE:
                return O_CREAT;
            case FILE_MODE_TRUNCATE:
                return O_TRUNC;
            case FILE_MODE_APPEND:
                return O_APPEND;
            default:
                IL2CPP_ASSERT("unknown FileMode");
        }

        return 0;
    }

    static int ConvertAccessModeToUnix(int access)
    {
        switch (access)
        {
            case MMAP_FILE_ACCESS_READ_WRITE:
            case MMAP_FILE_ACCESS_COPY_ON_WRITE:
            case MMAP_FILE_ACCESS_READ_WRITE_EXECUTE:
                return O_RDWR;
            case MMAP_FILE_ACCESS_READ:
            case MMAP_FILE_ACCESS_READ_EXECUTE:
                return O_RDONLY;
            case MMAP_FILE_ACCESS_WRITE:
                return O_WRONLY;
            default:
                IL2CPP_ASSERT("unknown MemoryMappedFileAccess");
        }

        return 0;
    }

    static int ConvertFlagsToProt(int flags)
    {
        int prot = PROT_NONE;
        /* translate the protection bits */
        if (flags & MONO_MMAP_READ)
            prot |= PROT_READ;
        if (flags & MONO_MMAP_WRITE)
            prot |= PROT_WRITE;
        if (flags & MONO_MMAP_EXEC)
            prot |= PROT_EXEC;
        return prot;
    }

    void MemoryMappedFile::AllocateStaticData()
    {
    }

    void MemoryMappedFile::FreeStaticData()
    {
    }

    FileHandle* MemoryMappedFile::Create(FileHandle* file, const char* mapName, int32_t mode, int64_t *capacity, MemoryMappedFileAccess access, int32_t options, MemoryMappedFileError* error)
    {
        struct stat buf;
        int result, fd;

        if (file != NULL)
            result = fstat(file->fd, &buf);
        else
            result = stat(mapName, &buf);

        if (mode == FILE_MODE_TRUNCATE || mode == FILE_MODE_APPEND || mode == FILE_MODE_OPEN)
        {
            if (result == -1)
            {
                if (error != NULL)
                    *error = FILE_NOT_FOUND;
                return NULL;
            }
        }

        if (mode == FILE_MODE_CREATE_NEW && result == 0)
        {
            if (error != NULL)
                *error = FILE_ALREADY_EXISTS;
            return NULL;
        }

        if (result == 0)
        {
            if (*capacity == 0)
            {
                /**
                 * Special files such as FIFOs, sockets, and devices can have a size of 0. Specifying a capacity for these
                 * also makes little sense, so don't do the check if th file is one of these.
                 */
                if (buf.st_size == 0 && !IsSpecialZeroSizeFile(&buf))
                {
                    if (error != NULL)
                        *error = CAPACITY_SMALLER_THAN_FILE_SIZE;
                    return NULL;
                }
                *capacity = buf.st_size;
            }
            else if (*capacity < buf.st_size)
            {
                if (error != NULL)
                    *error = CAPACITY_SMALLER_THAN_FILE_SIZE;
                return NULL;
            }
        }
        else
        {
            if (mode == FILE_MODE_CREATE_NEW && *capacity == 0)
            {
                if (error != NULL)
                    *error = CAPACITY_SMALLER_THAN_FILE_SIZE;
                return NULL;
            }
        }

        bool ownsFd = true;
        if (file != NULL)
        {
#if IL2CPP_HAS_DUP
            fd = dup(file->fd);
#else
            fd = file->fd;
            ownsFd = false;
#endif
        }
        else
        {
            fd = open(mapName, ConvertFileModeToUnix(mode) | ConvertAccessModeToUnix(access), DEFAULT_FILEMODE);
        }

        if (fd == -1)
        {
            if (error != NULL)
                *error = COULD_NOT_OPEN;
            return NULL;
        }

        if (result != 0 || *capacity > buf.st_size)
        {
            int result = ftruncate(fd, (off_t)*capacity);
            IL2CPP_ASSERT(result == 0);
            NO_UNUSED_WARNING(result);
        }

        if (ownsFd)
        {
            FileHandle* handle = new FileHandle;
            handle->fd = fd;
            handle->doesNotOwnFd = !ownsFd;
            return handle;
        }
        else
        {
            file->doesNotOwnFd = true;
            return file;
        }
    }

    MemoryMappedFile::MemoryMappedFileHandle MemoryMappedFile::View(FileHandle* mappedFileHandle, int64_t* length, int64_t offset, MemoryMappedFileAccess access, int64_t* actualOffset, MemoryMappedFileError* error)
    {
        IL2CPP_ASSERT(actualOffset != NULL);

        int64_t mmap_offset = 0;
        int64_t eff_size = *length;
        struct stat buf = { 0 };
        fstat(mappedFileHandle->fd, &buf);

        if (offset > buf.st_size || ((eff_size + offset) > buf.st_size && !IsSpecialZeroSizeFile(&buf)))
        {
            if (error != NULL)
                *error = ACCESS_DENIED;
            return NULL;
        }
        /**
          * We use the file size if one of the following conditions is true:
          *  -input size is zero
          *  -input size is bigger than the file and the file is not a magical zero size file such as /dev/mem.
          */
        if (eff_size == 0)
            eff_size = AlignUpToPageSize(buf.st_size) - offset;

        mmap_offset = AlignDownToPageSize(offset);
        eff_size += (offset - mmap_offset);
        *length = eff_size;
        *actualOffset = mmap_offset;

        int flags = ConvertAccessToMemoryMappedFileFlags(access);
        int prot = ConvertFlagsToProt(flags);

        /* translate the flags */
        int mflags = 0;
        if (flags & MONO_MMAP_PRIVATE)
            mflags |= MAP_PRIVATE;
        if (flags & MONO_MMAP_SHARED)
            mflags |= MAP_SHARED;
        if (flags & MONO_MMAP_FIXED)
            mflags |= MAP_FIXED;
        if (flags & MONO_MMAP_32BIT)
            mflags |= MAP_32BIT;

        void* address = mmap(NULL, eff_size, prot, mflags, mappedFileHandle->fd, mmap_offset);
        if (address == MAP_FAILED)
        {
            if (error != NULL)
                *error = COULD_NOT_MAP_MEMORY;
            return NULL;
        }

        return address;
    }

    void MemoryMappedFile::Flush(MemoryMappedFileHandle memoryMappedFileData, int64_t length)
    {
        if (memoryMappedFileData != NULL)
        {
            int error = msync(memoryMappedFileData, length, MS_SYNC);
            IL2CPP_ASSERT(error == 0);
            NO_UNUSED_WARNING(error);
        }
    }

    bool MemoryMappedFile::UnmapView(MemoryMappedFileHandle memoryMappedFileData, int64_t length)
    {
        int error = munmap(memoryMappedFileData, (size_t)length);
        return error == 0;
    }

    bool MemoryMappedFile::Close(FileHandle* file)
    {
        bool result = true;
        if (!file->doesNotOwnFd)
        {
            int error = 0;
            os::File::Close(file, &error);
            if (error != 0)
                result = false;
        }

        return result;
    }

    void MemoryMappedFile::ConfigureHandleInheritability(FileHandle* file, bool inheritability)
    {
#if IL2CPP_HAS_CLOSE_EXEC
        int flags = fcntl(file->fd, F_GETFD, 0);
        if (inheritability)
            flags &= ~FD_CLOEXEC;
        else
            flags |= FD_CLOEXEC;
        int result = fcntl(file->fd, F_SETFD, flags);
        IL2CPP_ASSERT(result != -1);
        NO_UNUSED_WARNING(result);
#endif
    }

    bool MemoryMappedFile::OwnsDuplicatedFileHandle(FileHandle* file)
    {
        return !file->doesNotOwnFd;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\MemoryMappedFile.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\NativeMethods.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX

#include "os/NativeMethods.h"
#include "os/Process.h"
#include "utils/Expected.h"

namespace il2cpp
{
namespace os
{
    bool NativeMethods::CloseProcess(ProcessHandle* handle)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(NativeMethods::CloseProcess);
        IL2CPP_UNREACHABLE;
        return false;
    }

    utils::Expected<bool> NativeMethods::GetExitCodeProcess(ProcessHandle* handle, int32_t* exitCode)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(NativeMethods::GetExitCodeProcess);
        IL2CPP_UNREACHABLE;
        return false;
    }

    int32_t NativeMethods::GetCurrentProcessId()
    {
        return Process::GetCurrentProcessId();
    }

    utils::Expected<ProcessHandle*> NativeMethods::GetCurrentProcess()
    {
        return Process::GetProcess(Process::GetCurrentProcessId());
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\NativeMethods.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Path.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_PATH
#include "os/Environment.h"
#include "os/Path.h"
#include "utils/PathUtils.h"
#include <string>

#if defined(__APPLE__)
#include "mach-o/dyld.h"
#elif IL2CPP_TARGET_LINUX || IL2CPP_TARGET_ANDROID
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#elif IL2CPP_TARGET_QNX
#include <unistd.h>
#endif

namespace il2cpp
{
namespace os
{
    std::string Path::GetExecutablePath()
    {
#if defined(__APPLE__)
        char path[1024];
        uint32_t size = sizeof(path);
        if (_NSGetExecutablePath(path, &size) == 0)
            return path;

        std::string result;
        result.resize(size + 1);
        _NSGetExecutablePath(&result[0], &size);
        return result;
#elif IL2CPP_TARGET_LINUX || IL2CPP_TARGET_ANDROID
        char path[PATH_MAX];
        char dest[PATH_MAX + 1];
        //readlink does not null terminate
        memset(dest, 0, PATH_MAX + 1);
        pid_t pid = getpid();
        sprintf(path, "/proc/%d/exe", pid);
        if (readlink(path, dest, PATH_MAX) == -1)
            return std::string();
        return dest;
#elif IL2CPP_TARGET_QNX
        char path[PATH_MAX];
        char dest[PATH_MAX + 1];
        pid_t pid = getpid();
        sprintf(path, "/proc/%d/exefile", pid);
        auto* fh = fopen(path, "r");
        if (fh)
        {
            const auto read = fread(dest, 1, sizeof(dest), fh);
            const auto errorFlag = ferror(fh);
            fclose(fh);
            if (errorFlag == 0)
            {
                return dest;
            }
        }
        return "";
#else
        return std::string();
#endif
    }

    std::string Path::GetApplicationFolder()
    {
        return utils::PathUtils::DirectoryName(GetExecutablePath());
    }

    std::string Path::GetTempPath()
    {
        static const char* tmpdirs[] = { "TMPDIR", "TMP", "TEMP", NULL};

        for (size_t i = 0; tmpdirs[i] != NULL; ++i)
        {
            std::string tmpdir = Environment::GetEnvironmentVariable(tmpdirs[i]);

            if (!tmpdir.empty())
                return tmpdir;
        }

#if IL2CPP_TARGET_ANDROID
        return std::string("/data/local/tmp");
#else
        return std::string("/tmp");
#endif
    }

    bool Path::IsAbsolute(const std::string& path)
    {
        return path[0] == '/';
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Path.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\PosixHelpers.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX || IL2CPP_SUPPORT_SOCKETS_POSIX_API

#if IL2CPP_TARGET_SWITCH || IL2CPP_TARGET_QNX
#include <errno.h>
#else
#include <sys/errno.h>
#endif

#include "os/Posix/PosixHelpers.h"

namespace il2cpp
{
namespace os
{
namespace posix
{
    int Poll(pollfd* handles, int numHandles, int timeout)
    {
        int32_t ret = 0;
        time_t start = time(NULL);

        do
        {
            ret = poll(handles, numHandles, timeout);

            if (timeout > 0 && ret < 0)
            {
                const int32_t err = errno;
                const int32_t sec = time(NULL) - start;

                timeout -= sec * 1000;

                if (timeout < 0)
                    timeout = 0;

                errno = err;
            }
        }
#if IL2CPP_TARGET_LINUX
        while (ret == -1 && (errno == EINTR || errno == EAGAIN));
#else
        while (ret == -1 && errno == EINTR);
#endif

#if IL2CPP_TARGET_LINUX
        // On Linux, socket will report POLLERR if the other end has been closed, in addition to normal POLLHUP
        // From man page:
        // POLLERR
        //   Error condition(only returned in revents; ignored in events).
        //   This bit is also set for a file descriptor referring to the
        //   write end of a pipe when the read end has been closed.
        //
        // Mac and Windows doesn't do it, so we zero out that bit if POLLHUP is set on Linux to get consistent behaviour
        for (int i = 0; i < numHandles; i++)
        {
            if ((handles[i].revents & POLLERR) && (handles[i].revents & POLLHUP))
                handles[i].revents &= ~POLLERR & handles[i].events;
        }
#endif

        return ret;
    }
}
}
}

#endif // IL2CPP_TARGET_POSIX
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\PosixHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Process.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_TARGET_DARWIN

#include <sys/types.h>
#include <unistd.h>

#if IL2CPP_TARGET_LINUX
#include <fcntl.h>
#include <sys/stat.h>
#endif

#include "os/Process.h"
#include "utils/Expected.h"
#include "utils/Il2CppError.h"

struct ProcessHandle
{
    pid_t pid;
};

namespace il2cpp
{
namespace os
{
    int Process::GetCurrentProcessId()
    {
        return getpid();
    }

    utils::Expected<ProcessHandle*> Process::GetProcess(int processId)
    {
        // If/when we implement the CreateProcess_internal icall we will likely
        // need to so something smarter here to find the process if we did
        // not create it and return a known pseudo-handle. For now this
        // is sufficient though.
        return (ProcessHandle*)(intptr_t)processId;
    }

    void Process::FreeProcess(ProcessHandle* handle)
    {
        // We have nothing to do here.
    }

    utils::Expected<std::string> Process::GetProcessName(ProcessHandle* handle)
    {
#if IL2CPP_TARGET_LINUX
        char pathBuffer[32];
        snprintf(pathBuffer, IL2CPP_ARRAY_SIZE(pathBuffer), "/proc/%d/comm", static_cast<int>(reinterpret_cast<intptr_t>(handle)));

        int fileHandle = open(pathBuffer, 0, O_RDONLY);
        if (fileHandle == -1)
            return std::string();

        std::string processName;
        char buffer[256];
        ssize_t bytesRead;

        do
        {
            bytesRead = read(fileHandle, buffer, IL2CPP_ARRAY_SIZE(buffer));
            if (bytesRead > 0)
                processName.append(buffer, bytesRead);
        }
        while (bytesRead == IL2CPP_ARRAY_SIZE(buffer));

        close(fileHandle);

        // Truncate name to first line ending
        size_t index = processName.find_first_of('\n');
        if (index != std::string::npos)
            processName.resize(index);

        return processName;
#else
        return utils::Il2CppError(utils::NotSupported, "GetProcessName is not supported for non-Windows/OSX/Linux desktop platforms");
#endif
    }

    intptr_t Process::GetMainWindowHandle(int32_t pid)
    {
        return 0;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Process.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\SocketImpl.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_SOCKET_IMPL && (IL2CPP_TARGET_POSIX || IL2CPP_SUPPORT_SOCKETS_POSIX_API) && IL2CPP_SUPPORT_SOCKETS

// enable support for AF_UNIX and socket paths
#define SUPPORT_UNIXSOCKETS (1)

// some platforms require a different function to close sockets
#define SOCK_CLOSE close

// allow option include file to configure platform
#if IL2CPP_USE_POSIX_SOCKET_PLATFORM_CONFIG
#include "SocketImplPlatformConfig.h"
#endif

#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
 #if SUPPORT_UNIXSOCKETS
#include <sys/un.h>
#endif
#include <sys/poll.h>
#include <sys/stat.h>

#if IL2CPP_SUPPORT_SEND_FILE && (IL2CPP_TARGET_LINUX || IL2CPP_TARGET_ANDROID)
#include <sys/sendfile.h>
#endif

#include "os/Error.h"
#include "os/Socket.h"
#include "os/ErrorCodes.h"
#include "os/Posix/Error.h"
#include "os/Posix/PosixHelpers.h"
#include "os/Posix/SocketImpl.h"
#include "os/Posix/ThreadImpl.h"
#include "utils/Memory.h"
#include "utils/Il2CppError.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace os
{
    static bool is_loopback(int32_t family, uint8_t *addr)
    {
        if (family == AF_INET)
            return addr[0] == 127;
#if IL2CPP_SUPPORT_IPV6
        else if (family == AF_INET6)
            return (IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr));
#endif
        return false;
    }

    static bool is_loopback(const char* address)
    {
        if (strcmp(address, "localhost") == 0)
        {
            return true;
        }

        {
            sockaddr_in sin = {0};
            if (inet_pton(AF_INET, address, &sin.sin_addr) > 0)
            {
                return is_loopback(AF_INET, (uint8_t*)&sin.sin_addr);
            }
        }
#if IL2CPP_SUPPORT_IPV6
        {
            sockaddr_in6 sin = {0};
            if (inet_pton(AF_INET6, address, &sin.sin6_addr) > 0)
            {
                return is_loopback(AF_INET6, (uint8_t*)&sin.sin6_addr);
            }
        }
#endif
        return false;
    }

    static bool is_limited_broadcast(const struct sockaddr *sa, socklen_t sa_size)
    {
        if (sa != NULL && sa_size >= sizeof(sockaddr_in))
        {
            const sockaddr_in *sin = (const sockaddr_in *)sa;
            return sin->sin_family == AF_INET && sin->sin_addr.s_addr == htonl(INADDR_BROADCAST);
        }

        return false;
    }

    bool SocketImpl::is_private(const struct sockaddr *sa, socklen_t sa_size)
    {
        if (is_limited_broadcast(sa, sa_size))
        {
            return true;
        }

        if (sa != NULL)
        {
            if (sa_size >= sizeof(const sockaddr_in) && sa->sa_family == AF_INET)
            {
                const uint8_t *addr = (uint8_t *)&(((const sockaddr_in *)sa)->sin_addr);
                if (addr[0] == 10) // Class A
                {
                    return true;
                }
                if (addr[0] == 172 && (addr[1] & 0xf0) == 16) // Class B
                {
                    return true;
                }
                if (addr[0] == 192 && addr[1] == 168) // Class C
                {
                    return true;
                }
            }
#if IL2CPP_SUPPORT_IPV6
            else if (sa_size >= sizeof(struct sockaddr_in6) && sa->sa_family == AF_INET6)
            {
                const uint8_t *addr = (uint8_t *)&(((const sockaddr_in6 *)sa)->sin6_addr);
                if (addr[0] == 0xf && (addr[1] & 0xe) == 0xc) // Unique local unicast address(ULA)
                {
                    return true;
                }
                if (addr[0] == 0xf && addr[1] == 0xe && (addr[2] & 0xc) == 0x8) // Link local unicast address
                {
                    return true;
                }
            }
#endif
        }

        return false;
    }

    bool SocketImpl::is_private(const char* address)
    {
        if (address == 0 || address[0] == 0)
        {
            return false;
        }

        {
            sockaddr_in sin = {0};
            if (inet_pton(AF_INET, address, &sin.sin_addr) > 0)
            {
                sin.sin_family = AF_INET;
                return is_private((const sockaddr *)&sin, sizeof(sin));
            }
        }
#if IL2CPP_SUPPORT_IPV6
        {
            sockaddr_in6 sin = {0};
            if (inet_pton(AF_INET6, address, &sin.sin6_addr) > 0)
            {
                sin.sin6_family = AF_INET6;
                return is_private((const sockaddr *)&sin, sizeof(sin));
            }
        }
#endif
        return false;
    }

#define IFCONF_BUFF_SIZE 1024
#ifndef _SIZEOF_ADDR_IFREQ
#define _SIZEOF_ADDR_IFREQ(ifr) (sizeof (struct ifreq))
#endif

#define FOREACH_IFR(IFR, IFC) \
    for (IFR = (IFC).ifc_req;   \
    ifr < (struct ifreq*)((char*)(IFC).ifc_req + (IFC).ifc_len); \
    ifr = (struct ifreq*)((char*)(IFR) + _SIZEOF_ADDR_IFREQ (*(IFR))))

    static int address_size_for_family(int family)
    {
        switch (family)
        {
            case AF_INET:
                return sizeof(struct in_addr);
#if IL2CPP_SUPPORT_IPV6
            case AF_INET6:
                return sizeof(struct in6_addr);
#endif
        }
        return 0;
    }

    static void*
    get_address_from_sockaddr(struct sockaddr *sa)
    {
        switch (sa->sa_family)
        {
            case AF_INET:
                return &((struct sockaddr_in*)sa)->sin_addr;
#if IL2CPP_SUPPORT_IPV6
            case AF_INET6:
                return &((struct sockaddr_in6*)sa)->sin6_addr;
#endif
        }
        return NULL;
    }

    static struct in_addr *get_local_ips(int32_t family, int32_t *interface_count)
    {
        int fd;
        struct ifconf ifc;
        struct ifreq *ifr;
        int if_count = 0;
        bool ignore_loopback = false;
        void *result = NULL;
        char *result_ptr;

        *interface_count = 0;

        if (!address_size_for_family(family))
            return NULL;

        fd = socket(family, SOCK_STREAM, 0);
        if (fd == -1)
            return NULL;

        memset(&ifc, 0, sizeof(ifc));
        ifc.ifc_len = IFCONF_BUFF_SIZE;
        ifc.ifc_buf = (char*)malloc(IFCONF_BUFF_SIZE);   /* We can't have such huge buffers on the stack. */
        if (ioctl(fd, SIOCGIFCONF, &ifc) < 0)
            goto done;

        FOREACH_IFR(ifr, ifc) {
            struct ifreq iflags;

            //only return addresses of the same type as @family
            if (ifr->ifr_addr.sa_family != family)
            {
                ifr->ifr_name[0] = '\0';
                continue;
            }

            strcpy(iflags.ifr_name, ifr->ifr_name);

            //ignore interfaces we can't get props for
            if (ioctl(fd, SIOCGIFFLAGS, &iflags) < 0)
            {
                ifr->ifr_name[0] = '\0';
                continue;
            }

            //ignore interfaces that are down
            if ((iflags.ifr_flags & IFF_UP) == 0)
            {
                ifr->ifr_name[0] = '\0';
                continue;
            }

            //If we have a non-loopback iface, don't return any loopback
            if ((iflags.ifr_flags & IFF_LOOPBACK) == 0)
            {
                ignore_loopback = true;
                ifr->ifr_name[0] = 1; //1 means non-loopback
            }
            else
            {
                ifr->ifr_name[0] = 2;  //2 means loopback
            }
            ++if_count;
        }

        result = (char*)malloc(if_count * address_size_for_family(family));
        result_ptr = (char*)result;
        FOREACH_IFR(ifr, ifc) {
            if (ifr->ifr_name[0] == '\0')
                continue;

            if (ignore_loopback && ifr->ifr_name[0] == 2)
            {
                --if_count;
                continue;
            }

            memcpy(result_ptr, get_address_from_sockaddr(&ifr->ifr_addr), address_size_for_family(family));
            result_ptr += address_size_for_family(family);
        }
        IL2CPP_ASSERT(result_ptr <= (char*)result + if_count * address_size_for_family(family));

    done:
        *interface_count = if_count;
        free(ifc.ifc_buf);
        close(fd);
        return (struct in_addr*)result;
    }

    static bool hostent_get_info(struct hostent *he, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addr_list)
    {
        if (he == NULL)
            return false;

        if (he->h_length != 4 || he->h_addrtype != AF_INET)
            return false;

        name.assign(he->h_name);

        for (int32_t i = 0; he->h_aliases[i] != NULL; ++i)
            aliases.push_back(he->h_aliases[i]);

        for (int32_t i = 0; he->h_addr_list[i] != NULL; ++i)
            addr_list.push_back(
                utils::StringUtils::NPrintf("%u.%u.%u.%u", 16,
                    (uint8_t)he->h_addr_list[i][0],
                    (uint8_t)he->h_addr_list[i][1],
                    (uint8_t)he->h_addr_list[i][2],
                    (uint8_t)he->h_addr_list[i][3]));

        return true;
    }

    static bool hostent_get_info_with_local_ips(struct hostent *he, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addr_list)
    {
        int32_t nlocal_in = 0;

        if (he != NULL)
        {
            if (he->h_length != 4 || he->h_addrtype != AF_INET)
                return false;

            name.assign(he->h_name);

            for (int32_t i = 0; he->h_aliases[i] != NULL; ++i)
                aliases.push_back(he->h_aliases[i]);
        }

        struct in_addr *local_in = get_local_ips(AF_INET, &nlocal_in);

        if (nlocal_in)
        {
            for (int32_t i = 0; i < nlocal_in; ++i)
            {
                const uint8_t *ptr = (uint8_t*)&local_in[i];

                addr_list.push_back(
                    utils::StringUtils::NPrintf("%u.%u.%u.%u", 16,
                        (uint8_t)ptr[0],
                        (uint8_t)ptr[1],
                        (uint8_t)ptr[2],
                        (uint8_t)ptr[3]));
            }

            free(local_in);
        }
        else if (he == NULL)
        {
            // If requesting "" and there are no other interfaces up, MS returns 127.0.0.1
            addr_list.push_back("127.0.0.1");
            return true;
        }

        if (nlocal_in == 0 && he != NULL)
        {
            for (int32_t i = 0; he->h_addr_list[i] != NULL; ++i)
            {
                addr_list.push_back(
                    utils::StringUtils::NPrintf("%u.%u.%u.%u", 16,
                        (uint8_t)he->h_addr_list[i][0],
                        (uint8_t)he->h_addr_list[i][1],
                        (uint8_t)he->h_addr_list[i][2],
                        (uint8_t)he->h_addr_list[i][3]));
            }
        }

        return true;
    }

    static int32_t convert_socket_flags(os::SocketFlags flags)
    {
        int32_t c_flags = 0;

        if (flags)
        {
            // Check if contains invalid flag values
            if (flags & ~(os::kSocketFlagsOutOfBand | os::kSocketFlagsMaxIOVectorLength | os::kSocketFlagsPeek | os::kSocketFlagsDontRoute | os::kSocketFlagsPartial))
            {
                return -1;
            }
    #ifdef MSG_OOB
            if (flags & os::kSocketFlagsOutOfBand)
                c_flags |= MSG_OOB;
    #endif
            if (flags & os::kSocketFlagsPeek)
                c_flags |= MSG_PEEK;

            if (flags & os::kSocketFlagsDontRoute)
                c_flags |= MSG_DONTROUTE;

            // Ignore Partial - see bug 349688.  Don't return -1, because
            // according to the comment in that bug ms runtime doesn't for
            // UDP sockets (this means we will silently ignore it for TCP
            // too)

    #ifdef MSG_MORE
            if (flags & os::kSocketFlagsPartial)
                c_flags |= MSG_MORE;
    #endif
        }

        return c_flags;
    }

    void SocketImpl::Startup()
    {
#if IL2CPP_TARGET_SWITCH
        Switch::NetworkInterface::Get().TryInitialize();
#endif
    }

    void SocketImpl::Cleanup()
    {
#if IL2CPP_TARGET_SWITCH
        Switch::NetworkInterface::Get().Finalize();
#endif
    }

#if IL2CPP_SUPPORT_IPV6
    static void AddrinfoGetAddresses(struct addrinfo *info, std::string& name, bool add_local_ips,
        std::vector<std::string> &addr_list)
    {
        if (add_local_ips)
        {
            bool any_local_ips_added = false;
            int nlocal_in = 0;
            int nlocal_in6 = 0;
            in_addr* local_in = (struct in_addr *)get_local_ips(AF_INET, &nlocal_in);
            in6_addr* local_in6 = (struct in6_addr *)get_local_ips(AF_INET6, &nlocal_in6);
            if (nlocal_in || nlocal_in6)
            {
                if (nlocal_in)
                {
                    for (int i = 0; i < nlocal_in; i++)
                    {
                        char addr[16];
                        inet_ntop(AF_INET, &local_in[i], addr, sizeof(addr));
                        addr_list.push_back(std::string(addr));
                        any_local_ips_added = true;
                    }
                }

                if (nlocal_in6)
                {
                    for (int i = 0; i < nlocal_in6; i++)
                    {
                        char addr[48];
                        const char* ret = inet_ntop(AF_INET6, &local_in6[i], addr, sizeof(addr));
                        if (ret != NULL)
                        {
                            addr_list.push_back(std::string(addr));
                            any_local_ips_added = true;
                        }
                    }
                }
            }

            free(local_in);
            free(local_in6);

            if (any_local_ips_added)
                return;
        }

        bool nameSet = false;
        for (addrinfo* ai = info; ai != NULL; ai = ai->ai_next)
        {
            const char *ret;
            char buffer[48]; /* Max. size for IPv6 */

            if ((ai->ai_family != PF_INET) && (ai->ai_family != PF_INET6))
                continue;

            if (ai->ai_family == PF_INET)
                ret = inet_ntop(ai->ai_family, (void*)&(((struct sockaddr_in*)ai->ai_addr)->sin_addr), buffer, 16);
            else
                ret = inet_ntop(ai->ai_family, (void*)&(((struct sockaddr_in6*)ai->ai_addr)->sin6_addr), buffer, 48);

            if (ret)
                addr_list.push_back(std::string(buffer));
            else
                addr_list.push_back(std::string());

            if (!nameSet)
            {
                if (ai->ai_canonname != NULL)
                    name = std::string(ai->ai_canonname);
                else
                    name = std::string();

                nameSet = true;
            }
        }
    }

    WaitStatus GetAddressInfo(const char* hostname, bool add_local_ips, std::string &name, std::vector<std::string> &addr_list)
    {
        NetworkAccessHandler::Auto scopedAccess;
        if (!is_loopback(hostname) || add_local_ips)
        {
            if (!scopedAccess.RequestAccessForAddressInfo(SocketImpl::is_private(hostname)))
            {
                return kWaitStatusFailure;
            }
        }

        addrinfo *info = NULL;

        addrinfo hints;
        memset(&hints, 0, sizeof(hints));

        // Here Mono inspects the ipv4Supported and ipv6Supported properties on the managed Socket class.
        // This seems to be unnecessary though, as we can use PF_UNSPEC in all cases, and getaddrinfo works.
        hints.ai_family = PF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
#if IL2CPP_TARGET_QNX
        // there is no AI_ADDRCONFIG flag on QNX:
        hints.ai_flags = AI_CANONNAME;
#else
        hints.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;
#endif

        if (*hostname && getaddrinfo(hostname, NULL, &hints, &info) == -1)
            return kWaitStatusFailure;

        AddrinfoGetAddresses(info, name, add_local_ips, addr_list);

        if (info)
            freeaddrinfo(info);

        if (name.empty())
            name.assign(hostname);

        return kWaitStatusSuccess;
    }

#endif

    WaitStatus SocketImpl::GetHostByAddr(const std::string &address, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addr_list)
    {
        NetworkAccessHandler::Auto scopedAccess;
        if (!is_loopback(address.c_str()))
        {
            if (!scopedAccess.RequestAccessForAddressInfo(is_private(address.c_str())))
            {
                return kWaitStatusFailure;
            }
        }

#if IL2CPP_SUPPORT_IPV6
        struct sockaddr_in saddr;
        struct sockaddr_in6 saddr6;
        int32_t family;
        char hostname[1024] = {0};
        int flags = 0;

        if (inet_pton(AF_INET, address.c_str(), &saddr.sin_addr) <= 0)
        {
            /* Maybe an ipv6 address */
            if (inet_pton(AF_INET6, address.c_str(), &saddr6.sin6_addr) <= 0)
            {
                return kWaitStatusFailure;
            }
            else
            {
                family = AF_INET6;
                saddr6.sin6_family = AF_INET6;
            }
        }
        else
        {
            family = AF_INET;
            saddr.sin_family = AF_INET;
        }

        if (family == AF_INET)
        {
#if HAVE_SOCKADDR_IN_SIN_LEN
            saddr.sin_len = sizeof(saddr);
#endif
            if (getnameinfo((struct sockaddr*)&saddr, sizeof(saddr),
                hostname, sizeof(hostname), NULL, 0,
                flags) != 0)
            {
                return kWaitStatusFailure;
            }
        }
        else if (family == AF_INET6)
        {
#if HAVE_SOCKADDR_IN6_SIN_LEN
            saddr6.sin6_len = sizeof(saddr6);
#endif
            if (getnameinfo((struct sockaddr*)&saddr6, sizeof(saddr6),
                hostname, sizeof(hostname), NULL, 0,
                flags) != 0)
            {
                return kWaitStatusFailure;
            }
        }

        return GetAddressInfo(hostname, false, name, addr_list);
#else
        struct in_addr inaddr;
        if (inet_pton(AF_INET, address.c_str(), &inaddr) <= 0)
            return kWaitStatusFailure;

        struct hostent *he = gethostbyaddr((char*)&inaddr, sizeof(inaddr), AF_INET);

        if (he == NULL)
        {
            name = address;
            addr_list.push_back(name);

            return kWaitStatusSuccess;
        }

        return hostent_get_info(he, name, aliases, addr_list)
            ? kWaitStatusSuccess
            : kWaitStatusFailure;
#endif
    }

    WaitStatus SocketImpl::GetHostByName(const std::string &host, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addresses)
    {
        char this_hostname[256] = {0};

        const char *hostname = host.c_str();
        bool add_local_ips = (*hostname == '\0');

        if (!add_local_ips && gethostname(this_hostname, sizeof(this_hostname)) != -1)
        {
            if (!strcmp(hostname, this_hostname))
                add_local_ips = true;
        }

#if IL2CPP_SUPPORT_IPV6
        return GetAddressInfo(hostname, add_local_ips, name, addresses);
#else
        struct hostent *he = NULL;
        if (*hostname)
            he = gethostbyname(hostname);

        if (*hostname && he == NULL)
            return kWaitStatusFailure;

        return (add_local_ips
            ? hostent_get_info_with_local_ips(he, name, aliases, addresses)
            : hostent_get_info(he, name, aliases, addresses))
            ? kWaitStatusSuccess
            : kWaitStatusFailure;
#endif
    }

    static bool HasAnyIPv4Addresses(const std::vector<std::string>& addresses)
    {
        for (std::vector<std::string>::const_iterator it = addresses.begin(); it != addresses.end(); ++it)
        {
            in_addr address;
            if (inet_pton(AF_INET, it->c_str(), &address))
                return true;
        }

        return false;
    }

    WaitStatus SocketImpl::GetHostByName(const std::string &host, std::string &name, int32_t &family, std::vector<std::string> &aliases, std::vector<void*> &addr_list, int32_t &addr_size)
    {
        std::vector<std::string> addresses;
        WaitStatus result = GetHostByName(host, name, aliases, addresses);

        // If we got an IPv4 address, use that and any others, skipping IPv6 addresses.
        // We can only return one address size, so we need to choose.
        if (HasAnyIPv4Addresses(addresses))
        {
            addr_size = sizeof(in_addr);
            family = AF_INET;
            for (std::vector<std::string>::iterator it = addresses.begin(); it != addresses.end(); ++it)
            {
                in_addr address;
                if (inet_pton(family, it->c_str(), &address))
                {
                    void* addressLocation = il2cpp::utils::Memory::Malloc(addr_size);
                    memcpy(addressLocation, &address.s_addr, addr_size);
                    addr_list.push_back(addressLocation);
                }
            }
        }
#if IL2CPP_SUPPORT_IPV6
        else
        {
            addr_size = sizeof(in6_addr);
            family = AF_INET6;
            for (std::vector<std::string>::iterator it = addresses.begin(); it != addresses.end(); ++it)
            {
                in6_addr address;
                if (inet_pton(family, it->c_str(), &address))
                {
                    void* addressLocation = il2cpp::utils::Memory::Malloc(addr_size);
                    memcpy(addressLocation, &address.s6_addr, addr_size);
                    addr_list.push_back(addressLocation);
                }
            }
        }
#endif
        return result;
    }

    WaitStatus SocketImpl::GetHostName(std::string &name)
    {
        char hostname[256];
        int32_t ret = gethostname(hostname, sizeof(hostname));

        if (ret == -1)
            return kWaitStatusFailure;

        name.assign(hostname);

        return kWaitStatusSuccess;
    }

    SocketImpl::SocketImpl(ThreadStatusCallback thread_status_callback)
        :   _is_valid(false)
        ,   _fd(-1)
        ,   _domain(-1)
        ,   _type(-1)
        ,   _protocol(-1)
        ,   _saved_error(kErrorCodeSuccess)
        ,   _still_readable(0)
        ,   _thread_status_callback(thread_status_callback)
    {
    }

    SocketImpl::~SocketImpl()
    {
    }

    static int32_t convert_address_family(AddressFamily family)
    {
        switch (family)
        {
            case kAddressFamilyUnspecified:
                return AF_UNSPEC;

            case kAddressFamilyUnix:
                return AF_UNIX;

            case kAddressFamilyInterNetwork:
                return AF_INET;
#ifdef AF_IPX
            case kAddressFamilyIpx:
                return AF_IPX;
#endif
#ifdef AF_SNA
            case kAddressFamilySna:
                return AF_SNA;
#endif
#ifdef AF_DECnet
            case kAddressFamilyDecNet:
                return AF_DECnet;
#endif
#ifdef AF_APPLETALK
            case kAddressFamilyAppleTalk:
                return AF_APPLETALK;
#endif
#ifdef AF_INET6
            case kAddressFamilyInterNetworkV6:
                return AF_INET6;
#endif
#ifdef AF_IRDA
            case kAddressFamilyIrda:
                return AF_IRDA;
#endif

            default:
                break;
        }

        return -1;
    }

    static AddressFamily convert_define_to_address_family(int32_t family)
    {
        switch (family)
        {
            case AF_UNSPEC:
                return kAddressFamilyUnspecified;

            case AF_UNIX:
                return kAddressFamilyUnix;

            case AF_INET:
                return kAddressFamilyInterNetwork;
#ifdef AF_IPX
            case AF_IPX:
                return kAddressFamilyIpx;
#endif
#ifdef AF_SNA
            case AF_SNA:
                return kAddressFamilySna;
#endif
#ifdef AF_DECnet
            case AF_DECnet:
                return kAddressFamilyDecNet;
#endif
#ifdef AF_APPLETALK
            case AF_APPLETALK:
                return kAddressFamilyAppleTalk;
#endif
#ifdef AF_INET6
            case AF_INET6:
                return kAddressFamilyInterNetworkV6;
#endif
#ifdef AF_IRDA
            case AF_IRDA:
                return kAddressFamilyIrda;
#endif

            default:
                break;
        }

        return kAddressFamilyError;
    }

    static int32_t convert_socket_type(SocketType type)
    {
        switch (type)
        {
            case kSocketTypeStream:
                return SOCK_STREAM;

            case kSocketTypeDgram:
                return SOCK_DGRAM;

            case kSocketTypeRaw:
                return SOCK_RAW;
#ifdef SOCK_RDM
            case kSocketTypeRdm:
                return SOCK_RDM;
#endif
#ifdef SOCK_SEQPACKET
            case kSocketTypeSeqpacket:
                return SOCK_SEQPACKET;
#endif
            default:
                break;
        }

        return -1;
    }

    static int32_t convert_socket_protocol(ProtocolType protocol)
    {
        switch (protocol)
        {
            case kProtocolTypeIP:
            case kProtocolTypeIPv6:
            case kProtocolTypeIcmp:
            case kProtocolTypeIgmp:
            case kProtocolTypeGgp:
            case kProtocolTypeTcp:
            case kProtocolTypePup:
            case kProtocolTypeUdp:
            case kProtocolTypeIdp:
                // In this case the enum values map exactly.
                return (int32_t)protocol;

            default:
                break;
        }

        // Everything else in unsupported and unexpected
        return -1;
    }

    WaitStatus SocketImpl::Create(AddressFamily family, SocketType type, ProtocolType protocol)
    {
        _fd = -1;
        _is_valid = false;
        _still_readable = 1;
        _domain = convert_address_family(family);
        _type = convert_socket_type(type);
        _protocol = convert_socket_protocol(protocol);

        IL2CPP_ASSERT(_type != -1 && "Unsupported socket type");
        IL2CPP_ASSERT(_domain != -1 && "Unsupported address family");
        IL2CPP_ASSERT(_protocol != -1 && "Unsupported protocol type");

        _fd = socket(_domain, _type, _protocol);
        if (_fd == -1 && _domain == AF_INET && _type == SOCK_RAW && _protocol == 0)
        {
            // Retry with protocol == 4 (see bug #54565)
            _protocol = 4;
            _fd = socket(AF_INET, SOCK_RAW, 4);
        }

        if (_fd == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        // if (fd >= _wapi_fd_reserve)
        // {
        //  WSASetLastError (WSASYSCALLFAILURE);
        //  close (fd);

        //  return(INVALID_SOCKET);
        // }

        /* .net seems to set this by default for SOCK_STREAM, not for
         * SOCK_DGRAM (see bug #36322)
         *
         * It seems winsock has a rather different idea of what
         * SO_REUSEADDR means.  If it's set, then a new socket can be
         * bound over an existing listening socket.  There's a new
         * windows-specific option called SO_EXCLUSIVEADDRUSE but
         * using that means the socket MUST be closed properly, or a
         * denial of service can occur.  Luckily for us, winsock
         * behaves as though any other system would when SO_REUSEADDR
         * is true, so we don't need to do anything else here.  See
         * bug 53992.
         */
        {
            int32_t v = 1;
            const int32_t ret = setsockopt(_fd, SOL_SOCKET, SO_REUSEADDR, &v, sizeof(v));

            if (ret == -1)
            {
                if (SOCK_CLOSE(_fd) == -1)
                    StoreLastError();

                return kWaitStatusFailure;
            }
        }

#if IL2CPP_TARGET_DARWIN
        int32_t value = 1;
        setsockopt(_fd, SOL_SOCKET, SO_NOSIGPIPE, &value, sizeof(value));
#endif

        // mono_once (&socket_ops_once, socket_ops_init);

        // handle = _wapi_handle_new_fd (WAPI_HANDLE_SOCKET, fd, &socket_handle);
        // if (handle == _WAPI_HANDLE_INVALID) {
        //  g_warning ("%s: error creating socket handle", __func__);
        //  WSASetLastError (WSASYSCALLFAILURE);
        //  close (fd);

        //  return(INVALID_SOCKET);
        // }

        _is_valid = true;

        _networkAccess.InheritNetworkAccessState(_fd);

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Create(SocketDescriptor fd, int32_t family, int32_t type, int32_t protocol)
    {
        _fd = fd;
        _is_valid = (fd != -1);
        _still_readable = 1;
        _domain = family;
        _type = type;
        _protocol = protocol;

        _networkAccess.InheritNetworkAccessState(_fd);

        IL2CPP_ASSERT(_type != -1 && "Unsupported socket type");
        IL2CPP_ASSERT(_domain != -1 && "Unsupported address family");
        IL2CPP_ASSERT(_protocol != -1 && "Unsupported protocol type");

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Close()
    {
        _saved_error = kErrorCodeSuccess;

        if (_is_valid && _fd != -1)
        {
            if (SOCK_CLOSE(_fd) == -1)
                StoreLastError();
        }

        _fd = -1;
        _is_valid = false;
        _still_readable = 0;
        _domain = -1;
        _type = -1;
        _protocol = -1;

        _networkAccess.CancelNetworkAccess();

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::SetBlocking(bool blocking)
    {
#if IL2CPP_USE_SOCKET_SETBLOCKING
        return (WaitStatus)setBlocking(_fd, blocking);
#else

        int32_t flags = fcntl(_fd, F_GETFL, 0);
        if (flags == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        flags = blocking
            ? (flags & ~O_NONBLOCK)
            : (flags | O_NONBLOCK);

        if (fcntl(_fd, F_SETFL, flags) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }
        return kWaitStatusSuccess;
#endif
    }

    ErrorCode SocketImpl::GetLastError() const
    {
        return _saved_error;
    }

    void SocketImpl::StoreLastError()
    {
        const ErrorCode error = SocketErrnoToErrorCode(errno);

        Error::SetLastError(error);

        _saved_error = error;
    }

    void SocketImpl::StoreLastError(int32_t error_no)
    {
        const ErrorCode error = SocketErrnoToErrorCode(error_no);

        Error::SetLastError(error);

        _saved_error = error;
    }

#if SUPPORT_UNIXSOCKETS
    static struct sockaddr* sockaddr_from_path(const char *path, socklen_t *sa_size)
    {
        struct sockaddr_un* sa_un;
        const size_t len = strlen(path);

        if (len >= sizeof(sa_un->sun_path))
            return NULL;

        sa_un = (struct sockaddr_un*)IL2CPP_CALLOC(1, sizeof(sockaddr_un));

        sa_un->sun_family = AF_UNIX;
        memcpy(sa_un->sun_path, path, len);

        *sa_size = sizeof(sockaddr_un);
        return (struct sockaddr *)sa_un;
    }

#endif

#if IL2CPP_SUPPORT_IPV6
    static void sockaddr_from_address(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, sockaddr_in6* sa, socklen_t *sa_size)
    {
        sa->sin6_family = AF_INET6;
        sa->sin6_port = port;
        memcpy(&sa->sin6_addr, &address[0], 16);
        sa->sin6_scope_id = scope;

        *sa_size = sizeof(struct sockaddr_in6);
    }

#endif

    static void sockaddr_from_address(uint32_t address, uint16_t port, struct sockaddr *sa, socklen_t *sa_size)
    {
        struct sockaddr_in sa_in = {0};

        sa_in.sin_family = AF_INET;
        sa_in.sin_port = port;
        sa_in.sin_addr.s_addr = address;

        *sa_size = sizeof(struct sockaddr_in);
        *sa = *((struct sockaddr*)&sa_in);
    }

    static bool socketaddr_to_endpoint_info(const struct sockaddr *address, socklen_t address_len, EndPointInfo &info)
    {
        info.family = convert_define_to_address_family(address->sa_family);

        if (info.family == os::kAddressFamilyInterNetwork)
        {
            const struct sockaddr_in *address_in = (const struct sockaddr_in *)address;

            info.data.inet.port = ntohs(address_in->sin_port);
            info.data.inet.address = ntohl(address_in->sin_addr.s_addr);

            return true;
        }

        if (info.family == os::kAddressFamilyUnix)
        {
            for (int32_t i = 0; i < address_len; i++)
                info.data.path[i] = address->sa_data[i];

            return true;
        }

#if IL2CPP_SUPPORT_IPV6
        if (info.family == os::kAddressFamilyInterNetworkV6)
        {
            const struct sockaddr_in6 *address_in = (const struct sockaddr_in6 *)address;

            uint16_t port = ntohs(address_in->sin6_port);

            info.data.raw[2] = (port >> 8) & 0xff;
            info.data.raw[3] = port & 0xff;

            for (int i = 0; i < 16; i++)
                info.data.raw[i + 8] = address_in->sin6_addr.s6_addr[i];

            info.data.raw[24] = address_in->sin6_scope_id & 0xff;
            info.data.raw[25] = (address_in->sin6_scope_id >> 8) & 0xff;
            info.data.raw[26] = (address_in->sin6_scope_id >> 16) & 0xff;
            info.data.raw[27] = (address_in->sin6_scope_id >> 24) & 0xff;

            return true;
        }
#endif

        return false;
    }

    WaitStatus SocketImpl::Bind(const char *path)
    {
#if SUPPORT_UNIXSOCKETS
        socklen_t sa_size = 0;

        struct sockaddr* sa = sockaddr_from_path(path, &sa_size);

        int result = bind(_fd, sa, sa_size);

        IL2CPP_FREE(sa);

        if (result == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
#else
        return kWaitStatusFailure;
#endif
    }

    WaitStatus SocketImpl::Bind(const char *address, uint16_t port)
    {
        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(inet_addr(address), htons(port), &sa, &sa_size);

        if (!_networkAccess.PrepareForBind(_fd, &sa, sa_size))
        {
            StoreLastError(_networkAccess.GetError());
            return kWaitStatusFailure;
        }

        if (bind(_fd, &sa, sa_size) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Bind(uint32_t address, uint16_t port)
    {
        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        if (!_networkAccess.PrepareForBind(_fd, &sa, sa_size))
        {
            StoreLastError(_networkAccess.GetError());
            return kWaitStatusFailure;
        }

        if (bind(_fd, &sa, sa_size) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    utils::Expected<WaitStatus> SocketImpl::Bind(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
#if IL2CPP_SUPPORT_IPV6
        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        if (!_networkAccess.PrepareForBind(_fd, &sa, sa_size))
        {
            StoreLastError(_networkAccess.GetError());
            return kWaitStatusFailure;
        }

        if (bind(_fd, (sockaddr*)&sa, sa_size) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
#else
        return utils::Il2CppError(utils::NotSupported, "IPv6 is not supported on this platform.");
#endif
    }

    WaitStatus SocketImpl::ConnectInternal(struct sockaddr *sa, int32_t sa_size)
    {
        if (!_networkAccess.PrepareForConnect(_fd, sa, sa_size))
        {
            StoreLastError(_networkAccess.GetError());
            return kWaitStatusFailure;
        }

        if (connect(_fd, sa, (socklen_t)sa_size) != -1)
            return kWaitStatusSuccess;

        if (errno != EINTR)
        {
            // errnum = errno_to_WSA (errnum, __func__);
            // if (errnum == WSAEINPROGRESS)
            //  errnum = WSAEWOULDBLOCK; /* see bug #73053 */

            StoreLastError();

            return kWaitStatusFailure;
        }

        struct pollfd fds = {0};

        fds.fd = _fd;
        fds.events = POLLOUT;

        while (poll(&fds, 1, -1) == -1)
        {
            if (errno != EINTR)
            {
                StoreLastError();
                return kWaitStatusFailure;
            }
        }

        int32_t so_error = 0;
        socklen_t len = sizeof(so_error);

        if (getsockopt(_fd, SOL_SOCKET, SO_ERROR, &so_error, &len) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        if (so_error != 0)
        {
            StoreLastError(so_error);
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Connect(const char *path)
    {
#if SUPPORT_UNIXSOCKETS
        socklen_t sa_size = 0;

        struct sockaddr* sa = sockaddr_from_path(path, &sa_size);

        WaitStatus status = ConnectInternal(sa, sa_size);

        IL2CPP_FREE(sa);

        return status;
#else
        return kWaitStatusFailure;
#endif
    }

    utils::Expected<WaitStatus> SocketImpl::Connect(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
#if IL2CPP_SUPPORT_IPV6
        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        return ConnectInternal((struct sockaddr *)&sa, sa_size);
#else
        return utils::Il2CppError(utils::NotSupported, "IPv6 is not supported on this platform.");
#endif
    }

    WaitStatus SocketImpl::Connect(uint32_t address, uint16_t port)
    {
        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        return ConnectInternal((struct sockaddr *)&sa, sa_size);
    }

    WaitStatus SocketImpl::GetLocalEndPointInfo(EndPointInfo &info)
    {
        // Note: the size here could probably be smaller
        uint8_t buffer[END_POINT_MAX_PATH_LEN + 3] = {0};
        socklen_t address_len = sizeof(buffer);

        if (getsockname(_fd, (struct sockaddr *)buffer, &address_len) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        if (!socketaddr_to_endpoint_info((struct sockaddr *)buffer, address_len, info))
        {
            _saved_error = kWSAeafnosupport;
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::GetRemoteEndPointInfo(EndPointInfo &info)
    {
        // Note: the size here could probably be smaller
        uint8_t buffer[END_POINT_MAX_PATH_LEN + 3] = {0};
        socklen_t address_len = sizeof(buffer);

        if (getpeername(_fd, (struct sockaddr *)buffer, &address_len) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        if (!socketaddr_to_endpoint_info((struct sockaddr *)buffer, address_len, info))
        {
            _saved_error = kWSAeafnosupport;
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Listen(int32_t backlog)
    {
        if (listen(_fd, backlog) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Shutdown(int32_t how)
    {
        if (shutdown(_fd, how) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        if (how == SHUT_RD || how == SHUT_RDWR)
            _still_readable = 0;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Accept(os::Socket **socket)
    {
        int32_t new_fd = 0;

        *socket = NULL;

        do
        {
            new_fd = accept(_fd, NULL, 0);
        }
        while (new_fd == -1 && errno == EINTR);

        if (new_fd == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        *socket = new os::Socket(_thread_status_callback);

        const WaitStatus status = (*socket)->Create(new_fd, _domain, _type, _protocol);

        if (status != kWaitStatusSuccess)
        {
            delete *socket;
            *socket = NULL;
            return status;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Disconnect(bool reuse)
    {
        int32_t new_sock = socket(_domain, _type, _protocol);
        if (new_sock == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        // According to Stevens "Advanced Programming in the UNIX
        // Environment: UNIX File I/O" dup2() is atomic so there
        // should not be a race condition between the old fd being
        // closed and the new socket fd being copied over

        int32_t ret = 0;

        do
        {
            ret = dup2(new_sock, _fd);
        }
        while (ret == -1 && errno == EAGAIN);

        if (ret == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        SOCK_CLOSE(new_sock);

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Receive(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        *len = 0;

        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        return ReceiveFromInternal(data, count, c_flags, len, NULL, 0);
    }

    WaitStatus SocketImpl::ReceiveFromInternal(const uint8_t *data, size_t count, int32_t flags, int32_t *len, struct sockaddr *from, int32_t *fromlen)
    {
        int32_t ret = 0;

        if (!_networkAccess.WaitForNetworkStatus(_fd))
        {
            StoreLastError(_networkAccess.GetError());
            return kWaitStatusFailure;
        }

        do
        {
            ret = (int32_t)recvfrom(_fd, (void*)data, count, flags, from, (socklen_t*)fromlen);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == 0 && count > 0)
        {
            // According to the Linux man page, recvfrom only
            // returns 0 when the socket has been shut down
            // cleanly.  Turn this into an EINTR to simulate win32
            // behaviour of returning EINTR when a socket is
            // closed while the recvfrom is blocking (we use a
            // shutdown() in socket_close() to trigger this.) See
            // bug 75705.

            // Distinguish between the socket being shut down at
            // the local or remote ends, and reads that request 0
            // bytes to be read

            // If this returns FALSE, it means the socket has been
            // closed locally.  If it returns TRUE, but
            // still_readable != 1 then shutdown
            // (SHUT_RD|SHUT_RDWR) has been called locally.

            if (_still_readable != 1)
            {
                ret = -1;
                errno = EINTR;
            }
        }

        if (ret == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        *len = ret;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Send(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        *len = 0;

        int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

#if IL2CPP_USE_SEND_NOSIGNAL
        c_flags |= MSG_NOSIGNAL;
#endif

        int32_t ret = 0;

        do
        {
            ret = (int32_t)send(_fd, (void*)data, count, c_flags);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        *len = ret;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::SendArray(WSABuf *wsabufs, int32_t count, int32_t *sent, SocketFlags flags)
    {
#if IL2CPP_SUPPORT_SEND_MSG
        int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        struct msghdr hdr = {0};

        hdr.msg_iovlen = count;
        hdr.msg_iov = (struct iovec*)malloc(sizeof(struct iovec) * count);

        for (int32_t i = 0; i < count; ++i)
        {
            hdr.msg_iov[i].iov_base = wsabufs[i].buffer;
            hdr.msg_iov[i].iov_len  = wsabufs[i].length;
        }

#if IL2CPP_USE_SEND_NOSIGNAL
        c_flags |= MSG_NOSIGNAL;
#endif

        int32_t ret = 0;

        do
        {
            ret = (int32_t)sendmsg(_fd, &hdr, c_flags);
        }
        while (ret == -1 && errno == EINTR);

        free(hdr.msg_iov);

        if (ret == -1)
        {
            *sent = 0;

            StoreLastError();

            return kWaitStatusFailure;
        }

        *sent = ret;

        return kWaitStatusSuccess;
#else
        if (sent != NULL)
        {
            *sent = 0; // Sent bytes.
        }

        if (wsabufs == NULL && count > 0)
        {
            _saved_error = kErrorInvalidFunction;
            return kWaitStatusFailure;
        }

        int32_t c_flags = convert_socket_flags(flags);

        for (int32_t i = 0; i < count; ++i)
        {
            ssize_t ret = 0;
            do
            {
                ret = send(_fd, wsabufs[i].buffer, wsabufs[i].length, c_flags);
            }
            while (ret == EINTR);

            if (ret == -1)
            {
                StoreLastError();
                return kWaitStatusFailure;
            }

            if (sent != NULL)
            {
                *sent += ret;
            }
        }

        return kWaitStatusSuccess;
#endif
    }

    WaitStatus SocketImpl::ReceiveArray(WSABuf *wsabufs, int32_t count, int32_t *len, SocketFlags flags)
    {
#if IL2CPP_SUPPORT_RECV_MSG
        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        struct msghdr hdr = {0};

        hdr.msg_iovlen = count;
        hdr.msg_iov = (struct iovec*)malloc(sizeof(struct iovec) * count);

        for (int32_t i = 0; i < count; ++i)
        {
            hdr.msg_iov[i].iov_base = wsabufs[i].buffer;
            hdr.msg_iov[i].iov_len  = wsabufs[i].length;
        }

        int32_t ret = 0;

        do
        {
            ret = (int32_t)recvmsg(_fd, &hdr, c_flags);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == 0)
        {
            // See SocketImpl::ReceiveFromInternal
            if (_still_readable != 1)
            {
                ret = -1;
                errno = EINTR;
            }
        }

        free(hdr.msg_iov);

        if (ret == -1)
        {
            *len = 0;

            StoreLastError();

            return kWaitStatusFailure;
        }

        *len = ret;

        return kWaitStatusSuccess;
#else
        if (len != NULL)
        {
            *len = 0;
        }

        if (wsabufs == NULL && count > 0)
        {
            _saved_error = kErrorInvalidFunction;
            return kWaitStatusFailure;
        }

        int32_t c_flags = convert_socket_flags(flags);

        for (int32_t i = 0; i < count; ++i)
        {
            int32_t ret = 0;
            do
            {
                ret = recvfrom(_fd, wsabufs[i].buffer, wsabufs[i].length, c_flags, NULL, NULL);
            }
            while (ret == EINTR);

            if (ret == 0 && count > 0)
            {
                if (_still_readable != 1)
                {
                    _saved_error = SocketErrnoToErrorCode(EINTR);
                    return kWaitStatusFailure;
                }
            }

            if (ret == -1)
            {
                StoreLastError();
                return kWaitStatusFailure;
            }

            if (len != NULL)
            {
                *len += ret;
            }
        }

        return kWaitStatusSuccess;
#endif
    }

    WaitStatus SocketImpl::SendToInternal(struct sockaddr *sa, int32_t sa_size, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

#if IL2CPP_USE_SEND_NOSIGNAL
        c_flags |= MSG_NOSIGNAL;
#endif

        if (!_networkAccess.RequestNetwork(_fd, sa, sa_size))
        {
            StoreLastError(_networkAccess.GetError());
            return kWaitStatusFailure;
        }

        int32_t ret = 0;

        do
        {
            ret = (int32_t)sendto(_fd, (void*)data, count, c_flags, sa, sa_size);
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        *len = ret;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::SendTo(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        *len = 0;

        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        return SendToInternal(&sa, sa_size, data, count, flags, len);
    }

    WaitStatus SocketImpl::SendTo(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
#if SUPPORT_UNIXSOCKETS
        *len = 0;

        socklen_t sa_size = 0;

        struct sockaddr* sa = sockaddr_from_path(path, &sa_size);

        WaitStatus status = SendToInternal(sa, sa_size, data, count, flags, len);

        IL2CPP_FREE(sa);

        return status;
#else
        return kWaitStatusFailure;
#endif
    }

    utils::Expected<WaitStatus> SocketImpl::SendTo(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
#if IL2CPP_SUPPORT_IPV6
        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        return SendToInternal((sockaddr*)&sa, sa_size, data, count, flags, len);
#else
        return utils::Il2CppError(utils::NotSupported, "IPv6 is not supported on this platform.");
#endif
    }

    WaitStatus SocketImpl::RecvFrom(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        *len = 0;

        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        const WaitStatus status = ReceiveFromInternal(data, count, c_flags, len, &sa, (int32_t*)&sa_size);

        if (status != kWaitStatusSuccess)
        {
            ep.family = os::kAddressFamilyError;
            return status;
        }

        if (sa_size == 0)
            return kWaitStatusSuccess;

        if (!socketaddr_to_endpoint_info(&sa, sa_size, ep))
        {
            ep.family = os::kAddressFamilyError;
            _saved_error = kWSAeafnosupport;
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::RecvFrom(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
#if SUPPORT_UNIXSOCKETS
        *len = 0;

        socklen_t sa_size = 0;

        struct sockaddr* sa = sockaddr_from_path(path, &sa_size);

        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            IL2CPP_FREE(sa);
            return kWaitStatusFailure;
        }

        const WaitStatus status = ReceiveFromInternal(data, count, c_flags, len, sa, (int32_t*)&sa_size);

        if (status != kWaitStatusSuccess)
        {
            ep.family = os::kAddressFamilyError;
            IL2CPP_FREE(sa);
            return kWaitStatusFailure;
        }

        if (sa_size == 0)
        {
            IL2CPP_FREE(sa);
            return kWaitStatusSuccess;
        }

        if (!socketaddr_to_endpoint_info(sa, sa_size, ep))
        {
            ep.family = os::kAddressFamilyError;
            _saved_error = kWSAeafnosupport;
            IL2CPP_FREE(sa);
            return kWaitStatusFailure;
        }

        IL2CPP_FREE(sa);
        return kWaitStatusSuccess;
#else
        return kWaitStatusFailure;
#endif
    }

    utils::Expected<WaitStatus> SocketImpl::RecvFrom(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
#if IL2CPP_SUPPORT_IPV6
        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        const WaitStatus status = ReceiveFromInternal(data, count, c_flags, len, (sockaddr*)&sa, (int32_t*)&sa_size);

        if (status != kWaitStatusSuccess)
        {
            ep.family = os::kAddressFamilyError;
            return kWaitStatusFailure;
        }

        if (sa_size == 0)
            return kWaitStatusSuccess;

        if (!socketaddr_to_endpoint_info((sockaddr*)&sa, sa_size, ep))
        {
            ep.family = os::kAddressFamilyError;
            _saved_error = kWSAeafnosupport;
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
#else
        return utils::Il2CppError(utils::NotSupported, "IPv6 is not supported on this platform.");
#endif
    }

    WaitStatus SocketImpl::Available(int32_t *amount)
    {
        // ioctl (fd, FIONREAD, XXX) returns the size of
        // the UDP header as well on Darwin.
        //
        // Use getsockopt SO_NREAD instead to get the
        // right values for TCP and UDP.
        //
        // ai_canonname can be null in some cases on darwin, where the runtime assumes it will
        // be the value of the ip buffer.

        *amount = 0;
#if IL2CPP_TARGET_DARWIN
        socklen_t optlen = sizeof(int32_t);
        if (getsockopt(_fd, SOL_SOCKET, SO_NREAD, amount, &optlen) == -1)
#else
        if (ioctl(_fd, FIONREAD, amount) == -1)
#endif
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Ioctl(int32_t command, const uint8_t *in_data, int32_t in_len, uint8_t *out_data, int32_t out_len, int32_t *written)
    {
        IL2CPP_ASSERT(command != 0xC8000006 /* SIO_GET_EXTENSION_FUNCTION_POINTER */ && "SIO_GET_EXTENSION_FUNCTION_POINTER ioctl command not supported");

        if (command == 0x98000004 /* SIO_KEEPALIVE_VALS */)
        {
            if (in_len < 3 * sizeof(uint32_t))
            {
                StoreLastError();
                return kWaitStatusFailure;
            }

            uint32_t onoff = *((uint32_t*)in_data);
            int32_t ret = setsockopt(_fd, SOL_SOCKET, SO_KEEPALIVE, &onoff, sizeof(uint32_t));
            if (ret < 0)
            {
                StoreLastError();
                return kWaitStatusFailure;
            }
        }
        else
        {
            uint8_t *buffer = NULL;

            if (in_len > 0)
            {
                buffer = (uint8_t*)malloc(in_len);
                memcpy(buffer, in_data, in_len);
            }

            const int32_t ret = ioctl(_fd, command, buffer);
            if (ret == -1)
            {
                StoreLastError();

                free(buffer);

                return kWaitStatusFailure;
            }

            if (buffer == NULL)
            {
                *written = 0;
                return kWaitStatusSuccess;
            }

            // We just copy the buffer to the out_data. Some ioctls
            // don't even out_data any data, but, well ...
            //
            // NB: windows returns WSAEFAULT if out_len is too small

            const int32_t len = (in_len > out_len) ? out_len : in_len;

            if (len > 0 && out_data != NULL)
                memcpy(out_data, buffer, len);

            free(buffer);

            *written = len;
        }

        return kWaitStatusSuccess;
    }

#define     SKIP_OPTION         -2
#define     INVALID_OPTION_NAME -1

    static int32_t level_and_name_to_system(SocketOptionLevel level, SocketOptionName name, int32_t *system_level, int32_t *system_name)
    {
        switch (level)
        {
            case kSocketOptionLevelSocket:
                *system_level = SOL_SOCKET;

                switch (name)
                {
                    // This is SO_LINGER, because the setsockopt
                    // internal call maps DontLinger to SO_LINGER
                    // with l_onoff=0
                    case kSocketOptionNameDontLinger:
                        *system_name = SO_LINGER;
                        break;
        #ifdef SO_DEBUG
                    case kSocketOptionNameDebug:
                        *system_name = SO_DEBUG;
                        break;
        #endif
        #ifdef SO_ACCEPTCONN
                    case kSocketOptionNameAcceptConnection:
                        *system_name = SO_ACCEPTCONN;
                        break;
        #endif
                    case kSocketOptionNameReuseAddress:
                        *system_name = SO_REUSEADDR;
                        break;

                    case kSocketOptionNameKeepAlive:
                        *system_name = SO_KEEPALIVE;
                        break;
        #ifdef SO_DONTROUTE
                    case kSocketOptionNameDontRoute:
                        *system_name = SO_DONTROUTE;
                        break;
        #endif
                    case kSocketOptionNameBroadcast:
                        *system_name = SO_BROADCAST;
                        break;

                    case kSocketOptionNameLinger:
                        *system_name = SO_LINGER;
                        break;
        #ifdef SO_OOBINLINE
                    case kSocketOptionNameOutOfBandInline:
                        *system_name = SO_OOBINLINE;
                        break;
        #endif
                    case kSocketOptionNameSendBuffer:
                        *system_name = SO_SNDBUF;
                        break;

                    case kSocketOptionNameReceiveBuffer:
                        *system_name = SO_RCVBUF;
                        break;

                    case kSocketOptionNameSendLowWater:
                        *system_name = SO_SNDLOWAT;
                        break;

                    case kSocketOptionNameReceiveLowWater:
                        *system_name = SO_RCVLOWAT;
                        break;

                    case kSocketOptionNameSendTimeout:
                        *system_name = SO_SNDTIMEO;
                        break;

                    case kSocketOptionNameReceiveTimeout:
                        *system_name = SO_RCVTIMEO;
                        break;

                    case kSocketOptionNameError:
                        *system_name = SO_ERROR;
                        break;

                    case kSocketOptionNameType:
                        *system_name = SO_TYPE;
                        break;

                    case kSocketOptionNameExclusiveAddressUse:
        #ifdef SO_EXCLUSIVEADDRUSE
                        *system_name = SO_EXCLUSIVEADDRUSE;
                        break;
        #elif SO_REUSEADDR
                        *system_name = SO_REUSEADDR;
                        break;
        #endif
                    case kSocketOptionNameUseLoopback:
        #ifdef SO_USELOOPBACK
                        *system_name = SO_USELOOPBACK;
                        break;
        #endif
                    case kSocketOptionNameMaxConnections:
        #ifdef SO_MAXCONN
                        *system_name = SO_MAXCONN;
                        break;
        #elif defined(SOMAXCONN)
                        *system_name = SOMAXCONN;
                        break;
        #endif
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;

            case kSocketOptionLevelIP:
        #ifdef SOL_IP
                *system_level = SOL_IP;
        #else
                *system_level = IPPROTO_IP;
        #endif

                switch (name)
                {
        #ifdef IP_OPTIONS
                    case kSocketOptionNameIPOptions:
                        *system_name = IP_OPTIONS;
                        break;
        #endif
                    case kSocketOptionNameHeaderIncluded:
                        *system_name = IP_HDRINCL;
                        break;

                    case kSocketOptionNameTypeOfService:
                        *system_name = IP_TOS;
                        break;

                    case kSocketOptionNameIpTimeToLive:
                        *system_name = IP_TTL;
                        break;

                    case kSocketOptionNameMulticastInterface:
                        *system_name = IP_MULTICAST_IF;
                        break;

                    case kSocketOptionNameMulticastTimeToLive:
                        *system_name = IP_MULTICAST_TTL;
                        break;

                    case kSocketOptionNameMulticastLoopback:
                        *system_name = IP_MULTICAST_LOOP;
                        break;

                    case kSocketOptionNameAddMembership:
                        *system_name = IP_ADD_MEMBERSHIP;
                        break;

                    case kSocketOptionNameDropMembership:
                        *system_name = IP_DROP_MEMBERSHIP;
                        break;

        #ifdef HAVE_IP_PKTINFO
                    case kSocketOptionNamePacketInformation:
                        *system_name = IP_PKTINFO;
                        break;
        #endif

                    case kSocketOptionNameDontFragment:
        #ifdef IP_DONTFRAGMENT
                        *system_name = IP_DONTFRAGMENT;
        #elif IP_MTU_DISCOVER
                        *system_name = IP_MTU_DISCOVER;
        #elif IP_DONTFRAG
                        *system_name = IP_DONTFRAG;
        #else
                        return SKIP_OPTION;
        #endif
                        break;

                    case kSocketOptionNameAddSourceMembership:
                    case kSocketOptionNameDropSourceMembership:
                    case kSocketOptionNameBlockSource:
                    case kSocketOptionNameUnblockSource:
                    // Can't figure out how to map these, so fall
                    // through
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;
#if IL2CPP_SUPPORT_IPV6
            case kSocketOptionLevelIPv6:
        #ifdef SOL_IPV6
                *system_level = SOL_IPV6;
        #else
                *system_level = IPPROTO_IPV6;
        #endif

                switch (name)
                {
                    case kSocketOptionNameMulticastInterface:
                        *system_name = IPV6_MULTICAST_IF;
                        break;
                    case kSocketOptionNameMulticastTimeToLive:
                        *system_name = IPV6_MULTICAST_HOPS;
                        break;
                    case kSocketOptionNameMulticastLoopback:
                        *system_name = IPV6_MULTICAST_LOOP;
                        break;
                    case kSocketOptionNameAddMembership:
                        *system_name = IPV6_JOIN_GROUP;
                        break;
                    case kSocketOptionNameDropMembership:
                        *system_name = IPV6_LEAVE_GROUP;
                        break;
                    case kSocketOptionNamePacketInformation:
#ifdef HAVE_IPV6_PKTINFO
                        *system_name = IPV6_PKTINFO;
                        break;
#endif
                    case kSocketOptionNameIPv6Only:
#ifdef IPV6_V6ONLY
                        *system_name = IPV6_V6ONLY;
                        break;
#endif
                    case kSocketOptionNameHeaderIncluded:
                    case kSocketOptionNameIPOptions:
                    case kSocketOptionNameTypeOfService:
                    case kSocketOptionNameDontFragment:
                    case kSocketOptionNameAddSourceMembership:
                    case kSocketOptionNameDropSourceMembership:
                    case kSocketOptionNameBlockSource:
                    case kSocketOptionNameUnblockSource:
                    // Can't figure out how to map these, so fall
                    // through
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;
#endif // IL2CPP_SUPPORT_IPV6
            case kSocketOptionLevelTcp:
        #ifdef SOL_TCP
                *system_level = SOL_TCP;
        #else
                *system_level = IPPROTO_TCP;
        #endif

                switch (name)
                {
                    case kSocketOptionNameNoDelay:
                        *system_name = TCP_NODELAY;
                        break;
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;

            case kSocketOptionLevelUdp:
            default:
                return INVALID_OPTION_NAME;
        }

        return 0;
    }

    WaitStatus SocketImpl::GetSocketOption(SocketOptionLevel level, SocketOptionName name, uint8_t *buffer, int32_t *length)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            *((int32_t*)buffer) = 0;
            *length = sizeof(int32_t);

            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct timeval tv;
        uint8_t *tmp_val = buffer;

        if (system_level == SOL_SOCKET && (system_name == SO_RCVTIMEO || system_name == SO_SNDTIMEO))
        {
            tmp_val = (uint8_t*)&tv;
            *length = sizeof(tv);
        }

        const int32_t ret = getsockopt(_fd, system_level, system_name, tmp_val, (socklen_t*)length);
        if (ret == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        if (system_level == SOL_SOCKET && (system_name == SO_RCVTIMEO || system_name == SO_SNDTIMEO))
        {
            // milliseconds from microseconds
            *((int32_t*)buffer)  = (int32_t)(tv.tv_sec * 1000 + (tv.tv_usec / 1000));
            *length = sizeof(int32_t);

            return kWaitStatusSuccess;
        }

        if (system_name == SO_ERROR)
        {
            if (*((int32_t*)buffer) != 0)
            {
                StoreLastError(*((int32_t*)buffer));
            }
            else
            {
                *((int32_t*)buffer) = _saved_error;
            }
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::GetSocketOptionFull(SocketOptionLevel level, SocketOptionName name, int32_t *first, int32_t *second)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

#if !defined(SO_EXCLUSIVEADDRUSE) && defined(SO_REUSEADDR)
        if (level == kSocketOptionLevelSocket && name == kSocketOptionNameExclusiveAddressUse)
        {
            system_level = SOL_SOCKET;
            system_name = SO_REUSEADDR;
        }
        else
#endif
        {
            const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

            if (o_res == SKIP_OPTION)
            {
                *first = 0;
                *second = 0;

                return kWaitStatusSuccess;
            }

            if (o_res == INVALID_OPTION_NAME)
            {
                _saved_error = kWSAenoprotoopt;

                return kWaitStatusFailure;
            }
        }

        int32_t ret = -1;

        switch (name)
        {
            case kSocketOptionNameLinger:
            {
                struct linger linger;
                socklen_t lingersize = sizeof(linger);

                ret = getsockopt(_fd, system_level, system_name, &linger, &lingersize);

                *first = linger.l_onoff;
                *second = linger.l_linger;
            }
            break;

            case kSocketOptionNameDontLinger:
            {
                struct linger linger;
                socklen_t lingersize = sizeof(linger);

                ret = getsockopt(_fd, system_level, system_name, &linger, &lingersize);

                *first = !linger.l_onoff;
            }
            break;

            case kSocketOptionNameSendTimeout:
            case kSocketOptionNameReceiveTimeout:
            {
                struct timeval time;
                socklen_t time_size = sizeof(time);
                ret = getsockopt(_fd, system_level, system_name, &time, &time_size);

                // Use a 64-bit integer to avoid overflow
                uint64_t timeInMilliseconds = (time.tv_sec * (uint64_t)1000) + (time.tv_usec / 1000);

                // Truncate back to a 32-bit integer to return the value back to the caller.
                *first = (int32_t)timeInMilliseconds;
            }
            break;

            default:
            {
                socklen_t valsize = sizeof(*first);
                ret = getsockopt(_fd, system_level, system_name, first, &valsize);
            }
            break;
        }

        if (ret == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

#if !defined(SO_EXCLUSIVEADDRUSE) && defined(SO_REUSEADDR)
        if (level == kSocketOptionLevelSocket && name == kSocketOptionNameExclusiveAddressUse)
            *first = *first ? 0 : 1;
#endif

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Poll(std::vector<PollRequest> &requests, int32_t count, int32_t timeout, int32_t *result, int32_t *error)
    {
        const int32_t n_fd = count;
        pollfd *p_fd = (pollfd*)calloc(n_fd, sizeof(pollfd));

        for (int32_t i = 0; i < n_fd; ++i)
        {
            if (requests[i].fd == -1)
            {
                p_fd[i].fd = -1;
                p_fd[i].events = kPollFlagsNone;
                p_fd[i].revents = kPollFlagsNone;
            }
            else
            {
                p_fd[i].fd = requests[i].fd;
                p_fd[i].events = posix::PollFlagsToPollEvents(requests[i].events);
                p_fd[i].revents = kPollFlagsNone;
            }
        }

        int32_t ret = os::posix::Poll(p_fd, n_fd, timeout);
        *result = ret;

        if (ret == -1)
        {
            free(p_fd);

            *error = SocketErrnoToErrorCode(errno);

            return kWaitStatusFailure;
        }

        if (ret == 0)
        {
            free(p_fd);

            return kWaitStatusSuccess;
        }

        for (int32_t i = 0; i < n_fd; ++i)
        {
            requests[i].revents = posix::PollEventsToPollFlags(p_fd[i].revents);
        }

        free(p_fd);

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Poll(std::vector<PollRequest> &requests, int32_t timeout, int32_t *result, int32_t *error)
    {
        return Poll(requests, (int32_t)requests.size(), timeout, result, error);
    }

    WaitStatus SocketImpl::Poll(PollRequest& request, int32_t timeout, int32_t *result, int32_t *error)
    {
        std::vector<PollRequest> requests;
        requests.push_back(request);
        return Poll(requests, 1, timeout, result, error);
    }

    WaitStatus SocketImpl::SetSocketOption(SocketOptionLevel level, SocketOptionName name, int32_t value)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct linger linger;

        WaitStatus ret = kWaitStatusFailure;

        switch (name)
        {
            case kSocketOptionNameDontLinger:
                linger.l_onoff = !value;
                linger.l_linger = 0;
                ret = SetSocketOptionInternal(system_level, system_name, &linger, sizeof(linger));
                break;

            case kSocketOptionNameDontFragment:
#ifdef IP_PMTUDISC_DO
                // Fiddle with the value slightly if we're turning DF on
                if (value == 1)
                    value = IP_PMTUDISC_DO;
#endif
                ret = SetSocketOptionInternal(system_level, system_name, (char*)&value, sizeof(value));
                break;

            default:
                ret = SetSocketOptionInternal(system_level, system_name, (char*)&value, sizeof(value));
                break;
        }

        return ret;
    }

    WaitStatus SocketImpl::SetSocketOptionLinger(SocketOptionLevel level, SocketOptionName name, bool enabled, int32_t seconds)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct linger linger;

        linger.l_onoff = enabled;
        linger.l_linger = seconds;

        return SetSocketOptionInternal(system_level, system_name, &linger, sizeof(linger));
    }

    WaitStatus SocketImpl::SetSocketOptionArray(SocketOptionLevel level, SocketOptionName name, const uint8_t *buffer, int32_t length)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct linger linger;

        WaitStatus ret = kWaitStatusFailure;

        switch (name)
        {
            case kSocketOptionNameDontLinger:
                if (length == 1)
                {
                    linger.l_linger = 0;
                    linger.l_onoff = (*((char*)buffer)) ? 0 : 1;

                    ret = SetSocketOptionInternal(system_level, system_name, &linger, sizeof(linger));
                }
                else
                {
                    _saved_error = kWSAeinval;

                    return kWaitStatusFailure;
                }
                break;

            default:
                ret = SetSocketOptionInternal(system_level, system_name, buffer, length);
                break;
        }

        return ret;
    }

    WaitStatus SocketImpl::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, uint32_t group_address, uint32_t local_address)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct ip_mreqn mreq = {{0}};

        mreq.imr_multiaddr.s_addr = group_address;
        mreq.imr_address.s_addr = local_address;

        return SetSocketOptionInternal(system_level, system_name, &mreq, sizeof(mreq));
    }

#if IL2CPP_TARGET_DARWIN || IL2CPP_TARGET_LINUX
    #include <sys/types.h>
    #include <ifaddrs.h>
    #include <sys/socket.h>
    #include <net/if.h>
    static int get_local_interface_id(int family)
    {
        struct ifaddrs *ifap = NULL, *ptr;
        int idx = 0;
        if (getifaddrs(&ifap))
            return 0;

        for (ptr = ifap; ptr; ptr = ptr->ifa_next)
        {
            if (!ptr->ifa_addr || !ptr->ifa_name)
                continue;
            if (ptr->ifa_addr->sa_family != family)
                continue;
            if ((ptr->ifa_flags & IFF_LOOPBACK) != 0)
                continue;
            if ((ptr->ifa_flags & IFF_MULTICAST) == 0)
                continue;

            idx = if_nametoindex(ptr->ifa_name);
            break;
        }

        freeifaddrs(ifap);
        return idx;
    }

#endif // IL2CPP_TARGET_DARWIN

#if IL2CPP_SUPPORT_IPV6
    WaitStatus SocketImpl::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, IPv6Address ipv6, uint64_t interfaceOffset)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);
        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct ipv6_mreq mreq6 = {{0}};
        struct in6_addr in6addr;
        for (int i = 0; i < 16; ++i)
            in6addr.s6_addr[i] = ipv6.addr[i];
        mreq6.ipv6mr_multiaddr = in6addr;

#if IL2CPP_TARGET_DARWIN || IL2CPP_TARGET_LINUX
        if (interfaceOffset == 0)
            interfaceOffset = get_local_interface_id(AF_INET6);
#endif
        mreq6.ipv6mr_interface = interfaceOffset;

        return SetSocketOptionInternal(system_level, system_name, &mreq6, sizeof(mreq6));
    }

#endif

    WaitStatus SocketImpl::SetSocketOptionInternal(int32_t level, int32_t name, const void *value, int32_t len)
    {
        const void *real_val = value;
        struct timeval tv;

        if (level == SOL_SOCKET && (name == SO_RCVTIMEO || name == SO_SNDTIMEO))
        {
            const int32_t ms = *((int32_t*)value);

            tv.tv_sec = ms / 1000;
            tv.tv_usec = (ms % 1000) * 1000;
            real_val = &tv;

            len = sizeof(tv);
        }

        const int32_t ret = setsockopt(_fd, level, name, real_val, (socklen_t)len);

        if (ret == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

#if defined(SO_REUSEPORT)
        // BSD's and MacOS X multicast sockets also need SO_REUSEPORT when SO_REUSEADDR is requested.
        if (level == SOL_SOCKET && name == SO_REUSEADDR)
        {
            int32_t type;
            socklen_t type_len = sizeof(type);

            if (!getsockopt(_fd, level, SO_TYPE, &type, &type_len))
            {
                if (type == SOCK_DGRAM)
                    setsockopt(_fd, level, SO_REUSEPORT, real_val, len);
            }
        }
#endif

        return kWaitStatusSuccess;
    }

#if IL2CPP_SUPPORT_IPV6_SUPPORT_QUERY
    bool SocketImpl::IsIPv6Supported()
    {
        ifaddrs* interfaces;
        if (getifaddrs(&interfaces))
            return false;

        bool ipv6IsSupported = false;
        for (ifaddrs* iface = interfaces; iface != NULL; iface = iface->ifa_next)
        {
            if (iface->ifa_addr && iface->ifa_addr->sa_family == AF_INET6)
            {
                ipv6IsSupported = true;
                break;
            }
        }

        freeifaddrs(interfaces);
        return ipv6IsSupported;
    }

#endif

    WaitStatus SocketImpl::SendFile(const char *filename, TransmitFileBuffers *buffers, TransmitFileOptions options)
    {
#if IL2CPP_SUPPORT_SEND_FILE
        int32_t file = open(filename, O_RDONLY);

        if (file == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        int32_t ret;

        // Write the header
        if (buffers != NULL && buffers->head != NULL && buffers->head_length > 0)
        {
            do
            {
                ret = (int32_t)send(_fd, (void*)buffers->head, buffers->head_length, 0);
            }
            while (ret == -1 && errno == EINTR);

            if (ret == -1)
            {
                StoreLastError();

                SOCK_CLOSE(file);

                return kWaitStatusFailure;
            }
        }

        struct stat statbuf;

        ret = fstat(file, &statbuf);
        if (ret == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        do
        {
#if IL2CPP_TARGET_DARWIN
            ret = sendfile(file, _fd, 0, &statbuf.st_size, NULL, 0);
#else
            ret = sendfile(_fd, file, NULL, statbuf.st_size);
#endif
        }
        while (ret != -1 && (errno == EINTR || errno == EAGAIN));

        if (ret == -1)
        {
            StoreLastError();

            SOCK_CLOSE(file);

            return kWaitStatusFailure;
        }

        // Write the tail
        if (buffers != NULL && buffers->tail != NULL && buffers->tail_length > 0)
        {
            do
            {
                ret = (int32_t)send(_fd, (void*)buffers->tail, buffers->tail_length, 0);
            }
            while (ret == -1 && errno == EINTR);

            if (ret == -1)
            {
                StoreLastError();

                SOCK_CLOSE(file);

                return kWaitStatusFailure;
            }
        }

        if (SOCK_CLOSE(file) == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
#else
        return kWaitStatusFailure;
#endif
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\SocketImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\StackTrace.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_TARGET_JAVASCRIPT && !IL2CPP_TARGET_ANDROID && !IL2CPP_TARGET_QNX && !IL2CPP_USE_PLATFORM_SPECIFIC_STACKTRACE

#include "os/StackTrace.h"
#include <execinfo.h>
#include <cxxabi.h>
#include <cstdlib>

namespace il2cpp
{
namespace os
{
    const int kMaxStackFrames = 128;

    void StackTrace::WalkStackNative(WalkStackCallback callback, void* context, WalkOrder walkOrder)
    {
        void* callstack[kMaxStackFrames];
        int frames = backtrace(callstack, kMaxStackFrames);

        if (walkOrder == kFirstCalledToLastCalled)
        {
            for (int i = frames - 1; i >= 0; i--)
            {
                if (!callback(reinterpret_cast<Il2CppMethodPointer>(callstack[i]), context))
                    break;
            }
        }
        else
        {
            for (int i = 0; i < frames; i++)
            {
                if (!callback(reinterpret_cast<Il2CppMethodPointer>(callstack[i]), context))
                    break;
            }
        }
    }

    std::string StackTrace::NativeStackTrace()
    {
        void* callstack[kMaxStackFrames];
        int frames = backtrace(callstack, kMaxStackFrames);
        char **symbols = backtrace_symbols(callstack, frames);

        std::string stackTrace;
        if (symbols != NULL)
        {
            for (int i = 0; i < frames; ++i)
            {
                stackTrace += symbols[i];
                stackTrace += "\n";
            }

            free(symbols);
        }

        return stackTrace;
    }

    const void* StackTrace::GetStackPointer()
    {
        // TODO implement to avoid extra WalkStack calls
        return nullptr;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\StackTrace.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\SystemCertificates.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#if IL2CPP_TARGET_LINUX || IL2CPP_TARGET_QNX

#include "os/SystemCertificates.h"

namespace il2cpp
{
namespace os
{
    void* SystemCertificates::OpenSystemRootStore()
    {
        return 0;
    }

    int SystemCertificates::EnumSystemCertificates(void* certStore, void** iter, int *format, int* size, void** data)
    {
        // Default location for linux CA
        const char* path = "/etc/ssl/certs/ca-certificates.crt";

        if (*iter == 0)
        {
            *data = (void*)(path);
            *size = sizeof((char*)path);
            *format = DATATYPE_FILE;
            *iter = (void*)1;
            return 1;
        }

        return 0;
    }

    void SystemCertificates::CloseSystemRootStore(void* cStore)
    {
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\SystemCertificates.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Thread.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_THREADS_PTHREAD && !IL2CPP_TARGET_DARWIN

#include <pthread.h>

#include "os/Thread.h"

namespace il2cpp
{
namespace os
{
    bool Thread::GetCurrentThreadStackBounds(void** low, void** high)
    {
#if IL2CPP_TARGET_LINUX

        pthread_attr_t attr;
        size_t stacksize = 0;
        pthread_t self = pthread_self();
        int ret = pthread_getattr_np(self, &attr);
        if (ret != 0)
            return false;

        ret = pthread_attr_getstack(&attr, low, &stacksize);
        if (ret != 0)
            return false;

        *high = (void*)((uintptr_t)low + stacksize);
        return true;
#else
        return false;
#endif
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\ThreadImpl.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_THREADS_STD && IL2CPP_THREADS_PTHREAD

#include <limits>
#include <unistd.h>
#include <map>
#include <pthread.h>
#include <errno.h>
#include <string.h>

#if IL2CPP_TARGET_LINUX
#include <sys/prctl.h>
#include <sys/resource.h>
#endif

#include "ThreadImpl.h"
#include "PosixHelpers.h"

namespace il2cpp
{
namespace os
{
#define ASSERT_CALLED_ON_CURRENT_THREAD \
    IL2CPP_ASSERT(pthread_equal (pthread_self (), m_Handle) && "Must be called on current thread!");

    static Event* s_ThreadSleepObject = nullptr;

    void ThreadImpl::AllocateStaticData()
    {
        s_ThreadSleepObject = new Event();
    }

    void ThreadImpl::FreeStaticData()
    {
        delete s_ThreadSleepObject;
        s_ThreadSleepObject = nullptr;
    }

    ThreadImpl::ThreadImpl()
        : m_Handle(0)
        , m_StartFunc(NULL)
        , m_StartArg(NULL)
        , m_CurrentWaitObject(NULL)
        , m_StackSize(IL2CPP_DEFAULT_STACK_SIZE)
        , m_ConditionSemaphore(1)
    {
    }

    ThreadImpl::~ThreadImpl()
    {
    }

    ErrorCode ThreadImpl::Run(Thread::StartFunc func, void* arg, int64_t affinityMask)
    {
        // Store state for run wrapper.
        m_StartFunc = func;
        m_StartArg = arg;

        // Initialize thread attributes.
        pthread_attr_t attr;
        int s = pthread_attr_init(&attr);
        if (s)
            return kErrorCodeGenFailure;

#if defined(IL2CPP_ENABLE_PLATFORM_THREAD_AFFINTY)
#if IL2CPP_THREAD_HAS_CPU_SET
        if (affinityMask != Thread::kThreadAffinityAll)
        {
            cpu_set_t cpuset;
            CPU_ZERO(&cpuset);
            for (int i = 0; i < 64; ++i)
            {
                if (affinityMask & (1 << i))
                    CPU_SET(i, &cpuset);
            }

            pthread_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);
        }
        else
        {
            // set create default core affinity
            pthread_attr_setaffinity_np(&attr, 0, NULL);
        }
#else
        pthread_attr_setaffinity_np(&attr, 0, NULL);
#endif // IL2CPP_THREAD_HAS_CPU_SET
#endif // defined(IL2CPP_ENABLE_PLATFORM_THREAD_AFFINTY)


#if defined(IL2CPP_ENABLE_PLATFORM_THREAD_STACKSIZE)
        pthread_attr_setstacksize(&attr, m_StackSize);
#endif


        // Create thread.
        pthread_t threadId;
        s = pthread_create(&threadId, &attr, &ThreadStartWrapper, this);
        if (s)
            return kErrorCodeGenFailure;

        // Destroy thread attributes.
        s = pthread_attr_destroy(&attr);
        if (s)
            return kErrorCodeGenFailure;

        // We're up and running.
        m_Handle = threadId;

        return kErrorCodeSuccess;
    }

    void* ThreadImpl::ThreadStartWrapper(void* arg)
    {
        ThreadImpl* thread = reinterpret_cast<ThreadImpl*>(arg);

        // Also set handle here. No matter which thread proceeds first,
        // we need to make sure the handle is set.
        thread->m_Handle = pthread_self();

        // Detach this thread since we will manage calling Join at the VM level
        // if necessary. Detaching it also prevents use from running out of thread
        // handles for background threads that are never joined.
        int returnValue = pthread_detach(thread->m_Handle);
        IL2CPP_ASSERT(returnValue == 0);
        (void)returnValue;

        // Run user code.
        thread->m_StartFunc(thread->m_StartArg);

        return 0;
    }

    uint64_t ThreadImpl::Id()
    {
        return posix::PosixThreadIdToThreadId(m_Handle);
    }

    void ThreadImpl::SetName(const char* name)
    {
        // Can only be set on current thread on OSX and Linux.
        if (pthread_self() != m_Handle)
            return;

#if IL2CPP_TARGET_DARWIN
        pthread_setname_np(name);
#elif IL2CPP_TARGET_LINUX || IL2CPP_TARGET_ANDROID || IL2CPP_ENABLE_PLATFORM_THREAD_RENAME
        if (pthread_setname_np(m_Handle, name) == ERANGE)
        {
            char buf[16]; // TASK_COMM_LEN=16
            strncpy(buf, name, sizeof(buf));
            buf[sizeof(buf) - 1] = '\0';
            pthread_setname_np(m_Handle, buf);
        }
#endif
    }

    void ThreadImpl::SetStackSize(size_t newsize)
    {
        // if newsize is zero we use the per-platform default value for size of stack
        if (newsize == 0)
        {
            newsize = IL2CPP_DEFAULT_STACK_SIZE;
        }

        m_StackSize = newsize;
    }

    int ThreadImpl::GetMaxStackSize()
    {
#if IL2CPP_TARGET_DARWIN || IL2CPP_TARGET_LINUX
        struct rlimit lim;

        /* If getrlimit fails, we don't enforce any limits. */
        if (getrlimit(RLIMIT_STACK, &lim))
            return INT_MAX;
        /* rlim_t is an unsigned long long on 64bits OSX but we want an int response. */
        if (lim.rlim_max > (rlim_t)INT_MAX)
            return INT_MAX;
        return (int)lim.rlim_max;
#else
        return INT_MAX;
#endif
    }

    void ThreadImpl::SetPriority(ThreadPriority priority)
    {
        ////TODO
    }

    ThreadPriority ThreadImpl::GetPriority()
    {
        /// TODO
        return kThreadPriorityNormal;
    }

    void ThreadImpl::QueueUserAPC(Thread::APCFunc function, void* context)
    {
        IL2CPP_ASSERT(function != NULL);

        // Put on queue.
        {
            m_PendingAPCsMutex.Acquire();
            m_PendingAPCs.push_back(APCRequest(function, context));
            m_PendingAPCsMutex.Release();
        }

        // Interrupt an ongoing wait, only interrupt if we have an object waiting
        if (m_CurrentWaitObject.load())
        {
            m_ConditionSemaphore.Release(1);
        }
    }

    void ThreadImpl::CheckForUserAPCAndHandle()
    {
        ASSERT_CALLED_ON_CURRENT_THREAD;
        m_PendingAPCsMutex.Acquire();

        while (!m_PendingAPCs.empty())
        {
            APCRequest apcRequest = m_PendingAPCs.front();

            // Remove from list. Do before calling the function to make sure the list
            // is up to date in case the function throws.
            m_PendingAPCs.erase(m_PendingAPCs.begin());

            // Release mutex while we call the function so that we don't deadlock
            // if the function starts waiting on a thread that tries queuing an APC
            // on us.
            m_PendingAPCsMutex.Release();

            // Call function.
            apcRequest.callback(apcRequest.context);

            // Re-acquire mutex.
            m_PendingAPCsMutex.Acquire();
        }

        m_PendingAPCsMutex.Release();
    }

    void ThreadImpl::SetWaitObject(WaitObject* waitObject)
    {
        // Cannot set wait objects on threads other than the current thread.
        ASSERT_CALLED_ON_CURRENT_THREAD;

        // This is an unprotected write as write acccess is restricted to the
        // current thread.
        m_CurrentWaitObject = waitObject;
    }

    void ThreadImpl::Sleep(uint32_t milliseconds, bool interruptible)
    {
        /// An Event that we never signal. This is used for sleeping threads in an alertable state. They
        /// simply wait on this object with the sleep timer as the timeout. This way we don't need a separate
        /// codepath for implementing sleep logic.

        s_ThreadSleepObject->Wait(milliseconds, interruptible);
    }

    uint64_t ThreadImpl::CurrentThreadId()
    {
        return posix::PosixThreadIdToThreadId(pthread_self());
    }

    ThreadImpl* ThreadImpl::GetCurrentThread()
    {
        return Thread::GetCurrentThread()->m_Thread;
    }

    ThreadImpl* ThreadImpl::CreateForCurrentThread()
    {
        ThreadImpl* thread = new ThreadImpl();
        thread->m_Handle = pthread_self();
        return thread;
    }

    bool ThreadImpl::YieldInternal()
    {
        return sched_yield() == 0;
    }

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP

    static pthread_key_t s_CleanupKey;
    static Thread::ThreadCleanupFunc s_CleanupFunc;

    static void CleanupThreadIfCanceled(void* arg)
    {
        Thread::ThreadCleanupFunc cleanupFunc = s_CleanupFunc;
        if (cleanupFunc)
            cleanupFunc(arg);
    }

    void ThreadImpl::SetNativeThreadCleanup(Thread::ThreadCleanupFunc cleanupFunction)
    {
        if (cleanupFunction)
        {
            IL2CPP_ASSERT(!s_CleanupFunc);
            s_CleanupFunc = cleanupFunction;
            int result = pthread_key_create(&s_CleanupKey, &CleanupThreadIfCanceled);
            IL2CPP_ASSERT(!result);
            NO_UNUSED_WARNING(result);
        }
        else
        {
            IL2CPP_ASSERT(s_CleanupFunc);
            int result = pthread_key_delete(s_CleanupKey);
            IL2CPP_ASSERT(!result);
            NO_UNUSED_WARNING(result);
            s_CleanupFunc = NULL;
        }
    }

    void ThreadImpl::RegisterCurrentThreadForCleanup(void* arg)
    {
        IL2CPP_ASSERT(s_CleanupFunc);
        pthread_setspecific(s_CleanupKey, arg);
    }

    void ThreadImpl::UnregisterCurrentThreadForCleanup()
    {
        IL2CPP_ASSERT(s_CleanupFunc);
        void* data = pthread_getspecific(s_CleanupKey);
        if (data != NULL)
            pthread_setspecific(s_CleanupKey, NULL);
    }

#endif
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\ThreadImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Time.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX && !IL2CPP_USE_PLATFORM_SPECIFIC_TIME

#include "os/Time.h"
#include <stdlib.h>
#include <stdio.h>

#include <sys/param.h>
#if IL2CPP_TARGET_DARWIN
#include <sys/sysctl.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#endif

#include <time.h>

#if IL2CPP_TARGET_LINUX || IL2CPP_TARGET_QNX
#include <sys/time.h>
#endif

/* a made up uptime of 300 seconds */
#define MADEUP_BOOT_TIME (300 * MTICKS_PER_SEC)

namespace il2cpp
{
namespace os
{
    const int64_t MTICKS_PER_SEC = 10000000;

    static int64_t
    GetBootTime()
    {
#if IL2CPP_TARGET_DARWIN
        int mib[2];
        size_t size;
        time_t now;
        struct timeval boottime;

        (void)time(&now);

        mib[0] = CTL_KERN;
        mib[1] = KERN_BOOTTIME;

        size = sizeof(boottime);

        if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1)
            return (int64_t)((now - boottime.tv_sec) * MTICKS_PER_SEC);
#else
        FILE *uptime = fopen("/proc/uptime", "r");

        if (uptime)
        {
            double upt;

            if (fscanf(uptime, "%lf", &upt) == 1)
            {
                const int64_t now = Time::GetTicks100NanosecondsMonotonic();
                fclose(uptime);
                return now - (int64_t)(upt * MTICKS_PER_SEC);
            }

            fclose(uptime);
        }

#endif
        /* a made up uptime of 300 seconds */
        return (int64_t)MADEUP_BOOT_TIME;
    }

    uint32_t Time::GetTicksMillisecondsMonotonic()
    {
#if IL2CPP_TARGET_ANDROID
        struct timespec ts;
        if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0)
        {
            return (int64_t)MADEUP_BOOT_TIME;
        }
        return (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
#else
        static int64_t boot_time = 0;
        int64_t now;
        if (!boot_time)
            boot_time = GetBootTime();
        now = GetTicks100NanosecondsMonotonic();
        return (uint32_t)((now - boot_time) / 10000);
#endif
    }

    int64_t Time::GetTicks100NanosecondsMonotonic()
    {
        struct timeval tv;
#if IL2CPP_TARGET_DARWIN
        /* http://developer.apple.com/library/mac/#qa/qa1398/_index.html */
        static mach_timebase_info_data_t timebase;
        uint64_t now = mach_absolute_time();
        if (timebase.denom == 0)
        {
            mach_timebase_info(&timebase);
            timebase.denom *= 100; /* we return 100ns ticks */
        }
        return now * timebase.numer / timebase.denom;
#elif defined(CLOCK_MONOTONIC)
        struct timespec tspec;
        static struct timespec tspec_freq = {0};
        static int can_use_clock = 0;
        if (!tspec_freq.tv_nsec)
        {
            can_use_clock = clock_getres(CLOCK_MONOTONIC, &tspec_freq) == 0;
        }
        if (can_use_clock)
        {
            if (clock_gettime(CLOCK_MONOTONIC, &tspec) == 0)
            {
                return ((int64_t)tspec.tv_sec * MTICKS_PER_SEC + tspec.tv_nsec / 100);
            }
        }

#endif
        if (gettimeofday(&tv, NULL) == 0)
            return ((int64_t)tv.tv_sec * 1000000 + tv.tv_usec) * 10;
        return 0;
    }

/*
 * Magic number to convert a time which is relative to
 * Jan 1, 1970 into a value which is relative to Jan 1, 0001.
 */
    const uint64_t EPOCH_ADJUST = ((uint64_t)62135596800LL);

    int64_t Time::GetTicks100NanosecondsDateTime()
    {
        struct timeval tv;
        if (gettimeofday(&tv, NULL) == 0)
            return (((int64_t)tv.tv_sec + EPOCH_ADJUST) * 1000000 + tv.tv_usec) * 10;
        return 0;
    }

    static const int64_t kSecondsBetween1601And1970 = 11644473600LL;
    static const int64_t kSecondsTo100NanoSeconds = 10000000;

    int64_t Time::GetSystemTimeAsFileTime()
    {
        timeval currentTime;
        int getTimeOfDayResult = gettimeofday(&currentTime, NULL);
        IL2CPP_ASSERT(getTimeOfDayResult == 0 && "gettimeofday() failed");

        return kSecondsTo100NanoSeconds * (static_cast<int64_t>(currentTime.tv_sec) + kSecondsBetween1601And1970) + 10 * currentTime.tv_usec;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\Time.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\TimeZone.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_POSIX

#include "os/TimeZone.h"

#include <sys/time.h>
#include <time.h>

namespace il2cpp
{
namespace os
{
/*
 * Magic number to convert a time which is relative to
 * Jan 1, 1970 into a value which is relative to Jan 1, 0001.
 */
    const uint64_t TZ_EPOCH_ADJUST = ((uint64_t)62135596800LL);

    /*
    * Return's the offset from GMT of a local time.
    *
    *  tm is a local time
    *  t  is the same local time as seconds.
    */
    static int
    GMTOffset(struct tm *tm, time_t t)
    {
#if defined(HAVE_TM_GMTOFF)
        return tm->tm_gmtoff;
#else
        struct tm g;
        time_t t2;
        g = *gmtime(&t);
        g.tm_isdst = tm->tm_isdst;
        t2 = mktime(&g);
        return (int)difftime(t, t2);
#endif
    }

    bool TimeZone::GetTimeZoneData(int32_t year, int64_t data[4], std::string names[2], bool* daylight_inverted)
    {
        struct tm start, tt;
        time_t t;

        long int gmtoff, gmtoff_start;
        int is_transitioned = 0, day;
        char tzone[64];

        /*
         * no info is better than crashing: we'll need our own tz data
         * to make this work properly, anyway. The range is probably
         * reduced to 1970 .. 2037 because that is what mktime is
         * guaranteed to support (we get into an infinite loop
         * otherwise).
         */

        memset(&start, 0, sizeof(start));

        start.tm_mday = 1;
        start.tm_year = year - 1900;

        t = mktime(&start);

        if ((year < 1970) || (year > 2037) || (t == -1))
        {
            t = time(NULL);
            tt = *localtime(&t);
            strftime(tzone, sizeof(tzone), "%Z", &tt);
            names[0] = tzone;
            names[1] = tzone;
            *daylight_inverted = false;
            return true;
        }

        *daylight_inverted = start.tm_isdst;

#ifdef IL2CPP_TARGET_QNX
        // If we got here then probably there is no tz database in the system.
        // The default time zone is GMT which has no daylight saving time (same for UTC).

        tt = *localtime(&t);
        strftime(tzone, sizeof(tzone), "%Z", &tt);

        if (tzone[0] == 0 || memcmp(tzone, "GMT", 3) == 0 || memcmp(tzone, "UTC", 3) == 0)
        {
            names[0] = tzone;
            names[1] = tzone;
            return true;
        }
#endif // IL2CPP_TARGET_QNX

        gmtoff = GMTOffset(&start, t);
        gmtoff_start = gmtoff;

        /* For each day of the year, calculate the tm_gmtoff. */
        for (day = 0; day < 365; day++)
        {
            t += 3600 * 24;
            tt = *localtime(&t);

            /* Daylight saving starts or ends here. */
            if (GMTOffset(&tt, t) != gmtoff)
            {
                struct tm tt1;
                time_t t1;

                /* Try to find the exact hour when daylight saving starts/ends. */
                t1 = t;
                do
                {
                    t1 -= 3600;
                    tt1 = *localtime(&t1);
                }
                while (GMTOffset(&tt1, t1) != gmtoff);

                /* Try to find the exact minute when daylight saving starts/ends. */
                do
                {
                    t1 += 60;
                    tt1 = *localtime(&t1);
                }
                while (GMTOffset(&tt1, t1) == gmtoff);
                t1 += gmtoff;
                strftime(tzone, sizeof(tzone), "%Z", &tt);

                /* Write data, if we're already in daylight saving, we're done. */
                if (is_transitioned)
                {
                    if (!start.tm_isdst)
                        names[0] = tzone;
                    else
                        names[1] = tzone;

                    data[1] = ((int64_t)t1 + TZ_EPOCH_ADJUST) * 10000000L;
                    return true;
                }
                else
                {
                    if (!start.tm_isdst)
                        names[1] = tzone;
                    else
                        names[0] = tzone;

                    data[0] = ((int64_t)t1 + TZ_EPOCH_ADJUST) * 10000000L;
                    is_transitioned = 1;
                }

                /* This is only set once when we enter daylight saving. */
                if (!*daylight_inverted)
                {
                    data[2] = (int64_t)gmtoff * 10000000L;
                    data[3] = (int64_t)(GMTOffset(&tt, t) - gmtoff) * 10000000L;
                }
                else
                {
                    data[2] = (int64_t)(gmtoff_start + (GMTOffset(&tt, t) - gmtoff)) * 10000000L;
                    data[3] = (int64_t)(gmtoff - GMTOffset(&tt, t)) * 10000000L;
                }

                gmtoff = GMTOffset(&tt, t);
            }
        }

        if (!is_transitioned)
        {
            strftime(tzone, sizeof(tzone), "%Z", &tt);
            names[0] = tzone;
            names[1] = tzone;
            data[0] = 0;
            data[1] = 0;
            data[2] = (int64_t)gmtoff * 10000000L;
            data[3] = 0;
            *daylight_inverted = false;
        }

        return true;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Posix\TimeZone.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Std\ThreadImpl.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_THREADS_STD

#include "os/Thread.h"
#include "ThreadImpl.h"

#include <thread>

namespace il2cpp
{
namespace os
{
    struct StartData
    {
        Thread::StartFunc m_StartFunc;
        void* m_StartArg;
    };


    static void ThreadStartWrapper(void* arg)
    {
        StartData* startData = (StartData*)arg;
        startData->m_StartFunc(startData->m_StartArg);

        free(startData);
    }

    uint64_t ThreadImpl::Id()
    {
        return m_Thread.get_id().hash();
    }

    ErrorCode ThreadImpl::Run(Thread::StartFunc func, void* arg, int64_t affinityMask)
    {
        StartData* startData = (StartData*)malloc(sizeof(StartData));
        startData->m_StartFunc = func;
        startData->m_StartArg = arg;

        std::thread t(ThreadStartWrapper, startData);
        if (affinityMask != Thread::kThreadAffinityAll)
        {
            IL2CPP_ASSERT(0 && "Using non-default thread affinity is not supported on the STD implementation.");
        }

        m_Thread.swap(t);

        return kErrorCodeSuccess;
    }

    WaitStatus ThreadImpl::Join(uint32_t ms)
    {
        m_Thread.join();

        return kWaitStatusSuccess;
    }

    ErrorCode ThreadImpl::Sleep(uint32_t milliseconds)
    {
        std::chrono::milliseconds dura(milliseconds);
        std::this_thread::sleep_for(dura);

        return kErrorCodeSuccess;
    }

    uint64_t ThreadImpl::CurrentThreadId()
    {
        return std::this_thread::get_id().hash();
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Std\ThreadImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Assert.cpp---------------
.
.
#include "os/Assert.h"

#if IL2CPP_DEBUG

#if IL2CPP_TARGET_WINDOWS
#include <crtdbg.h>

void il2cpp_assert(const char* assertion, const char* file, unsigned int line)
{
    if (_CrtDbgReport(_CRT_ASSERT, file, line, "", "%s", assertion) == 1)
    {
        _CrtDbgBreak();
    }
}

#endif // IL2CPP_TARGET_WINDOWS

#endif // IL2CPP_DEBUG
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Assert.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\COM.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "os/COM.h"
#include "WindowsHeaders.h"

#if !IL2CPP_USE_GENERIC_COM

namespace il2cpp
{
namespace os
{
    il2cpp_hresult_t COM::CreateInstance(const Il2CppGuid& clsid, Il2CppIUnknown** object)
    {
        return ::CoCreateInstance(reinterpret_cast<REFCLSID>(clsid), NULL, CLSCTX_ALL, __uuidof(IUnknown), reinterpret_cast<LPVOID*>(object));
    }

    il2cpp_hresult_t COM::CreateFreeThreadedMarshaler(Il2CppIUnknown* outer, Il2CppIUnknown** marshal)
    {
        return ::CoCreateFreeThreadedMarshaler(reinterpret_cast<LPUNKNOWN>(outer), reinterpret_cast<LPUNKNOWN*>(marshal));
    }
}
}

#endif

#if !IL2CPP_USE_GENERIC_COM_SAFEARRAYS

namespace il2cpp
{
namespace os
{
// variant

    void COM::VariantInit(Il2CppVariant* variant)
    {
        ::VariantInit(reinterpret_cast<VARIANTARG*>(variant));
    }

    il2cpp_hresult_t COM::VariantClear(Il2CppVariant* variant)
    {
        return ::VariantClear(reinterpret_cast<VARIANTARG*>(variant));
    }

// safe array

    Il2CppSafeArray* COM::SafeArrayCreate(uint16_t type, uint32_t dimension_count, Il2CppSafeArrayBound* bounds)
    {
        return reinterpret_cast<Il2CppSafeArray*>(::SafeArrayCreate(type, dimension_count, reinterpret_cast<SAFEARRAYBOUND*>(bounds)));
    }

    il2cpp_hresult_t COM::SafeArrayDestroy(Il2CppSafeArray* safeArray)
    {
        return ::SafeArrayDestroy(reinterpret_cast<SAFEARRAY*>(safeArray));
    }

    il2cpp_hresult_t COM::SafeArrayAccessData(Il2CppSafeArray* safeArray, void** data)
    {
        return ::SafeArrayAccessData(reinterpret_cast<SAFEARRAY*>(safeArray), data);
    }

    il2cpp_hresult_t COM::SafeArrayUnaccessData(Il2CppSafeArray* safeArray)
    {
        return ::SafeArrayUnaccessData(reinterpret_cast<SAFEARRAY*>(safeArray));
    }

    il2cpp_hresult_t COM::SafeArrayGetVartype(Il2CppSafeArray* safeArray, uint16_t* type)
    {
        return ::SafeArrayGetVartype(reinterpret_cast<SAFEARRAY*>(safeArray), type);
    }

    uint32_t COM::SafeArrayGetDim(Il2CppSafeArray* safeArray)
    {
        return ::SafeArrayGetDim(reinterpret_cast<SAFEARRAY*>(safeArray));
    }

    il2cpp_hresult_t COM::SafeArrayGetLBound(Il2CppSafeArray* safeArray, uint32_t dimention, int32_t* bound)
    {
        return ::SafeArrayGetLBound(reinterpret_cast<SAFEARRAY*>(safeArray), dimention, reinterpret_cast<LONG*>(bound));
    }

    il2cpp_hresult_t COM::SafeArrayGetUBound(Il2CppSafeArray* safeArray, uint32_t dimention, int32_t* bound)
    {
        return ::SafeArrayGetUBound(reinterpret_cast<SAFEARRAY*>(safeArray), dimention, reinterpret_cast<LONG*>(bound));
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\COM.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\ConditionVariableImpl.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"
#if IL2CPP_THREADS_WIN32

#include "WindowsHeaders.h"
#include "os/Win32/MutexImpl.h"
#include "ConditionVariableImpl.h"
#include "WindowsHelpers.h"

namespace il2cpp
{
namespace os
{
    ConditionVariableImpl::ConditionVariableImpl()
    {
        ::InitializeConditionVariable(&m_ConditionVariable);
    }

    ConditionVariableImpl::~ConditionVariableImpl()
    {
        /* Beauty of win32 API: do not destroy it */
    }

    int ConditionVariableImpl::Wait(FastMutexImpl* lock)
    {
        return ::SleepConditionVariableCS(&m_ConditionVariable, lock->GetOSHandle(), INFINITE) ? 0 : 1;
    }

    int ConditionVariableImpl::TimedWait(FastMutexImpl* lock, uint32_t timeout_ms)
    {
        return ::SleepConditionVariableCS(&m_ConditionVariable, lock->GetOSHandle(), timeout_ms) ? 0 : 1;
    }

    void ConditionVariableImpl::Broadcast()
    {
        ::WakeAllConditionVariable(&m_ConditionVariable);
    }

    void ConditionVariableImpl::Signal()
    {
        ::WakeConditionVariable(&m_ConditionVariable);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\ConditionVariableImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Console.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/Console.h"

namespace il2cpp
{
namespace os
{
namespace Console
{
    int32_t InternalKeyAvailable(int32_t ms_timeout)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Console::InternalKeyAvailable);
        return 0;
    }

    bool SetBreak(bool wantBreak)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Console::SetBreak);
        return false;
    }

    bool SetEcho(bool wantEcho)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Console::SetEcho);
        return false;
    }

    bool TtySetup(const std::string& keypadXmit, const std::string& teardown, uint8_t* control_characters, int32_t** size)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Console::TtySetup);
        return false;
    }

    const char* NewLine()
    {
        return "\r\n";
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Console.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\CpuInfo.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"
#if IL2CPP_PLATFORM_SUPPORTS_CPU_INFO

#if IL2CPP_TARGET_WINDOWS

#include "os/CpuInfo.h"
#include "utils/Memory.h"

#include "WindowsHeaders.h"

struct Il2CppCpuUsageState
{
    uint64_t kernel_time;
    uint64_t user_time;
    uint64_t idle_time;
};

namespace il2cpp
{
namespace os
{
    void* CpuInfo::Create()
    {
        return IL2CPP_MALLOC_ZERO(sizeof(Il2CppCpuUsageState));
    }

    int32_t CpuInfo::Usage(void* previous)
    {
        Il2CppCpuUsageState* prev = (Il2CppCpuUsageState*)previous;
        int32_t cpu_usage = 0;
        int64_t cpu_total_time;
        int64_t cpu_busy_time;

        uint64_t idle_time;
        uint64_t kernel_time;
        uint64_t user_time;

        ::GetSystemTimes((FILETIME*)&idle_time, (FILETIME*)&kernel_time, (FILETIME*)&user_time);

        cpu_total_time = (int64_t)((user_time - (prev ? prev->user_time : 0)) + (kernel_time - (prev ? prev->kernel_time : 0)));
        cpu_busy_time = (int64_t)(cpu_total_time - (idle_time - (prev ? prev->idle_time : 0)));

        if (prev)
        {
            prev->idle_time = idle_time;
            prev->kernel_time = kernel_time;
            prev->user_time = user_time;
        }

        if (cpu_total_time > 0 && cpu_busy_time > 0)
            cpu_usage = (int32_t)(cpu_busy_time * 100 / cpu_total_time);

        return cpu_usage;
    }
}
}

#endif
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\CpuInfo.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\CrashHelpers.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/CrashHelpers.h"

#if IL2CPP_TARGET_WINDOWS && !IL2CPP_USE_GENERIC_CRASH_HELPERS

#include "WindowsHeaders.h"

namespace il2cpp
{
namespace os
{
    void CrashHelpers::CrashImpl()
    {
        // __fastfail() is available since VS2012
#if _MSC_VER >= 1700
        __fastfail(FAST_FAIL_FATAL_APP_EXIT);
#else
        abort();
#endif
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\CrashHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Cryptography.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/Win32/WindowsHeaders.h"
#include "os/Cryptography.h"

#include <bcrypt.h>

namespace il2cpp
{
namespace os
{
    // This has to be non-null value because the return value of NULL from GetCryptographyProvider means it failed
    void* const kCryptographyProvider = reinterpret_cast<void*>(0x12345678);

    void* Cryptography::GetCryptographyProvider()
    {
        return kCryptographyProvider;
    }

    bool Cryptography::OpenCryptographyProvider()
    {
        return true;
    }

    void Cryptography::ReleaseCryptographyProvider(void* provider)
    {
        // Do nothing, since we never allocated it
    }

    bool Cryptography::FillBufferWithRandomBytes(void* provider, intptr_t length, unsigned char* data)
    {
        NO_UNUSED_WARNING(provider);
        return SUCCEEDED(BCryptGenRandom(NULL, data, (ULONG)length, BCRYPT_USE_SYSTEM_PREFERRED_RNG));
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Cryptography.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Debug.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/Debug.h"
#include "os/Win32/WindowsHeaders.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace os
{
    bool Debug::IsDebuggerPresent()
    {
        return ::IsDebuggerPresent() != FALSE;
    }

    void Debug::WriteString(const utils::StringView<Il2CppNativeChar>& message)
    {
        OutputDebugString(message.Str());
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Debug.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Directory.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "WindowsHeaders.h"

#undef FindFirstFile
#undef FindNextFile

#include "os/Directory.h"
#include "os/ErrorCodes.h"
#include "utils/StringUtils.h"
#include "utils/PathUtils.h"

#if IL2CPP_TARGET_WINRT
#include "os/BrokeredFileSystem.h"
#endif

static inline int DirectoryWin32ErrorToErrorCode(DWORD win32ErrorCode)
{
    return win32ErrorCode;
}

using namespace il2cpp::utils::PathUtils;

namespace il2cpp
{
namespace os
{
    std::string Directory::GetCurrent(int *error)
    {
        UTF16String buf;
        int len, res_len;

        len = MAX_PATH + 1;
        buf.resize(len, 0);

        *error = ERROR_SUCCESS;

        res_len = ::GetCurrentDirectory(len, (LPWSTR)buf.c_str());
        if (res_len > len) /*buf is too small.*/
        {
            int old_res_len = res_len;
            buf.resize(res_len, 0);
            res_len = ::GetCurrentDirectory(res_len, (LPWSTR)buf.c_str()) == old_res_len;
        }

        std::string directory;

        if (res_len)
        {
            len = 0;
            while (buf[len])
                ++len;

            directory = il2cpp::utils::StringUtils::Utf16ToUtf8(buf.c_str());
        }
        else
        {
            *error = DirectoryWin32ErrorToErrorCode(::GetLastError());
        }

        return directory;
    }

    bool Directory::SetCurrent(const std::string& path, int* error)
    {
        *error = kErrorCodeSuccess;

        const UTF16String utf16Path(il2cpp::utils::StringUtils::Utf8ToUtf16(path.c_str()));
        if (::SetCurrentDirectory((LPWSTR)utf16Path.c_str()))
            return true;

        *error = DirectoryWin32ErrorToErrorCode(::GetLastError());
        return false;
    }

    bool Directory::Create(const std::string& path, int *error)
    {
        *error = kErrorCodeSuccess;

        const UTF16String utf16Path(il2cpp::utils::StringUtils::Utf8ToUtf16(path.c_str()));
        if (::CreateDirectory((LPWSTR)utf16Path.c_str(), NULL))
            return true;

        auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
        if (lastError == ERROR_ACCESS_DENIED)
        {
            *error = BrokeredFileSystem::CreateDirectoryW(utf16Path);
            return *error == kErrorCodeSuccess;
        }
#endif

        *error = DirectoryWin32ErrorToErrorCode(lastError);
        return false;
    }

    bool Directory::Remove(const std::string& path, int *error)
    {
        *error = kErrorCodeSuccess;

        const UTF16String utf16Path(il2cpp::utils::StringUtils::Utf8ToUtf16(path.c_str()));
        if (::RemoveDirectory((LPWSTR)utf16Path.c_str()))
            return true;

        auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
        if (lastError == ERROR_ACCESS_DENIED)
        {
            *error = BrokeredFileSystem::RemoveDirectoryW(utf16Path);
            return *error == kErrorCodeSuccess;
        }
#endif

        *error = DirectoryWin32ErrorToErrorCode(lastError);
        return false;
    }

    std::set<std::string> Directory::GetFileSystemEntries(const std::string& path, const std::string& pathWithPattern, int32_t attrs, int32_t mask, int* error)
    {
        *error = kErrorCodeSuccess;
        std::set<std::string> files;
        WIN32_FIND_DATA ffd;
        const UTF16String utf16Path(il2cpp::utils::StringUtils::Utf8ToUtf16(pathWithPattern));

        HANDLE handle = ::FindFirstFileExW((LPCWSTR)utf16Path.c_str(), FindExInfoStandard, &ffd, FindExSearchNameMatch, NULL, 0);
        if (INVALID_HANDLE_VALUE == handle)
        {
            auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
            if (lastError == ERROR_ACCESS_DENIED)
                return BrokeredFileSystem::GetFileSystemEntries(utils::StringUtils::Utf8ToUtf16(path), utf16Path, attrs, mask, error);
#endif

            // Following the Mono implementation, do not treat a directory with no files as an error.
            int errorCode = DirectoryWin32ErrorToErrorCode(lastError);
            if (errorCode != ERROR_FILE_NOT_FOUND)
                *error = errorCode;
            return files;
        }

        do
        {
            const std::string fileName(il2cpp::utils::StringUtils::Utf16ToUtf8(ffd.cFileName));

            if ((fileName.length() == 1 && fileName.at(0) == '.') ||
                (fileName.length() == 2 && fileName.at(0) == '.' && fileName.at(1) == '.'))
                continue;

            if ((ffd.dwFileAttributes & mask) == attrs)
            {
                files.insert(Combine(path, fileName));
            }
        }
        while (::FindNextFileW(handle, &ffd) != 0);

        ::FindClose(handle);

        return files;
    }

    Directory::FindHandle::FindHandle(const utils::StringView<Il2CppNativeChar>& searchPathWithPattern) :
        osHandle(INVALID_HANDLE_VALUE),
        handleFlags(os::kNoFindHandleFlags),
        directoryPath(il2cpp::utils::PathUtils::DirectoryName(searchPathWithPattern)),
        pattern(il2cpp::utils::PathUtils::Basename(searchPathWithPattern))
    {
    }

    Directory::FindHandle::~FindHandle()
    {
        IL2CPP_ASSERT(osHandle == INVALID_HANDLE_VALUE);
    }

    int32_t Directory::FindHandle::CloseOSHandle()
    {
        int32_t result = os::kErrorCodeSuccess;

        if (osHandle != INVALID_HANDLE_VALUE)
        {
#if IL2CPP_TARGET_WINRT
            if (handleFlags & kUseBrokeredFileSystem)
            {
                result = BrokeredFileSystem::FindClose(osHandle);
            }
            else
#endif
            {
                result = ::FindClose(osHandle);
            }

            osHandle = INVALID_HANDLE_VALUE;
        }

        return result;
    }

    os::ErrorCode Directory::FindFirstFile(FindHandle* findHandle, const utils::StringView<Il2CppNativeChar>& searchPathWithPattern, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
        WIN32_FIND_DATA findData;
        HANDLE handle = FindFirstFileExW(searchPathWithPattern.Str(), FindExInfoStandard, &findData, FindExSearchNameMatch, NULL, 0);

        if (handle != INVALID_HANDLE_VALUE)
        {
            findHandle->SetOSHandle(handle);
            *resultFileName = findData.cFileName;
            *resultAttributes = findData.dwFileAttributes;
            return os::kErrorCodeSuccess;
        }
        else
        {
            auto lastError = GetLastError();

#if IL2CPP_TARGET_WINRT
            if (lastError == ERROR_ACCESS_DENIED)
                return BrokeredFileSystem::FindFirstFileW(findHandle, searchPathWithPattern, resultFileName, resultAttributes);
#endif

            return static_cast<os::ErrorCode>(lastError);
        }
    }

    os::ErrorCode Directory::FindNextFile(FindHandle* findHandle, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
#if IL2CPP_TARGET_WINRT
        if (findHandle->handleFlags & kUseBrokeredFileSystem)
            return BrokeredFileSystem::FindNextFileW(findHandle, resultFileName, resultAttributes);
#endif

        WIN32_FIND_DATA findData;
        if (FindNextFileW(findHandle->osHandle, &findData) == FALSE)
            return static_cast<os::ErrorCode>(GetLastError());

        *resultFileName = findData.cFileName;
        *resultAttributes = findData.dwFileAttributes;
        return os::kErrorCodeSuccess;
    }

    int32_t Directory::CloseOSFindHandleDirectly(intptr_t osHandle)
    {
        return ::FindClose((HANDLE)osHandle);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Directory.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\DllMain.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "DllMain.h"
#include "ThreadImpl.h"
#include "WindowsHeaders.h"

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD reason, LPVOID lpvReserved)
{
    if (reason == DLL_THREAD_DETACH)
        il2cpp::os::ThreadImpl::OnCurrentThreadExiting();

    return TRUE;
}

#if LIBIL2CPP_IS_IN_EXECUTABLE
typedef BOOL(WINAPI* DllMainFunc)(HINSTANCE hinstDLL, DWORD reason, LPVOID lpvReserved);
__declspec(dllimport) extern void Libil2cppLackeySetDllMain(DllMainFunc dllMain);
#endif

void il2cpp::os::InitializeDllMain()
{
#if LIBIL2CPP_IS_IN_EXECUTABLE
    Libil2cppLackeySetDllMain(DllMain);
#endif
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\DllMain.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Encoding.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS
#include "WindowsHelpers.H"

#include "os/Encoding.h"

namespace il2cpp
{
namespace os
{
namespace Encoding
{
    std::string GetCharSet()
    {
        static char buf[14];
        sprintf(buf, "CP%u", GetACP());
        return std::string(buf);
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Encoding.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Environment.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_ENVIRONMENT && IL2CPP_TARGET_WINDOWS
#include "WindowsHelpers.h"
#if !IL2CPP_TARGET_WINDOWS_GAMES
#include <Shlobj.h>
#endif
// Windows.h defines GetEnvironmentVariable as GetEnvironmentVariableW for unicode and this will
// change the string "Environment::GetEnvironmentVariable" below to "Environment::GetEnvironmentVariableW"
// in the preprocessor. So we undef to avoid this issue and use GetEnvironmentVariableW directly.
// Same for SetEnvironmentVariable
#undef GetEnvironmentVariable
#undef SetEnvironmentVariable
#include "os/Environment.h"
#include "utils/StringUtils.h"
#include <string>

#define BUFFER_SIZE 1024

namespace il2cpp
{
namespace os
{
    std::string Environment::GetMachineName()
    {
        Il2CppChar computerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD size = sizeof(computerName) / sizeof(computerName[0]);
        if (!GetComputerNameW(computerName, &size))
            return NULL;

        return utils::StringUtils::Utf16ToUtf8(computerName);
    }

    int32_t Environment::GetProcessorCount()
    {
        SYSTEM_INFO info;
        GetSystemInfo(&info);
        return info.dwNumberOfProcessors;
    }

// GetVersionEx is deprecated on desktop in Windows SDK, and we shim it for WinRT
#pragma warning( push )
#pragma warning( disable : 4996 )

    std::string Environment::GetOsVersionString()
    {
        OSVERSIONINFO verinfo;

        verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&verinfo))
        {
            char version[64];
            /* maximum string length is 35 bytes
               3 x 10 bytes per number, 1 byte for 0, 3 x 1 byte for dots, 1 for NULL */
            sprintf(version, "%ld.%ld.%ld.0",
                verinfo.dwMajorVersion,
                verinfo.dwMinorVersion,
                verinfo.dwBuildNumber);
            return version;
        }

        return "0.0.0.0";
    }

#pragma warning( pop )

    std::string Environment::GetOsUserName()
    {
#if !IL2CPP_TARGET_WINDOWS_GAMES
        Il2CppChar user_name[256 + 1];
        DWORD user_name_size = ARRAYSIZE(user_name);
        if (GetUserNameW(user_name, &user_name_size))
            return utils::StringUtils::Utf16ToUtf8(user_name);
#endif // !IL2CPP_TARGET_WINDOWS_GAMES

        return "Unknown";
    }

    std::string Environment::GetEnvironmentVariable(const std::string& name)
    {
        std::vector<Il2CppChar> buffer(BUFFER_SIZE);

        const UTF16String varName = utils::StringUtils::Utf8ToUtf16(name.c_str());

        DWORD ret = GetEnvironmentVariableW(varName.c_str(), &buffer[0], BUFFER_SIZE);

        if (ret == 0) // Not found
            return std::string();

        if (ret < BUFFER_SIZE) // Found and fits into buffer
            return utils::StringUtils::Utf16ToUtf8(&buffer[0]);

        // Requires bigger buffer
        IL2CPP_ASSERT(ret >= BUFFER_SIZE);

        buffer.resize(ret + 1);

        ret = GetEnvironmentVariableW(varName.c_str(), &buffer[0], ret + 1);
        IL2CPP_ASSERT(ret != 0);

        return utils::StringUtils::Utf16ToUtf8(&buffer[0]);
    }

    void Environment::SetEnvironmentVariable(const std::string& name, const std::string& value)
    {
        const UTF16String varName = utils::StringUtils::Utf8ToUtf16(name.c_str());

        if (value.empty())
            SetEnvironmentVariableW((LPWSTR)varName.c_str(), NULL);
        else
        {
            const UTF16String varValue = utils::StringUtils::Utf8ToUtf16(value.c_str());
            SetEnvironmentVariableW((LPWSTR)varName.c_str(), (LPWSTR)varValue.c_str());
        }
    }

    std::vector<std::string> Environment::GetEnvironmentVariableNames()
    {
        WCHAR* env_strings;
        WCHAR* env_string;
        WCHAR* equal_str;

        std::vector<std::string> result;

        env_strings = GetEnvironmentStringsW();

        if (env_strings)
        {
            env_string = env_strings;
            while (*env_string != '\0')
            {
                // Skip over environment variables starting with '='
                if (*env_string != '=')
                {
                    equal_str = wcschr(env_string, '=');
                    result.push_back(utils::StringUtils::Utf16ToUtf8(env_string, (int)(equal_str - env_string)));
                }
                while (*env_string != '\0')
                    env_string++;
                env_string++;
            }

            FreeEnvironmentStringsW(env_strings);
        }

        return result;
    }

    std::string Environment::GetHomeDirectory()
    {
#if IL2CPP_TARGET_WINDOWS_DESKTOP
        std::string home_directory;

        PWSTR profile_path = NULL;
        HRESULT hr = SHGetKnownFolderPath(FOLDERID_Profile, KF_FLAG_DEFAULT, NULL, &profile_path);
        if (SUCCEEDED(hr))
        {
            home_directory = utils::StringUtils::Utf16ToUtf8(profile_path);
            CoTaskMemFree(profile_path);
        }

        if (home_directory.empty())
        {
            home_directory = GetEnvironmentVariable("USERPROFILE");
        }

        if (home_directory.empty())
        {
            std::string drive = GetEnvironmentVariable("HOMEDRIVE");
            std::string path = GetEnvironmentVariable("HOMEPATH");

            if (!drive.empty() && !path.empty())
                home_directory = drive + path;
        }

        return home_directory;
#else
        IL2CPP_NOT_IMPLEMENTED_ICALL(Environment::GetHomeDirectory);
        return std::string();
#endif
    }

    std::vector<std::string> SplitLogicalDriveString(Il2CppChar *buffer, DWORD size)
    {
        std::vector<std::string> retVal;
        Il2CppChar *ptr = buffer;

        for (DWORD i = 0; i < size; ++i)
        {
            Il2CppChar c = buffer[i];
            if (c == 0)
            {
                retVal.push_back(utils::StringUtils::Utf16ToUtf8(ptr));
                ptr = &buffer[i + 1];
            }
        }

        return retVal;
    }

    std::vector<std::string> Environment::GetLogicalDrives()
    {
#if IL2CPP_TARGET_WINDOWS_DESKTOP
        std::vector<Il2CppChar> buffer(BUFFER_SIZE);

        DWORD size = GetLogicalDriveStringsW(BUFFER_SIZE, &buffer[0]);

        if (size == 0)
            return std::vector<std::string>();

        if (size > BUFFER_SIZE)
        {
            buffer.resize(size + 1);
            size = GetLogicalDriveStringsW(size + 1, &buffer[0]);
            IL2CPP_ASSERT(size != 0);
        }

        return SplitLogicalDriveString(&buffer[0], size);
#else
        return std::vector<std::string>();
#endif
    }

    void Environment::Exit(int result)
    {
        ::exit(result);
    }

    NORETURN void Environment::Abort()
    {
        // __fastfail() is available since VS2012
#if _MSC_VER >= 1700
        __fastfail(FAST_FAIL_FATAL_APP_EXIT);
#else
        abort();
#endif
    }

#if IL2CPP_TARGET_WINDOWS_DESKTOP

    utils::Expected<std::string> Environment::GetWindowsFolderPath(int32_t folder)
    {
        Il2CppChar path[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPathW(NULL, folder | CSIDL_FLAG_CREATE, NULL, 0, path)))
            return utils::StringUtils::Utf16ToUtf8(path);

        return std::string();
    }

    utils::Expected<bool> Environment::Is64BitOs()
    {
        BOOL isWow64Process = false;
        if (IsWow64Process(GetCurrentProcess(), &isWow64Process))
        {
            return isWow64Process == TRUE;
        }
        return false;
    }

#elif IL2CPP_TARGET_WINDOWS_GAMES
    utils::Expected<std::string> Environment::GetWindowsFolderPath(int32_t folder)
    {
        return std::string();
    }

    utils::Expected<bool> Environment::Is64BitOs()
    {
#if _WIN64 // the IsWow64Process(used above) function is not available on Windows Games,this is the best available.
        return true;
#else
        return false;
#endif
    }

#endif
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Environment.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\File.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "WindowsHelpers.h"

#undef CopyFile
#undef DeleteFile
#undef MoveFile
#undef ReplaceFile
#undef GetFileAttributes
#undef SetFileAttributes
#undef CreatePipe

#include "os/File.h"
#include "utils/Expected.h"
#include "utils/Il2CppError.h"
#include "utils/StringUtils.h"
#include "utils/PathUtils.h"

#if IL2CPP_TARGET_WINRT
#include "os/BrokeredFileSystem.h"
#endif

#include <stdint.h>

static inline int FileWin32ErrorToErrorCode(DWORD win32ErrorCode)
{
    return win32ErrorCode;
}

namespace il2cpp
{
namespace os
{
#if IL2CPP_TARGET_WINDOWS_DESKTOP
    utils::Expected<bool> File::Isatty(FileHandle* fileHandle)
    {
        DWORD mode;
        return GetConsoleMode((HANDLE)fileHandle, &mode) != 0;
    }

#elif IL2CPP_TARGET_WINDOWS_GAMES
    utils::Expected<bool> File::Isatty(FileHandle* fileHandle)
    {
        return utils::Il2CppError(utils::NotSupported, "Console functions are not supported on Windows Games platforms.");
    }

#endif

#if IL2CPP_TARGET_WINDOWS_DESKTOP || IL2CPP_TARGET_WINDOWS_GAMES
    FileHandle* File::GetStdInput()
    {
        return (FileHandle*)GetStdHandle(STD_INPUT_HANDLE);
    }

    FileHandle* File::GetStdError()
    {
        return (FileHandle*)GetStdHandle(STD_ERROR_HANDLE);
    }

    FileHandle* File::GetStdOutput()
    {
        return (FileHandle*)GetStdHandle(STD_OUTPUT_HANDLE);
    }

#endif // IL2CPP_TARGET_WINDOWS_DESKTOP || IL2CPP_TARGET_WINDOWS_GAMES

    utils::Expected<bool> File::CreatePipe(FileHandle** read_handle, FileHandle** write_handle)
    {
        int error;
        return CreatePipe(read_handle, write_handle, &error);
    }

    utils::Expected<bool> File::CreatePipe(FileHandle** read_handle, FileHandle** write_handle, int* error)
    {
        SECURITY_ATTRIBUTES attr;

        attr.nLength = sizeof(SECURITY_ATTRIBUTES);
        attr.bInheritHandle = TRUE;
        attr.lpSecurityDescriptor = NULL;

        bool ret = ::CreatePipe((PHANDLE)read_handle, (PHANDLE)write_handle, &attr, 0);

        if (ret == FALSE)
        {
            *error = GetLastError();
            /* FIXME: throw an exception? */
            return false;
        }

        return true;
    }

#if !IL2CPP_TARGET_WINDOWS_GAMES
    UnityPalFileAttributes File::GetFileAttributes(const std::string& path, int *error)
    {
        const UTF16String utf16Path(utils::StringUtils::Utf8ToUtf16(path.c_str()));
        WIN32_FILE_ATTRIBUTE_DATA fileAttributes;

        BOOL result = ::GetFileAttributesExW((LPCWSTR)utf16Path.c_str(), GetFileExInfoStandard, &fileAttributes);
        if (result == FALSE)
        {
            auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
            if (lastError == ERROR_ACCESS_DENIED)
                return BrokeredFileSystem::GetFileAttributesW(utf16Path, error);
#endif

            *error = FileWin32ErrorToErrorCode(lastError);
            return static_cast<UnityPalFileAttributes>(INVALID_FILE_ATTRIBUTES);
        }

        *error = kErrorCodeSuccess;
        return static_cast<UnityPalFileAttributes>(fileAttributes.dwFileAttributes);
    }

#endif // !IL2CPP_TARGET_WINDOWS_GAMES

    bool File::SetFileAttributes(const std::string& path, UnityPalFileAttributes attributes, int* error)
    {
        const UTF16String utf16Path(utils::StringUtils::Utf8ToUtf16(path.c_str()));

        *error = kErrorCodeSuccess;
        if (::SetFileAttributesW((LPCWSTR)utf16Path.c_str(), attributes))
            return true;

        auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
        if (lastError == ERROR_ACCESS_DENIED)
            return BrokeredFileSystem::SetFileAttributesW(utf16Path, attributes, error);
#endif

        *error = FileWin32ErrorToErrorCode(lastError);
        return false;
    }

    static inline int64_t HighAndLowToInt64(uint32_t high, uint32_t low)
    {
        return ((uint64_t)high << 32) + low;
    }

    static inline int64_t FileTimeToInt64(const FILETIME& fileTime)
    {
        return HighAndLowToInt64(fileTime.dwHighDateTime, fileTime.dwLowDateTime);
    }

    bool File::GetFileStat(const std::string& path, il2cpp::os::FileStat * stat, int* error)
    {
        *error = kErrorCodeSuccess;
        const UTF16String utf16Path(utils::StringUtils::Utf8ToUtf16(path.c_str()));

        WIN32_FILE_ATTRIBUTE_DATA data;
        if (!::GetFileAttributesExW((LPCWSTR)utf16Path.c_str(), GetFileExInfoStandard, &data))
        {
            auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
            if (lastError == ERROR_ACCESS_DENIED)
                return BrokeredFileSystem::GetFileStat(path, utf16Path, stat, error);
#endif

            *error = FileWin32ErrorToErrorCode(lastError);
            return false;
        }

        stat->name = il2cpp::utils::PathUtils::Basename(path);
        stat->attributes = data.dwFileAttributes;
        stat->creation_time = FileTimeToInt64(data.ftCreationTime);
        stat->last_access_time = FileTimeToInt64(data.ftLastAccessTime);
        stat->last_write_time = FileTimeToInt64(data.ftLastWriteTime);
        stat->length = HighAndLowToInt64(data.nFileSizeHigh, data.nFileSizeLow);
        return true;
    }

    FileType File::GetFileType(FileHandle* handle)
    {
        int result = ::GetFileType((HANDLE)handle);
        /*if (result == FILE_TYPE_UNKNOWN)
        {
            *error = GetLastError();
        }*/
        return (FileType)result;
    }

    bool File::CopyFile(const std::string& src, const std::string& dest, bool overwrite, int* error)
    {
        const UTF16String utf16Src(utils::StringUtils::Utf8ToUtf16(src.c_str()));
        const UTF16String utf16Dest(utils::StringUtils::Utf8ToUtf16(dest.c_str()));

        *error = kErrorCodeSuccess;

        if (::CopyFileW((LPWSTR)utf16Src.c_str(), (LPWSTR)utf16Dest.c_str(), overwrite ? FALSE : TRUE))
            return true;

        auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
        if (lastError == ERROR_ACCESS_DENIED)
            return BrokeredFileSystem::CopyFileW(utf16Src, utf16Dest, overwrite, error);
#endif

        *error = FileWin32ErrorToErrorCode(lastError);
        return false;
    }

    bool File::MoveFile(const std::string& src, const std::string& dest, int* error)
    {
        const UTF16String utf16Src(utils::StringUtils::Utf8ToUtf16(src.c_str()));
        const UTF16String utf16Dest(utils::StringUtils::Utf8ToUtf16(dest.c_str()));

        *error = kErrorCodeSuccess;

        if (::MoveFileExW((LPWSTR)utf16Src.c_str(), (LPWSTR)utf16Dest.c_str(), MOVEFILE_COPY_ALLOWED))
            return true;

        auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
        if (lastError == ERROR_ACCESS_DENIED)
            return BrokeredFileSystem::MoveFileW(utf16Src, utf16Dest, error);
#endif

        *error = FileWin32ErrorToErrorCode(lastError);
        return false;
    }

    bool File::DeleteFile(const std::string& path, int *error)
    {
        *error = kErrorCodeSuccess;
        const UTF16String utf16Path(utils::StringUtils::Utf8ToUtf16(path.c_str()));
        if (::DeleteFileW((LPWSTR)utf16Path.c_str()))
            return true;

        auto lastError = ::GetLastError();

#if IL2CPP_TARGET_WINRT
        if (lastError == ERROR_ACCESS_DENIED)
        {
            *error = BrokeredFileSystem::DeleteFileW(utf16Path);
            return *error == kErrorCodeSuccess;
        }
#endif

        *error = FileWin32ErrorToErrorCode(lastError);
        return false;
    }

    bool File::ReplaceFile(const std::string& sourceFileName, const std::string& destinationFileName, const std::string& destinationBackupFileName, bool ignoreMetadataErrors, int* error)
    {
        const UTF16String utf16Src(utils::StringUtils::Utf8ToUtf16(sourceFileName.c_str()));
        const UTF16String utf16Dest(utils::StringUtils::Utf8ToUtf16(destinationFileName.c_str()));
        const UTF16String utf16Backup(utils::StringUtils::Utf8ToUtf16(destinationBackupFileName.c_str()));

        *error = kErrorCodeSuccess;

        DWORD flags = REPLACEFILE_WRITE_THROUGH;
        if (ignoreMetadataErrors)
            flags |= REPLACEFILE_IGNORE_MERGE_ERRORS;

        if (::ReplaceFileW((LPWSTR)utf16Dest.c_str(), (LPWSTR)utf16Src.c_str(), utf16Backup.empty() ? NULL : (LPWSTR)utf16Backup.c_str(), flags, NULL, NULL))
            return true;

        *error = FileWin32ErrorToErrorCode(::GetLastError());
        return false;
    }

    static inline int MonoToWindowsOpenMode(int monoOpenMode)
    {
        switch (monoOpenMode)
        {
            case kFileModeCreateNew:
                return CREATE_NEW;

            case kFileModeCreate:
                return CREATE_ALWAYS;

            case kFileModeOpen:
                return OPEN_EXISTING;

            case kFileModeOpenOrCreate:
            case kFileModeAppend:
                return OPEN_ALWAYS;

            case kFileModeTruncate:
                return TRUNCATE_EXISTING;

            default:
                Assert(false && "Unknown mono open mode");
                IL2CPP_UNREACHABLE;
        }
    }

    static inline int MonoToWindowsAccessMode(int monoAccessMode)
    {
        switch (monoAccessMode)
        {
            case kFileAccessRead:
                return GENERIC_READ;

            case kFileAccessWrite:
                return GENERIC_WRITE;

            case kFileAccessExecute:
                return GENERIC_EXECUTE;

            case kFileAccessReadWrite:
                return GENERIC_READ | GENERIC_WRITE;

            case kFileAccessReadWriteExecute:
                return GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE;

            default:
                return 0;
        }
    }

    static inline DWORD MonoOptionsToWindowsFlagsAndAttributes(const std::string& path, int options)
    {
        DWORD flagsAndAttributes;

        if (options != 0)
        {
            if (options & kFileOptionsEncrypted)
                flagsAndAttributes = FILE_ATTRIBUTE_ENCRYPTED;
            else
                flagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
            if (options & kFileOptionsDeleteOnClose)
                flagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
            if (options & kFileOptionsSequentialScan)
                flagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
            if (options & kFileOptionsRandomAccess)
                flagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;

            if (options & kFileOptionsWriteThrough)
                flagsAndAttributes |= FILE_FLAG_WRITE_THROUGH;
        }
        else
        {
            flagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        int error;
        UnityPalFileAttributes currentAttributes = File::GetFileAttributes(path, &error);

        if (currentAttributes != INVALID_FILE_ATTRIBUTES && (currentAttributes & FILE_ATTRIBUTE_DIRECTORY))
            flagsAndAttributes |= FILE_FLAG_BACKUP_SEMANTICS; // Required to open a directory

        return flagsAndAttributes;
    }

    FileHandle* File::Open(const std::string& path, int openMode, int accessMode, int shareMode, int options, int *error)
    {
        const UTF16String utf16Path(utils::StringUtils::Utf8ToUtf16(path.c_str()));

        openMode = MonoToWindowsOpenMode(openMode);
        accessMode = MonoToWindowsAccessMode(accessMode);
        DWORD flagsAndAttributes = MonoOptionsToWindowsFlagsAndAttributes(path, options);

        HANDLE handle = ::CreateFileW((LPCWSTR)utf16Path.c_str(), accessMode, shareMode, NULL, openMode, flagsAndAttributes, NULL);

        if (INVALID_HANDLE_VALUE == handle)
        {
            auto lastError = ::GetLastError();
#if IL2CPP_TARGET_WINRT
            if (lastError == ERROR_ACCESS_DENIED)
                return BrokeredFileSystem::Open(utf16Path, accessMode, shareMode, openMode, flagsAndAttributes, error);
#endif

            *error = FileWin32ErrorToErrorCode(lastError);
            return (FileHandle*)INVALID_HANDLE_VALUE;
        }

        *error = kErrorCodeSuccess;
        return (FileHandle*)handle;
    }

    bool File::Close(FileHandle* handle, int *error)
    {
        *error = kErrorCodeSuccess;
        if (CloseHandle((HANDLE)handle))
            return true;

        *error = FileWin32ErrorToErrorCode(::GetLastError());
        return false;
    }

    bool File::SetFileTime(FileHandle* handle, int64_t creation_time, int64_t last_access_time, int64_t last_write_time, int* error)
    {
        FILE_BASIC_INFO fileInfo;

        fileInfo.CreationTime.QuadPart = creation_time;
        fileInfo.LastAccessTime.QuadPart = last_access_time;
        fileInfo.LastWriteTime.QuadPart = last_write_time;
        fileInfo.ChangeTime.QuadPart = 0; // 0 means don't change anything
        fileInfo.FileAttributes = 0; // 0 means don't change anything

        if (SetFileInformationByHandle(handle, FileBasicInfo, &fileInfo, sizeof(FILE_BASIC_INFO)) == FALSE)
        {
            *error = GetLastError();
            return false;
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    int64_t File::GetLength(FileHandle* handle, int *error)
    {
        *error = kErrorCodeSuccess;
        LARGE_INTEGER size;
        if (!::GetFileSizeEx((HANDLE)handle, &size))
        {
            *error = FileWin32ErrorToErrorCode(::GetLastError());
            return 0;
        }
        return size.QuadPart;
    }

#if !IL2CPP_USE_GENERIC_FILE
    bool File::Truncate(FileHandle* handle, int *error)
    {
        *error = kErrorCodeSuccess;
        if (!::SetEndOfFile((HANDLE)handle))
        {
            *error = FileWin32ErrorToErrorCode(::GetLastError());
            return false;
        }
        return true;
    }

#endif // IL2CPP_USE_GENERIC_FILE

    bool File::SetLength(FileHandle* handle, int64_t length, int *error)
    {
        *error = kErrorCodeSuccess;
        LARGE_INTEGER zeroOffset = { 0 };
        LARGE_INTEGER requestedOffset = { 0 };
        requestedOffset.QuadPart = length;
        LARGE_INTEGER initialPosition = { 0 };

        // set position to 0 from current to retrieve current position
        if (!::SetFilePointerEx((HANDLE)handle, zeroOffset, &initialPosition, FILE_CURRENT))
        {
            *error = FileWin32ErrorToErrorCode(::GetLastError());
            return false;
        }

        // seek to requested length
        if (!::SetFilePointerEx((HANDLE)handle, requestedOffset, NULL, FILE_BEGIN))
        {
            *error = FileWin32ErrorToErrorCode(::GetLastError());
            return false;
        }

        // set requested length
        if (!::SetEndOfFile((HANDLE)handle))
        {
            *error = FileWin32ErrorToErrorCode(::GetLastError());
            return false;
        }

        // restore original position
        if (!::SetFilePointerEx((HANDLE)handle, initialPosition, NULL, FILE_BEGIN))
        {
            *error = FileWin32ErrorToErrorCode(::GetLastError());
            return false;
        }

        return true;
    }

    int64_t File::Seek(FileHandle* handle, int64_t offset, int origin, int *error)
    {
        *error = kErrorCodeSuccess;
        LARGE_INTEGER distance;
        distance.QuadPart = offset;
        LARGE_INTEGER position = { 0 };
        if (!::SetFilePointerEx((HANDLE)handle, distance, &position, origin))
            *error = FileWin32ErrorToErrorCode(::GetLastError());

        return position.QuadPart;
    }

    int File::Read(FileHandle* handle, char *dest, int count, int *error)
    {
        *error = kErrorCodeSuccess;
        DWORD bytesRead = 0;
        if (!::ReadFile(handle, dest, count, &bytesRead, NULL))
            *error = FileWin32ErrorToErrorCode(::GetLastError());

        return bytesRead;
    }

    int32_t File::Write(FileHandle* handle, const char* buffer, int count, int *error)
    {
        int32_t written;

        BOOL success = WriteFile((HANDLE)handle, buffer, count, (LPDWORD)&written, NULL);

        if (!success)
        {
            DWORD originalError = GetLastError();
            if (originalError == ERROR_INVALID_PARAMETER)
            {
                // Maybe this is an async file write, so try with those parameters.
                OVERLAPPED overlapped = {0};
                success = WriteFile((HANDLE)handle, buffer, count, NULL, &overlapped);
                if (success != 0 || GetLastError() == ERROR_IO_PENDING)
                {
                    success = TRUE;
                    // The async write succeeded. Now get the number of bytes written.
#if IL2CPP_TARGET_WINDOWS_DESKTOP
                    if (GetOverlappedResult((HANDLE)handle, &overlapped, (LPDWORD)&written, TRUE) == 0)
#else
                    if (GetOverlappedResultEx((HANDLE)handle, &overlapped, (LPDWORD)&written, INFINITE, FALSE) == 0)
#endif
                    {
                        // Oops, we could not get the number of bytes writen, so return an error.
                        *error = GetLastError();
                        return -1;
                    }
                }
            }

            if (!success)
            {
                *error = originalError;
                return -1;
            }
        }

        return written;
    }

    bool File::Flush(FileHandle* handle, int* error)
    {
        *error = kErrorCodeSuccess;
        if (FlushFileBuffers((HANDLE)handle))
            return true;

        *error = FileWin32ErrorToErrorCode(::GetLastError());

        return false;
    }

    void File::Lock(FileHandle* handle,  int64_t position, int64_t length, int* error)
    {
        *error = kErrorCodeSuccess;

        OVERLAPPED overlapped;
        ZeroMemory(&overlapped, sizeof(overlapped));

        overlapped.Offset = position & 0xFFFFFFFF;
        overlapped.OffsetHigh = position >> 32;

        LARGE_INTEGER lengthUnion;
        lengthUnion.QuadPart = length;

        if (!::LockFileEx((HANDLE)handle, LOCKFILE_FAIL_IMMEDIATELY, 0, lengthUnion.LowPart, lengthUnion.HighPart, &overlapped))
            *error = FileWin32ErrorToErrorCode(::GetLastError());
    }

    void File::Unlock(FileHandle* handle,  int64_t position, int64_t length, int* error)
    {
        *error = kErrorCodeSuccess;

        OVERLAPPED overlapped;
        ZeroMemory(&overlapped, sizeof(overlapped));

        overlapped.Offset = position & 0xFFFFFFFF;
        overlapped.OffsetHigh = position >> 32;

        LARGE_INTEGER lengthUnion;
        lengthUnion.QuadPart = length;

        if (!::UnlockFileEx((HANDLE)handle, 0, lengthUnion.LowPart, lengthUnion.HighPart, &overlapped))
            *error = FileWin32ErrorToErrorCode(::GetLastError());
    }

    utils::Expected<bool> File::DuplicateHandle(FileHandle* source_process_handle, FileHandle* source_handle, FileHandle* target_process_handle,
        FileHandle** target_handle, int access, int inherit, int options, int* error)
    {
        /* This is only used on Windows */

        //MONO_PREPARE_BLOCKING;
        BOOL ret = ::DuplicateHandle((HANDLE)source_process_handle, (HANDLE)source_handle, (HANDLE)target_process_handle, (LPHANDLE)target_handle, access, inherit, options);
        //MONO_FINISH_BLOCKING;

        if (ret == FALSE)
        {
            *error = GetLastError();
            /* FIXME: throw an exception? */
            return false;
        }

        return true;
    }

    static bool ends_with(const std::string& value, const std::string& ending)
    {
        if (value.length() >= ending.length())
            return value.compare(value.length() - ending.length(), ending.length(), ending) == 0;
        return false;
    }

    utils::Expected<bool> File::IsExecutable(const std::string& path)
    {
        return ends_with(path, "exe");
    }

    bool File::Cancel(FileHandle* handle)
    {
        return CancelIoEx((HANDLE)handle, NULL);
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\File.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\FileSystemWatcher.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include <cassert>
#include "os/FileSystemWatcher.h"

namespace il2cpp
{
namespace os
{
namespace FileSystemWatcher
{
    int IsSupported()
    {
        return 1;
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\FileSystemWatcher.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Image.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/Memory.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/Image.h"

#include "WindowsHeaders.h"
#include <libloaderapi.h>
#include <cstdio>

EXTERN_C IMAGE_DOS_HEADER __ImageBase;

namespace il2cpp
{
namespace os
{
namespace Image
{
    static void InitializeManagedSection()
    {
        PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)(((char*)&__ImageBase) + __ImageBase.e_lfanew);
        PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)((char*)&ntHeaders->OptionalHeader + ntHeaders->FileHeader.SizeOfOptionalHeader);
        for (int i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++)
        {
            if (strncmp(IL2CPP_BINARY_SECTION_NAME, (char*)sectionHeader->Name, IMAGE_SIZEOF_SHORT_NAME) == 0)
            {
                void* start = (char*)&__ImageBase + sectionHeader->VirtualAddress;
                void* end = (char*)start + sectionHeader->Misc.VirtualSize;
                SetManagedSectionStartAndEnd(start, end);
            }
            sectionHeader++;
        }
    }

    void Initialize()
    {
        InitializeManagedSection();
    }

    void* GetImageBase()
    {
        return &__ImageBase;
    }

#if IL2CPP_ENABLE_NATIVE_INSTRUCTION_POINTER_EMISSION
    struct PdbInfo
    {
        DWORD     Signature;
        GUID      Guid;
        DWORD     Age;
        char      PdbFileName[1];
    };

    char* GetImageUUID()
    {
        uintptr_t base_pointer = (uintptr_t)((char*)&__ImageBase);

        PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)(base_pointer + __ImageBase.e_lfanew);
        IMAGE_DATA_DIRECTORY* dir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
        IMAGE_DEBUG_DIRECTORY* dbg_dir = (IMAGE_DEBUG_DIRECTORY*)(base_pointer + dir->VirtualAddress);

        if (IMAGE_DEBUG_TYPE_CODEVIEW == dbg_dir->Type)
        {
            PdbInfo* pdb_info = (PdbInfo*)(base_pointer + dbg_dir->AddressOfRawData);
            char* uuid = static_cast<char*>(IL2CPP_MALLOC(41));

            // Crash reporting expects the GUID without dashes (the format used by symbol servers)
            _snprintf_s(uuid, 41, 40, "%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX%X",
                (unsigned char)(pdb_info->Guid.Data1 >> 24),
                (unsigned char)(pdb_info->Guid.Data1 >> 16),
                (unsigned char)(pdb_info->Guid.Data1 >> 8),
                (unsigned char)pdb_info->Guid.Data1,
                (unsigned char)(pdb_info->Guid.Data2 >> 8),
                (unsigned char)pdb_info->Guid.Data2,
                (unsigned char)(pdb_info->Guid.Data3 >> 8),
                (unsigned char)pdb_info->Guid.Data3,
                pdb_info->Guid.Data4[0], pdb_info->Guid.Data4[1], pdb_info->Guid.Data4[2], pdb_info->Guid.Data4[3],
                pdb_info->Guid.Data4[4], pdb_info->Guid.Data4[5], pdb_info->Guid.Data4[6], pdb_info->Guid.Data4[7],
                pdb_info->Age);
            return uuid;
        }

        return NULL;
    }

    char* GetImageName()
    {
        char* name = static_cast<char*>(IL2CPP_MALLOC(MAX_PATH + 1));
        GetModuleFileNameA((HMODULE)&__ImageBase, name, MAX_PATH + 1);
        return name;
    }

#endif
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Image.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Initialize.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Initialize.h"
#if IL2CPP_TARGET_WINDOWS

#include "os/Environment.h"
#include "os/WindowsRuntime.h"

#include "DllMain.h"
#include <crtdbg.h>

void il2cpp::os::Initialize()
{
#ifdef _DEBUG
    std::string buildMachine = il2cpp::os::Environment::GetEnvironmentVariable("UNITY_THISISABUILDMACHINE");
    if (!buildMachine.empty())
    {
        _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);
        _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
    }
#endif

    // This is needed so we could extract exception text from bad hresults
    os::WindowsRuntime::EnableErrorReporting();
    os::InitializeDllMain();
}

#if !IL2CPP_TARGET_WINRT
void il2cpp::os::Uninitialize()
{
}

#endif

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Initialize.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\LastError.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/LastError.h"

#include "WindowsHeaders.h"

namespace il2cpp
{
namespace os
{
    uint32_t LastError::GetLastError()
    {
        return ::GetLastError();
    }
} /* namespace os */
} /* namespace il2cpp*/

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\LastError.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\LibraryLoader.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "il2cpp-runtime-metadata.h"
#include "os/LibraryLoader.h"
#include "os/Image.h"
#include "utils/StringUtils.h"

#include "WindowsHelpers.h"
#include "Evntprov.h"

#define WINNT // All functions in Evntrace.h are under this define.. Why? I have no idea!
#include "Evntrace.h"

#if IL2CPP_TARGET_WINDOWS_GAMES
#include "os/WindowsGames/Win32ApiWindowsGamesEmulation.h"
#endif

#include <bcrypt.h>

namespace il2cpp
{
namespace os
{
    const HardcodedPInvokeDependencyFunction kAdvapiFunctions[] =
    {
        HARDCODED_DEPENDENCY_FUNCTION(EnumerateTraceGuidsEx),
        HARDCODED_DEPENDENCY_FUNCTION(EventActivityIdControl),
        HARDCODED_DEPENDENCY_FUNCTION(EventRegister),
        HARDCODED_DEPENDENCY_FUNCTION(EventSetInformation),
        HARDCODED_DEPENDENCY_FUNCTION(EventUnregister),
        HARDCODED_DEPENDENCY_FUNCTION(EventWrite),
        HARDCODED_DEPENDENCY_FUNCTION(EventWriteEx),
        HARDCODED_DEPENDENCY_FUNCTION(EventWriteString),
        HARDCODED_DEPENDENCY_FUNCTION(EventWriteTransfer),
    };

    const HardcodedPInvokeDependencyFunction kKernel32Functions[] =
    {
        HARDCODED_DEPENDENCY_FUNCTION(FormatMessageW),
        HARDCODED_DEPENDENCY_FUNCTION(GetCurrentProcessId),
        HARDCODED_DEPENDENCY_FUNCTION(GetDynamicTimeZoneInformation),
        HARDCODED_DEPENDENCY_FUNCTION(GetNativeSystemInfo),
        HARDCODED_DEPENDENCY_FUNCTION(GetTimeZoneInformation),
        HARDCODED_DEPENDENCY_FUNCTION(GetFullPathNameW),
        HARDCODED_DEPENDENCY_FUNCTION(GetFileAttributesExW),
        HARDCODED_DEPENDENCY_FUNCTION(CreateDirectoryW),
        HARDCODED_DEPENDENCY_FUNCTION(CloseHandle),
        HARDCODED_DEPENDENCY_FUNCTION(CreateFileW),
        HARDCODED_DEPENDENCY_FUNCTION(DeleteFileW),
        HARDCODED_DEPENDENCY_FUNCTION(FindFirstFileExW),
        HARDCODED_DEPENDENCY_FUNCTION(FindNextFileW),
        HARDCODED_DEPENDENCY_FUNCTION(MoveFileExW),
        HARDCODED_DEPENDENCY_FUNCTION(MultiByteToWideChar),
        HARDCODED_DEPENDENCY_FUNCTION(RemoveDirectoryW),
        HARDCODED_DEPENDENCY_FUNCTION(ReplaceFileW),
        HARDCODED_DEPENDENCY_FUNCTION(SetFileAttributesW),
        HARDCODED_DEPENDENCY_FUNCTION(SetFileInformationByHandle),
        HARDCODED_DEPENDENCY_FUNCTION(GetFileInformationByHandleEx),
        HARDCODED_DEPENDENCY_FUNCTION(CopyFile2),
        HARDCODED_DEPENDENCY_FUNCTION(SetThreadErrorMode),
        HARDCODED_DEPENDENCY_FUNCTION(GetCurrentThread),
        HARDCODED_DEPENDENCY_FUNCTION(GetThreadDescription),
        HARDCODED_DEPENDENCY_FUNCTION(CopyFileExW),
        HARDCODED_DEPENDENCY_FUNCTION(DeleteVolumeMountPointW),
        HARDCODED_DEPENDENCY_FUNCTION(GetLogicalDrives),
        HARDCODED_DEPENDENCY_FUNCTION(LocalAlloc),
        HARDCODED_DEPENDENCY_FUNCTION(LocalReAlloc),
        HARDCODED_DEPENDENCY_FUNCTION(LocalFree),
    };

    const HardcodedPInvokeDependencyFunction kBCryptFunctions[] =
    {
        HARDCODED_DEPENDENCY_FUNCTION(BCryptGenRandom),
    };

    const HardcodedPInvokeDependencyFunction kiphlpapiFunctions[] =
    {
        HARDCODED_DEPENDENCY_FUNCTION(GetNetworkParams),
        HARDCODED_DEPENDENCY_FUNCTION(GetAdaptersAddresses),
        HARDCODED_DEPENDENCY_FUNCTION(GetIfEntry),
    };

#if !IL2CPP_TARGET_WINDOWS_GAMES
    const HardcodedPInvokeDependencyFunction kTimezoneFunctions[] =
    {
        HARDCODED_DEPENDENCY_FUNCTION(EnumDynamicTimeZoneInformation),
        HARDCODED_DEPENDENCY_FUNCTION(GetDynamicTimeZoneInformation),
        HARDCODED_DEPENDENCY_FUNCTION(GetDynamicTimeZoneInformationEffectiveYears),
        HARDCODED_DEPENDENCY_FUNCTION(GetTimeZoneInformationForYear),
    };

    const HardcodedPInvokeDependencyFunction kWinTypesFunctions[] =
    {
        HARDCODED_DEPENDENCY_FUNCTION(RoGetBufferMarshaler)
    };
#endif

// All these come without ".dll" extension!
    const HardcodedPInvokeDependencyLibrary kHardcodedPInvokeDependencies[] =
    {
#if IL2CPP_TARGET_WINDOWS_GAMES
        HARDCODED_DEPENDENCY_LIBRARY(L"bcrypt", kBCryptFunctions),
#else
        HARDCODED_DEPENDENCY_LIBRARY(L"advapi32", kAdvapiFunctions),
        HARDCODED_DEPENDENCY_LIBRARY(L"api-ms-win-core-timezone-l1-1-0", kTimezoneFunctions),
        HARDCODED_DEPENDENCY_LIBRARY(L"kernel32", kKernel32Functions),
        HARDCODED_DEPENDENCY_LIBRARY(L"iphlpapi", kiphlpapiFunctions),
        HARDCODED_DEPENDENCY_LIBRARY(L"wintypes", kWinTypesFunctions),
        HARDCODED_DEPENDENCY_LIBRARY(L"bcrypt", kBCryptFunctions),
#endif
    };

    const HardcodedPInvokeDependencyLibrary* LibraryLoader::HardcodedPInvokeDependencies = kHardcodedPInvokeDependencies;
    const size_t LibraryLoader::HardcodedPInvokeDependenciesCount = ARRAYSIZE(kHardcodedPInvokeDependencies);

    Baselib_DynamicLibrary_Handle LibraryLoader::ProbeForLibrary(const Il2CppNativeChar* libraryName, const size_t /*libraryNameLength*/, std::string& detailedError)
    {
        return TryOpeningLibrary(libraryName, detailedError);
    }

    Baselib_DynamicLibrary_Handle LibraryLoader::OpenProgramHandle(Baselib_ErrorState& errorState, bool& needsClosing)
    {
        needsClosing = false;
        return Baselib_DynamicLibrary_FromNativeHandle(reinterpret_cast<uint64_t>(Image::GetImageBase()), Baselib_DynamicLibrary_WinApiHMODULE, &errorState);
    }

    bool LibraryLoader::EntryNameMatches(const il2cpp::utils::StringView<char>& hardcodedEntryPoint, const il2cpp::utils::StringView<char>& entryPoint)
    {
        // Handle windows mapping generic to unicode methods. e.g. MoveFileEx -> MoveFileExW
        if (hardcodedEntryPoint.Length() == entryPoint.Length() || (hardcodedEntryPoint.Length() - 1 == entryPoint.Length() && hardcodedEntryPoint[hardcodedEntryPoint.Length() - 1] == 'W'))
        {
            return strncmp(hardcodedEntryPoint.Str(), entryPoint.Str(), entryPoint.Length()) == 0;
        }

        return false;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\LibraryLoader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Locale.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/Locale.h"
#include "WindowsHelpers.h"
#include <locale.h>
#include <vector>

namespace il2cpp
{
namespace os
{
#if IL2CPP_TARGET_WINDOWS_DESKTOP

    std::string Locale::GetLocale()
    {
        LCID lcid = GetThreadLocale();

        int number_of_characters = GetLocaleInfo(lcid, LOCALE_SNAME, NULL, 0);
        std::vector<WCHAR> locale_name(number_of_characters);
        if (GetLocaleInfo(lcid, LOCALE_SNAME, &locale_name[0], number_of_characters) == 0)
            return std::string();

        std::vector<char> locale_name_char(number_of_characters);
        if (WideCharToMultiByte(CP_ACP, 0, &locale_name[0], number_of_characters, &locale_name_char[0], number_of_characters, NULL, NULL) == 0)
            return std::string();

        return std::string(locale_name_char.begin(), locale_name_char.end());
    }

#endif

#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
    static _locale_t s_cLocale = NULL;
#endif

    void Locale::Initialize()
    {
#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
        s_cLocale = _create_locale(LC_ALL, "C");
#endif
    }

    void Locale::UnInitialize()
    {
#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
        _free_locale(s_cLocale);
        s_cLocale = NULL;
#endif
    }

#if IL2CPP_SUPPORT_LOCALE_INDEPENDENT_PARSING
    double Locale::DoubleParseLocaleIndependentImpl(char *ptr, char** endptr)
    {
        return _strtod_l(ptr, endptr, s_cLocale);
    }

#endif
} /* namespace os */
} /* namespace il2cpp */

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Locale.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\MarshalAlloc.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/MarshalAlloc.h"

#include "WindowsHeaders.h"
#include "Objbase.h"

namespace il2cpp
{
namespace os
{
    void* MarshalAlloc::Allocate(size_t size)
    {
        return ::CoTaskMemAlloc(size);
    }

    void* MarshalAlloc::ReAlloc(void* ptr, size_t size)
    {
        return ::CoTaskMemRealloc(ptr, size);
    }

    void MarshalAlloc::Free(void* ptr)
    {
        ::CoTaskMemFree(ptr);
    }

    void* MarshalAlloc::AllocateHGlobal(size_t size)
    {
        return ::GlobalAlloc(GMEM_FIXED, size);
    }

    void* MarshalAlloc::ReAllocHGlobal(void* ptr, size_t size)
    {
        return ::GlobalReAlloc(ptr, size, GMEM_MOVEABLE);
    }

    void MarshalAlloc::FreeHGlobal(void* ptr)
    {
        ::GlobalFree(ptr);
    }
} /* namespace os */
} /* namespace il2cpp*/

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\MarshalAlloc.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\MarshalStringAlloc.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_COM
#include "os/MarshalStringAlloc.h"
#include "WindowsHeaders.h"

namespace il2cpp
{
namespace os
{
    il2cpp_hresult_t MarshalStringAlloc::AllocateBStringLength(const Il2CppChar* text, int32_t length, Il2CppChar** bstr)
    {
        IL2CPP_ASSERT(bstr);
        *bstr = ::SysAllocStringLen(text, length);
        return *bstr ? IL2CPP_S_OK : IL2CPP_E_OUTOFMEMORY;
    }

    il2cpp_hresult_t MarshalStringAlloc::GetBStringLength(const Il2CppChar* bstr, int32_t* length)
    {
        IL2CPP_ASSERT(length);
        *length = ::SysStringLen((BSTR)bstr);
        return IL2CPP_S_OK;
    }

    il2cpp_hresult_t MarshalStringAlloc::FreeBString(Il2CppChar* bstr)
    {
        ::SysFreeString((BSTR)bstr);
        return IL2CPP_S_OK;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\MarshalStringAlloc.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Memory.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Memory.h"

#if IL2CPP_TARGET_WINDOWS

namespace il2cpp
{
namespace os
{
namespace Memory
{
    void* AlignedAlloc(size_t size, size_t alignment)
    {
        return _aligned_malloc(size, alignment);
    }

    void* AlignedReAlloc(void* memory, size_t newSize, size_t alignment)
    {
        return _aligned_realloc(memory, newSize, alignment);
    }

    void AlignedFree(void* memory)
    {
        return _aligned_free(memory);
    }
}
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Memory.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\MemoryMappedFile.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_MEMORY_MAPPED_FILE && IL2CPP_TARGET_WINDOWS

#include <map>
#include <limits>
#include "WindowsHelpers.h"
#include "os/MemoryMappedFile.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace os
{
    static DWORD ConvertMappedFileAccessToWindowsPageAccess(MemoryMappedFileAccess access)
    {
        switch (access)
        {
            case MMAP_FILE_ACCESS_READ:
                return PAGE_READONLY;
            case MMAP_FILE_ACCESS_READ_WRITE:
                return PAGE_READWRITE;
            case MMAP_FILE_ACCESS_COPY_ON_WRITE:
                return PAGE_WRITECOPY;
            case MMAP_FILE_ACCESS_READ_EXECUTE:
                return PAGE_EXECUTE_READ;
            case MMAP_FILE_ACCESS_READ_WRITE_EXECUTE:
                return PAGE_EXECUTE_READWRITE;
            default:
                IL2CPP_ASSERT("unknown MemoryMappedFileAccess");
        }

        return MMAP_FILE_ACCESS_READ;
    }

    static int ConvertMappedFileAccessToWindowsFileAccess(MemoryMappedFileAccess access)
    {
        switch (access)
        {
            case MMAP_FILE_ACCESS_READ:
                return FILE_MAP_READ;
            case MMAP_FILE_ACCESS_WRITE:
                return FILE_MAP_WRITE;
            case MMAP_FILE_ACCESS_READ_WRITE:
                return FILE_MAP_READ | FILE_MAP_WRITE;
            case MMAP_FILE_ACCESS_COPY_ON_WRITE:
                return FILE_MAP_COPY;
            case MMAP_FILE_ACCESS_READ_EXECUTE:
                return FILE_MAP_EXECUTE | FILE_MAP_READ;
            case MMAP_FILE_ACCESS_READ_WRITE_EXECUTE:
                return FILE_MAP_EXECUTE | FILE_MAP_READ | FILE_MAP_WRITE;
            default:
                IL2CPP_ASSERT("unknown MemoryMappedFileAccess");
        }

        return MMAP_FILE_ACCESS_READ;
    }

    static MemoryMappedFileError ConvertWindowsErrorToMemoryMappedFileError(DWORD error, MemoryMappedFileError defaultError)
    {
        switch (error)
        {
            case ERROR_FILE_NOT_FOUND:
                return FILE_NOT_FOUND;
            case ERROR_FILE_EXISTS:
            case ERROR_ALREADY_EXISTS:
                return FILE_ALREADY_EXISTS;
            case ERROR_ACCESS_DENIED:
                return ACCESS_DENIED;
        }
        return defaultError;
    }

    void MemoryMappedFile::AllocateStaticData()
    {
    }

    void MemoryMappedFile::FreeStaticData()
    {
    }

    FileHandle* MemoryMappedFile::Create(FileHandle* file, const char* mapName, int32_t mode, int64_t *capacity, MemoryMappedFileAccess access, int32_t options, MemoryMappedFileError* error)
    {
        HANDLE result = NULL;
        HANDLE handle = file != NULL ? file : INVALID_HANDLE_VALUE;

        if (handle == INVALID_HANDLE_VALUE)
        {
            if (*capacity <= 0 && mode != os::FILE_MODE_OPEN)
            {
                *error = CAPACITY_MUST_BE_POSITIVE;
                return NULL;
            }
#if IL2CPP_SIZEOF_VOID_P == 4
            if (*capacity > UINT32_MAX)
            {
                *error = CAPACITY_LARGER_THAN_LOGICAL_ADDRESS_SPACE;
                return NULL;
            }
#endif
            if (!(mode == FILE_MODE_CREATE_NEW || mode == FILE_MODE_OPEN_OR_CREATE || mode == FILE_MODE_OPEN))
            {
                *error = INVALID_FILE_MODE;
                return NULL;
            }
        }
        else
        {
            FILE_STANDARD_INFO info;
            if (!GetFileInformationByHandleEx(handle, FileStandardInfo, &info, sizeof(FILE_STANDARD_INFO)))
            {
                *error = ConvertWindowsErrorToMemoryMappedFileError(GetLastError(), COULD_NOT_OPEN);
                return NULL;
            }
            if (*capacity == 0)
            {
                if (info.EndOfFile.QuadPart == 0)
                {
                    *error = CAPACITY_SMALLER_THAN_FILE_SIZE;
                    return NULL;
                }
            }
            else if (*capacity < info.EndOfFile.QuadPart)
            {
                *error = CAPACITY_SMALLER_THAN_FILE_SIZE;
                return NULL;
            }
        }

        UTF16String utf16MapNameString = mapName != NULL ? il2cpp::utils::StringUtils::Utf8ToUtf16(mapName) : UTF16String();
        LPCWSTR utf16MapName = mapName != NULL ? utf16MapNameString.c_str() : NULL;

        if (mode == FILE_MODE_CREATE_NEW || handle != INVALID_HANDLE_VALUE)
        {
            result = CreateFileMapping(handle, NULL, ConvertMappedFileAccessToWindowsPageAccess(access) | options, (DWORD)(((uint64_t)*capacity) >> 32), (DWORD)*capacity, utf16MapName);
            if (result && GetLastError() == ERROR_ALREADY_EXISTS)
            {
                CloseHandle(result);
                result = NULL;
                *error = FILE_ALREADY_EXISTS;
            }
            else if (!result && GetLastError() != NO_ERROR)
            {
                *error = ConvertWindowsErrorToMemoryMappedFileError(GetLastError(), COULD_NOT_OPEN);
            }
        }
        else if (mode == FILE_MODE_OPEN || mode == FILE_MODE_OPEN_OR_CREATE && access == MMAP_FILE_ACCESS_WRITE)
        {
            result = OpenFileMappingW(ConvertMappedFileAccessToWindowsFileAccess(access), FALSE, utf16MapName);
            if (!result)
            {
                if (mode == FILE_MODE_OPEN_OR_CREATE && GetLastError() == ERROR_FILE_NOT_FOUND)
                {
                    *error = INVALID_FILE_MODE;
                }
                else
                {
                    *error = ConvertWindowsErrorToMemoryMappedFileError(GetLastError(), COULD_NOT_OPEN);
                }
            }
        }
        else if (mode == FILE_MODE_OPEN_OR_CREATE)
        {
            // This replicates how CoreFX does MemoryMappedFile.CreateOrOpen ().

            /// Try to open the file if it exists -- this requires a bit more work. Loop until we can
            /// either create or open a memory mapped file up to a timeout. CreateFileMapping may fail
            /// if the file exists and we have non-null security attributes, in which case we need to
            /// use OpenFileMapping.  But, there exists a race condition because the memory mapped file
            /// may have closed between the two calls -- hence the loop.
            ///
            /// The retry/timeout logic increases the wait time each pass through the loop and times
            /// out in approximately 1.4 minutes. If after retrying, a MMF handle still hasn't been opened,
            /// throw an InvalidOperationException.

            uint32_t waitRetries = 14;   //((2^13)-1)*10ms == approximately 1.4mins
            uint32_t waitSleep = 0;

            while (waitRetries > 0)
            {
                result = CreateFileMapping(handle, NULL, ConvertMappedFileAccessToWindowsPageAccess(access) | options, (DWORD)(((uint64_t)*capacity) >> 32), (DWORD)*capacity, utf16MapName);
                if (result)
                    break;
                if (GetLastError() != ERROR_ACCESS_DENIED)
                {
                    *error = ConvertWindowsErrorToMemoryMappedFileError(GetLastError(), COULD_NOT_OPEN);
                    break;
                }
                result = OpenFileMapping(ConvertMappedFileAccessToWindowsFileAccess(access), FALSE, utf16MapName);
                if (result)
                    break;
                if (GetLastError() != ERROR_FILE_NOT_FOUND)
                {
                    *error = ConvertWindowsErrorToMemoryMappedFileError(GetLastError(), COULD_NOT_OPEN);
                    break;
                }
                // increase wait time
                --waitRetries;
                if (waitSleep == 0)
                {
                    waitSleep = 10;
                }
                else
                {
                    Sleep(waitSleep);
                    waitSleep *= 2;
                }
            }

            if (!result)
                *error = COULD_NOT_OPEN;
        }

        return (os::FileHandle*)result;
    }

    MemoryMappedFile::MemoryMappedFileHandle MemoryMappedFile::View(FileHandle* mappedFileHandle, int64_t* length, int64_t offset, MemoryMappedFileAccess access, int64_t* actualOffset, MemoryMappedFileError* error)
    {
        IL2CPP_ASSERT(actualOffset != NULL);
        IL2CPP_ASSERT(offset <= std::numeric_limits<DWORD>::max());
        IL2CPP_ASSERT(*length <= std::numeric_limits<DWORD>::max());

        static DWORD allocationGranularity = 0;
        if (allocationGranularity == 0)
        {
            SYSTEM_INFO info;
            GetSystemInfo(&info);
            allocationGranularity = info.dwAllocationGranularity;
        }

        int64_t extraMemNeeded = offset % allocationGranularity;
        uint64_t newOffset = offset - extraMemNeeded;
        uint64_t nativeSize = (*length != 0) ? *length + extraMemNeeded : 0;
        *actualOffset = newOffset;

        void* address = MapViewOfFile((HANDLE)mappedFileHandle, ConvertMappedFileAccessToWindowsFileAccess(access), (DWORD)(newOffset >> 32), (DWORD)newOffset, (SIZE_T)nativeSize);
        if (address == NULL)
        {
            if (error != NULL)
                *error = ConvertWindowsErrorToMemoryMappedFileError(GetLastError(), COULD_NOT_MAP_MEMORY);

            CloseHandle(mappedFileHandle);
            return NULL;
        }

        // Query the view for its size and allocation type
        MEMORY_BASIC_INFORMATION viewInfo;
        VirtualQuery(address, &viewInfo, sizeof(MEMORY_BASIC_INFORMATION));
        uint64_t viewSize = (uint64_t)viewInfo.RegionSize;

        // Allocate the pages if we were using the MemoryMappedFileOptions.DelayAllocatePages option
        // OR check if the allocated view size is smaller than the expected native size
        // If multiple overlapping views are created over the file mapping object, the pages in a given region
        // could have different attributes(MEM_RESERVE OR MEM_COMMIT) as MapViewOfFile preserves coherence between
        // views created on a mapping object backed by same file.
        // In which case, the viewSize will be smaller than nativeSize required and viewState could be MEM_COMMIT
        // but more pages may need to be committed in the region.
        // This is because, VirtualQuery function(that internally invokes VirtualQueryEx function) returns the attributes
        // and size of the region of pages with matching attributes starting from base address.
        // VirtualQueryEx: http://msdn.microsoft.com/en-us/library/windows/desktop/aa366907(v=vs.85).aspx
        if (((viewInfo.State & MEM_RESERVE) != 0) || viewSize < (uint64_t)nativeSize)
        {
            void *tempAddress = VirtualAlloc(address, (SIZE_T)(nativeSize != 0 ? nativeSize : viewSize), MEM_COMMIT, ConvertMappedFileAccessToWindowsPageAccess(access));
            if (!tempAddress)
            {
                if (error != NULL)
                    *error = ConvertWindowsErrorToMemoryMappedFileError(GetLastError(), COULD_NOT_MAP_MEMORY);
                return NULL;
            }
            // again query the view for its new size
            VirtualQuery(address, &viewInfo, sizeof(MEMORY_BASIC_INFORMATION));
            viewSize = (uint64_t)viewInfo.RegionSize;
        }

        if (*length == 0)
            *length = viewSize - extraMemNeeded;

        return address;
    }

    void MemoryMappedFile::Flush(MemoryMappedFileHandle memoryMappedFileData, int64_t length)
    {
        BOOL success = FlushViewOfFile(memoryMappedFileData, (SIZE_T)length);
        if (success)
            return;

        // This replicates how CoreFX does MemoryMappedView.Flush ().

        // It is a known issue within the NTFS transaction log system that
        // causes FlushViewOfFile to intermittently fail with ERROR_LOCK_VIOLATION
        // As a workaround, we catch this particular error and retry the flush operation
        // a few milliseconds later. If it does not work, we give it a few more tries with
        // increasing intervals. Eventually, however, we need to give up. In ad-hoc tests
        // this strategy successfully flushed the view after no more than 3 retries.

        if (GetLastError() != ERROR_LOCK_VIOLATION)
            // TODO: Propagate error to caller
            return;

        // These control the retry behaviour when lock violation errors occur during Flush:
        const int MAX_FLUSH_WAITS = 15;  // must be <=30
        const int MAX_FLUSH_RETIRES_PER_WAIT = 20;

        for (int w = 0; w < MAX_FLUSH_WAITS; w++)
        {
            int pause = (1 << w);  // MaxFlushRetries should never be over 30
            Sleep(pause);

            for (int r = 0; r < MAX_FLUSH_RETIRES_PER_WAIT; r++)
            {
                if (FlushViewOfFile(memoryMappedFileData, (SIZE_T)length))
                    return;

                if (GetLastError() != ERROR_LOCK_VIOLATION)
                    // TODO: Propagate error to caller
                    return;

                SwitchToThread();
            }
        }

        // We got to here, so there was no success
        IL2CPP_ASSERT(false);
    }

    bool MemoryMappedFile::UnmapView(MemoryMappedFileHandle memoryMappedFileData, int64_t length)
    {
        if (memoryMappedFileData != NULL)
        {
            BOOL success = UnmapViewOfFile(memoryMappedFileData);
            IL2CPP_ASSERT(success);
            if (!success)
                return false;
        }

        return true;
    }

    bool MemoryMappedFile::Close(FileHandle* file)
    {
        BOOL success = CloseHandle(file);
        IL2CPP_ASSERT(success);
        return success;
    }

    void MemoryMappedFile::ConfigureHandleInheritability(FileHandle* file, bool inheritability)
    {
#if IL2CPP_TARGET_WINDOWS_DESKTOP
        BOOL success = SetHandleInformation((HANDLE)file, HANDLE_FLAG_INHERIT, inheritability ? HANDLE_FLAG_INHERIT : 0);
        IL2CPP_ASSERT(success);
#endif
    }

    bool MemoryMappedFile::OwnsDuplicatedFileHandle(FileHandle* file)
    {
        return true;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\MemoryMappedFile.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\NativeMethods.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "WindowsHelpers.h"

#include "os/NativeMethods.h"
#include "utils/Expected.h"
#include "utils/Il2CppError.h"

namespace il2cpp
{
namespace os
{
    bool NativeMethods::CloseProcess(ProcessHandle* handle)
    {
        return ::CloseHandle(handle) != FALSE;
    }

    utils::Expected<bool> NativeMethods::GetExitCodeProcess(ProcessHandle* handle, int32_t* exitCode)
    {
        return ::GetExitCodeProcess((HANDLE)handle, (LPDWORD)exitCode);
    }

    int32_t NativeMethods::GetCurrentProcessId()
    {
        return ::GetCurrentProcessId();
    }

    utils::Expected<ProcessHandle*> NativeMethods::GetCurrentProcess()
    {
        return (ProcessHandle*)::GetCurrentProcess();
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\NativeMethods.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Path.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "WindowsHeaders.h"
#undef GetTempPath

#include "os/Environment.h"
#include "os/Path.h"
#include "utils/PathUtils.h"
#include "utils/StringUtils.h"
#include "WindowsHelpers.h"
#include <string>

EXTERN_C IMAGE_DOS_HEADER __ImageBase;

namespace il2cpp
{
namespace os
{
    std::string Path::GetExecutablePath()
    {
        wchar_t buffer[MAX_PATH];
        GetModuleFileNameW(nullptr, buffer, MAX_PATH);
        return utils::StringUtils::Utf16ToUtf8(buffer);
    }

    std::string Path::GetApplicationFolder()
    {
        wchar_t buffer[MAX_PATH];
        GetModuleFileNameW(reinterpret_cast<HMODULE>(&__ImageBase), buffer, MAX_PATH);
        return utils::PathUtils::DirectoryName(utils::StringUtils::Utf16ToUtf8(buffer));
    }

    std::string Path::GetTempPath()
    {
#if IL2CPP_TARGET_GAMECORE_XBOX
        return "T:\\";
#else
        WCHAR tempPath[MAX_PATH + 1];
        ::GetTempPathW(sizeof(tempPath) / sizeof(tempPath[0]), tempPath);
#if !IL2CPP_TARGET_WINDOWS_GAMES
        ::GetLongPathNameW(tempPath, tempPath, sizeof(tempPath) / sizeof(tempPath[0]));
#endif // !IL2CPP_TARGET_WINDOWS_GAMES

        return utils::StringUtils::Utf16ToUtf8(tempPath);
#endif
    }

    bool Path::IsAbsolute(const std::string& path)
    {
        if (path[0] != '\0' && path[1] != '\0')
        {
            if (path[1] == ':' && path[2] != '\0' && (path[2] == '\\' || path[2] == '/'))
                return true;
            /* UNC paths */
            else if (path[0] == '\\' && path[1] == '\\' && path[2] != '\0')
                return true;
        }

        return false;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Path.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Process.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS_DESKTOP || IL2CPP_TARGET_WINDOWS_GAMES

#include "WindowsHelpers.h"
#include <Psapi.h>

#include "os/Process.h"

struct ProcessHandle
{
    HANDLE handle;
};

namespace il2cpp
{
namespace os
{
    int Process::GetCurrentProcessId()
    {
        return ::GetCurrentProcessId();
    }

    utils::Expected<ProcessHandle*> Process::GetProcess(int processId)
    {
        return (ProcessHandle*)OpenProcess(PROCESS_ALL_ACCESS, TRUE, processId);
    }

    void Process::FreeProcess(ProcessHandle* handle)
    {
        ::CloseHandle((HANDLE)handle);
    }

    utils::Expected<std::string> Process::GetProcessName(ProcessHandle* handle)
    {
        const size_t bufferLength = 256;
        WCHAR buf[bufferLength];

        DWORD length = ::GetModuleBaseName((HANDLE)handle, NULL, buf, bufferLength);

        if (length == 0)
            return std::string();

        char multiByteStr[bufferLength];

        size_t numConverted = wcstombs(multiByteStr, buf, bufferLength);
        if (numConverted <= 0)
            return std::string();

        return std::string(multiByteStr, numConverted);
    }

#if IL2CPP_TARGET_WINDOWS_GAMES
    intptr_t Process::GetMainWindowHandle(int32_t pid)
    {
        return 0;
    }

#else
    typedef struct
    {
        DWORD pid;
        HWND hwnd;
    } EnumWindowsArgs;

    static BOOL STDCALL Il2CppEnumWindowsCallback(HWND hwnd, LPARAM lparam)
    {
        EnumWindowsArgs* args = (EnumWindowsArgs*)lparam;
        DWORD pid = 0;
        GetWindowThreadProcessId(hwnd, &pid);
        if (pid != args->pid || GetWindow(hwnd, GW_OWNER) != NULL || !IsWindowVisible(hwnd)) return TRUE;
        args->hwnd = hwnd;
        return FALSE;
    }

    intptr_t Process::GetMainWindowHandle(int32_t pid)
    {
        EnumWindowsArgs args = { (DWORD)pid, 0 };
        EnumWindows(Il2CppEnumWindowsCallback, (LPARAM)&args);
        return (intptr_t)args.hwnd;
    }

#endif
}
}

#endif // IL2CPP_TARGET_WINDOWS_DESKTOP || IL2CPP_TARGET_WINDOWS_GAMES
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Process.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\SocketImpl.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_USE_GENERIC_SOCKET_IMPL && IL2CPP_TARGET_WINDOWS && IL2CPP_SUPPORT_SOCKETS

#include <time.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "WindowsHelpers.h"
#include <WinSock2.h>
#include <WS2tcpip.h>
#include <mswsock.h>
#include "os/Error.h"
#include "os/Socket.h"
#include "os/ErrorCodes.h"
#include "os/Win32/SocketImpl.h"
#include "utils/Il2CppError.h"
#include "utils/StringUtils.h"
#include "utils/Memory.h"

typedef int socklen_t;

namespace il2cpp
{
namespace os
{
    static bool is_loopback(int32_t family, uint8_t *addr)
    {
        if (family == AF_INET)
            return addr[0] == 127;
#if IL2CPP_SUPPORT_IPV6
        else if (family == AF_INET6)
            return (IN6_IS_ADDR_LOOPBACK((struct in6_addr *)addr));
#endif
        return false;
    }

    static struct in_addr *get_local_ips(int32_t family, int32_t *nips)
    {
        *nips = 0;

        return 0;
    }

    static bool hostent_get_info(struct hostent *he, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addresses)
    {
        if (he == NULL)
            return false;

        if (he->h_length != 4 || he->h_addrtype != AF_INET)
            return false;

        name.assign(he->h_name);

        for (int32_t i = 0; he->h_aliases[i] != NULL; ++i)
            aliases.push_back(he->h_aliases[i]);

        if (he->h_addrtype == AF_INET)
        {
            struct in_addr addr = {0};
            for (int32_t i = 0; he->h_addr_list[i] != NULL; ++i)
            {
                addr.s_addr = *(u_long*)he->h_addr_list[i];
                addresses.push_back(inet_ntoa(addr));
            }
        }

        return true;
    }

    static bool hostent_get_info_with_local_ips(struct hostent *he, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addresses)
    {
        int32_t i = 0;
        int32_t nlocal_in = 0;

        if (he != NULL)
        {
            if (he->h_length != 4 || he->h_addrtype != AF_INET)
                return false;

            name.assign(he->h_name);

            for (int32_t i = 0; he->h_aliases[i] != NULL; ++i)
                aliases.push_back(he->h_aliases[i]);
        }

        struct in_addr *local_in = get_local_ips(AF_INET, &nlocal_in);

        if (nlocal_in)
        {
            for (int32_t i = 0; i < nlocal_in; ++i)
                addresses.push_back(inet_ntoa(local_in[i]));

            free(local_in);
        }
        else if (he == NULL)
        {
            // If requesting "" and there are no other interfaces up, MS returns 127.0.0.1
            addresses.push_back("127.0.0.1");
            return true;
        }

        if (nlocal_in == 0 && he != NULL)
        {
            if (he->h_addrtype == AF_INET)
            {
                struct in_addr addr = {0};
                for (int32_t i = 0; he->h_addr_list[i] != NULL; ++i)
                {
                    addr.s_addr = *(u_long*)he->h_addr_list[i];
                    addresses.push_back(inet_ntoa(addr));
                }
            }
        }

        return true;
    }

    static int32_t convert_socket_flags(os::SocketFlags flags)
    {
        int32_t c_flags = 0;

        if (flags)
        {
            // Check if contains invalid flag values
            if (flags & ~(os::kSocketFlagsOutOfBand | os::kSocketFlagsMaxIOVectorLength | os::kSocketFlagsPeek | os::kSocketFlagsDontRoute | os::kSocketFlagsPartial))
            {
                return -1;
            }

            if (flags & os::kSocketFlagsOutOfBand)
                c_flags |= MSG_OOB;

            if (flags & os::kSocketFlagsPeek)
                c_flags |= MSG_PEEK;

            if (flags & os::kSocketFlagsDontRoute)
                c_flags |= MSG_DONTROUTE;

            // Ignore Partial - see bug 349688.  Don't return -1, because
            // according to the comment in that bug ms runtime doesn't for
            // UDP sockets (this means we will silently ignore it for TCP
            // too)

    #ifdef MSG_MORE
            if (flags & os::kSocketFlagsPartial)
                c_flags |= MSG_MORE;
    #endif
        }

        return c_flags;
    }

#if IL2CPP_SUPPORT_IPV6
    static void AddrinfoGetAddresses(struct addrinfo *info, std::string& name, bool add_local_ips,
        std::vector<std::string> &addr_list)
    {
        if (add_local_ips)
        {
            int nlocal_in = 0;
            int nlocal_in6 = 0;
            in_addr* local_in = (struct in_addr *)get_local_ips(AF_INET, &nlocal_in);
            in6_addr* local_in6 = (struct in6_addr *)get_local_ips(AF_INET6, &nlocal_in6);
            if (nlocal_in || nlocal_in6)
            {
                if (nlocal_in)
                {
                    for (int i = 0; i < nlocal_in; i++)
                    {
                        char addr[16];
                        inet_ntop(AF_INET, &local_in[i], addr, sizeof(addr));
                        addr_list.push_back(std::string(addr));
                    }
                }

                if (nlocal_in6)
                {
                    for (int i = 0; i < nlocal_in6; i++)
                    {
                        char addr[48];
                        const char* ret = inet_ntop(AF_INET6, &local_in6[i], addr, sizeof(addr));
                        if (ret != NULL)
                            addr_list.push_back(std::string(addr));
                    }
                }
            }

            free(local_in);
            free(local_in6);
        }

        bool nameSet = false;
        for (addrinfo* ai = info; ai != NULL; ai = ai->ai_next)
        {
            const char *ret;
            char buffer[48]; /* Max. size for IPv6 */

            if ((ai->ai_family != PF_INET) && (ai->ai_family != PF_INET6))
                continue;

            if (ai->ai_family == PF_INET)
                ret = inet_ntop(ai->ai_family, (void*)&(((struct sockaddr_in*)ai->ai_addr)->sin_addr), buffer, 16);
            else
                ret = inet_ntop(ai->ai_family, (void*)&(((struct sockaddr_in6*)ai->ai_addr)->sin6_addr), buffer, 48);

            if (ret)
                addr_list.push_back(std::string(buffer));
            else
                addr_list.push_back(std::string());

            if (!nameSet)
            {
                if (ai->ai_canonname != NULL)
                    name = std::string(ai->ai_canonname);
                else
                    name = std::string();

                nameSet = true;
            }
        }
    }

    WaitStatus GetAddressInfo(const char* hostname, bool add_local_ips, std::string &name, std::vector<std::string> &addr_list)
    {
        addrinfo *info = NULL;

        addrinfo hints;
        memset(&hints, 0, sizeof(hints));

        // Here Mono inspects the ipv4Supported and ipv6Supported properties on the managed Socket class.
        // This seems to be unnecessary though, as we can use PF_UNSPEC in all cases, and getaddrinfo works.
        hints.ai_family = PF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;

        if (getaddrinfo(hostname, NULL, &hints, &info) == -1)
            return kWaitStatusFailure;

        AddrinfoGetAddresses(info, name, add_local_ips, addr_list);

        if (info)
            freeaddrinfo(info);

        if (name.empty())
            name.assign(hostname);

        return kWaitStatusSuccess;
    }

#endif

    static WaitStatus GetHostByAddrIPv4(const std::string &address, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addr_list)
    {
        struct in_addr inaddr;
        if (inet_pton(AF_INET, address.c_str(), &inaddr) <= 0)
            return kWaitStatusFailure;

        struct hostent *he = gethostbyaddr((char*)&inaddr, sizeof(inaddr), AF_INET);

        if (he == NULL)
        {
            name = address;
            addr_list.push_back(name);

            return kWaitStatusSuccess;
        }

        return hostent_get_info(he, name, aliases, addr_list)
            ? kWaitStatusSuccess
            : kWaitStatusFailure;
    }

    WaitStatus SocketImpl::GetHostByAddr(const std::string &address, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addr_list)
    {
#if IL2CPP_SUPPORT_IPV6
        struct sockaddr_in saddr;
        struct sockaddr_in6 saddr6;
        int32_t family;
        char hostname[1024] = { 0 };
        int flags = 0;

        if (inet_pton(AF_INET, address.c_str(), &saddr.sin_addr) <= 0)
        {
            /* Maybe an ipv6 address */
            if (inet_pton(AF_INET6, address.c_str(), &saddr6.sin6_addr) <= 0)
            {
                return kWaitStatusFailure;
            }
            else
            {
                family = AF_INET6;
                saddr6.sin6_family = AF_INET6;
            }
        }
        else
        {
            family = AF_INET;
            saddr.sin_family = AF_INET;
        }

        if (family == AF_INET)
        {
            return GetHostByAddrIPv4(address, name, aliases, addr_list);
        }
        else if (family == AF_INET6)
        {
#if HAVE_SOCKADDR_IN6_SIN_LEN
            saddr6.sin6_len = sizeof(saddr6);
#endif
            if (getnameinfo((struct sockaddr*)&saddr6, sizeof(saddr6),
                hostname, sizeof(hostname), NULL, 0,
                flags) != 0)
            {
                return kWaitStatusFailure;
            }
        }

        return GetAddressInfo(hostname, true, name, addr_list);
#else
        return GetHostByAddrIPv4(address, name, aliases, addr_list);
#endif
    }

    WaitStatus SocketImpl::GetHostByName(const std::string &host, std::string &name, std::vector<std::string> &aliases, std::vector<std::string> &addresses)
    {
        char this_hostname[256] = {0};

        const char *hostname = host.c_str();
        bool add_local_ips = (*hostname == '\0');

        if (!add_local_ips && gethostname(this_hostname, sizeof(this_hostname)) != -1)
        {
            if (!strcmp(hostname, this_hostname))
                add_local_ips = true;
        }

#if IL2CPP_SUPPORT_IPV6
        return GetAddressInfo(hostname, add_local_ips, name, addresses);
#else
        struct hostent *he = NULL;
        if (*hostname)
            he = gethostbyname(hostname);

        if (*hostname && he == NULL)
            return kWaitStatusFailure;

        return (add_local_ips
            ? hostent_get_info_with_local_ips(he, name, aliases, addresses)
            : hostent_get_info(he, name, aliases, addresses))
            ? kWaitStatusSuccess
            : kWaitStatusFailure;
#endif
    }

    WaitStatus SocketImpl::GetHostByName(const std::string &host, std::string &name, int32_t &family, std::vector<std::string> &aliases, std::vector<void*> &addr_list, int32_t &addr_size)
    {
        std::vector<std::string> addresses;
        WaitStatus result = GetHostByName(host, name, aliases, addresses);

        addr_size = sizeof(in_addr);
        family = AF_INET;

        for (std::vector<std::string>::iterator it = addresses.begin(); it != addresses.end(); ++it)
        {
            void* addressLocation = il2cpp::utils::Memory::Malloc(addr_size);
            in_addr address;
            if (inet_pton(family, it->c_str(), &address))
            {
                memcpy(addressLocation, &address.S_un.S_addr, addr_size);
                addr_list.push_back(addressLocation);
            }
        }

        return result;
    }

    void SocketImpl::Startup()
    {
        WSADATA wsadata;

        const int32_t ret = WSAStartup(MAKEWORD(2, 0), &wsadata);
        if (ret != 0)
        {
            exit(-1);
        }
    }

    void SocketImpl::Cleanup()
    {
        WSACleanup();
    }

    WaitStatus SocketImpl::GetHostName(std::string &name)
    {
        char hostname[256];
        int32_t ret = gethostname(hostname, sizeof(hostname));

        if (ret == -1)
            return kWaitStatusFailure;

        name.assign(hostname);

        return kWaitStatusSuccess;
    }

    SocketImpl::SocketImpl(ThreadStatusCallback thread_status_callback)
        :   _is_valid(false)
        ,   _fd(-1)
        ,   _domain(-1)
        ,   _type(-1)
        ,   _protocol(-1)
        ,   _saved_error(kErrorCodeSuccess)
        ,   _still_readable(0)
        ,   _thread_status_callback(thread_status_callback)
    {
    }

    SocketImpl::~SocketImpl()
    {
    }

    static int32_t convert_address_family(AddressFamily family)
    {
        switch (family)
        {
            case kAddressFamilyUnspecified:
                return AF_UNSPEC;

            // NOTE(gab): not supported on Windows
            //case kAddressFamilyUnix:
            //  return AF_UNIX;

            case kAddressFamilyInterNetwork:
                return AF_INET;

            case kAddressFamilyIpx:
                return AF_IPX;

            case kAddressFamilySna:
                return AF_SNA;

            case kAddressFamilyDecNet:
                return AF_DECnet;

            case kAddressFamilyAppleTalk:
                return AF_APPLETALK;

#if IL2CPP_SUPPORT_IPV6
            case kAddressFamilyInterNetworkV6:
                return AF_INET6;
#endif

#ifdef AF_IRDA
            case kAddressFamilyIrda:
                return AF_IRDA;
#endif

            default:
                break;
        }

        return -1;
    }

    static int32_t convert_socket_type(SocketType type)
    {
        switch (type)
        {
            case kSocketTypeStream:
                return SOCK_STREAM;

            case kSocketTypeDgram:
                return SOCK_DGRAM;

            case kSocketTypeRaw:
                return SOCK_RAW;

            case kSocketTypeRdm:
                return SOCK_RDM;

            case kSocketTypeSeqpacket:
                return SOCK_SEQPACKET;

            default:
                break;
        }

        return -1;
    }

    static int32_t convert_socket_protocol(ProtocolType protocol)
    {
        switch (protocol)
        {
            case kProtocolTypeIP:
            case kProtocolTypeIPv6:
            case kProtocolTypeIcmp:
            case kProtocolTypeIgmp:
            case kProtocolTypeGgp:
            case kProtocolTypeTcp:
            case kProtocolTypePup:
            case kProtocolTypeUdp:
            case kProtocolTypeIdp:
            case kProtocolTypeIcmpV6:
                // In this case the enum values map exactly.
                return (int32_t)protocol;

            default:
                break;
        }

        // Everything else in unsupported and unexpected
        return -1;
    }

    static int SocketExceptionFilter(unsigned int code)
    {
        // Sometimes, we call the socket functions and close the socket right after,
        // and in some rare cases, it throws EXCEPTION_INVALID_HANDLE SEH exception
        // rather than returning an error code. Although this is undocumented on MSDN,
        // it causes a crash just because it thinks we gave it an invalid handle.
        // We guard against it by wrapping every socket call with __try/__except
        if (code == EXCEPTION_INVALID_HANDLE)
            return EXCEPTION_CONTINUE_EXECUTION;

        return EXCEPTION_CONTINUE_SEARCH;
    }

    WaitStatus SocketImpl::Create(AddressFamily family, SocketType type, ProtocolType protocol)
    {
        _fd = -1;
        _is_valid = false;
        _still_readable = 1;
        _domain = convert_address_family(family);
        _type = convert_socket_type(type);
        _protocol = convert_socket_protocol(protocol);

        IL2CPP_ASSERT(_type != -1 && "Unsupported socket type");
        IL2CPP_ASSERT(_domain != -1 && "Unsupported address family");
        IL2CPP_ASSERT(_protocol != -1 && "Unsupported protocol type");

        _fd = socket(_domain, _type, _protocol);
        if (_fd == -1 && _domain == AF_INET && _type == SOCK_RAW && _protocol == 0)
        {
            // Retry with protocol == 4 (see bug #54565)
            _protocol = 4;
            _fd = socket(AF_INET, SOCK_RAW, 4);
        }

        if (_fd == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        _is_valid = true;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Create(SocketDescriptor fd, int32_t family, int32_t type, int32_t protocol)
    {
        _fd = fd;
        _is_valid = (fd != -1);
        _still_readable = 1;
        _domain = family;
        _type = type;
        _protocol = protocol;

        IL2CPP_ASSERT(_type != -1 && "Unsupported socket type");
        IL2CPP_ASSERT(_domain != -1 && "Unsupported address family");
        IL2CPP_ASSERT(_protocol != -1 && "Unsupported protocol type");

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Close()
    {
        _saved_error = kErrorCodeSuccess;

        SOCKET fd = (SOCKET)_fd;
        if (_is_valid && fd != -1)
        {
            if (closesocket(fd) == -1)
                StoreLastError();
        }

        _fd = -1;
        _is_valid = false;
        _still_readable = 0;
        _domain = -1;
        _type = -1;
        _protocol = -1;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::SetBlocking(bool blocking)
    {
        /*
        * block == TRUE/FALSE means we will block/not block.
        * But the ioctlsocket call takes TRUE/FALSE for non-block/block
        */
        u_long ioctl_socket_blocking = (u_long) !blocking;

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int32_t ret = -1;

        __try
        {
            ret = ioctlsocket(fd, FIONBIO, &ioctl_socket_blocking);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (ret == SOCKET_ERROR)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    ErrorCode SocketImpl::GetLastError() const
    {
        return _saved_error;
    }

    void SocketImpl::StoreLastError()
    {
        const ErrorCode error = (ErrorCode)WSAGetLastError();

        Error::SetLastError(error);

        _saved_error = error;
    }

    void SocketImpl::StoreLastError(int32_t error_no)
    {
        const ErrorCode error = (ErrorCode)error_no;

        Error::SetLastError(error);

        _saved_error = error;
    }

    static void sockaddr_from_address(uint32_t address, uint16_t port, struct sockaddr *sa, socklen_t *sa_size)
    {
        struct sockaddr_in sa_in = {0};

        sa_in.sin_family = AF_INET;
        sa_in.sin_port = port;
        sa_in.sin_addr.s_addr = address;

        *sa_size = sizeof(struct sockaddr_in);
        *sa = *((struct sockaddr*)&sa_in);
    }

#if IL2CPP_SUPPORT_IPV6
    static void sockaddr_from_address(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, sockaddr_in6* sa, socklen_t *sa_size)
    {
        sa->sin6_family = AF_INET6;
        sa->sin6_port = port;
        memcpy(&sa->sin6_addr, &address[0], 16);
        sa->sin6_scope_id = scope;

        *sa_size = sizeof(struct sockaddr_in6);
    }

#endif

    static AddressFamily convert_define_to_address_family(int32_t family)
    {
        switch (family)
        {
            case AF_UNSPEC:
                return kAddressFamilyUnspecified;

            case AF_UNIX:
                return kAddressFamilyUnix;

            case AF_INET:
                return kAddressFamilyInterNetwork;
#ifdef AF_IPX
            case AF_IPX:
                return kAddressFamilyIpx;
#endif
#ifdef AF_SNA
            case AF_SNA:
                return kAddressFamilySna;
#endif
#ifdef AF_DECnet
            case AF_DECnet:
                return kAddressFamilyDecNet;
#endif
#ifdef AF_APPLETALK
            case AF_APPLETALK:
                return kAddressFamilyAppleTalk;
#endif
#ifdef AF_INET6
            case AF_INET6:
                return kAddressFamilyInterNetworkV6;
#endif
#ifdef AF_IRDA
            case AF_IRDA:
                return kAddressFamilyIrda;
#endif

            default:
                break;
        }

        return kAddressFamilyError;
    }

    static bool socketaddr_to_endpoint_info(const struct sockaddr *address, socklen_t address_len, EndPointInfo &info)
    {
        info.family = convert_define_to_address_family(address->sa_family);

        if (info.family == os::kAddressFamilyInterNetwork)
        {
            const struct sockaddr_in *address_in = (const struct sockaddr_in *)address;

            info.data.inet.port = ntohs(address_in->sin_port);
            info.data.inet.address = ntohl(address_in->sin_addr.s_addr);

            return true;
        }

        // NOTE(gab): kAddressFamilyUnix not supported on Windows
        //if (info.family == os::kAddressFamilyUnix)
        //{
        //  for (int32_t i = 0; i < address_len; i++)
        //      info.data.path[i] = address->sa_data[i];

        //  return true;
        //}

#if IL2CPP_SUPPORT_IPV6
        if (info.family == os::kAddressFamilyInterNetworkV6)
        {
            const struct sockaddr_in6 *address_in = (const struct sockaddr_in6 *)address;

            uint16_t port = ntohs(address_in->sin6_port);

            info.data.raw[2] = (port >> 8) & 0xff;
            info.data.raw[3] = port & 0xff;

            for (int i = 0; i < 16; i++)
                info.data.raw[i + 8] = address_in->sin6_addr.s6_addr[i];

            info.data.raw[24] = address_in->sin6_scope_id & 0xff;
            info.data.raw[25] = (address_in->sin6_scope_id >> 8) & 0xff;
            info.data.raw[26] = (address_in->sin6_scope_id >> 16) & 0xff;
            info.data.raw[27] = (address_in->sin6_scope_id >> 24) & 0xff;

            return true;
        }
#endif

        return false;
    }

    WaitStatus SocketImpl::Bind(const char *path)
    {
        // NOTE(gab): not supported on Windows.
        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Bind(const char *address, uint16_t port)
    {
        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(inet_addr(address), htons(port), &sa, &sa_size);

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int bindResult = -1;

        __try
        {
            bindResult = bind(fd, &sa, sa_size);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (bindResult == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Bind(uint32_t address, uint16_t port)
    {
        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int bindResult = -1;

        __try
        {
            bindResult = bind(fd, &sa, sa_size);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (bindResult == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Bind(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        if (bind((SOCKET)_fd, (sockaddr*)&sa, sa_size) == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::ConnectInternal(struct sockaddr *sa, int32_t sa_size)
    {
        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        __try
        {
            if (connect(fd, sa, (socklen_t)sa_size) != -1)
                return kWaitStatusSuccess;

            if (errno != EINTR)
            {
                StoreLastError();
                return kWaitStatusFailure;
            }

            struct pollfd fds = { 0 };

            fds.fd = fd;
            fds.events = POLLOUT;

            while (WSAPoll(&fds, 1, -1) == -1)
            {
                if (errno != EINTR)
                {
                    StoreLastError();
                    return kWaitStatusFailure;
                }
            }

            int32_t so_error = 0;
            socklen_t len = sizeof(so_error);

            if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (char*)&so_error, &len) == -1)
            {
                StoreLastError();
                return kWaitStatusFailure;
            }

            if (so_error != 0)
            {
                StoreLastError(so_error);
                return kWaitStatusFailure;
            }
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
            SetLastError(kWSAeshutdown);
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Connect(const char *path)
    {
        // NOTE(gab): not supported on Windows.
        return kWaitStatusFailure;
    }

    WaitStatus SocketImpl::Connect(uint32_t address, uint16_t port)
    {
        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        return ConnectInternal((struct sockaddr *)&sa, sa_size);
    }

    WaitStatus SocketImpl::Connect(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port)
    {
        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        return ConnectInternal((struct sockaddr *)&sa, sa_size);
    }

    WaitStatus SocketImpl::GetLocalEndPointInfo(EndPointInfo &info)
    {
        // Note: the size here could probably be smaller
        uint8_t buffer[END_POINT_MAX_PATH_LEN + 3] = {0};
        socklen_t address_len = sizeof(buffer);

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int getsocknameResult = -1;

        __try
        {
            getsocknameResult = getsockname(fd, (struct sockaddr *)buffer, &address_len);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
            SetLastError(kWSAeshutdown);
            return kWaitStatusFailure;
        }

        if (getsocknameResult == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        if (!socketaddr_to_endpoint_info((struct sockaddr *)buffer, address_len, info))
        {
            _saved_error = kWSAeafnosupport;
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::GetRemoteEndPointInfo(EndPointInfo &info)
    {
        // Note: the size here could probably be smaller
        uint8_t buffer[END_POINT_MAX_PATH_LEN + 3] = {0};
        socklen_t address_len = sizeof(buffer);

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int getpeernameResult = -1;

        __try
        {
            getpeernameResult = getpeername(fd, (struct sockaddr *)buffer, &address_len);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (getpeernameResult == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        if (!socketaddr_to_endpoint_info((struct sockaddr *)buffer, address_len, info))
        {
            _saved_error = kWSAeafnosupport;
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Listen(int32_t backlog)
    {
        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int listenResult = -1;

        __try
        {
            listenResult = listen(fd, backlog);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (listenResult == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Shutdown(int32_t how)
    {
        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int shutdownResult = -1;

        __try
        {
            shutdownResult = shutdown(fd, how);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (shutdownResult == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        if (how == SD_RECEIVE || how == SD_BOTH)
            _still_readable = 0;

        return kWaitStatusSuccess;
    }

    static SOCKET AcceptProtected(SOCKET fd)
    {
        SOCKET new_fd;

        do
        {
            __try
            {
                new_fd = accept(fd, NULL, 0);
            }
            __except (SocketExceptionFilter(GetExceptionCode()))
            {
                new_fd = -1;
                break;
            }
        }
        while (new_fd == -1 && errno == EINTR);

        return new_fd;
    }

    WaitStatus SocketImpl::Accept(os::Socket **socket)
    {
        SocketDescriptor new_fd = 0;

        *socket = NULL;

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        new_fd = AcceptProtected(fd);

        if (new_fd == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        *socket = new os::Socket(_thread_status_callback);

        const WaitStatus status = (*socket)->Create(new_fd, _domain, _type, _protocol);

        if (status != kWaitStatusSuccess)
        {
            delete *socket;
            *socket = NULL;
            return status;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Disconnect(bool reuse)
    {
        GUID GuidDisconnectEx = WSAID_DISCONNECTEX;
        LPFN_DISCONNECTEX disconnectEx;
        DWORD copied;

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        __try
        {
            int32_t ret = WSAIoctl(fd, SIO_GET_EXTENSION_FUNCTION_POINTER, &GuidDisconnectEx, sizeof(GuidDisconnectEx), &disconnectEx, sizeof(disconnectEx), &copied, 0, 0);

            if (ret == SOCKET_ERROR)
            {
                StoreLastError();
                return kWaitStatusFailure;
            }

            if (!disconnectEx(fd, NULL, 0, NULL))
            {
                StoreLastError();
                return kWaitStatusFailure;
            }
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Receive(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        *len = 0;

        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        return ReceiveFromInternal(data, count, c_flags, len, NULL, 0);
    }

    WaitStatus SocketImpl::ReceiveFromInternal(const uint8_t *data, size_t count, int32_t flags, int32_t *len, struct sockaddr *from, int32_t *fromlen)
    {
        int32_t ret = 0;
        IL2CPP_ASSERT(count < static_cast<size_t>(std::numeric_limits<int>::max()));

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        do
        {
            __try
            {
                ret = recvfrom(fd, (char*)data, static_cast<int>(count), flags, from, (socklen_t*)fromlen);
            }
            __except (SocketExceptionFilter(GetExceptionCode()))
            {
                ret = -1;
                break;
            }
        }
        while (ret == -1 && errno == EINTR);

        if (ret == 0 && count > 0)
        {
            // According to the Linux man page, recvfrom only
            // returns 0 when the socket has been shut down
            // cleanly.  Turn this into an EINTR to simulate win32
            // behaviour of returning EINTR when a socket is
            // closed while the recvfrom is blocking (we use a
            // shutdown() in socket_close() to trigger this.) See
            // bug 75705.

            // Distinguish between the socket being shut down at
            // the local or remote ends, and reads that request 0
            // bytes to be read

            // If this returns FALSE, it means the socket has been
            // closed locally.  If it returns TRUE, but
            // still_readable != 1 then shutdown
            // (SHUT_RD|SHUT_RDWR) has been called locally.

            if (_still_readable != 1)
            {
                ret = -1;
                errno = EINTR;
            }
        }

        if (ret == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        *len = ret;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Send(const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        *len = 0;

        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int32_t ret = 0;

        do
        {
            __try
            {
                ret = send(fd, (char*)data, count, flags);
            }
            __except (SocketExceptionFilter(GetExceptionCode()))
            {
                ret = -1;
                break;
            }
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        *len = ret;
        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::SendArray(WSABuf *wsabufs, int32_t count, int32_t *sent, SocketFlags flags)
    {
        DWORD c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        DWORD bytes_sent;

        int32_t ret = -1;

        __try
        {
            ret = WSASend(fd, (WSABUF*)wsabufs, count, &bytes_sent, c_flags, NULL, NULL);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (ret == SOCKET_ERROR)
        {
            *sent = 0;

            StoreLastError();

            return kWaitStatusFailure;
        }

        *sent = bytes_sent;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::ReceiveArray(WSABuf *wsabufs, int32_t count, int32_t *len, SocketFlags flags)
    {
        DWORD recv;
        DWORD c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int32_t ret = -1;

        __try
        {
            // NOTE(gab): this cast is possible as long as WSABuf is binary compatible with WSABUF
            ret = WSARecv(fd, (WSABUF*)wsabufs, count, &recv, &c_flags, NULL, NULL);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (ret == SOCKET_ERROR)
        {
            *len = 0;

            StoreLastError();

            return kWaitStatusFailure;
        }

        *len = recv;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::SendToInternal(struct sockaddr *sa, int32_t sa_size, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int32_t ret = 0;

        do
        {
            __try
            {
                ret = sendto(fd, (char*)data, count, c_flags, sa, sa_size);
            }
            __except (SocketExceptionFilter(GetExceptionCode()))
            {
                ret = -1;
                break;
            }
        }
        while (ret == -1 && errno == EINTR);

        if (ret == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        *len = ret;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::SendTo(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        *len = 0;

        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        return SendToInternal(&sa, sa_size, data, count, flags, len);
    }

    utils::Expected<WaitStatus> SocketImpl::SendTo(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        return utils::Il2CppError(utils::NotSupported, "Unix sockets are not supported on this platform.");
    }

    WaitStatus SocketImpl::SendTo(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len)
    {
        *len = 0;

        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        return SendToInternal((sockaddr*)&sa, sa_size, data, count, flags, len);
    }

    WaitStatus SocketImpl::RecvFromInternal(struct sockaddr* sa, int32_t sa_size, const uint8_t* data, int32_t count, os::SocketFlags flags, int32_t* len, os::EndPointInfo& ep)
    {
        const int32_t c_flags = convert_socket_flags(flags);

        if (c_flags == -1)
        {
            _saved_error = kWSAeopnotsupp;
            return kWaitStatusFailure;
        }

        int32_t ret = 0;

        const WaitStatus status = ReceiveFromInternal(data, count, c_flags, len, sa, &sa_size);

        if (status != kWaitStatusSuccess)
        {
            ep.family = os::kAddressFamilyError;
            return status;
        }

        if (sa_size == 0)
            return kWaitStatusSuccess;

        if (!socketaddr_to_endpoint_info(sa, sa_size, ep))
        {
            ep.family = os::kAddressFamilyError;
            _saved_error = kWSAeafnosupport;
            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::RecvFrom(uint32_t address, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        *len = 0;

        struct sockaddr sa = {0};
        socklen_t sa_size = 0;

        sockaddr_from_address(htonl(address), htons(port), &sa, &sa_size);

        return RecvFromInternal(&sa, sa_size, data, count, flags, len, ep);
    }

    utils::Expected<WaitStatus> SocketImpl::RecvFrom(const char *path, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        return utils::Il2CppError(utils::NotSupported, "Unix sockets are not supported on this platform.");
    }

    WaitStatus SocketImpl::RecvFrom(uint8_t address[ipv6AddressSize], uint32_t scope, uint16_t port, const uint8_t *data, int32_t count, os::SocketFlags flags, int32_t *len, os::EndPointInfo &ep)
    {
        *len = 0;

        struct sockaddr_in6 sa = { 0 };
        socklen_t sa_size = 0;

        sockaddr_from_address(address, scope, htons(port), &sa, &sa_size);

        return RecvFromInternal((sockaddr*)&sa, sa_size, data, count, flags, len, ep);
    }

    WaitStatus SocketImpl::Available(int32_t *amount)
    {
        *amount = 0;

        u_long a = 0;

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int ioctlsocketResult = -1;

        __try
        {
            ioctlsocketResult = ioctlsocket(fd, FIONREAD, &a);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (ioctlsocketResult == -1)
        {
            StoreLastError();
            return kWaitStatusFailure;
        }

        *amount = a;

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Ioctl(int32_t command, const uint8_t *in_data, int32_t in_len, uint8_t *out_data, int32_t out_len, int32_t *written)
    {
        IL2CPP_ASSERT(command != 0xC8000006 /* SIO_GET_EXTENSION_FUNCTION_POINTER */ && "SIO_GET_EXTENSION_FUNCTION_POINTER ioctl command not supported");

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        DWORD len = 0;
        int32_t ret = -1;

        __try
        {
            ret = WSAIoctl(fd, command, (void*)in_data, in_len, out_data, out_len, &len, NULL, NULL);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (ret == SOCKET_ERROR)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        *written = len;

        return kWaitStatusSuccess;
    }

#define     SKIP_OPTION         -2
#define     INVALID_OPTION_NAME -1

    static int32_t level_and_name_to_system(SocketOptionLevel level, SocketOptionName name, int32_t *system_level, int32_t *system_name)
    {
        switch (level)
        {
            case kSocketOptionLevelSocket:
                *system_level = SOL_SOCKET;

                switch (name)
                {
                    // This is SO_LINGER, because the setsockopt
                    // internal call maps DontLinger to SO_LINGER
                    // with l_onoff=0
                    case kSocketOptionNameDontLinger:
                        *system_name = SO_LINGER;
                        break;

                    case kSocketOptionNameDebug:
                        *system_name = SO_DEBUG;
                        break;

                    // #ifdef SO_ACCEPTCONN
                    case kSocketOptionNameAcceptConnection:
                        *system_name = SO_ACCEPTCONN;
                        break;
                    // #endif
                    case kSocketOptionNameReuseAddress:
                        *system_name = SO_REUSEADDR;
                        break;

                    case kSocketOptionNameKeepAlive:
                        *system_name = SO_KEEPALIVE;
                        break;

                    case kSocketOptionNameDontRoute:
                        *system_name = SO_DONTROUTE;
                        break;

                    case kSocketOptionNameBroadcast:
                        *system_name = SO_BROADCAST;
                        break;

                    case kSocketOptionNameLinger:
                        *system_name = SO_LINGER;
                        break;

                    case kSocketOptionNameOutOfBandInline:
                        *system_name = SO_OOBINLINE;
                        break;

                    case kSocketOptionNameSendBuffer:
                        *system_name = SO_SNDBUF;
                        break;

                    case kSocketOptionNameReceiveBuffer:
                        *system_name = SO_RCVBUF;
                        break;

                    case kSocketOptionNameSendLowWater:
                        *system_name = SO_SNDLOWAT;
                        break;

                    case kSocketOptionNameReceiveLowWater:
                        *system_name = SO_RCVLOWAT;
                        break;

                    case kSocketOptionNameSendTimeout:
                        *system_name = SO_SNDTIMEO;
                        break;

                    case kSocketOptionNameReceiveTimeout:
                        *system_name = SO_RCVTIMEO;
                        break;

                    case kSocketOptionNameError:
                        *system_name = SO_ERROR;
                        break;

                    case kSocketOptionNameType:
                        *system_name = SO_TYPE;
                        break;

                    case kSocketOptionNameExclusiveAddressUse:
        #ifdef SO_EXCLUSIVEADDRUSE
                        *system_name = SO_EXCLUSIVEADDRUSE;
                        break;
        #elif SO_REUSEADDR
                        *system_name = SO_REUSEADDR;
                        break;
        #endif
                    case kSocketOptionNameUseLoopback:
        #ifdef SO_USELOOPBACK
                        *system_name = SO_USELOOPBACK;
                        break;
        #endif
                    case kSocketOptionNameMaxConnections:
        #ifdef SO_MAXCONN
                        *system_name = SO_MAXCONN;
                        break;
        #elif defined(SOMAXCONN)
                        *system_name = SOMAXCONN;
                        break;
        #endif
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;

            case kSocketOptionLevelIP:
                *system_level = IPPROTO_IP;

                switch (name)
                {
                    case kSocketOptionNameIPOptions:
                        *system_name = IP_OPTIONS;
                        break;

        #ifdef IP_HDRINCL
                    case kSocketOptionNameHeaderIncluded:
                        *system_name = IP_HDRINCL;
                        break;
        #endif
        #ifdef IP_TOS
                    case kSocketOptionNameTypeOfService:
                        *system_name = IP_TOS;
                        break;
        #endif
        #ifdef IP_TTL
                    case kSocketOptionNameIpTimeToLive:
                        *system_name = IP_TTL;
                        break;
        #endif
                    case kSocketOptionNameMulticastInterface:
                        *system_name = IP_MULTICAST_IF;
                        break;

                    case kSocketOptionNameMulticastTimeToLive:
                        *system_name = IP_MULTICAST_TTL;
                        break;

                    case kSocketOptionNameMulticastLoopback:
                        *system_name = IP_MULTICAST_LOOP;
                        break;

                    case kSocketOptionNameAddMembership:
                        *system_name = IP_ADD_MEMBERSHIP;
                        break;

                    case kSocketOptionNameDropMembership:
                        *system_name = IP_DROP_MEMBERSHIP;
                        break;

        #ifdef HAVE_IP_PKTINFO
                    case kSocketOptionNamePacketInformation:
                        *system_name = IP_PKTINFO;
                        break;
        #endif

                    case kSocketOptionNameDontFragment:
        #ifdef IP_DONTFRAGMENT
                        *system_name = IP_DONTFRAGMENT;
        #elif IP_MTU_DISCOVER
                        *system_name = IP_MTU_DISCOVER;
        #elif IP_DONTFRAG
                        *system_name = IP_DONTFRAG;
        #else
                        return SKIP_OPTION;
        #endif
                        break;

                    case kSocketOptionNameAddSourceMembership:
                    case kSocketOptionNameDropSourceMembership:
                    case kSocketOptionNameBlockSource:
                    case kSocketOptionNameUnblockSource:
                    // Can't figure out how to map these, so fall
                    // through
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;
#if IL2CPP_SUPPORT_IPV6
            case kSocketOptionLevelIPv6:
                *system_level = IPPROTO_IPV6;

                switch (name)
                {
                    case kSocketOptionNameMulticastInterface:
                        *system_name = IPV6_MULTICAST_IF;
                        break;
                    case kSocketOptionNameMulticastTimeToLive:
                        *system_name = IPV6_MULTICAST_HOPS;
                        break;
                    case kSocketOptionNameMulticastLoopback:
                        *system_name = IPV6_MULTICAST_LOOP;
                        break;
                    case kSocketOptionNameAddMembership:
                        *system_name = IPV6_JOIN_GROUP;
                        break;
                    case kSocketOptionNameDropMembership:
                        *system_name = IPV6_LEAVE_GROUP;
                        break;
                    case kSocketOptionNamePacketInformation:
#ifdef HAVE_IPV6_PKTINFO
                        *system_name = IPV6_PKTINFO;
                        break;
#endif
                    case kSocketOptionNameIPv6Only:
#ifdef IPV6_V6ONLY
                        *system_name = IPV6_V6ONLY;
                        break;
#endif
                    case kSocketOptionNameHeaderIncluded:
                    case kSocketOptionNameIPOptions:
                    case kSocketOptionNameTypeOfService:
                    case kSocketOptionNameDontFragment:
                    case kSocketOptionNameAddSourceMembership:
                    case kSocketOptionNameDropSourceMembership:
                    case kSocketOptionNameBlockSource:
                    case kSocketOptionNameUnblockSource:
                    // Can't figure out how to map these, so fall
                    // through
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;
#endif // IL2CPP_SUPPORT_IPV6
            case kSocketOptionLevelTcp:
#ifdef SOL_TCP
                *system_level = SOL_TCP;
#else
                *system_level = IPPROTO_TCP;
#endif

                switch (name)
                {
                    case kSocketOptionNameNoDelay:
                        *system_name = TCP_NODELAY;
                        break;
                    default:
                        return INVALID_OPTION_NAME;
                }
                break;

            case kSocketOptionLevelUdp:
            default:
                return INVALID_OPTION_NAME;
        }

        return 0;
    }

    WaitStatus SocketImpl::GetSocketOption(SocketOptionLevel level, SocketOptionName name, uint8_t *buffer, int32_t *length)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            *((int32_t*)buffer) = 0;
            *length = sizeof(int32_t);

            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        uint8_t *tmp_val = buffer;

        int32_t ret = -1;

        __try
        {
            ret = getsockopt(fd, system_level, system_name, (char*)tmp_val, (socklen_t*)length);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (ret == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        if (system_name == SO_ERROR)
        {
            if (*((int32_t*)buffer) != 0)
            {
                StoreLastError(*((int32_t*)buffer));
            }
            else
            {
                *((int32_t*)buffer) = _saved_error;
            }
        }

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::GetSocketOptionFull(SocketOptionLevel level, SocketOptionName name, int32_t *first, int32_t *second)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

#if !defined(SO_EXCLUSIVEADDRUSE) && defined(SO_REUSEADDR)
        if (level == kSocketOptionLevelSocket && name == kSocketOptionNameExclusiveAddressUse)
        {
            system_level = SOL_SOCKET;
            system_name = SO_REUSEADDR;
        }
        else
#endif
        {
            const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

            if (o_res == SKIP_OPTION)
            {
                *first = 0;
                *second = 0;

                return kWaitStatusSuccess;
            }

            if (o_res == INVALID_OPTION_NAME)
            {
                _saved_error = kWSAenoprotoopt;

                return kWaitStatusFailure;
            }
        }

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int32_t ret = -1;

        switch (name)
        {
            case kSocketOptionNameLinger:
            {
                struct linger linger;
                socklen_t lingersize = sizeof(linger);

                __try
                {
                    ret = getsockopt(fd, system_level, system_name, (char*)&linger, &lingersize);

                    *first = linger.l_onoff;
                    *second = linger.l_linger;
                }
                __except (SocketExceptionFilter(GetExceptionCode()))
                {
                    ret = -1;
                }
            }
            break;

            case kSocketOptionNameDontLinger:
            {
                struct linger linger;
                socklen_t lingersize = sizeof(linger);

                __try
                {
                    ret = getsockopt(fd, system_level, system_name, (char*)&linger, &lingersize);

                    *first = !linger.l_onoff;
                }
                __except (SocketExceptionFilter(GetExceptionCode()))
                {
                    ret = -1;
                }
            }
            break;

            case kSocketOptionNameSendTimeout:
            case kSocketOptionNameReceiveTimeout:
            {
                socklen_t time_ms_size = sizeof(*first);

                __try
                {
                    ret = getsockopt(fd, system_level, system_name, (char*)first, &time_ms_size);
                }
                __except (SocketExceptionFilter(GetExceptionCode()))
                {
                    ret = -1;
                }
            }
            break;

            default:
            {
                socklen_t valsize = sizeof(*first);

                __try
                {
                    ret = getsockopt(fd, system_level, system_name, (char*)first, &valsize);
                }
                __except (SocketExceptionFilter(GetExceptionCode()))
                {
                    ret = -1;
                }
            }
            break;
        }

        if (ret == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

#if !defined(SO_EXCLUSIVEADDRUSE) && defined(SO_REUSEADDR)
        if (level == kSocketOptionLevelSocket && name == kSocketOptionNameExclusiveAddressUse)
            *first = *first ? 0 : 1;
#endif

        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Poll(std::vector<PollRequest> &requests, int32_t count, int32_t timeout, int32_t *result, int32_t *error)
    {
        const size_t nfds = (size_t)count;
        fd_set rfds, wfds, efds;

        FD_ZERO(&rfds);
        FD_ZERO(&wfds);
        FD_ZERO(&efds);

        for (size_t i = 0; i < nfds; i++)
        {
            SOCKET fd = static_cast<SOCKET>(requests[i].fd);
            requests[i].revents = kPollFlagsNone;
            if (fd == -1)
                continue;

            if ((requests[i].events & kPollFlagsIn) != 0)
                FD_SET(fd, &rfds);

            if ((requests[i].events & kPollFlagsOut) != 0)
                FD_SET(fd, &wfds);

            FD_SET(fd, &efds);
        }

        timeval timevalTimeout;
        timeval* timeoutPtr = NULL;
        if (timeout != -1)
        {
            timevalTimeout.tv_sec = timeout / 1000;
            timevalTimeout.tv_usec = (timeout % 1000) * 1000;
            timeoutPtr = &timevalTimeout;
        }

        int32_t affected = -1;

        __try
        {
            affected = select(0, &rfds, &wfds, &efds, timeoutPtr);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (affected == -1)
        {
            *error = WSAGetLastError();

            // Mono does this as well and the threadpool-ms-io-poll code depends on this behavior
            if (*error == WSAENOTSOCK)
            {
                *error = os::kInvalidHandle;
            }

            return kWaitStatusFailure;
        }

        int32_t resultCount = 0;
        for (size_t i = 0; i < nfds && affected > 0; i++)
        {
            SOCKET fd = static_cast<SOCKET>(requests[i].fd);
            if (fd == -1)
                continue;

            if ((requests[i].events & kPollFlagsIn) != 0 && FD_ISSET(fd, &rfds))
            {
                requests[i].revents |= kPollFlagsIn;
                affected--;
            }

            if ((requests[i].events & kPollFlagsOut) != 0 && FD_ISSET(fd, &wfds))
            {
                requests[i].revents |= kPollFlagsOut;
                affected--;
            }

            if (FD_ISSET(fd, &efds))
            {
                requests[i].revents |= kPollFlagsErr;
                affected--;
            }

            if (requests[i].revents != kPollFlagsNone)
                resultCount++;
        }

        *result = resultCount;
        return kWaitStatusSuccess;
    }

    WaitStatus SocketImpl::Poll(std::vector<PollRequest>& requests, int32_t timeout, int32_t *result, int32_t *error)
    {
        return Poll(requests, (int32_t)requests.size(), timeout, result, error);
    }

    WaitStatus SocketImpl::Poll(PollRequest& request, int32_t timeout, int32_t *result, int32_t *error)
    {
        std::vector<PollRequest> requests;
        requests.push_back(request);
        return Poll(requests, 1, timeout, result, error);
    }

    WaitStatus SocketImpl::SetSocketOption(SocketOptionLevel level, SocketOptionName name, int32_t value)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct linger linger;

        WaitStatus ret = kWaitStatusFailure;

        switch (name)
        {
            case kSocketOptionNameDontLinger:
                linger.l_onoff = !value;
                linger.l_linger = 0;
                ret = SetSocketOptionInternal(system_level, system_name, &linger, sizeof(linger));
                break;

            case kSocketOptionNameDontFragment:
#ifdef IP_PMTUDISC_DO
                // Fiddle with the value slightly if we're turning DF on
                if (value == 1)
                    value = IP_PMTUDISC_DO;
#endif
                ret = SetSocketOptionInternal(system_level, system_name, (char*)&value, sizeof(value));
                break;

            default:
                ret = SetSocketOptionInternal(system_level, system_name, (char*)&value, sizeof(value));
                break;
        }

        return ret;
    }

    WaitStatus SocketImpl::SetSocketOptionLinger(SocketOptionLevel level, SocketOptionName name, bool enabled, int32_t seconds)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct linger linger;

        linger.l_onoff = enabled;
        linger.l_linger = seconds;

        return SetSocketOptionInternal(system_level, system_name, &linger, sizeof(linger));
    }

    WaitStatus SocketImpl::SetSocketOptionArray(SocketOptionLevel level, SocketOptionName name, const uint8_t *buffer, int32_t length)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct linger linger;

        WaitStatus ret = kWaitStatusFailure;

        switch (name)
        {
            case kSocketOptionNameDontLinger:
                if (length == 1)
                {
                    linger.l_linger = 0;
                    linger.l_onoff = (*((char*)buffer)) ? 0 : 1;

                    ret = SetSocketOptionInternal(system_level, system_name, &linger, sizeof(linger));
                }
                else
                {
                    _saved_error = kWSAeinval;

                    return kWaitStatusFailure;
                }
                break;

            default:
                ret = SetSocketOptionInternal(system_level, system_name, buffer, length);
                break;
        }

        return ret;
    }

    WaitStatus SocketImpl::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, uint32_t group_address, uint32_t local_address)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);

        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        IP_MREQ mreq = {{0}};

        mreq.imr_multiaddr.s_addr = group_address;
        mreq.imr_interface.s_addr = local_address;

        return SetSocketOptionInternal(system_level, system_name, &mreq, sizeof(mreq));

        return kWaitStatusFailure;
    }

#if IL2CPP_SUPPORT_IPV6
    WaitStatus SocketImpl::SetSocketOptionMembership(SocketOptionLevel level, SocketOptionName name, IPv6Address ipv6, uint64_t interfaceOffset)
    {
        int32_t system_level = 0;
        int32_t system_name = 0;

        const int32_t o_res = level_and_name_to_system(level, name, &system_level, &system_name);
        if (o_res == SKIP_OPTION)
        {
            return kWaitStatusSuccess;
        }

        if (o_res == INVALID_OPTION_NAME)
        {
            _saved_error = kWSAenoprotoopt;

            return kWaitStatusFailure;
        }

        struct ipv6_mreq mreq6 = { { 0 } };
        struct in6_addr in6addr;
        for (int i = 0; i < 16; ++i)
            in6addr.s6_addr[i] = ipv6.addr[i];
        mreq6.ipv6mr_multiaddr = in6addr;
        mreq6.ipv6mr_interface = (ULONG)interfaceOffset;

        return SetSocketOptionInternal(system_level, system_name, &mreq6, sizeof(mreq6));
    }

#endif

    WaitStatus SocketImpl::SetSocketOptionInternal(int32_t level, int32_t name, const void *value, int32_t len)
    {
        const void *real_val = value;

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int32_t ret = -1;

        __try
        {
            ret = setsockopt(fd, level, name, (const char*)real_val, (socklen_t)len);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        if (ret == -1)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        return kWaitStatusSuccess;
    }

    int32_t WSAIoctlProtected(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
    {
        __try
        {
            return WSAIoctl(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        return -1;
    }

    BOOL transmitFileProtected(LPFN_TRANSMITFILE transmitFile, SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
    {
        __try
        {
            return transmitFile(hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved);
        }
        __except (SocketExceptionFilter(GetExceptionCode()))
        {
        }

        return FALSE;
    }

    WaitStatus SocketImpl::SendFile(const char *filename, TransmitFileBuffers *buffers, TransmitFileOptions options)
    {
        if (filename == NULL)
            return kWaitStatusFailure;

        const UTF16String wideFilename = utils::StringUtils::Utf8ToUtf16(filename);
        HANDLE file = CreateFileW((LPCWSTR)wideFilename.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

        if (file == INVALID_HANDLE_VALUE)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        GUID transmitFileGuid = WSAID_TRANSMITFILE;
        LPFN_TRANSMITFILE transmitFile;
        DWORD copied;

        SOCKET fd = (SOCKET)_fd;
        if (fd == -1)
        {
            Error::SetLastError(il2cpp::os::kWSAeshutdown);
            return kWaitStatusFailure;
        }

        int32_t ret = WSAIoctlProtected(fd, SIO_GET_EXTENSION_FUNCTION_POINTER, &transmitFileGuid, sizeof(transmitFileGuid), &transmitFile, sizeof(transmitFile), &copied, 0, 0);

        if (ret == SOCKET_ERROR)
        {
            StoreLastError();

            return kWaitStatusFailure;
        }

        if (!transmitFileProtected(transmitFile, fd, file, 0, 0, NULL, (TRANSMIT_FILE_BUFFERS*)buffers, options))
        {
            StoreLastError();

            CloseHandle(file);
            return kWaitStatusFailure;
        }

        CloseHandle(file);

        return kWaitStatusSuccess;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\SocketImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\StackTrace.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "WindowsHeaders.h"
#include "dbghelp.h"

#include "os/Mutex.h"
#include "os/StackTrace.h"

namespace il2cpp
{
namespace os
{
    void StackTrace::WalkStackNative(WalkStackCallback callback, void* context, WalkOrder walkOrder)
    {
        const uint32_t kMaxFrames = 128;
        void* stack[kMaxFrames];

        size_t frames = CaptureStackBackTrace(0, kMaxFrames, stack, NULL);

        // If didn't get any frames on the first try, try again
        // Sometimes on Windows 10 on a newly created thread CaptureStackBackTrace doesn't work the first time we call it.
        if (frames == 0)
            frames = CaptureStackBackTrace(0, kMaxFrames, stack, NULL);

        IL2CPP_ASSERT(frames > 0 && "CaptureStackBackTrace returned no frames");

        if (walkOrder == kFirstCalledToLastCalled)
        {
            for (size_t i = frames; i--;)
            {
                if (!callback(reinterpret_cast<Il2CppMethodPointer>(stack[i]), context))
                    break;
            }
        }
        else
        {
            for (size_t i = 0; i < frames; i++)
            {
                if (!callback(reinterpret_cast<Il2CppMethodPointer>(stack[i]), context))
                    break;
            }
        }
    }

    std::string StackTrace::NativeStackTrace()
    {
        std::string stackTrace;

#if !IL2CPP_TARGET_WINRT && !IL2CPP_TARGET_WINDOWS_GAMES
        HANDLE hProcess = GetCurrentProcess();
        BOOL result = SymInitialize(hProcess, NULL, TRUE);
        if (!result)
            return std::string();

        const uint32_t kMaxFrames = 128;
        void* stack[kMaxFrames];

        size_t frames = CaptureStackBackTrace(0, kMaxFrames, stack, NULL);

        for (size_t i = 0; i < frames; i++)
        {
            DWORD64  dwDisplacement = 0;

            char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
            PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;

            pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
            pSymbol->MaxNameLen = MAX_SYM_NAME;

            if (SymFromAddr(hProcess, (DWORD64)stack[i], &dwDisplacement, pSymbol))
            {
                stackTrace += "at ";
                stackTrace += pSymbol->Name;
                stackTrace += "\n  ";
            }
        }
#endif // !IL2CPP_TARGET_WINRT && !IL2CPP_TARGET_WINDOWS_GAMES

        return stackTrace;
    }

    const void* StackTrace::GetStackPointer()
    {
        // TODO implement to avoid extra WalkStack calls
        return nullptr;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\StackTrace.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\SynchronizationContext.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS && IL2CPP_HAS_OS_SYNCHRONIZATION_CONTEXT

#include "os/SynchronizationContext.h"
#include "os/WindowsRuntime.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/RCW.h"
#include "WindowsHelpers.h"

#ifndef WINDOWS_SDK_BUILD_VERSION
#error "We need to know which Windows SDK version we are compiling against!"
#endif

#include <windows.System.h>
#include <windows.ui.core.h>
#include <wrl.h>

using il2cpp::os::SynchronizationContext;
using Microsoft::WRL::Callback;
using Microsoft::WRL::ComPtr;
using Microsoft::WRL::Wrappers::HStringReference;

template<typename T>
using AgileCallback = Microsoft::WRL::Implements<Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::ClassicCom>, T, Microsoft::WRL::FtmBase>;

#if !IL2CPP_TARGET_WINDOWS_DESKTOP
ComPtr<ABI::Windows::UI::Core::ICoreWindowStatic> s_CoreWindowStatics;
#endif

ComPtr<ABI::Windows::System::IDispatcherQueueStatics> s_DispatcherQueueStatics;

Il2CppObject* SynchronizationContext::GetForCurrentThread()
{
    HRESULT hr;

#if !IL2CPP_TARGET_WINDOWS_DESKTOP
    if (s_CoreWindowStatics != nullptr)
    {
        ComPtr<ABI::Windows::UI::Core::ICoreWindow> currentThreadWindow;
        hr = s_CoreWindowStatics->GetForCurrentThread(&currentThreadWindow);
        if (SUCCEEDED(hr) && currentThreadWindow != nullptr)
        {
            ComPtr<ABI::Windows::UI::Core::ICoreDispatcher> dispatcher;
            hr = currentThreadWindow->get_Dispatcher(&dispatcher);
            if (SUCCEEDED(hr))
                return vm::RCW::GetOrCreateFromIInspectable(reinterpret_cast<Il2CppIInspectable*>(dispatcher.Get()), il2cpp_defaults.il2cpp_com_object_class);
        }
    }
#endif

    if (s_DispatcherQueueStatics != nullptr)
    {
        ComPtr<ABI::Windows::System::IDispatcherQueue> dispatcherQueue;
        hr = s_DispatcherQueueStatics->GetForCurrentThread(&dispatcherQueue);
        if (SUCCEEDED(hr) && dispatcherQueue != nullptr)
            return vm::RCW::GetOrCreateFromIInspectable(reinterpret_cast<Il2CppIInspectable*>(dispatcherQueue.Get()), il2cpp_defaults.il2cpp_com_object_class);
    }

    return nullptr;
}

void SynchronizationContext::Post(Il2CppObject* context, SynchronizationContextCallback callback, intptr_t arg)
{
    IL2CPP_ASSERT(vm::Class::HasParent(context->klass, il2cpp_defaults.il2cpp_com_object_class));

    HRESULT hr;
    auto dispatcherUnknown = reinterpret_cast<IUnknown*>(static_cast<Il2CppComObject*>(context)->identity);

#if !IL2CPP_TARGET_WINDOWS_DESKTOP
    ComPtr<ABI::Windows::UI::Core::ICoreDispatcher> dispatcher;
    hr = dispatcherUnknown->QueryInterface(__uuidof(dispatcher), &dispatcher);
    if (SUCCEEDED(hr))
    {
        ComPtr<ABI::Windows::Foundation::IAsyncAction> ignoredAction;
        hr = dispatcher->RunAsync(ABI::Windows::UI::Core::CoreDispatcherPriority_Normal, Callback<AgileCallback<ABI::Windows::UI::Core::IDispatchedHandler> >([callback, arg]() -> HRESULT
        {
            callback(arg);
            return S_OK;
        }).Get(), &ignoredAction);
        vm::Exception::RaiseIfFailed(hr, false);
    }
#endif

    ComPtr<ABI::Windows::System::IDispatcherQueue> dispatcherQueue;
    hr = dispatcherUnknown->QueryInterface(__uuidof(dispatcherQueue), &dispatcherQueue);
    if (SUCCEEDED(hr))
    {
        boolean ignoredResult;
        hr = dispatcherQueue->TryEnqueueWithPriority(ABI::Windows::System::DispatcherQueuePriority_Normal, Callback<AgileCallback<ABI::Windows::System::IDispatcherQueueHandler> >([callback, arg]() -> HRESULT
        {
            callback(arg);
            return S_OK;
        }).Get(), &ignoredResult);
        vm::Exception::RaiseIfFailed(hr, false);
    }
}

void SynchronizationContext::Initialize()
{
#if !IL2CPP_TARGET_WINDOWS_DESKTOP
    RoGetActivationFactory(HStringReference(L"Windows.UI.Core.CoreWindow").Get(), __uuidof(s_CoreWindowStatics), &s_CoreWindowStatics);
#endif

    RoGetActivationFactory(HStringReference(L"Windows.System.DispatcherQueue").Get(), __uuidof(s_DispatcherQueueStatics), &s_DispatcherQueueStatics);
}

void SynchronizationContext::Shutdown()
{
#if !IL2CPP_TARGET_WINDOWS_DESKTOP
    s_CoreWindowStatics = nullptr;
#endif

    s_DispatcherQueueStatics = nullptr;
}

#endif // IL2CPP_TARGET_WINDOWS && IL2CPP_HAS_OS_SYNCHRONIZATION_CONTEXT
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\SynchronizationContext.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\SystemCertificates.cpp---------------
.
.
#include "os/c-api/il2cpp-config-platforms.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/SystemCertificates.h"
#include "WindowsHeaders.h"

namespace il2cpp
{
namespace os
{
    void* SystemCertificates::OpenSystemRootStore()
    {
        HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_STORE_READONLY_FLAG, L"ROOT");
        if (hStore == NULL)
            return 0;

        return hStore;
    }

    int SystemCertificates::EnumSystemCertificates(void* certStore, void** iter, int *format, int* size, void** data)
    {
        HCERTSTORE hStore = (HCERTSTORE)certStore;
        *format = DATATYPE_INTPTR;

        // Build list of system certificates
        PCCERT_CONTEXT pContext = (PCCERT_CONTEXT)*iter;
        if (pContext = CertEnumCertificatesInStore(hStore, pContext))
        {
            *iter = (void*)pContext;
            *data = pContext->pbCertEncoded;
            *size = pContext->cbCertEncoded;
            return TRUE;
        }
        else if (*iter)
        {
            CertFreeCertificateContext((PCCERT_CONTEXT)*iter);
        }

        return FALSE;
    }

    void SystemCertificates::CloseSystemRootStore(void* cStore)
    {
        CertCloseStore((HCERTSTORE)cStore, 0);
    }
}
}

#endif // IL2CPP_TARGET_WINDOWS
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\SystemCertificates.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Thread.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "WindowsHeaders.h"
#include "os/Thread.h"

#include <processthreadsapi.h>

namespace il2cpp
{
namespace os
{
    bool Thread::GetCurrentThreadStackBounds(void** low, void** high)
    {
        GetCurrentThreadStackLimits((PULONG_PTR)low, (PULONG_PTR)high);
        return true;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\ThreadImpl.cpp---------------
.
.
#include "il2cpp-config.h"

#if !IL2CPP_THREADS_STD && IL2CPP_THREADS_WIN32

#include "ThreadImpl.h"
#include "os/ThreadLocalValue.h"
#include "os/Time.h"
#include "utils/StringUtils.h"
#include "os/Debug.h"
#include "WindowsHelpers.h"

namespace il2cpp
{
namespace os
{
    struct ThreadImplStartData
    {
        Thread::StartFunc m_StartFunc;
        void* m_StartArg;
        volatile DWORD* m_ThreadId;
    };

    static DWORD WINAPI ThreadStartWrapper(LPVOID arg)
    {
        ThreadImplStartData startData = *(ThreadImplStartData*)arg;
        free(arg);
        *startData.m_ThreadId = GetCurrentThreadId();
        startData.m_StartFunc(startData.m_StartArg);
        return 0;
    }

    static Event* s_ThreadSleepObject = nullptr;

    void ThreadImpl::AllocateStaticData()
    {
        s_ThreadSleepObject = new Event();
    }

    void ThreadImpl::FreeStaticData()
    {
        delete s_ThreadSleepObject;
        s_ThreadSleepObject = nullptr;
    }

    ThreadImpl::ThreadImpl()
        : m_ThreadHandle(0), m_ThreadId(0), m_StackSize(IL2CPP_DEFAULT_STACK_SIZE), m_ApartmentState(kApartmentStateUnknown), m_Priority(kThreadPriorityNormal)
        , m_ConditionSemaphore(1)
    {
    }

    ThreadImpl::~ThreadImpl()
    {
        if (m_ThreadHandle != NULL)
            CloseHandle(m_ThreadHandle);
    }

    size_t ThreadImpl::Id()
    {
        return m_ThreadId;
    }

    void ThreadImpl::SetNameForDebugger(const char* name)
    {
        // http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx

        const DWORD MS_VC_EXCEPTION = 0x406D1388;

#pragma pack(push,8)
        typedef struct tagTHREADNAME_INFO
        {
            DWORD dwType; // Must be 0x1000.
            LPCSTR szName; // Pointer to name (in user addr space).
            DWORD dwThreadID; // Thread ID (-1=caller thread).
            DWORD dwFlags; // Reserved for future use, must be zero.
        } THREADNAME_INFO;
#pragma pack(pop)

        THREADNAME_INFO info;
        info.dwType = 0x1000;
        info.szName = name;
        info.dwThreadID = static_cast<DWORD>(Id());
        info.dwFlags = 0;

        __try
        {
            RaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*)&info);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    typedef HRESULT (__stdcall *SETTHREADPROC) (HANDLE, PCWSTR);
    void ThreadImpl::SetName(const char* name)
    {
        SetThreadDescription(m_ThreadHandle, utils::StringUtils::Utf8ToUtf16(name).c_str());

        if (Debug::IsDebuggerPresent())
            SetNameForDebugger(name);
    }

    void ThreadImpl::SetPriority(ThreadPriority priority)
    {
        if (m_ThreadHandle == NULL)
            m_Priority = priority;
        else
        {
            int ret = ::SetThreadPriority(m_ThreadHandle, priority - 2);
            IL2CPP_ASSERT(ret);
        }
    }

    ThreadPriority ThreadImpl::GetPriority()
    {
        if (m_ThreadHandle == NULL)
            return m_Priority;
        int ret = ::GetThreadPriority(m_ThreadHandle) + 2;
        IL2CPP_ASSERT(ret != THREAD_PRIORITY_ERROR_RETURN);
        return (ThreadPriority)ret;
    }

    ErrorCode ThreadImpl::Run(Thread::StartFunc func, void* arg, int64_t affinityMask)
    {
        // It might happen that func will start executing and will try to access m_ThreadId before CreateThread gets a chance to assign it.
        // Therefore m_ThreadId is assigned both by this thread and from the newly created thread (race condition could go the other way too).

        ThreadImplStartData* startData = (ThreadImplStartData*)malloc(sizeof(ThreadImplStartData));
        startData->m_StartFunc = func;
        startData->m_StartArg = arg;
        startData->m_ThreadId = &m_ThreadId;

        // Create thread.
        DWORD threadId;
        HANDLE threadHandle = ::CreateThread(NULL, m_StackSize, &ThreadStartWrapper, startData, STACK_SIZE_PARAM_IS_A_RESERVATION, &threadId);

        if (!threadHandle)
            return kErrorCodeGenFailure;

#if IL2CPP_TARGET_WINDOWS_GAMES
        if (affinityMask != Thread::kThreadAffinityAll)
            SetThreadAffinityMask(threadHandle, static_cast<DWORD_PTR>(affinityMask));
#endif

        m_ThreadHandle = threadHandle;
        m_ThreadId = threadId;

        SetPriority(m_Priority);

        return kErrorCodeSuccess;
    }

    void ThreadImpl::Sleep(uint32_t ms, bool interruptible)
    {
        /// An Event that we never signal. This is used for sleeping threads in an alertable state. They
        /// simply wait on this object with the sleep timer as the timeout. This way we don't need a separate
        /// codepath for implementing sleep logic.

        s_ThreadSleepObject->Wait(ms, interruptible);
    }

    void ThreadImpl::CheckForUserAPCAndHandle()
    {
        m_PendingAPCsMutex.Acquire();

        while (!m_PendingAPCs.empty())
        {
            APCRequest apcRequest = m_PendingAPCs.front();

            // Remove from list. Do before calling the function to make sure the list
            // is up to date in case the function throws.
            m_PendingAPCs.erase(m_PendingAPCs.begin());

            // Release mutex while we call the function so that we don't deadlock
            // if the function starts waiting on a thread that tries queuing an APC
            // on us.
            m_PendingAPCsMutex.Release();

            // Call function.
            apcRequest.callback(apcRequest.context);

            // Re-acquire mutex.
            m_PendingAPCsMutex.Acquire();
        }

        m_PendingAPCsMutex.Release();
    }

    void ThreadImpl::SetWaitObject(WaitObject* waitObject)
    {
        // This is an unprotected write as write acccess is restricted to the
        // current thread.
        m_CurrentWaitObject = waitObject;
    }

    void ThreadImpl::QueueUserAPC(Thread::APCFunc func, void* context)
    {
        IL2CPP_ASSERT(func != NULL);

        // Put on queue.
        {
            m_PendingAPCsMutex.Acquire();
            m_PendingAPCs.push_back(APCRequest(func, context));
            m_PendingAPCsMutex.Release();
        }

        // Interrupt an ongoing wait, only interrupt if we have an object waiting
        if (m_CurrentWaitObject.load())
        {
            m_ConditionSemaphore.Release(1);
        }
    }

    int ThreadImpl::GetMaxStackSize()
    {
        return INT_MAX;
    }

    ThreadImpl* ThreadImpl::GetCurrentThread()
    {
        return Thread::GetCurrentThread()->m_Thread;
    }

namespace
{
    ApartmentState GetApartmentImpl(bool* implicit)
    {
        *implicit = false;

        APTTYPE type;
        APTTYPEQUALIFIER qualifier;
        const HRESULT hr = CoGetApartmentType(&type, &qualifier);
        if (FAILED(hr))
        {
            IL2CPP_ASSERT(CO_E_NOTINITIALIZED == hr);
            return kApartmentStateUnknown;
        }

        switch (type)
        {
            case APTTYPE_STA:
            case APTTYPE_MAINSTA:
                return kApartmentStateInSTA;

            case APTTYPE_MTA:
                *implicit = (APTTYPEQUALIFIER_IMPLICIT_MTA == qualifier);
                return kApartmentStateInMTA;

            case APTTYPE_NA:
                switch (qualifier)
                {
                    case APTTYPEQUALIFIER_NA_ON_STA:
                    case APTTYPEQUALIFIER_NA_ON_MAINSTA:
                        return kApartmentStateInSTA;

                    case APTTYPEQUALIFIER_NA_ON_MTA:
                        return kApartmentStateInMTA;

                    case APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA:
                        *implicit = true;
                        return kApartmentStateInMTA;
                }
                break;
        }

        IL2CPP_ASSERT(0 && "CoGetApartmentType returned unexpected value.");
        return kApartmentStateUnknown;
    }
}

    ApartmentState ThreadImpl::GetApartment()
    {
        Assert(GetCurrentThreadId() == m_ThreadId);

        ApartmentState state = static_cast<ApartmentState>(m_ApartmentState & ~kApartmentStateCoInitialized);

        if (kApartmentStateUnknown == state)
        {
            bool implicit;
            state = GetApartmentImpl(&implicit);
            if (!implicit)
                m_ApartmentState = state;
        }

        return state;
    }

    ApartmentState ThreadImpl::GetExplicitApartment()
    {
        return static_cast<ApartmentState>(m_ApartmentState & ~kApartmentStateCoInitialized);
    }

    ApartmentState ThreadImpl::SetApartment(ApartmentState state)
    {
        Assert(GetCurrentThreadId() == m_ThreadId);

        // Unknown state uninitializes COM.
        if (kApartmentStateUnknown == state)
        {
            if (m_ApartmentState & kApartmentStateCoInitialized)
            {
                CoUninitialize();
                m_ApartmentState = kApartmentStateUnknown;
            }

            return GetApartment();
        }

        // Initialize apartment state. Ignore result of this function because it will return MTA value for both implicit and explicit apartment.
        // On the other hand m_ApartmentState will only be set to MTA if it was initialized explicitly with CoInitializeEx.
        GetApartment();

        ApartmentState currentState = static_cast<ApartmentState>(m_ApartmentState & ~kApartmentStateCoInitialized);

        if (kApartmentStateUnknown != currentState)
        {
            Assert(state == currentState);
            return currentState;
        }

        HRESULT hr = CoInitializeEx(nullptr, (kApartmentStateInSTA == state) ? COINIT_APARTMENTTHREADED : COINIT_MULTITHREADED);
        if (SUCCEEDED(hr))
        {
            m_ApartmentState = state;
            if (S_OK == hr)
                m_ApartmentState = static_cast<ApartmentState>(m_ApartmentState | kApartmentStateCoInitialized);
            else
                CoUninitialize(); // Someone has already called correct CoInitialize. Don't leave incorrect reference count.
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            // CoInitialize has already been called with a different apartment state.
            m_ApartmentState = (kApartmentStateInSTA == state) ? kApartmentStateInMTA : kApartmentStateInSTA;
        }
        else
        {
            // Based on where this function is called (Init and Shutdown) we can't really recover from this, so
            // just abort.
            abort();
        }

        return GetApartment();
    }

    void ThreadImpl::SetExplicitApartment(ApartmentState state)
    {
        Assert(!(m_ApartmentState & kApartmentStateCoInitialized));
        m_ApartmentState = state;
    }

    size_t ThreadImpl::CurrentThreadId()
    {
        return GetCurrentThreadId();
    }

    ThreadImpl* ThreadImpl::CreateForCurrentThread()
    {
        ThreadImpl* thread = new ThreadImpl();
        BOOL duplicateResult = DuplicateHandle(::GetCurrentProcess(), ::GetCurrentThread(), ::GetCurrentProcess(), &thread->m_ThreadHandle, 0, FALSE, DUPLICATE_SAME_ACCESS);
        Assert(duplicateResult && "DuplicateHandle failed.");
        thread->m_ThreadId = ::GetCurrentThreadId();
        return thread;
    }

    bool ThreadImpl::YieldInternal()
    {
        return SwitchToThread();
    }

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP

    static Thread::ThreadCleanupFunc s_ThreadCleanupFunction;
    static ThreadLocalValue s_ThreadCleanupArguments;

    void ThreadImpl::SetNativeThreadCleanup(Thread::ThreadCleanupFunc cleanupFunction)
    {
        s_ThreadCleanupFunction = cleanupFunction;
    }

    void ThreadImpl::RegisterCurrentThreadForCleanup(void* arg)
    {
        s_ThreadCleanupArguments.SetValue(arg);
    }

    void ThreadImpl::UnregisterCurrentThreadForCleanup()
    {
        s_ThreadCleanupArguments.SetValue(NULL);
    }

    void ThreadImpl::OnCurrentThreadExiting()
    {
        Thread::ThreadCleanupFunc cleanupFunction = s_ThreadCleanupFunction;
        if (cleanupFunction == NULL)
            return;

        void* threadCleanupArgument = NULL;
        s_ThreadCleanupArguments.GetValue(&threadCleanupArgument);

        if (threadCleanupArgument != NULL)
            cleanupFunction(threadCleanupArgument);
    }

#endif
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\ThreadImpl.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Time.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/Time.h"
#include "os/Win32/WindowsHeaders.h"

#define MTICKS_PER_SEC 10000000LL

namespace il2cpp
{
namespace os
{
    static LARGE_INTEGER s_PerformanceCounterFrequency;
    static double s_MTicksPerQfcFreq;

    static inline void InitializePerformanceCounterFrequency()
    {
        if (!s_PerformanceCounterFrequency.QuadPart)
        {
            // From MSDN: On systems that run Windows XP or later, the function will always succeed and will thus never return zero.
            // so I'll just assume we never run on older than XP

            BOOL qpfResult = QueryPerformanceFrequency(&s_PerformanceCounterFrequency);
            IL2CPP_ASSERT(qpfResult != FALSE);

            s_MTicksPerQfcFreq = (double)MTICKS_PER_SEC / s_PerformanceCounterFrequency.QuadPart;
        }
    }

    uint32_t Time::GetTicksMillisecondsMonotonic()
    {
        InitializePerformanceCounterFrequency();

        LARGE_INTEGER value;
        QueryPerformanceCounter(&value);
        return static_cast<uint32_t>(value.QuadPart * 1000 / s_PerformanceCounterFrequency.QuadPart);
    }

    int64_t Time::GetTicks100NanosecondsMonotonic()
    {
        InitializePerformanceCounterFrequency();

        LARGE_INTEGER value;
        QueryPerformanceCounter(&value);
        return (int64_t)(value.QuadPart * s_MTicksPerQfcFreq);
    }

/*
 * Magic number to convert FILETIME base Jan 1, 1601 to DateTime - base Jan, 1, 0001
 */
    const uint64_t FILETIME_ADJUST = ((uint64_t)504911232000000000LL);

    int64_t Time::GetTicks100NanosecondsDateTime()
    {
        ULARGE_INTEGER ft;

        IL2CPP_ASSERT(sizeof(ft) == sizeof(FILETIME));

        ::GetSystemTimeAsFileTime((FILETIME*)&ft);
        return FILETIME_ADJUST + ft.QuadPart;
    }

    int64_t Time::GetSystemTimeAsFileTime()
    {
        int64_t fileTime;
        ::GetSystemTimeAsFileTime(reinterpret_cast<FILETIME*>(&fileTime));
        return fileTime;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\Time.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\TimeZone.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS

#include "os/TimeZone.h"
#include "os/Win32/WindowsHeaders.h"

/*
 * Magic number to convert FILETIME base Jan 1, 1601 to DateTime - base Jan, 1, 0001
 */
const uint64_t FILETIME_ADJUST = ((uint64_t)504911232000000000LL);

namespace il2cpp
{
namespace os
{
    static void
    convert_to_absolute_date(SYSTEMTIME *date)
    {
#define IS_LEAP(y) ((y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0))
        static int days_in_month[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        static int leap_days_in_month[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        /* from the calendar FAQ */
        int a = (14 - date->wMonth) / 12;
        int y = date->wYear - a;
        int m = date->wMonth + 12 * a - 2;
        int d = (1 + y + y / 4 - y / 100 + y / 400 + (31 * m) / 12) % 7;

        /* d is now the day of the week for the first of the month (0 == Sunday) */

        int day_of_week = date->wDayOfWeek;

        /* set day_in_month to the first day in the month which falls on day_of_week */
        int day_in_month = 1 + (day_of_week - d);
        if (day_in_month <= 0)
            day_in_month += 7;

        /* wDay is 1 for first weekday in month, 2 for 2nd ... 5 means last - so work that out allowing for days in the month */
        date->wDay = day_in_month + (date->wDay - 1) * 7;
        if (date->wDay > (IS_LEAP(date->wYear) ? leap_days_in_month[date->wMonth - 1] : days_in_month[date->wMonth - 1]))
            date->wDay -= 7;
    }

// names[0] - standardName
// names[1] - daylightName
    bool TimeZone::GetTimeZoneData(int32_t year, int64_t data[4], std::string names[2], bool* daylight_inverted)
    {
        //On Windows, we should always load timezones in managed
        return false;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\TimeZone.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\WindowsHelpers.cpp---------------
.
.
#include "il2cpp-config.h"
#include "WindowsHelpers.h"
#include "os/Time.h"

#if IL2CPP_TARGET_WINDOWS

namespace il2cpp
{
namespace os
{
namespace win
{
    WaitStatus WaitForSingleObjectAndAccountForAPCs(HANDLE handle, uint32_t ms, bool interruptible)
    {
        uint32_t remainingWaitTimeMS = ms;
        while (true)
        {
            uint32_t waitStartTime = os::Time::GetTicksMillisecondsMonotonic();
            DWORD result = ::WaitForSingleObjectEx(handle, remainingWaitTimeMS, interruptible);

            if (result == WAIT_OBJECT_0)
                return kWaitStatusSuccess;

            if (result == WAIT_TIMEOUT)
                return kWaitStatusTimeout;

            if (result == WAIT_IO_COMPLETION)
            {
                if (ms != INFINITE)
                {
                    uint32_t haveWaitedTimeMS = os::Time::GetTicksMillisecondsMonotonic() - waitStartTime;
                    if (haveWaitedTimeMS >= remainingWaitTimeMS)
                        return kWaitStatusTimeout;
                    remainingWaitTimeMS -= haveWaitedTimeMS;
                }
                continue;
            }

            break;
        }

        return kWaitStatusFailure;
    }

    int32_t WaitForAnyObjectAndAccountForAPCs(const std::vector<HANDLE>& handles, uint32_t ms, bool interruptible)
    {
        IL2CPP_ASSERT(handles.size() != 0);

        uint32_t remainingWaitTimeMS = ms;
        while (true)
        {
            uint32_t waitStartTime = os::Time::GetTicksMillisecondsMonotonic();
            DWORD result = ::WaitForMultipleObjectsEx((DWORD)handles.size(), handles.data(), false, remainingWaitTimeMS, interruptible);

            // If we are waiting for just one of many objects, the return value
            // might be WAIT_OBJECT_0 + the index of the handle that was signaled.
            // Check for a return value in that range and return the index of that handle.
            if (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + handles.size())
                return result - WAIT_OBJECT_0;

            if (result == WAIT_TIMEOUT)
                return WAIT_TIMEOUT;

            if (result == WAIT_IO_COMPLETION)
            {
                if (ms != INFINITE)
                {
                    uint32_t haveWaitedTimeMS = os::Time::GetTicksMillisecondsMonotonic() - waitStartTime;
                    if (haveWaitedTimeMS >= remainingWaitTimeMS)
                        return WAIT_TIMEOUT;
                    remainingWaitTimeMS -= haveWaitedTimeMS;
                }
                continue;
            }

            break;
        }

        return WAIT_FAILED;
    }

    bool WaitForAllObjectsAndAccountForAPCs(const std::vector<HANDLE>& handles, uint32_t ms, bool interruptible)
    {
        IL2CPP_ASSERT(handles.size() != 0);

        uint32_t remainingWaitTimeMS = ms;
        while (true)
        {
            uint32_t waitStartTime = os::Time::GetTicksMillisecondsMonotonic();
            DWORD result = ::WaitForMultipleObjectsEx((DWORD)handles.size(), handles.data(), true, remainingWaitTimeMS, interruptible);

            if (result == WAIT_OBJECT_0)
                return true;

            if (result == WAIT_TIMEOUT)
                return false;

            if (result == WAIT_IO_COMPLETION)
            {
                if (ms != INFINITE)
                {
                    uint32_t haveWaitedTimeMS = os::Time::GetTicksMillisecondsMonotonic() - waitStartTime;
                    if (haveWaitedTimeMS >= remainingWaitTimeMS)
                        return false;
                    remainingWaitTimeMS -= haveWaitedTimeMS;
                }
                continue;
            }

            break;
        }

        return false;
    }
}
}
}

#endif // IL2CPP_TARGET_WINDOWS
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\WindowsHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\WindowsRuntime.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS && !IL2CPP_USE_GENERIC_WINDOWSRUNTIME

#include "il2cpp-class-internals.h"
#include "il2cpp-string-types.h"
#include "os/WindowsRuntime.h"
#include "utils/Expected.h"
#include "utils/Il2CppError.h"
#include "utils/StringUtils.h"
#include "vm/CCW.h"
#include "WindowsHeaders.h"

#include <roerrorapi.h>

namespace il2cpp
{
namespace os
{
    il2cpp_hresult_t WindowsRuntime::GetActivationFactory(Il2CppHString className, Il2CppIActivationFactory** activationFactory)
    {
        IL2CPP_ASSERT(className != NULL);
        IL2CPP_ASSERT(activationFactory != NULL);

        return RoGetActivationFactory(reinterpret_cast<HSTRING>(className), reinterpret_cast<const IID&>(Il2CppIActivationFactory::IID), reinterpret_cast<void**>(activationFactory));
    }

    il2cpp_hresult_t WindowsRuntime::CreateHStringReference(const utils::StringView<Il2CppNativeChar>& str, Il2CppHStringHeader* header, Il2CppHString* hstring)
    {
        IL2CPP_ASSERT(header != NULL);
        IL2CPP_ASSERT(hstring != NULL);

        if (str.Length() == 0)
        {
            *hstring = NULL;
            return S_OK;
        }

        return WindowsCreateStringReference(str.Str(), static_cast<uint32_t>(str.Length()), reinterpret_cast<HSTRING_HEADER*>(header), reinterpret_cast<HSTRING*>(hstring));
    }

    il2cpp_hresult_t WindowsRuntime::CreateHString(const utils::StringView<Il2CppChar>& str, Il2CppHString* hstring)
    {
        IL2CPP_ASSERT(str.Str() != NULL || str.Length() == 0);

        if (str.Length() == 0)
        {
            *hstring = NULL;
            return S_OK;
        }

        return WindowsCreateString(str.Str(), static_cast<uint32_t>(str.Length()), reinterpret_cast<HSTRING*>(hstring));
    }

    il2cpp_hresult_t WindowsRuntime::DuplicateHString(Il2CppHString hstring, Il2CppHString* duplicated)
    {
        return WindowsDuplicateString(reinterpret_cast<HSTRING>(hstring), reinterpret_cast<HSTRING*>(duplicated));
    }

    il2cpp_hresult_t WindowsRuntime::DeleteHString(Il2CppHString hstring)
    {
        if (hstring == NULL)
            return IL2CPP_S_OK;

        return WindowsDeleteString(reinterpret_cast<HSTRING>(hstring));
    }

    utils::Expected<const Il2CppChar*> WindowsRuntime::GetHStringBuffer(Il2CppHString hstring, uint32_t* length)
    {
        return WindowsGetStringRawBuffer(reinterpret_cast<HSTRING>(hstring), length);
    }

    utils::Expected<const Il2CppNativeChar*> WindowsRuntime::GetNativeHStringBuffer(Il2CppHString hstring, uint32_t* length)
    {
        return GetHStringBuffer(hstring, length);
    }

    utils::Expected<il2cpp_hresult_t> WindowsRuntime::PreallocateHStringBuffer(uint32_t length, Il2CppNativeChar** mutableBuffer, void** bufferHandle)
    {
        return WindowsPreallocateStringBuffer(length, mutableBuffer, reinterpret_cast<HSTRING_BUFFER*>(bufferHandle));
    }

    utils::Expected<il2cpp_hresult_t> WindowsRuntime::PromoteHStringBuffer(void* bufferHandle, Il2CppHString* hstring)
    {
        return WindowsPromoteStringBuffer(static_cast<HSTRING_BUFFER>(bufferHandle), reinterpret_cast<HSTRING*>(hstring));
    }

    utils::Expected<il2cpp_hresult_t> WindowsRuntime::DeleteHStringBuffer(void* bufferHandle)
    {
        return WindowsDeleteStringBuffer(static_cast<HSTRING_BUFFER>(bufferHandle));
    }

    Il2CppIRestrictedErrorInfo* WindowsRuntime::GetRestrictedErrorInfo()
    {
        Il2CppIRestrictedErrorInfo* errorInfo;
        HRESULT hr;

        hr = ::GetRestrictedErrorInfo(reinterpret_cast<IRestrictedErrorInfo**>(&errorInfo));

        if (FAILED(hr))
            return NULL;

        return errorInfo;
    }

    void WindowsRuntime::OriginateLanguageException(il2cpp_hresult_t hresult, Il2CppException* ex, Il2CppString* exceptionString, GetOrCreateFunc createCCWCallback)
    {
        utils::StringView<Il2CppNativeChar> message(utils::StringUtils::GetChars(exceptionString), utils::StringUtils::GetLength(exceptionString));
        Il2CppHString messageHString;
        Il2CppHStringHeader unused;
        CreateHStringReference(message, &unused, &messageHString);

        Il2CppIUnknown* exceptionCCW = createCCWCallback(reinterpret_cast<Il2CppObject*>(ex), Il2CppIUnknown::IID);
        RoOriginateLanguageException(hresult, reinterpret_cast<HSTRING>(messageHString), reinterpret_cast<IUnknown*>(exceptionCCW));
        exceptionCCW->Release();
    }

    void WindowsRuntime::EnableErrorReporting()
    {
        il2cpp_hresult_t hr = RoSetErrorReportingFlags(RO_ERROR_REPORTING_USESETERRORINFO);
        IL2CPP_ASSERT(IL2CPP_HR_SUCCEEDED(hr) && "RoSetErrorReportingFlags failed");
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\Win32\WindowsRuntime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WindowsGames\Win32ApiWindowsGamesEmulation.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINDOWS_GAMES

#include "Win32ApiWindowsGamesEmulation.h"

#include "os/Win32/WindowsHeaders.h"

#undef GetFileAttributes

#include "os/File.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace os
{
    UnityPalFileAttributes File::GetFileAttributes(const std::string& path, int *error)
    {
        const UTF16String utf16Path(utils::StringUtils::Utf8ToUtf16(path.c_str()));

        // HACK: DLC api returns these funky long form UNC paths (\\?\GLOBALROOT\)
        // For some reason even though many of the file APIs on Xbox understand such a path
        // GetFileAttributesEx does not, so we check explicitly for such a path, and fake it.
        wchar_t * p = (wchar_t*)utf16Path.c_str();
        size_t len = wcslen(p);
        if (((len > 3 && (p[0] == L'\\' && p[1] == L'?'  && p[2] == L'\\'))
             || (len > 4 && (p[0] == L'\\' && p[1] == L'\\' && p[2] == L'?' && p[3] == L'\\'))
            ) && NULL != wcsstr(p, L"GLOBALROOT\\Device\\Harddisk"))
        {
            size_t diff = len - (wcsstr(p, L"Partition") - p);
            if (diff <= 11)
                return static_cast<UnityPalFileAttributes>(FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN);
        }

        WIN32_FILE_ATTRIBUTE_DATA fileAttributes;

        BOOL result = ::GetFileAttributesExW((LPCWSTR)utf16Path.c_str(), GetFileExInfoStandard, &fileAttributes);
        if (result == FALSE)
        {
            *error = ::GetLastError();
            return static_cast<UnityPalFileAttributes>(INVALID_FILE_ATTRIBUTES);
        }

        *error = kErrorCodeSuccess;
        return static_cast<UnityPalFileAttributes>(fileAttributes.dwFileAttributes);
    }
} //os
} //il2cpp


#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WindowsGames\Win32ApiWindowsGamesEmulation.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\BrokeredFileSystem.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_SUPPORTS_BROKERED_FILESYSTEM

#include "os/BrokeredFileSystem.h"
#include "os/Atomic.h"
#include "os/Win32/WindowsHelpers.h"
#include "SynchronousOperation.h"
#include "utils/PathUtils.h"
#include "utils/StringUtils.h"

#include <windows.storage.h>
#include <windows.storage.search.h>

using il2cpp::winrt::MakeSynchronousOperation;
using Microsoft::WRL::ComPtr;
using Microsoft::WRL::Wrappers::HStringReference;

namespace winrt_interfaces
{
    enum HANDLE_CREATION_OPTIONS
    {
        HCO_CREATE_NEW = 0x1,
        HCO_CREATE_ALWAYS = 0x2,
        HCO_OPEN_EXISTING = 0x3,
        HCO_OPEN_ALWAYS = 0x4,
        HCO_TRUNCATE_EXISTING = 0x5
    };

    enum HANDLE_ACCESS_OPTIONS
    {
        HAO_NONE = 0,
        HAO_READ_ATTRIBUTES = 0x80,
        HAO_READ = 0x120089,
        HAO_WRITE = 0x120116,
        HAO_DELETE = 0x10000
    };

    enum HANDLE_SHARING_OPTIONS
    {
        HSO_SHARE_NONE = 0,
        HSO_SHARE_READ = 0x1,
        HSO_SHARE_WRITE = 0x2,
        HSO_SHARE_DELETE = 0x4
    };

    enum HANDLE_OPTIONS
    {
        HO_NONE = 0,
        HO_OPEN_REQUIRING_OPLOCK = 0x40000,
        HO_DELETE_ON_CLOSE = 0x4000000,
        HO_SEQUENTIAL_SCAN = 0x8000000,
        HO_RANDOM_ACCESS = 0x10000000,
        HO_NO_BUFFERING = 0x20000000,
        HO_OVERLAPPED = 0x40000000,
        HO_WRITE_THROUGH = 0x80000000,

        HO_ALL_POSSIBLE_OPTIONS = HO_OPEN_REQUIRING_OPLOCK | HO_DELETE_ON_CLOSE | HO_SEQUENTIAL_SCAN | HO_RANDOM_ACCESS | HO_NO_BUFFERING | HO_OVERLAPPED | HO_WRITE_THROUGH,
    };

    MIDL_INTERFACE("DF19938F-5462-48A0-BE65-D2A3271A08D6")
    IStorageFolderHandleAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create(
            LPCWSTR fileName,
            HANDLE_CREATION_OPTIONS creationOptions,
            HANDLE_ACCESS_OPTIONS accessOptions,
            HANDLE_SHARING_OPTIONS sharingOptions,
            HANDLE_OPTIONS options,
            struct IOplockBreakingHandler* oplockBreakingHandler,
            HANDLE* interopHandle) = 0;
    };

    MIDL_INTERFACE("5CA296B2-2C25-4D22-B785-B885C8201E6A")
    IStorageItemHandleAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create(
            HANDLE_ACCESS_OPTIONS accessOptions,
            HANDLE_SHARING_OPTIONS sharingOptions,
            HANDLE_OPTIONS options,
            struct IOplockBreakingHandler* oplockBreakingHandler,
            HANDLE* interopHandle) = 0;
    };
}

namespace il2cpp
{
namespace os
{
    template<typename T, const wchar_t* className>
    struct StaticsStorage
    {
        ~StaticsStorage()
        {
            Assert(!s_Initialized && "StaticsStorage was not properly disposed before destruction!");
            Assert(s_Statics == nullptr && "StaticsStorage was not properly disposed before destruction!");
        }

        T* Get()
        {
            if (s_Initialized)
                return s_Statics;

            T* statics;
            auto hr = RoGetActivationFactory(HStringReference(className).Get(), __uuidof(T), reinterpret_cast<void**>(&statics));
            if (FAILED(hr))
            {
                s_Initialized = true;
                return nullptr;
            }

            // The reason this is atomic isn't to prevent multiple RoGetActivationFactory invocations,
            // it's there to make sure we don't mess up reference counting
            if (Atomic::CompareExchangePointer<T>(&s_Statics, statics, nullptr) != nullptr)
            {
                statics->Release();
                return s_Statics;
            }

            s_Initialized = true;
            return statics;
        }

        void Release()
        {
            s_Initialized = false;

            if (s_Statics != nullptr)
            {
                s_Statics->Release();
                s_Statics = nullptr;
            }
        }

    private:
        // Note: It is not a smart pointer for atomicity
        T* s_Statics;
        volatile bool s_Initialized;
    };

    static StaticsStorage<ABI::Windows::Storage::IStorageFileStatics, RuntimeClass_Windows_Storage_StorageFile> s_StorageFileStatics;
    static StaticsStorage<ABI::Windows::Storage::IStorageFolderStatics, RuntimeClass_Windows_Storage_StorageFolder> s_StorageFolderStatics;

    static int HResultToWin32OrAccessDenied(HRESULT hr)
    {
        if (SUCCEEDED(hr))
            return ERROR_SUCCESS;

        if ((hr & 0xFFFF0000) == MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, 0))
            return HRESULT_CODE(hr);

        return ERROR_ACCESS_DENIED;
    }

#define StoreErrorAndReturnIfFailed(hr, valueToReturn) do { if (FAILED(hr)) { *error = HResultToWin32OrAccessDenied(hr); return valueToReturn; } } while (false)
#define StoreErrorAndReturnFalseIfFailed(hr) StoreErrorAndReturnIfFailed(hr, false)

    static inline bool IsPathRooted(const UTF16String& path)
    {
        if (path.empty())
            return false;

        if (path[0] == '\\')
            return true;

        return path.length() > 1 && path[1] == ':';
    }

    static inline void FixSlashes(UTF16String& path)
    {
        for (auto& c : path)
        {
            if (c == '/')
                c = '\\';
        }
    }

    static UTF16String GetFullPath(UTF16String path)
    {
        FixSlashes(path);
        if (IsPathRooted(path))
            return path;

        UTF16String fullPath;
        DWORD fullPathLength = GetFullPathNameW(path.c_str(), 0, nullptr, nullptr);
        Assert(fullPathLength != 0 && "GetFullPathNameW failed!");

        do
        {
            fullPath.resize(fullPathLength);
            fullPathLength = GetFullPathNameW(path.c_str(), fullPathLength, &fullPath[0], nullptr);
            Assert(fullPathLength != 0 && "GetFullPathNameW failed!");
        }
        while (fullPathLength > fullPath.size());

        fullPath.resize(fullPathLength);
        return fullPath;
    }

    static bool SplitPathToFolderAndFileName(UTF16String path, UTF16String& outFolder, UTF16String& outFile)
    {
        FixSlashes(path);

        wchar_t* filePart = nullptr;

        DWORD fullPathLength = GetFullPathNameW(path.c_str(), 0, nullptr, nullptr);
        Assert(fullPathLength != 0 && "GetFullPathNameW failed!");

        do
        {
            outFolder.resize(fullPathLength);
            fullPathLength = GetFullPathNameW(path.c_str(), fullPathLength, &outFolder[0], &filePart);
            Assert(fullPathLength != 0 && "GetFullPathNameW failed!");
        }
        while (fullPathLength > outFolder.size());

        if (filePart != nullptr)
        {
            outFile = filePart;
            outFolder.resize(filePart - &outFolder[0] - 1);
            return true;
        }
        else
        {
            outFolder.resize(fullPathLength);
            outFile.clear();
            return false;
        }
    }

    static HRESULT GetStorageFolderAsync(const UTF16String& path, ABI::Windows::Foundation::IAsyncOperation<ABI::Windows::Storage::StorageFolder*>** operation)
    {
        Assert(IsPathRooted(path) && "GetStorageFolder expects an absolute path.");

        auto storageFolderStatics = s_StorageFolderStatics.Get();
        Assert(storageFolderStatics != nullptr && "Failed to get StorageFolder statics");

        return storageFolderStatics->GetFolderFromPathAsync(HStringReference(path.c_str(), static_cast<uint32_t>(path.length())).Get(), operation);
    }

    static HRESULT GetStorageFolder(const UTF16String& path, ABI::Windows::Storage::IStorageFolder** storageFolder)
    {
        ComPtr<ABI::Windows::Foundation::IAsyncOperation<ABI::Windows::Storage::StorageFolder*> > operation;
        auto hr = GetStorageFolderAsync(path, &operation);
        if (FAILED(hr))
            return hr;

        return MakeSynchronousOperation(operation.Get())->GetResults(storageFolder);
    }

    static HRESULT GetStorageFileAsync(const UTF16String& path, ABI::Windows::Foundation::IAsyncOperation<ABI::Windows::Storage::StorageFile*>** operation)
    {
        Assert(IsPathRooted(path) && "GetStorageFile expects an absolute path.");

        auto storageFileStatics = s_StorageFileStatics.Get();
        Assert(storageFileStatics != nullptr && "Failed to get StorageFile statics");

        return storageFileStatics->GetFileFromPathAsync(HStringReference(path.c_str(), static_cast<uint32_t>(path.length())).Get(), operation);
    }

    static HRESULT GetStorageFile(const UTF16String& path, ABI::Windows::Storage::IStorageFile** storageFile)
    {
        ComPtr<ABI::Windows::Foundation::IAsyncOperation<ABI::Windows::Storage::StorageFile*> > operation;
        auto hr = GetStorageFileAsync(path, &operation);
        if (FAILED(hr))
            return hr;

        return MakeSynchronousOperation(operation.Get())->GetResults(storageFile);
    }

    static HRESULT AsStorageItem(IInspectable* itf, ABI::Windows::Storage::IStorageItem** storageItem)
    {
        return itf->QueryInterface(__uuidof(*storageItem), reinterpret_cast<void**>(storageItem));
    }

    static HRESULT GetStorageItem(const UTF16String& path, ABI::Windows::Storage::IStorageItem** storageItem)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        auto fullPath = GetFullPath(path);

        // We don't know whether it's a folder or a file. Try getting a file first
        ComPtr<IStorageFile> storageFile;
        auto hr = GetStorageFile(fullPath, &storageFile);
        if (SUCCEEDED(hr))
            return AsStorageItem(storageFile.Get(), storageItem);

        // Perhaps it's not a file but a folder?
        ComPtr<IStorageFolder> storageFolder;
        hr = GetStorageFolder(fullPath, &storageFolder);
        if (SUCCEEDED(hr))
            return AsStorageItem(storageFolder.Get(), storageItem);

        return hr;
    }

    int BrokeredFileSystem::CreateDirectoryW(const UTF16String& path)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        ComPtr<IAsyncOperation<StorageFolder*> > creationOperation;

        {
            UTF16String parentFolderName, name;
            if (!SplitPathToFolderAndFileName(path, parentFolderName, name))
                return ERROR_ACCESS_DENIED;

            ComPtr<IStorageFolder> parentFolder;
            auto hr = GetStorageFolder(parentFolderName, &parentFolder);
            if (FAILED(hr))
                return HResultToWin32OrAccessDenied(hr);

            hr = parentFolder->CreateFolderAsync(HStringReference(name.c_str(), static_cast<uint32_t>(name.length())).Get(), CreationCollisionOption_FailIfExists, &creationOperation);
            if (FAILED(hr))
                return HResultToWin32OrAccessDenied(hr);
        }

        auto hr = MakeSynchronousOperation(creationOperation.Get())->Wait();
        if (FAILED(hr))
            return HResultToWin32OrAccessDenied(hr);

        return kErrorCodeSuccess;
    }

    static int DeleteStorageItem(ABI::Windows::Storage::IStorageItem* storageItem)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        ComPtr<IAsyncAction> deletionAction;
        auto hr = storageItem->DeleteAsync(StorageDeleteOption_PermanentDelete, &deletionAction);
        if (FAILED(hr))
            return HResultToWin32OrAccessDenied(hr);

        hr = MakeSynchronousOperation(deletionAction.Get())->Wait();
        if (FAILED(hr))
            return HResultToWin32OrAccessDenied(hr);

        return kErrorCodeSuccess;
    }

    int BrokeredFileSystem::RemoveDirectoryW(const UTF16String& path)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        auto fullPath = GetFullPath(path);

        ComPtr<IStorageFolder> storageFolder;
        auto hr = GetStorageFolder(fullPath, &storageFolder);
        if (FAILED(hr))
            return HResultToWin32OrAccessDenied(hr);

        ComPtr<IStorageItem> storageItem;
        hr = storageFolder.As(&storageItem);
        if (FAILED(hr))
            return HResultToWin32OrAccessDenied(hr);

        return DeleteStorageItem(storageItem.Get());
    }

    static UnityPalFileAttributes TranslateWinRTAttributesToPALAttributes(ABI::Windows::Storage::FileAttributes winrtAttributes)
    {
        // Normal file attribute enum value is different.
        // The rest are the same.
        if (winrtAttributes == ABI::Windows::Storage::FileAttributes_Normal)
            return kFileAttributeNormal;

        return static_cast<UnityPalFileAttributes>(winrtAttributes);
    }

    static ABI::Windows::Storage::FileAttributes TranslatePALAttributesToWinRTAttributes(UnityPalFileAttributes attributes)
    {
        return static_cast<ABI::Windows::Storage::FileAttributes>(attributes & ~kFileAttributeNormal);
    }

    static HRESULT FindFileSystemEntries(const UTF16String& path, UTF16String pathWithPattern, int* error, ABI::Windows::Foundation::Collections::IVectorView<ABI::Windows::Storage::IStorageItem*>** foundItems)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Foundation::Collections;
        using namespace ABI::Windows::Storage;
        using namespace ABI::Windows::Storage::Search;

        ComPtr<IAsyncOperation<StorageFolder*> > getFolderOperation;
        auto hr = GetStorageFolderAsync(GetFullPath(path), &getFolderOperation);
        StoreErrorAndReturnIfFailed(hr, hr);

        ComPtr<IInspectable> queryOptionsInspectable;
        hr = RoActivateInstance(HStringReference(RuntimeClass_Windows_Storage_Search_QueryOptions).Get(), &queryOptionsInspectable);
        StoreErrorAndReturnIfFailed(hr, hr);

        ComPtr<IQueryOptions> queryOptions;
        hr = queryOptionsInspectable.As(&queryOptions);
        IL2CPP_ASSERT(SUCCEEDED(hr) && "Failed to cast QueryOptions to IQueryOptions");

        hr = queryOptions->put_FolderDepth(FolderDepth_Shallow); // We're doing a non-recursive search
        StoreErrorAndReturnIfFailed(hr, hr);

        auto aqs = L"System.ItemPathDisplay:~\"" + GetFullPath(std::move(pathWithPattern)) + L"\"";
        hr = queryOptions->put_ApplicationSearchFilter(HStringReference(aqs.c_str(), static_cast<uint32_t>(aqs.length())).Get());
        StoreErrorAndReturnIfFailed(hr, hr);

        ComPtr<IStorageFolder> folderToSearch;
        hr = MakeSynchronousOperation(getFolderOperation.Get())->GetResults(&folderToSearch);
        StoreErrorAndReturnIfFailed(hr, hr);

        ComPtr<IStorageFolderQueryOperations> folderQueryOperations;
        hr = folderToSearch.As(&folderQueryOperations);
        IL2CPP_ASSERT(SUCCEEDED(hr) && "Failed to cast StorageFolder to IStorageFolderQueryOperations!");

        ComPtr<IStorageItemQueryResult> queryResult;
        hr = folderQueryOperations->CreateItemQueryWithOptions(queryOptions.Get(), &queryResult);
        StoreErrorAndReturnIfFailed(hr, hr);

        ComPtr<IAsyncOperation<IVectorView<IStorageItem*>*> > itemsOperation;
        hr = queryResult->GetItemsAsyncDefaultStartAndCount(&itemsOperation);
        StoreErrorAndReturnIfFailed(hr, hr);

        hr = MakeSynchronousOperation(itemsOperation.Get())->GetResults(foundItems);
        StoreErrorAndReturnIfFailed(hr, hr);

        return hr;
    }

    std::set<std::string> BrokeredFileSystem::GetFileSystemEntries(const UTF16String& path, const UTF16String& pathWithPattern, int32_t attributes, int32_t attributeMask, int* error)
    {
        using namespace ABI::Windows::Foundation::Collections;
        using namespace ABI::Windows::Storage;

        std::set<std::string> fileSystemEntries;

        ComPtr<IVectorView<IStorageItem*> > foundItems;
        auto hr = FindFileSystemEntries(path, pathWithPattern, error, &foundItems);
        StoreErrorAndReturnIfFailed(hr, fileSystemEntries);

        uint32_t foundCount;
        hr = foundItems->get_Size(&foundCount);
        StoreErrorAndReturnIfFailed(hr, fileSystemEntries);

        for (uint32_t i = 0; i < foundCount; i++)
        {
            ComPtr<IStorageItem> item;
            hr = foundItems->GetAt(i, &item);
            if (FAILED(hr)) continue;

            FileAttributes winrtAttributes;
            hr = item->get_Attributes(&winrtAttributes);
            if (FAILED(hr)) continue;

            auto palAttributes = TranslateWinRTAttributesToPALAttributes(winrtAttributes);
            if ((palAttributes & attributeMask) == attributes)
            {
                Microsoft::WRL::Wrappers::HString path;
                hr = item->get_Path(path.GetAddressOf());
                if (FAILED(hr)) continue;

                uint32_t pathLength;
                auto pathStr = path.GetRawBuffer(&pathLength);
                fileSystemEntries.insert(utils::StringUtils::Utf16ToUtf8(pathStr, pathLength));
            }
        }

        return fileSystemEntries;
    }

    os::ErrorCode BrokeredFileSystem::FindFirstFileW(Directory::FindHandle* findHandle, const utils::StringView<Il2CppNativeChar>& searchPathWithPattern, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
        using namespace ABI::Windows::Foundation::Collections;
        using namespace ABI::Windows::Storage;

        int error;
        UTF16String searchPath(searchPathWithPattern.Str(), searchPathWithPattern.Length());
        FixSlashes(searchPath);

        ComPtr<IVectorView<IStorageItem*> > foundItems;
        auto hr = FindFileSystemEntries(utils::PathUtils::DirectoryName(searchPath), searchPath, &error, &foundItems);
        if (FAILED(hr))
            return static_cast<os::ErrorCode>(error);

        ComPtr<IIterable<IStorageItem*> > foundItemsIterable;
        hr = foundItems.As(&foundItemsIterable);
        IL2CPP_ASSERT(SUCCEEDED(hr) && "Failed to cast IVectorView<IStorageItem*> to IIterable<IStorageItem*>");

        ComPtr<IIterator<IStorageItem*> > iterator;
        hr = foundItemsIterable->First(&iterator);
        if (FAILED(hr))
            return static_cast<os::ErrorCode>(HResultToWin32OrAccessDenied(hr));

        *resultAttributes = kFileAttributeDirectory;
        *resultFileName = L".";
        findHandle->handleFlags = kUseBrokeredFileSystem;
        findHandle->SetOSHandle(iterator.Detach());
        return kErrorCodeSuccess;
    }

    os::ErrorCode BrokeredFileSystem::FindNextFileW(Directory::FindHandle* findHandle, Il2CppNativeString* resultFileName, int32_t* resultAttributes)
    {
        using namespace ABI::Windows::Foundation::Collections;
        using namespace ABI::Windows::Storage;

        IL2CPP_ASSERT(findHandle->handleFlags & kUseBrokeredFileSystem);

        auto iterator = static_cast<IIterator<IStorageItem*>*>(findHandle->osHandle);

        boolean hasCurrent;
        auto hr = iterator->get_HasCurrent(&hasCurrent);
        if (FAILED(hr))
            return static_cast<os::ErrorCode>(HResultToWin32OrAccessDenied(hr));

        if (!hasCurrent)
            return kErrorCodeNoMoreFiles;

        ComPtr<IStorageItem> storageItem;
        hr = iterator->get_Current(&storageItem);
        if (FAILED(hr))
            return static_cast<os::ErrorCode>(HResultToWin32OrAccessDenied(hr));

        hr = iterator->MoveNext(&hasCurrent);
        if (FAILED(hr))
            return static_cast<os::ErrorCode>(HResultToWin32OrAccessDenied(hr));

        Microsoft::WRL::Wrappers::HString name;
        hr = storageItem->get_Name(name.GetAddressOf());
        if (FAILED(hr))
            return static_cast<os::ErrorCode>(HResultToWin32OrAccessDenied(hr));

        FileAttributes winrtAttributes;
        hr = storageItem->get_Attributes(&winrtAttributes);
        if (FAILED(hr))
            return static_cast<os::ErrorCode>(HResultToWin32OrAccessDenied(hr));

        uint32_t nameLength;
        auto nameBuffer = name.GetRawBuffer(&nameLength);
        resultFileName->assign(nameBuffer, nameBuffer + nameLength);
        *resultAttributes = TranslateWinRTAttributesToPALAttributes(winrtAttributes);
        return kErrorCodeSuccess;
    }

    os::ErrorCode BrokeredFileSystem::FindClose(void* osHandle)
    {
        using namespace ABI::Windows::Foundation::Collections;
        using namespace ABI::Windows::Storage;

        static_cast<IIterator<IStorageItem*>*>(osHandle)->Release();
        return kErrorCodeSuccess;
    }

    template<typename Operation>
    static bool MoveOrCopyFile(const UTF16String& source, const UTF16String& destination, int* error, Operation&& performOperation)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        ComPtr<IAsyncOperation<StorageFile*> > getSourceFileOp;
        ComPtr<IAsyncOperation<StorageFolder*> > getDestinationFolderOp;

        auto fullSourcePath = GetFullPath(source);
        auto hr = GetStorageFileAsync(fullSourcePath, &getSourceFileOp);
        StoreErrorAndReturnFalseIfFailed(hr);

        UTF16String destinationFolderPath, destinationFileName;
        if (!SplitPathToFolderAndFileName(destination, destinationFolderPath, destinationFileName))
        {
            *error = ERROR_ACCESS_DENIED;
            return false;
        }

        hr = GetStorageFolderAsync(destinationFolderPath, &getDestinationFolderOp);
        StoreErrorAndReturnFalseIfFailed(hr);

        // We start getting both source file and destination folder before waiting on the first async operation to complete.

        ComPtr<IStorageFile> sourceFile;
        hr = MakeSynchronousOperation(getSourceFileOp.Get())->GetResults(&sourceFile);
        if (FAILED(hr))
        {
            auto originalHR = hr;

            // If source is not a file but a folder, we need to fail with E_ACCESSDENIED
            // In this case, GetStorageFile fails with E_INVALIDARG but we cannot tell whether
            // that means that the path is malformed or if it points to a folder, so we try to
            // get a folder and if we succeed, we change the originalHR to E_ACCESSDENIED
            ComPtr<IStorageFolder> sourceFolder;
            hr = GetStorageFolder(fullSourcePath, &sourceFolder);
            if (SUCCEEDED(hr))
                originalHR = E_ACCESSDENIED;

            StoreErrorAndReturnFalseIfFailed(originalHR);
        }

        ComPtr<IStorageFolder> destinationFolder;
        hr = MakeSynchronousOperation(getDestinationFolderOp.Get())->GetResults(&destinationFolder);
        if (FAILED(hr))
        {
            // If we cannot retrieve destination folder, we should return ERROR_PATH_NOT_FOUND
            if (hr == E_INVALIDARG || hr == MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND))
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND);

            StoreErrorAndReturnFalseIfFailed(hr);
        }

        HStringReference destinationFileNameHString(destinationFileName.c_str(), static_cast<uint32_t>(destinationFileName.length()));
        hr = performOperation(sourceFile.Get(), destinationFolder.Get(), destinationFileNameHString.Get());
        if (FAILED(hr))
        {
            // We're being consistent with WIN32 API here
            if (hr == MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_EXISTS))
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_EXISTS);

            StoreErrorAndReturnFalseIfFailed(hr);
        }

        *error = kErrorCodeSuccess;
        return true;
    }

    bool BrokeredFileSystem::CopyFileW(const UTF16String& source, const UTF16String& destination, bool overwrite, int* error)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        return MoveOrCopyFile(source, destination, error, [overwrite](IStorageFile* sourceFile, IStorageFolder* destinationFolder, HSTRING destinationFileName)
        {
            NameCollisionOption collisionOption = overwrite ? NameCollisionOption_ReplaceExisting : NameCollisionOption_FailIfExists;

            ComPtr<IAsyncOperation<StorageFile*> > copyOperation;
            auto hr = sourceFile->CopyOverload(destinationFolder, destinationFileName, collisionOption, &copyOperation);
            if (FAILED(hr))
                return hr;

            return MakeSynchronousOperation(copyOperation.Get())->Wait();
        });
    }

    bool BrokeredFileSystem::MoveFileW(const UTF16String& source, const UTF16String& destination, int * error)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        return MoveOrCopyFile(source, destination, error, [](IStorageFile* sourceFile, IStorageFolder* destinationFolder, HSTRING destinationFileName)
        {
            ComPtr<IAsyncAction> moveOperation;
            auto hr = sourceFile->MoveOverloadDefaultOptions(destinationFolder, destinationFileName, &moveOperation);
            if (FAILED(hr))
                return hr;

            return MakeSynchronousOperation(moveOperation.Get())->Wait();
        });
    }

    int BrokeredFileSystem::DeleteFileW(const UTF16String& path)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        auto fullPath = GetFullPath(path);

        ComPtr<IStorageFile> storageFile;
        auto hr = GetStorageFile(fullPath, &storageFile);
        if (FAILED(hr))
            return HResultToWin32OrAccessDenied(hr);

        ComPtr<IStorageItem> storageItem;
        hr = storageFile.As(&storageItem);
        if (FAILED(hr))
            return HResultToWin32OrAccessDenied(hr);

        return DeleteStorageItem(storageItem.Get());
    }

    UnityPalFileAttributes BrokeredFileSystem::GetFileAttributesW(const UTF16String& path, int* error)
    {
        ComPtr<ABI::Windows::Storage::IStorageItem> storageItem;
        auto hr = GetStorageItem(path, &storageItem);
        if (FAILED(hr))
        {
            *error = HResultToWin32OrAccessDenied(hr);
            return static_cast<UnityPalFileAttributes>(INVALID_FILE_ATTRIBUTES);
        }

        ABI::Windows::Storage::FileAttributes attributes;
        hr = storageItem->get_Attributes(&attributes);
        if (FAILED(hr))
        {
            *error = HResultToWin32OrAccessDenied(hr);
            return static_cast<UnityPalFileAttributes>(INVALID_FILE_ATTRIBUTES);
        }

        *error = kErrorCodeSuccess;
        return TranslateWinRTAttributesToPALAttributes(attributes);
    }

    struct StringObjectKeyValuePair : Microsoft::WRL::RuntimeClass<Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::WinRtClassicComMix>, Microsoft::WRL::FtmBase, ABI::Windows::Foundation::Collections::IKeyValuePair<HSTRING, IInspectable*> >
    {
    public:
        StringObjectKeyValuePair(Microsoft::WRL::Wrappers::HString key, ComPtr<IInspectable> value) :
            m_Key(std::move(key)),
            m_Value(std::move(value))
        {
        }

        HRESULT __stdcall get_Key(HSTRING* key) override
        {
            return WindowsDuplicateString(m_Key.Get(), key);
        }

        HRESULT __stdcall get_Value(IInspectable** value) override
        {
            *value = m_Value.Get();
            (*value)->AddRef();
            return S_OK;
        }

    private:
        Microsoft::WRL::Wrappers::HString m_Key;
        ComPtr<IInspectable> m_Value;
    };

    // Wraps a single object in IIterable collection
    // Used by SetFileAttributesW and GetFileStat... we only ever need one item so there's no reason to implement a full collection
    template<typename T>
    struct SingleItemIterable : Microsoft::WRL::RuntimeClass<Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::WinRtClassicComMix>, Microsoft::WRL::FtmBase, ABI::Windows::Foundation::Collections::IIterable<T> >
    {
        SingleItemIterable(T value) :
            m_Value(value)
        {
            il2cpp::winrt::ReferenceCounter<T>::AddRef(m_Value);
        }

        ~SingleItemIterable()
        {
            il2cpp::winrt::ReferenceCounter<T>::Release(m_Value);
        }

        HRESULT __stdcall First(ABI::Windows::Foundation::Collections::IIterator<T>** first) override
        {
            *first = Microsoft::WRL::Make<Iterator>(m_Value).Detach();
            return S_OK;
        }

    private:
        T m_Value;

        struct Iterator : Microsoft::WRL::RuntimeClass<Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::WinRtClassicComMix>, Microsoft::WRL::FtmBase, ABI::Windows::Foundation::Collections::IIterator<T> >
        {
            Iterator(T value) :
                m_Value(std::move(value)),
                m_HasValue(true)
            {
                il2cpp::winrt::ReferenceCounter<T>::AddRef(m_Value);
            }

            ~Iterator()
            {
                il2cpp::winrt::ReferenceCounter<T>::Release(m_Value);
            }

            virtual HRESULT __stdcall get_Current(T* current) override
            {
                if (!m_HasValue)
                    return E_BOUNDS;

                *current = m_Value;
                il2cpp::winrt::ReferenceCounter<T>::AddRef(*current);
                return S_OK;
            }

            virtual HRESULT __stdcall get_HasCurrent(boolean* hasCurrent) override
            {
                *hasCurrent = m_HasValue;
                return S_OK;
            }

            virtual HRESULT __stdcall MoveNext(boolean* hasCurrent) override
            {
                *hasCurrent = m_HasValue = false;
                return S_OK;
            }

        private:
            T m_Value;
            bool m_HasValue;
        };
    };

    static HRESULT GetStorageItemBasicProperties(ABI::Windows::Storage::IStorageItem* storageItem, ABI::Windows::Storage::FileProperties::IBasicProperties** result)
    {
        ComPtr<ABI::Windows::Foundation::IAsyncOperation<ABI::Windows::Storage::FileProperties::BasicProperties*> > filePropertiesGetOperation;
        auto hr = storageItem->GetBasicPropertiesAsync(&filePropertiesGetOperation);
        if (FAILED(hr))
            return hr;

        return MakeSynchronousOperation(filePropertiesGetOperation.Get())->GetResults(result);
    }

    bool BrokeredFileSystem::SetFileAttributesW(const UTF16String& path, UnityPalFileAttributes attributes, int* error)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Foundation::Collections;
        using namespace ABI::Windows::Storage;
        using namespace ABI::Windows::Storage::FileProperties;

        ComPtr<IAsyncAction> savePropertiesAction;

        {
            ComPtr<IStorageItem> storageItem;
            auto hr = GetStorageItem(path, &storageItem);
            StoreErrorAndReturnFalseIfFailed(hr);

            ComPtr<IBasicProperties> fileProperties;
            hr = GetStorageItemBasicProperties(storageItem.Get(), &fileProperties);
            StoreErrorAndReturnFalseIfFailed(hr);

            ComPtr<IStorageItemExtraProperties> extraFileProperties;
            hr = fileProperties.As(&extraFileProperties);
            StoreErrorAndReturnFalseIfFailed(hr);

            ComPtr<IPropertyValueStatics> propertyValueStatics;
            hr = RoGetActivationFactory(HStringReference(RuntimeClass_Windows_Foundation_PropertyValue).Get(), __uuidof(propertyValueStatics), &propertyValueStatics);
            IL2CPP_ASSERT(SUCCEEDED(hr) && "Failed to get PropertyValue statics!"); // This should never fail.

            Microsoft::WRL::Wrappers::HString propertyKey;
            hr = propertyKey.Set(L"System.FileAttributes");
            StoreErrorAndReturnFalseIfFailed(hr);

            ComPtr<IInspectable> attributesValue;
            hr = propertyValueStatics->CreateUInt32(TranslatePALAttributesToWinRTAttributes(attributes), &attributesValue);
            StoreErrorAndReturnFalseIfFailed(hr);

            auto pair = Microsoft::WRL::Make<StringObjectKeyValuePair>(std::move(propertyKey), std::move(attributesValue));
            auto propertyPair = Microsoft::WRL::Make<SingleItemIterable<IKeyValuePair<HSTRING, IInspectable*>*> >(pair.Get());
            hr = extraFileProperties->SavePropertiesAsync(propertyPair.Get(), &savePropertiesAction);
            StoreErrorAndReturnFalseIfFailed(hr);

            // We release all unneeded smart pointers before waiting on async operation
        }

        auto hr = MakeSynchronousOperation(savePropertiesAction.Get())->Wait();
        StoreErrorAndReturnFalseIfFailed(hr);

        *error = il2cpp::os::ErrorCode::kErrorCodeSuccess;
        return true;
    }

    bool BrokeredFileSystem::GetFileStat(const std::string& utf8Path, const UTF16String& path, FileStat* stat, int* error)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Foundation::Collections;
        using namespace ABI::Windows::Storage;
        using namespace ABI::Windows::Storage::FileProperties;

        FileAttributes winrtAttributes;
        DateTime creationDate, modificationDate, accessDate;
        UINT64 fileSize;
        ComPtr<IAsyncOperation<IMap<HSTRING, IInspectable*>*> > propertiesRetrievalOperation;
        HStringReference dateAccessedKeyString(L"System.DateAccessed");

        {
            ComPtr<IStorageItem> storageItem;
            auto hr = GetStorageItem(path, &storageItem);
            StoreErrorAndReturnFalseIfFailed(hr);

            hr = storageItem->get_Attributes(&winrtAttributes);
            StoreErrorAndReturnFalseIfFailed(hr);

            hr = storageItem->get_DateCreated(&creationDate);
            StoreErrorAndReturnFalseIfFailed(hr);

            ComPtr<IBasicProperties> fileProperties;
            hr = GetStorageItemBasicProperties(storageItem.Get(), &fileProperties);
            StoreErrorAndReturnFalseIfFailed(hr);

            hr = fileProperties->get_DateModified(&modificationDate);
            StoreErrorAndReturnFalseIfFailed(hr);

            hr = fileProperties->get_Size(&fileSize);
            StoreErrorAndReturnFalseIfFailed(hr);

            ComPtr<IStorageItemExtraProperties> extraFileProperties;
            hr = fileProperties.As(&extraFileProperties);
            StoreErrorAndReturnFalseIfFailed(hr);

            auto dateAccessedKey = Microsoft::WRL::Make<SingleItemIterable<HSTRING> >(dateAccessedKeyString.Get());
            hr = extraFileProperties->RetrievePropertiesAsync(dateAccessedKey.Get(), &propertiesRetrievalOperation);
            StoreErrorAndReturnFalseIfFailed(hr);

            // We release all unneeded smart pointers before waiting on async operation
        }

        ComPtr<IMap<HSTRING, IInspectable*> > propertiesMap;
        auto hr = MakeSynchronousOperation(propertiesRetrievalOperation.Get())->GetResults(&propertiesMap);
        StoreErrorAndReturnFalseIfFailed(hr);

        ComPtr<IInspectable> accessDateInspectable; // This will fail for certain file types
        if (SUCCEEDED(propertiesMap->Lookup(dateAccessedKeyString.Get(), &accessDateInspectable)))
        {
            ComPtr<IReference<DateTime> > boxedAccessDate;
            hr = accessDateInspectable.As(&boxedAccessDate);
            StoreErrorAndReturnFalseIfFailed(hr);

            hr = boxedAccessDate->get_Value(&accessDate);
            StoreErrorAndReturnFalseIfFailed(hr);
        }
        else
        {
            // Fallback to modification date if failed
            accessDate = modificationDate;
        }

        stat->attributes = TranslateWinRTAttributesToPALAttributes(winrtAttributes);
        stat->name = il2cpp::utils::PathUtils::Basename(utf8Path);
        stat->length = fileSize;
        stat->creation_time = creationDate.UniversalTime;
        stat->last_write_time = modificationDate.UniversalTime;
        stat->last_access_time = accessDate.UniversalTime;

        *error = il2cpp::os::ErrorCode::kErrorCodeSuccess;
        return true;
    }

    FileHandle* BrokeredFileSystem::Open(const UTF16String& path, uint32_t desiredAccess, uint32_t shareMode, uint32_t creationDisposition, uint32_t flagsAndAttributes, int* error)
    {
        using namespace ABI::Windows::Foundation;
        using namespace ABI::Windows::Storage;

        UTF16String parentFolderName, name;
        if (!SplitPathToFolderAndFileName(path, parentFolderName, name))
        {
            *error = ERROR_ACCESS_DENIED;
            return reinterpret_cast<FileHandle*>(INVALID_HANDLE_VALUE);
        }

        ComPtr<IStorageFolder> parentFolder;
        auto hr = GetStorageFolder(parentFolderName, &parentFolder);
        if (FAILED(hr))
        {
            *error = HResultToWin32OrAccessDenied(hr);
            return reinterpret_cast<FileHandle*>(INVALID_HANDLE_VALUE);
        }

        ComPtr<winrt_interfaces::IStorageFolderHandleAccess> folderHandleAccess;
        hr = parentFolder.As(&folderHandleAccess);
        if (FAILED(hr))
        {
            *error = ERROR_ACCESS_DENIED;
            return reinterpret_cast<FileHandle*>(INVALID_HANDLE_VALUE);
        }

        int translatedAccess = winrt_interfaces::HAO_NONE;
        if (desiredAccess & GENERIC_READ)
            translatedAccess |= winrt_interfaces::HAO_READ | winrt_interfaces::HAO_READ_ATTRIBUTES;

        if (desiredAccess & GENERIC_WRITE)
            translatedAccess |= winrt_interfaces::HAO_WRITE;

        HANDLE fileHandle;
        hr = folderHandleAccess->Create(name.c_str(),
            static_cast<winrt_interfaces::HANDLE_CREATION_OPTIONS>(creationDisposition),
            static_cast<winrt_interfaces::HANDLE_ACCESS_OPTIONS>(translatedAccess),
            static_cast<winrt_interfaces::HANDLE_SHARING_OPTIONS>(shareMode),
            static_cast<winrt_interfaces::HANDLE_OPTIONS>(flagsAndAttributes & winrt_interfaces::HO_ALL_POSSIBLE_OPTIONS),
            nullptr,
            &fileHandle);
        if (FAILED(hr))
        {
            *error = ERROR_ACCESS_DENIED;
            return reinterpret_cast<FileHandle*>(INVALID_HANDLE_VALUE);
        }

        *error = ERROR_SUCCESS;
        return reinterpret_cast<FileHandle*>(fileHandle);
    }

    void BrokeredFileSystem::CleanupStatics()
    {
        s_StorageFileStatics.Release();
        s_StorageFolderStatics.Release();
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\BrokeredFileSystem.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Environment.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINRT

#include "os\Environment.h"
#include "os\Win32\WindowsHelpers.h"
#include "utils\Expected.h"
#include "utils\Il2CppError.h"
#include "utils\StringUtils.h"

#include <windows.storage.h>
#include <wrl.h>

using namespace ABI::Windows::Storage;
using namespace Microsoft::WRL;
using namespace Microsoft::WRL::Wrappers;

namespace il2cpp
{
namespace os
{
#define CSIDL_DESKTOP                   0x0000        // <desktop>
#define CSIDL_PROGRAMS                  0x0002        // Start Menu\Programs
#define CSIDL_PERSONAL                  0x0005        // My Documents
#define CSIDL_FAVORITES                 0x0006        // <user name>\Favorites
#define CSIDL_STARTUP                   0x0007        // Start Menu\Programs\Startup
#define CSIDL_RECENT                    0x0008        // <user name>\Recent
#define CSIDL_SENDTO                    0x0009        // <user name>\SendTo
#define CSIDL_STARTMENU                 0x000b        // <user name>\Start Menu
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#define CSIDL_MYVIDEO                   0x000e        // "My Videos" folder
#define CSIDL_DESKTOPDIRECTORY          0x0010        // <user name>\Desktop
#define CSIDL_DRIVES                    0x0011        // My Computer
#define CSIDL_NETWORK                   0x0012        // Network Neighborhood (My Network Places)
#define CSIDL_NETHOOD                   0x0013        // <user name>\nethood
#define CSIDL_FONTS                     0x0014        // windows\fonts
#define CSIDL_TEMPLATES                 0x0015
#define CSIDL_COMMON_STARTMENU          0x0016        // All Users\Start Menu
#define CSIDL_COMMON_PROGRAMS           0X0017        // All Users\Start Menu\Programs
#define CSIDL_COMMON_STARTUP            0x0018        // All Users\Startup
#define CSIDL_COMMON_DESKTOPDIRECTORY   0x0019        // All Users\Desktop
#define CSIDL_APPDATA                   0x001a        // <user name>\Application Data
#define CSIDL_PRINTHOOD                 0x001b        // <user name>\PrintHood
#define CSIDL_LOCAL_APPDATA             0x001c        // <user name>\Local Settings\Applicaiton Data (non roaming)
#define CSIDL_ALTSTARTUP                0x001d        // non localized startup
#define CSIDL_COMMON_ALTSTARTUP         0x001e        // non localized common startup
#define CSIDL_COMMON_FAVORITES          0x001f
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023        // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025        // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026        // C:\Program Files
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#define CSIDL_PROFILE                   0x0028        // USERPROFILE
#define CSIDL_SYSTEMX86                 0x0029        // x86 system directory on RISC
#define CSIDL_PROGRAM_FILESX86          0x002a        // x86 C:\Program Files on RISC
#define CSIDL_PROGRAM_FILES_COMMON      0x002b        // C:\Program Files\Common
#define CSIDL_PROGRAM_FILES_COMMONX86   0x002c        // x86 Program Files\Common on RISC
#define CSIDL_COMMON_TEMPLATES          0x002d        // All Users\Templates
#define CSIDL_COMMON_DOCUMENTS          0x002e        // All Users\Documents
#define CSIDL_COMMON_ADMINTOOLS         0x002f        // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030        // <user name>\Start Menu\Programs\Administrative Tools
#define CSIDL_CONNECTIONS               0x0031        // Network and Dial-up Connections
#define CSIDL_COMMON_MUSIC              0x0035        // All Users\My Music
#define CSIDL_COMMON_PICTURES           0x0036        // All Users\My Pictures
#define CSIDL_COMMON_VIDEO              0x0037        // All Users\My Video
#define CSIDL_RESOURCES                 0x0038        // Resource Direcotry
#define CSIDL_RESOURCES_LOCALIZED       0x0039        // Localized Resource Direcotry
#define CSIDL_COMMON_OEM_LINKS          0x003a        // Links to All Users OEM specific apps
#define CSIDL_CDBURN_AREA               0x003b        // USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning
#define CSIDL_COMPUTERSNEARME           0x003d        // Computers Near Me (computered from Workgroup membership)

    template<typename T>
    static inline utils::Expected<std::string> GetAppFolder(T appDataToStorageFolder)
    {
        ComPtr<IApplicationDataStatics> appDataStatics;
        ComPtr<IApplicationData> appData;
        ComPtr<IStorageFolder> appDataFolder;
        ComPtr<IStorageItem> appDataFolderItem;
        HString appDataPath;

        auto hr = RoGetActivationFactory(HStringReference(RuntimeClass_Windows_Storage_ApplicationData).Get(), __uuidof(IApplicationDataStatics), &appDataStatics);
        if (IL2CPP_HR_FAILED(hr))
            return utils::Il2CppError(utils::ComError, hr);

        hr = appDataStatics->get_Current(&appData);
        if (IL2CPP_HR_FAILED(hr))
            return utils::Il2CppError(utils::ComError, hr);

        hr = appDataToStorageFolder(appData.Get(), &appDataFolder);
        if (IL2CPP_HR_FAILED(hr))
            return utils::Il2CppError(utils::ComError, hr);

        hr = appDataFolder.As(&appDataFolderItem);
        if (IL2CPP_HR_FAILED(hr))
            return utils::Il2CppError(utils::ComError, hr);

        hr = appDataFolderItem->get_Path(appDataPath.GetAddressOf());
        if (IL2CPP_HR_FAILED(hr))
            return utils::Il2CppError(utils::ComError, hr);

        unsigned int dummy;
        return utils::StringUtils::Utf16ToUtf8(appDataPath.GetRawBuffer(&dummy));
    }

    static inline utils::Expected<std::string> GetLocalAppDataFolder()
    {
        return GetAppFolder([](IApplicationData* appData, IStorageFolder** folder) { return appData->get_LocalFolder(folder); });
    }

    static inline utils::Expected<std::string> GetRoamingAppDataFolder()
    {
        return GetAppFolder([](IApplicationData* appData, IStorageFolder** folder) { return appData->get_RoamingFolder(folder); });
    }

    template<typename T>
    static utils::Expected<std::string> GetUserFolderPath(T&& userDataPathToFolderPathConverter)
    {
        ComPtr<ABI::Windows::Storage::IUserDataPathsStatics> userDataPathsStatics;
        auto hr = RoGetActivationFactory(HStringReference(L"Windows.Storage.UserDataPaths").Get(), __uuidof(userDataPathsStatics), &userDataPathsStatics);
        if (FAILED(hr))
        {
            // Before OS version 16299, you weren't allowed to touch these folders.
            // In OS version 16299 they added UserDataPaths class for this purpose
            // If that class does not exist, we throw UnauthorizedAccessException
            return utils::Il2CppError(utils::UnauthorizedAccess, "Failed getting the path of a special folder: Access Denied.");
        }

        ComPtr<ABI::Windows::Storage::IUserDataPaths> userDataPaths;
        hr = userDataPathsStatics->GetDefault(&userDataPaths);
        if (IL2CPP_HR_FAILED(hr))
            return utils::Il2CppError(utils::ComError, hr);

        HString resultHString;
        hr = userDataPathToFolderPathConverter(userDataPaths.Get(), resultHString.GetAddressOf());
        if (IL2CPP_HR_FAILED(hr))
            return utils::Il2CppError(utils::ComError, hr);

        unsigned int dummy;
        return utils::StringUtils::Utf16ToUtf8(resultHString.GetRawBuffer(&dummy));
    }

    utils::Expected<std::string> Environment::GetWindowsFolderPath(int32_t folder)
    {
        switch (folder)
        {
            case CSIDL_APPDATA:
                return GetRoamingAppDataFolder();

            case CSIDL_COOKIES:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Cookies(result); });

            case CSIDL_DESKTOP:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Desktop(result); });

            case CSIDL_FAVORITES:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Favorites(result); });

            case CSIDL_HISTORY:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_History(result); });

            case CSIDL_INTERNET_CACHE:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_InternetCache(result); });

            case CSIDL_MYMUSIC:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Music(result); });

            case CSIDL_MYPICTURES:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Pictures(result); });

            case CSIDL_MYVIDEO:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Videos(result); });

            case CSIDL_PERSONAL:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Documents(result); });

            case CSIDL_PROFILE:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Profile(result); });

            case CSIDL_RECENT:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Recent(result); });

            case CSIDL_TEMPLATES:
                return GetUserFolderPath([](ABI::Windows::Storage::IUserDataPaths* userDataPaths, HSTRING* result) { return userDataPaths->get_Templates(result); });

            case CSIDL_LOCAL_APPDATA:
                return GetLocalAppDataFolder();

            default:
                return utils::Il2CppError(utils::UnauthorizedAccess, "Failed getting the path of a special folder: Access Denied.");
        }

        return std::string();
    }

    utils::Expected<bool> Environment::Is64BitOs()
    {
#if IL2CPP_TARGET_WINRT
        BOOL isWow64Process = FALSE;
        if (IsWow64Process(GetCurrentProcess(), &isWow64Process))
            return isWow64Process == TRUE;

        return false;
#endif // IL2CPP_TARGET_WINRT
        return true;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Environment.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\File.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINRT

#include <io.h>

#include "os/File.h"
#include "os/Win32/WindowsHeaders.h"
#include "utils/Expected.h"
#include "utils/Il2CppError.h"

namespace il2cpp
{
namespace os
{
    static inline std::wstring GetDirectoryForStandardOutput()
    {
        wchar_t buffer[MAX_PATH + 2];
        uint32_t tempPathLength = GetTempPathW(MAX_PATH + 2, buffer);
        return std::wstring(buffer, tempPathLength);
    }

    static FileHandle* GetOrCreateRedirectedHandle(FILE* stdFile, const wchar_t* fileNameOnDisk)
    {
#if IL2CPP_DEBUG || IL2CPP_DEVELOPMENT
        auto stdFd = _fileno(stdFile);
        auto stdHandle = reinterpret_cast<FileHandle*>(_get_osfhandle(stdFd));

        if (stdHandle != INVALID_HANDLE_VALUE && !_isatty(stdFd))
            return stdHandle;

        std::wstring pathOnDisk = GetDirectoryForStandardOutput() + fileNameOnDisk;
        auto redirectedFile = _wfreopen(pathOnDisk.c_str(), L"w+", stdFile);
        return reinterpret_cast<FileHandle*>(_get_osfhandle(_fileno(redirectedFile)));
#else
        return NULL;
#endif
    }

    utils::Expected<bool> File::Isatty(FileHandle* fileHandle)
    {
        return utils::Il2CppError(utils::NotSupported, "File::Isatty is not supported on WinRT");
    }

    FileHandle* File::GetStdInput()
    {
        return GetOrCreateRedirectedHandle(stdin, L"stdin.txt");
    }

    FileHandle* File::GetStdError()
    {
        return GetOrCreateRedirectedHandle(stderr, L"stderr.txt");
    }

    FileHandle* File::GetStdOutput()
    {
        return GetOrCreateRedirectedHandle(stdout, L"stdout.txt");
    }
} //os
} //il2cpp

#endif // IL2CPP_TARGET_WINRT
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\File.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Initialize.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINRT

#include "os/Initialize.h"
#include "os/Win32/WindowsHelpers.h"
#include "os/BrokeredFileSystem.h"
#include "os/Locale.h"

#include <io.h>

void il2cpp::os::Uninitialize()
{
    BrokeredFileSystem::CleanupStatics();
    Locale::UnInitializeWinRT();

    HANDLE stdoutHandle = reinterpret_cast<HANDLE>(_get_osfhandle(_fileno(stdout)));
    HANDLE stderrHandle = reinterpret_cast<HANDLE>(_get_osfhandle(_fileno(stderr)));

    if (stdoutHandle != INVALID_HANDLE_VALUE)
        FlushFileBuffers(stdoutHandle);

    if (stderrHandle != INVALID_HANDLE_VALUE)
        FlushFileBuffers(stderrHandle);
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Initialize.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Locale.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINRT || IL2CPP_TARGET_WINDOWS_GAMES

#include "os/Locale.h"
#include "os/Win32/WindowsHeaders.h"

#if IL2CPP_TARGET_WINRT
#include "utils/StringUtils.h"
#include "WinRTVector.h"

#include <Windows.ApplicationModel.Resources.Core.h>
#include <wrl.h>
#endif

namespace il2cpp
{
namespace os
{
    std::string Locale::GetLocale()
    {
        WCHAR wideLocaleName[LOCALE_NAME_MAX_LENGTH];
        if (GetUserDefaultLocaleName(wideLocaleName, LOCALE_NAME_MAX_LENGTH) == 0)
            return std::string();

        int length = static_cast<int>(wcslen(wideLocaleName));
        std::string multiLocaleName;
        multiLocaleName.resize(2 * length);
        int narrowLength = WideCharToMultiByte(CP_ACP, 0, &wideLocaleName[0], length, &multiLocaleName[0], 2 * length, NULL, NULL);
        multiLocaleName.resize(narrowLength);
        return multiLocaleName;
    }

#if IL2CPP_TARGET_WINRT
    static CultureInfoChangedCallback s_OnCultureInfoChangedInAppX;
    static EventRegistrationToken s_OnGlobalResourceContextChangedToken;
    static Microsoft::WRL::ComPtr<ABI::Windows::ApplicationModel::Resources::Core::IResourceContext> s_AppResourceContext;
    static Microsoft::WRL::ComPtr<ABI::Windows::Foundation::Collections::IObservableMap<HSTRING, HSTRING> > s_AppResourceContextValues;

    static il2cpp_hresult_t DispatchLanguageUpdateToManagedCode()
    {
        using namespace ABI::Windows::Foundation::Collections;
        using namespace Microsoft::WRL;
        using namespace Microsoft::WRL::Wrappers;

        ComPtr<IVectorView<HSTRING> > languages;
        auto hr = s_AppResourceContext->get_Languages(&languages);
        if (FAILED(hr))
            return hr;

        uint32_t languageCount;
        hr = languages->get_Size(&languageCount);
        if (FAILED(hr))
            return hr;

        for (uint32_t i = 0; i < languageCount; i++)
        {
            HString language;
            hr = languages->GetAt(i, language.GetAddressOf());
            if (SUCCEEDED(hr))
            {
                uint32_t languageLength;
                auto languagePtr = language.GetRawBuffer(&languageLength);

                // HSTRINGs aren't null terminated so we need to copy
                // it into a null terminated buffer before passing it to
                // win32 APIs or to managed code
                if (languageLength >= LOCALE_NAME_MAX_LENGTH)
                    languageLength = LOCALE_NAME_MAX_LENGTH - 1;

                wchar_t languageBuffer[LOCALE_NAME_MAX_LENGTH];
                memcpy(languageBuffer, languagePtr, languageLength * sizeof(wchar_t));
                languageBuffer[languageLength] = 0;

                if (IsValidLocaleName(languageBuffer))
                {
                    s_OnCultureInfoChangedInAppX(languageBuffer);
                    return S_OK;
                }

                wchar_t resolvedLanguage[LOCALE_NAME_MAX_LENGTH];
                if (ResolveLocaleName(languageBuffer, resolvedLanguage, IL2CPP_ARRAY_SIZE(resolvedLanguage)) != 0)
                {
                    s_OnCultureInfoChangedInAppX(resolvedLanguage);
                    return S_OK;
                }
            }
        }

        s_OnCultureInfoChangedInAppX(nullptr);
        return S_OK;
    }

    il2cpp_hresult_t Locale::InitializeUserPreferredCultureInfoInAppX(CultureInfoChangedCallback onCultureInfoChangedInAppX)
    {
        using namespace ABI::Windows::ApplicationModel::Resources::Core;
        using namespace ABI::Windows::Foundation::Collections;
        using namespace Microsoft::WRL;
        using namespace Microsoft::WRL::Wrappers;

        s_OnCultureInfoChangedInAppX = onCultureInfoChangedInAppX;

        if (s_OnGlobalResourceContextChangedToken.value == 0)
        {
            ComPtr<IResourceContextStatics2> resourceContextStatics;
            auto hr = RoGetActivationFactory(HStringReference(RuntimeClass_Windows_ApplicationModel_Resources_Core_ResourceContext).Get(), __uuidof(resourceContextStatics), &resourceContextStatics);
            if (FAILED(hr))
                return hr;

            hr = resourceContextStatics->GetForViewIndependentUse(&s_AppResourceContext);
            if (FAILED(hr))
                return hr;

            hr = s_AppResourceContext->get_QualifierValues(&s_AppResourceContextValues);
            if (FAILED(hr))
                return hr;

            hr = s_AppResourceContextValues->add_MapChanged(Callback<MapChangedEventHandler<HSTRING, HSTRING> >([](IObservableMap<HSTRING, HSTRING>* sender, IMapChangedEventArgs<HSTRING>* e)
            {
                DispatchLanguageUpdateToManagedCode();
                return S_OK;
            }).Get(), &s_OnGlobalResourceContextChangedToken);
            if (FAILED(hr))
                return hr;

            hr = DispatchLanguageUpdateToManagedCode();
            if (FAILED(hr))
                return hr;
        }

        return IL2CPP_S_OK;
    }

    static bool AreLanguagesEqual(HSTRING language, const Il2CppChar* name, uint32_t length)
    {
        uint32_t languageLength;
        auto languagePtr = WindowsGetStringRawBuffer(language, &languageLength);
        return CompareStringOrdinal(name, length, languagePtr, languageLength, TRUE) == CSTR_EQUAL;
    }

    il2cpp_hresult_t Locale::SetUserPreferredCultureInfoInAppX(const Il2CppChar* name)
    {
        using namespace ABI::Windows::Foundation::Collections;
        using namespace Microsoft::WRL;
        using namespace Microsoft::WRL::Wrappers;

        ComPtr<IVectorView<HSTRING> > languages;
        auto hr = s_AppResourceContext->get_Languages(&languages);
        if (FAILED(hr))
            return hr;

        uint32_t languageCount;
        hr = languages->get_Size(&languageCount);
        if (FAILED(hr))
            return hr;

        auto nameLength = static_cast<uint32_t>(utils::StringUtils::StrLen(name));
        if (languageCount > 0)
        {
            HString firstLanguage;
            if (SUCCEEDED(languages->GetAt(0, firstLanguage.GetAddressOf())) && AreLanguagesEqual(firstLanguage.Get(), name, nameLength))
                return S_OK; // Nothing to do, the language is already set
        }

        auto newLanguages = Make<winrt::Vector<HSTRING> >();
        newLanguages->Reserve(languageCount + 1);
        newLanguages->Append(HStringReference(name).Get());

        if (languageCount > 0)
        {
            HString language;
            if (SUCCEEDED(languages->GetAt(0, language.GetAddressOf())))
            {
                // No need to check for duplicates: we already checked that the new language doesn't match the first language above
                newLanguages->Append(language.Get());
            }

            for (uint32_t i = 1; i < languageCount; i++)
            {
                if (SUCCEEDED(languages->GetAt(i, language.GetAddressOf())) && !AreLanguagesEqual(language.Get(), name, nameLength))
                    newLanguages->Append(language.Get());
            }
        }

        return s_AppResourceContext->put_Languages(newLanguages.Get());
    }

    void Locale::UnInitializeWinRT()
    {
        if (s_OnGlobalResourceContextChangedToken.value != 0)
        {
            s_AppResourceContextValues->remove_MapChanged(s_OnGlobalResourceContextChangedToken);
            s_OnGlobalResourceContextChangedToken.value = 0;
        }

        s_OnCultureInfoChangedInAppX = nullptr;
        s_AppResourceContext = nullptr;
        s_AppResourceContextValues = nullptr;
    }

#endif
} /* namespace os */
} /* namespace il2cpp */

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Locale.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Process.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINRT
#include "os/Win32/WindowsHeaders.h"

#include "os/Process.h"
#include "utils/Il2CppError.h"
#include "utils/StringUtils.h"

struct ProcessHandle
{
    HANDLE handle;
};


namespace il2cpp
{
namespace os
{
    int Process::GetCurrentProcessId()
    {
        return ::GetCurrentProcessId();
    }

    utils::Expected<ProcessHandle*> Process::GetProcess(int processId)
    {
        if (processId == GetCurrentProcessId())
            return (ProcessHandle*)::GetCurrentProcess();

        return utils::Il2CppError(utils::NotSupported, "It is not possible to interact with other system processes on current platform.");
    }

    void Process::FreeProcess(ProcessHandle* handle)
    {
        // We have nothing to do here.
    }

    utils::Expected<std::string> Process::GetProcessName(ProcessHandle* handle)
    {
        if (handle == ::GetCurrentProcess())
        {
            wchar_t path[MAX_PATH + 1];
            SetLastError(ERROR_SUCCESS);

            DWORD pathLength = GetModuleFileNameW(NULL, path, MAX_PATH + 1);
            return utils::StringUtils::Utf16ToUtf8(path, static_cast<int>(pathLength));
        }

        return utils::Il2CppError(utils::NotSupported, "It is not possible to interact with other system processes on current platform.");
    }

    intptr_t Process::GetMainWindowHandle(int32_t pid)
    {
        return 0;
    }
}
}
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Process.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Win32ApiSharedEmulation.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINRT

#include "Win32ApiSharedEmulation.h"

extern "C"
{
    // Provide a dummy GetIfEntry for WinRT. This is used by the class library
    // code to implement GetAllNetworkInterfaces(). It looks like the values
    // returned though are never actually used. So this dummy implementation seems
    // to be enough for the class library code to work in WinRT.
    DWORD WINAPI GetIfEntry(PMIB_IFROW pIfRow)
    {
        memset(pIfRow, 0, sizeof(MIB_IFROW));
        return NO_ERROR;
    }
} // extern "C"

#endif // IL2CPP_TARGET_WINRT
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Win32ApiSharedEmulation.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Win32ApiWinRTEmulation.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_TARGET_WINRT

#include "os/Win32/WindowsHeaders.h"

#include <string>
#include <windows.system.profile.h>
#include <windows.system.userprofile.h>

#include "os/Mutex.h"
#include "SynchronousOperation.h"
#include "utils/Il2CppHashMap.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "Win32ApiSharedEmulation.h"
#include "Win32ApiWinRTEmulation.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

using namespace ABI::Windows::Foundation;
using namespace ABI::Windows::System::Profile;
using namespace ABI::Windows::System::UserProfile;
using namespace Microsoft::WRL;
using namespace Microsoft::WRL::Wrappers;
using namespace il2cpp::winrt;

extern "C"
{
    BOOL WINAPI GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
    {
#define ERROR_CHECK(hr) do { if (FAILED(hr)) { SetLastError(WIN32_FROM_HRESULT(hr)); return FALSE; } } while (false)

        ComPtr<IUserInformationStatics> info;
        auto hr = RoGetActivationFactory(HStringReference(RuntimeClass_Windows_System_UserProfile_UserInformation).Get(), __uuidof(info), &info);
        ERROR_CHECK(hr);

        boolean isAccessAllowed;
        hr = info->get_NameAccessAllowed(&isAccessAllowed);
        ERROR_CHECK(hr);

        if (!isAccessAllowed)
        {
            SetLastError(ERROR_ACCESS_DENIED);
            return FALSE;
        }

        ComPtr<IAsyncOperation<HSTRING> > op;
        hr = info->GetDisplayNameAsync(&op);
        ERROR_CHECK(hr);

        HString name;
        hr = MakeSynchronousOperation(op.Get())->GetResults(name.GetAddressOf());
        ERROR_CHECK(hr);

#undef ERROR_CHECK

        return CopyHStringToBuffer(name, lpBuffer, pcbBuffer);
    }
} // extern "C"

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\os\WinRT\Win32ApiWinRTEmulation.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\pch\pch-cpp.cpp---------------
.
.
#include "pch-cpp.hpp"
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\pch\pch-cpp.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\DirectoryUtils.cpp---------------
.
.
/*
    Directory utility functions that are common to all posix and posix-like platforms.
*/

#include "il2cpp-config.h"

#include "StringUtils.h"
#include "DirectoryUtils.h"

namespace il2cpp
{
namespace utils
{
    bool Match(const std::string name, size_t nameIndex, const std::string& pattern, const size_t patternIndex)
    {
        const size_t nameLength = name.length();

        for (size_t i = patternIndex, patternLength = pattern.length(); i < patternLength; ++i)
        {
            const char c = pattern[i];

            if (c == '*')
            {
                if (i + 1 == patternLength) // Star is last character, match everything.
                    return true;

                do
                {
                    // Check that we match the rest of the pattern against name.
                    if (Match(name, nameIndex, pattern, i + 1))
                        return true;
                }
                while (nameIndex++ < nameLength);

                return false;
            }
            else if (c == '?')
            {
                if (nameIndex == nameLength)
                    return false;

                nameIndex++;
            }
            else
            {
                if (nameIndex == nameLength)
                {
                    // A pattern ending with .* should match a file with no extension
                    // The pattern "file.*" should match "file"
                    if (c == '.' && i + 2 == patternLength && pattern[i + 1] == '*')
                        return true;
                    return false;
                }
                else if (name[nameIndex] != c)
                {
                    return false;
                }

                nameIndex++;
            }
        }

        // All characters matched
        return nameIndex == nameLength;
    }

    bool Match(const std::string name, const std::string& pattern)
    {
        return Match(name, 0, pattern, 0);
    }

    std::string CollapseAdjacentStars(const std::string& pattern)
    {
        std::string matchPattern;
        matchPattern.reserve(pattern.length());

        // Collapse adjacent stars into one
        for (size_t i = 0, length = pattern.length(); i < length; ++i)
        {
            if (i > 0 && pattern[i] == '*' && pattern[i - 1] == '*')
                continue;

            matchPattern.append(1, pattern[i]);
        }

        return matchPattern;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\DirectoryUtils.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Environment.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/StringUtils.h"
#include "utils/Environment.h"

namespace il2cpp
{
namespace utils
{
    static int s_ArgCount = 0;
    static std::vector<UTF16String> s_Args;

    void Environment::SetMainArgs(const char* const* args, int num_args)
    {
        s_ArgCount = num_args;
        s_Args.resize(num_args);

        for (int i = 0; i < num_args; i++)
            s_Args[i] = utils::StringUtils::Utf8ToUtf16(args[i]);
    }

    void Environment::SetMainArgs(const Il2CppChar* const* args, int num_args)
    {
        s_ArgCount = num_args;
        s_Args.resize(num_args);

        for (int i = 0; i < num_args; i++)
            s_Args[i] = args[i];
    }

    const std::vector<UTF16String>& Environment::GetMainArgs()
    {
        return s_Args;
    }

    int Environment::GetNumMainArgs()
    {
        return s_ArgCount;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Environment.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Exception.cpp---------------
.
.
#include "utils/Exception.h"
#include "utils/StringUtils.h"
#include "il2cpp-object-internals.h"

struct Il2CppClass;

namespace il2cpp
{
namespace utils
{
    std::string Exception::FormatException(const Il2CppException* ex)
    {
        std::string exception_namespace = ex->klass->namespaze;
        std::string exception_type = ex->klass->name;
        if (ex->message)
            return exception_namespace + "." + exception_type + ": " + il2cpp::utils::StringUtils::Utf16ToUtf8(il2cpp::utils::StringUtils::GetChars(ex->message));
        else
            return exception_namespace + "." + exception_type;
    }

    std::string Exception::FormatInvalidCastException(const Il2CppClass* fromType, const Il2CppClass* toType)
    {
        std::string message;
        if (fromType != NULL && toType != NULL)
        {
            message += "Unable to cast object of type '";
            message += fromType->name;
            message += "' to type '";
            message += toType->name;
            message += "'.";
        }
        return message;
    }

    std::string Exception::FormatStackTrace(const Il2CppException* ex)
    {
        // Exception.RestoreExceptionDispatchInfo() will clear stack_trace, so we need to ensure that we read it only once
        Il2CppString* stack_trace = ex->stack_trace;

        if (stack_trace)
            return il2cpp::utils::StringUtils::Utf16ToUtf8(il2cpp::utils::StringUtils::GetChars(stack_trace));

        return "";
    }

    std::string Exception::FormatBaselibErrorState(const Baselib_ErrorState& errorState)
    {
        const auto len = Baselib_ErrorState_Explain(&errorState, nullptr, 0, Baselib_ErrorState_ExplainVerbosity_ErrorType_SourceLocation_Explanation);
        std::string buffer(len, ' ');
        // std::string::data() is const only until C++17
        Baselib_ErrorState_Explain(&errorState, &buffer[0], len, Baselib_ErrorState_ExplainVerbosity_ErrorType_SourceLocation_Explanation);
        return buffer;
    }
} // utils
} // il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Exception.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Il2CppError.cpp---------------
.
.
#include "Il2CppError.h"

namespace il2cpp
{
namespace utils
{
    Il2CppError::Il2CppError() : m_ErrorCode(NoError), m_Hr(0)
    {
    }

    Il2CppError::Il2CppError(Il2CppErrorCode errorCode, const char* message) :
        m_ErrorCode(errorCode), m_Message(message), m_Hr(0)
    {
    }

    Il2CppError::Il2CppError(Il2CppErrorCode errorCode, il2cpp_hresult_t hr) :
        m_ErrorCode(errorCode), m_Hr(hr)
    {
    }

    Il2CppErrorCode Il2CppError::GetErrorCode() const
    {
        return m_ErrorCode;
    }

    std::string Il2CppError::GetErrorMessage() const
    {
        return m_Message;
    }

    il2cpp_hresult_t Il2CppError::GetHr() const
    {
        return m_Hr;
    }
} // namespace utils
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Il2CppError.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Logging.cpp---------------
.
.
#include <stdarg.h>
#include <cstdio>
#include <cassert>
#include "Logging.h"
#include "Output.h"

using namespace il2cpp::utils;

static void DefaultLogCallback(const char* message)
{
    Output::WriteToStdout(message);
    Output::WriteToStdout("\n");
}

Il2CppLogCallback Logging::s_Callback = DefaultLogCallback;

void Logging::Write(const char* format, ...)
{
    IL2CPP_ASSERT(s_Callback != NULL);

    if (format == NULL)
        return;

    va_list va;
    va_start(va, format);

    const char* prefix = "[libil2cpp] ";
    const int bufferSize = 1024 * 5;
    char buffer[bufferSize];
    memcpy(buffer, prefix, 12);
    vsnprintf(buffer + 12, bufferSize - 12, format, va);

    s_Callback(buffer);

    va_end(va);
}

void Logging::SetLogCallback(Il2CppLogCallback method)
{
    IL2CPP_ASSERT(method != NULL);
    s_Callback = method;
}

bool Logging::IsLogCallbackSet()
{
    return s_Callback != DefaultLogCallback;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Logging.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MarshalingUtils.cpp---------------
.
.
#include "MarshalingUtils.h"
#include "il2cpp-pinvoke-support.h"

namespace il2cpp
{
namespace utils
{
    void MarshalingUtils::MarshalStructToNative(void* managedStructure, void* marshaledStructure, const Il2CppInteropData* interopData)
    {
        IL2CPP_ASSERT(interopData);
        IL2CPP_ASSERT(interopData->pinvokeMarshalToNativeFunction);
        interopData->pinvokeMarshalToNativeFunction(managedStructure, marshaledStructure);
    }

    void MarshalingUtils::MarshalStructFromNative(void* marshaledStructure, void* managedStructure, const Il2CppInteropData* interopData)
    {
        IL2CPP_ASSERT(interopData);
        IL2CPP_ASSERT(interopData->pinvokeMarshalFromNativeFunction);
        interopData->pinvokeMarshalFromNativeFunction(marshaledStructure, managedStructure);
    }

    bool MarshalingUtils::MarshalFreeStruct(void* marshaledStructure, const Il2CppInteropData* interopData)
    {
        if (interopData == NULL)
            return false;

        PInvokeMarshalCleanupFunc cleanup = interopData->pinvokeMarshalCleanupFunction;

        if (cleanup == NULL)
            return false;

        cleanup(marshaledStructure);
        return true;
    }
} // namespace utils
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MarshalingUtils.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Memory.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Memory.h"
#include "utils/Memory.h"
#include <cstdlib>

namespace il2cpp
{
namespace utils
{
    struct MonoMemoryCallbacks
    {
        int version;
        void *(*malloc_func)(size_t size);
        void *(*realloc_func)(void *mem, size_t count);
        void(*free_func)(void *mem);
        void *(*calloc_func)(size_t count, size_t size);
    };

    extern "C"
    {
        int32_t mono_set_allocator_vtable(MonoMemoryCallbacks* callbacks);
    }

    static MonoMemoryCallbacks s_MonoCallbacks =
    {
        1, //MONO_ALLOCATOR_VTABLE_VERSION
        NULL,
        NULL,
        NULL,
        NULL
    };

    static Il2CppMemoryCallbacks s_Callbacks =
    {
        malloc,
        os::Memory::AlignedAlloc,
        free,
        os::Memory::AlignedFree,
        calloc,
        realloc,
        os::Memory::AlignedReAlloc
    };

    void Memory::SetMemoryCallbacks(Il2CppMemoryCallbacks* callbacks)
    {
        memcpy(&s_Callbacks, callbacks, sizeof(Il2CppMemoryCallbacks));

#if IL2CPP_MONO_DEBUGGER
        // The debugger uses Mono code, so we need to remap the callbacks
        // for Mono allocations and frees to the same ones IL2CPP is using.
        s_MonoCallbacks.malloc_func = callbacks->malloc_func;
        s_MonoCallbacks.realloc_func = callbacks->realloc_func;
        s_MonoCallbacks.free_func = callbacks->free_func;
        s_MonoCallbacks.calloc_func = callbacks->calloc_func;
        int32_t installed = mono_set_allocator_vtable(&s_MonoCallbacks);
        IL2CPP_ASSERT(installed != 0);
        NO_UNUSED_WARNING(installed);
#endif
    }

    void* Memory::Malloc(size_t size)
    {
        return s_Callbacks.malloc_func(size);
    }

    void* Memory::AlignedMalloc(size_t size, size_t alignment)
    {
        return s_Callbacks.aligned_malloc_func(size, alignment);
    }

    void Memory::Free(void* memory)
    {
        return s_Callbacks.free_func(memory);
    }

    void Memory::AlignedFree(void* memory)
    {
        return s_Callbacks.aligned_free_func(memory);
    }

    void* Memory::Calloc(size_t count, size_t size)
    {
        return s_Callbacks.calloc_func(count, size);
    }

    void* Memory::Realloc(void* memory, size_t newSize)
    {
        return s_Callbacks.realloc_func(memory, newSize);
    }

    void* Memory::AlignedRealloc(void* memory, size_t newSize, size_t alignment)
    {
        return s_Callbacks.aligned_realloc_func(memory, newSize, alignment);
    }
} /* namespace utils */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Memory.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryMappedFile.cpp---------------
.
.
#include "il2cpp-config.h"

#include "MemoryMappedFile.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace utils
{
    static baselib::ReentrantLock s_Mutex;
    static std::map<void*, os::FileHandle*> s_MappedAddressToMappedFileObject;
    static std::map<void*, int64_t> s_MappedAddressToMappedLength;

    void* MemoryMappedFile::Map(os::FileHandle* file)
    {
        return Map(file, 0, 0);
    }

    bool MemoryMappedFile::Unmap(void* address)
    {
        return Unmap(address, 0);
    }

    void* MemoryMappedFile::Map(os::FileHandle* file, int64_t length, int64_t offset)
    {
        return Map(file, length, offset, os::MMAP_FILE_ACCESS_READ);
    }

    void* MemoryMappedFile::Map(os::FileHandle* file, int64_t length, int64_t offset, int32_t access)
    {
        os::FastAutoLock lock(&s_Mutex);

        int64_t unused = 0;
        os::MemoryMappedFileError error = os::NO_MEMORY_MAPPED_FILE_ERROR;
        os::FileHandle* mappedFileHandle = os::MemoryMappedFile::Create(file, NULL, 0, &unused, (os::MemoryMappedFileAccess)access, 0, &error);
        if (error != 0)
            return NULL;

        int64_t actualOffset = offset;
        void* address = os::MemoryMappedFile::View(mappedFileHandle, &length, offset, (os::MemoryMappedFileAccess)access, &actualOffset, &error);

        if (address != NULL)
        {
            address = (uint8_t*)address + (offset - actualOffset);
            if (os::MemoryMappedFile::OwnsDuplicatedFileHandle(mappedFileHandle))
                s_MappedAddressToMappedFileObject[address] = mappedFileHandle;
            s_MappedAddressToMappedLength[address] = length;
        }

        return address;
    }

    bool MemoryMappedFile::Unmap(void* address, int64_t length)
    {
        os::FastAutoLock lock(&s_Mutex);

        if (length == 0)
        {
            std::map<void*, int64_t>::iterator entry = s_MappedAddressToMappedLength.find(address);
            if (entry != s_MappedAddressToMappedLength.end())
            {
                length = entry->second;
                s_MappedAddressToMappedLength.erase(entry);
            }
        }

        bool success = os::MemoryMappedFile::UnmapView(address, length);
        if (!success)
            return false;

        std::map<void*, os::FileHandle*>::iterator entry = s_MappedAddressToMappedFileObject.find(address);
        if (entry != s_MappedAddressToMappedFileObject.end())
        {
            bool result = os::MemoryMappedFile::Close(entry->second);
            s_MappedAddressToMappedFileObject.erase(entry);
            return result;
        }

        return true;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryMappedFile.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryPool.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/MemoryPool.h"
#include "utils/Memory.h"
#include <algorithm>
#include <limits>

namespace il2cpp
{
namespace utils
{
    // by making all allocations a multiple of this value, we ensure the next
    // allocation will always be aligned to this value
    const size_t kMemoryAlignment = 8;
    static size_t s_RegionSize = 64 * 1024;

    static inline size_t MakeMultipleOf(size_t size, size_t alignment)
    {
        return (size + alignment - 1) & ~(alignment - 1);
    }

    struct MemoryPool::Region
    {
        char* start;
        char* current;
        size_t size;
        size_t free;
    };

    void MemoryPool::SetRegionSize(size_t size)
    {
        s_RegionSize = size;
    }

    size_t MemoryPool::GetRegionSize()
    {
        return s_RegionSize;
    }

    MemoryPool::MemoryPool()
    {
        AddRegion(s_RegionSize);
    }

    MemoryPool::MemoryPool(size_t initialSize)
    {
        AddRegion(initialSize);
    }

    MemoryPool::~MemoryPool()
    {
        for (RegionList::iterator iter = m_Regions.begin(); iter != m_Regions.end(); ++iter)
        {
            IL2CPP_FREE((*iter)->start);
            IL2CPP_FREE(*iter);
        }

        m_Regions.clear();
    }

    void* MemoryPool::Malloc(size_t size)
    {
        size = MakeMultipleOf(size, kMemoryAlignment);

        Region* region = m_Regions.back();
        if (region->free < size)
            region = AddRegion(size);

        IL2CPP_ASSERT(region->free >= size);

        void* value = region->current;
        region->current += size;
        region->free -= size;

        return value;
    }

    void* MemoryPool::Calloc(size_t count, size_t size)
    {
        void* ret = Malloc(count * size);
        return memset(ret, 0, count * size);
    }

    MemoryPool::Region* MemoryPool::AddRegion(size_t size)
    {
        Region* newRegion = (Region*)IL2CPP_MALLOC(sizeof(Region));
        Region* lastFreeRegion = m_Regions.size() > 0 ? m_Regions.back() : NULL;
        size_t allocationSize;

        // If we have more than 1/16th (4k by default) of the current region remaining free,
        // perform a one off allocation rather than losing that space to fragmentation.
        if (lastFreeRegion != NULL && lastFreeRegion->free >= (s_RegionSize / 16))
        {
            allocationSize = size;

            m_Regions.pop_back();
            m_Regions.push_back(newRegion);
            m_Regions.push_back(lastFreeRegion);
        }
        else
        {
            allocationSize = std::max(s_RegionSize, size);
            m_Regions.push_back(newRegion);
        }

        newRegion->start = newRegion->current = (char*)IL2CPP_MALLOC(allocationSize);
        newRegion->size = newRegion->free = allocationSize;

        return newRegion;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryPool.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryPoolAddressSanitizer.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_SANITIZE_ADDRESS

#include "utils/MemoryPoolAddressSanitizer.h"

namespace il2cpp
{
namespace utils
{
    MemoryPoolAddressSanitizer::MemoryPoolAddressSanitizer()
    {
    }

    MemoryPoolAddressSanitizer::MemoryPoolAddressSanitizer(size_t initialSize)
    {
    }

    MemoryPoolAddressSanitizer::~MemoryPoolAddressSanitizer()
    {
        for (auto allocation : m_Allocations)
            free(allocation);

        m_Allocations.clear();
    }

    void* MemoryPoolAddressSanitizer::Malloc(size_t size)
    {
        void* allocation = malloc(size);
        m_Allocations.push_back(allocation);
        return allocation;
    }

    void* MemoryPoolAddressSanitizer::Calloc(size_t count, size_t size)
    {
        void* allocation = calloc(count, size);
        m_Allocations.push_back(allocation);
        return allocation;
    }
}
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryPoolAddressSanitizer.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryRead.cpp---------------
.
.
#include "MemoryRead.h"
#include "il2cpp-config.h"

namespace il2cpp
{
namespace utils
{
    uint32_t ReadCompressedUInt32(const char** p)
    {
        uint32_t val = 0;
        uint8_t read = Read8(p);

        if ((read & 0x80) == 0)
        {
            // 1 byte written
            val = read;
        }
        else if ((read & 0xC0) == 0x80)
        {
            // 2 bytes written
            val = (read & ~0x80) << 8;
            val |= Read8(p);
        }
        else if ((read & 0xE0) == 0xC0)
        {
            // 4 bytes written
            val = (read & ~0xC0) << 24;
            val |= ((uint32_t)Read8(p) << 16);
            val |= ((uint32_t)Read8(p) << 8);
            val |= Read8(p);
        }
        else if (read == 0xF0)
        {
            // 5 bytes written, we had a really large int32!
            val = Read32(p);
        }
        else if (read == 0xFE)
        {
            // Special encoding for Int32.MaxValue
            val = UINT32_MAX - 1;
        }
        else if (read == 0xFF)
        {
            // Yes we treat UInt32.MaxValue (and Int32.MinValue, see ReadCompressedInt32) specially
            val = UINT32_MAX;
        }
        else
        {
            IL2CPP_ASSERT(false && "Invalid compressed integer format");
        }

        return val;
    }

    int32_t ReadCompressedInt32(const char** p)
    {
        uint32_t encoded = ReadCompressedUInt32(p);

        // -UINT32_MAX can't be represted safely in an int32_t, so we treat it specially
        if (encoded == UINT32_MAX)
            return INT32_MIN;

        bool isNegative = encoded & 1;
        encoded >>= 1;
        if (isNegative)
            return -(int32_t)(encoded + 1);
        return encoded;
    }
} /* utils */
} /* il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\MemoryRead.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\mono-structs.cpp---------------
.
.
#include "mono-structs.h"
#include "os/c-api/il2cpp-config-platforms.h"
#include "os/c-api/Allocator.h"

MonoGPtrArray* void_ptr_array_to_gptr_array(const VoidPtrArray& array)
{
    MonoGPtrArray *pRetVal;

    pRetVal = (MonoGPtrArray*)Allocator::Allocate(sizeof(MonoGPtrArray));

    pRetVal->len = (unsigned int)array.size();
    if (pRetVal->len > 0)
    {
        size_t numBytes = sizeof(void*) * pRetVal->len;
        pRetVal->pdata = Allocator::Allocate(numBytes);
        memcpy(pRetVal->pdata, array.data(), numBytes);
    }
    else
    {
        pRetVal->pdata = NULL;
    }

    return pRetVal;
}

MonoGPtrArray* empty_gptr_array()
{
    MonoGPtrArray *pRetVal = (MonoGPtrArray*)Allocator::Allocate(sizeof(MonoGPtrArray));
    pRetVal->len = 0;
    pRetVal->pdata = NULL;
    return pRetVal;
}

void free_gptr_array(MonoGPtrArray *pArray)
{
    if (!pArray)
        return;

    if (pArray->pdata)
    {
        IL2CPP_FREE(pArray->pdata);
        pArray->pdata = NULL;
    }

    IL2CPP_FREE(pArray);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\mono-structs.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Output.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "Output.h"
#include "os/ErrorCodes.h"
#include "os/File.h"
#include "StringUtils.h"

using namespace il2cpp::utils;

static inline void WriteToHandle(il2cpp::os::FileHandle* handle, const char* message)
{
    int error = il2cpp::os::kErrorCodeSuccess;
    il2cpp::os::File::Write(handle, message, static_cast<int>(strlen(message)), &error);
    IL2CPP_ASSERT(error == il2cpp::os::kErrorCodeSuccess);
}

void Output::WriteToStdout(const char* message)
{
    WriteToHandle(os::File::GetStdOutput(), message);
}

void Output::WriteToStderr(const char* message)
{
    WriteToHandle(os::File::GetStdError(), message);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Output.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\PathUtils.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/PathUtils.h"
#include <string>

namespace il2cpp
{
namespace utils
{
namespace PathUtils
{
    std::string BasenameNoExtension(const std::string& path)
    {
        if (path.empty())
            return ".";

        std::string base = Basename(path);

        const size_t pos = base.rfind('.');

        // No extension.
        if (pos == std::string::npos)
            return base;

        return base.substr(0, pos);
    }

    std::string PathNoExtension(const std::string& path)
    {
        const size_t pos = path.rfind('.');

        // No extension.
        if (pos == std::string::npos)
            return path;

        return path.substr(0, pos);
    }
}
} /* utils */
} /* il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\PathUtils.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Runtime.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Path.h"
#include "os/Environment.h"
#include "utils/Runtime.h"
#include "utils/PathUtils.h"
#include "utils/StringUtils.h"
#include "utils/Environment.h"


#ifndef IL2CPP_DEFAULT_DATA_DIR_PATH
#define IL2CPP_DEFAULT_DATA_DIR_PATH Data
#endif

#define IL2CPP_DEFAULT_DATA_DIR_PATH_STR MAKE_STRING(STRINGIZE, IL2CPP_DEFAULT_DATA_DIR_PATH)

namespace il2cpp
{
namespace utils
{
    NORETURN void Runtime::Abort()
    {
        os::Environment::Abort();
    }

    static std::string s_DataDirFallback;

    static std::string s_DataDir;

    void Runtime::SetDataDir(const char *path)
    {
        s_DataDir = path;
    }

    std::string Runtime::GetDataDir()
    {
        // use explicit value if set
        if (s_DataDir.size() > 0)
            return s_DataDir;

        std::string applicationFolder = os::Path::GetApplicationFolder();
        if (!applicationFolder.empty())
            return PathUtils::Combine(applicationFolder, StringView<char>(IL2CPP_DEFAULT_DATA_DIR_PATH_STR));

        if (s_DataDirFallback.size() == 0 && Environment::GetNumMainArgs() > 0)
        {
            std::string main = StringUtils::Utf16ToUtf8(Environment::GetMainArgs()[0]);
            s_DataDirFallback = PathUtils::DirectoryName(main);
        }

        return s_DataDirFallback;
    }
} // utils
} // il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\Runtime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\sha1.cpp---------------
.
.
/**
\file
SHA-1 in C
By Steve Reid <sreid@sea-to-sky.net>
100% Public Domain

-----------------
Modified 7/98
By James H. Brown <jbrown@burgoyne.com>
Still 100% Public Domain

Corrected a problem which generated improper hash values on 16 bit machines
Routine mono_sha1_update changed from
    void mono_sha1_update(Il2CppSHA1Context* context, unsigned char* data, unsigned int
len)
to
    void mono_sha1_update(Il2CppSHA1Context* context, unsigned char* data, unsigned
long len)

The 'len' parameter was declared an int which works fine on 32 bit machines.
However, on 16 bit machines an int is too small for the shifts being done
against
it.  This caused the hash function to generate incorrect values if len was
greater than 8191 (8K - 1) due to the 'len << 3' on line 3 of mono_sha1_update().

Since the file IO in main() reads 16K at a time, any file 8K or larger would
be guaranteed to generate the wrong hash (e.g. Test Vector #3, a million
"a"s).

I also changed the declaration of variables i & j in mono_sha1_update to
unsigned long from unsigned int for the same reason.

These changes should make no difference to any 32 bit implementations since
an
int and a long are the same size in those environments.

--
I also corrected a few compiler warnings generated by Borland C.
1. Added #include <process.h> for exit() prototype
2. Removed unused variable 'j' in mono_sha1_final
3. Changed exit(0) to return(0) at end of main.

ALL changes I made can be located by searching for comments containing 'JHB'
-----------------
Modified 8/98
By Steve Reid <sreid@sea-to-sky.net>
Still 100% public domain

1- Removed #include <process.h> and used return() instead of exit()
2- Fixed overwriting of finalcount in mono_sha1_final() (discovered by Chris Hall)
3- Changed email address from steve@edmweb.com to sreid@sea-to-sky.net

-----------------
Modified 4/01
By Saul Kravitz <Saul.Kravitz@celera.com>
Still 100% PD
Modified to run on Compaq Alpha hardware.


*/

/*
Test Vectors (from FIPS PUB 180-1)
"abc"
  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
A million repetitions of "a"
  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
*/

#include <stdio.h>
#include <string.h>
#include <stdint.h>

typedef struct
{
    uint32_t state[5];
    uint32_t count[2];
    unsigned char buffer[64];
} Il2CppSHA1Context;

/* #include <process.h> */  /* prototype for exit() - JHB */
/* Using return() instead of exit() - SWR */

static void SHA1Transform(uint32_t state[5], const uint8_t buffer[64]);

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

/* blk0() and blk() perform the initial expand. */
/* I got the idea of expanding during the round function from SSLeay */
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
    |(rol(block->l[i],8)&0x00FF00FF))
#else
#define blk0(i) block->l[i]
#endif
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
    ^block->l[(i+2)&15]^block->l[i&15],1))

/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
#define R0(v, w, x, y, z, i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R1(v, w, x, y, z, i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R2(v, w, x, y, z, i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
#define R3(v, w, x, y, z, i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
#define R4(v, w, x, y, z, i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);

/* Hash a single 512-bit block. This is the core of the algorithm. */

static void SHA1Transform(uint32_t state[5], const uint8_t buffer[64])
{
    uint32_t a, b, c, d, e;
    typedef union
    {
        unsigned char c[64];
        uint32_t l[16];
    } CHAR64LONG16;
    CHAR64LONG16* block;

    unsigned char workspace[64];
    block = (CHAR64LONG16*)workspace;
    memcpy(block, buffer, 64);

    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a, b, c, d, e, 0); R0(e, a, b, c, d, 1); R0(d, e, a, b, c, 2); R0(c, d, e, a, b, 3);
    R0(b, c, d, e, a, 4); R0(a, b, c, d, e, 5); R0(e, a, b, c, d, 6); R0(d, e, a, b, c, 7);
    R0(c, d, e, a, b, 8); R0(b, c, d, e, a, 9); R0(a, b, c, d, e, 10); R0(e, a, b, c, d, 11);
    R0(d, e, a, b, c, 12); R0(c, d, e, a, b, 13); R0(b, c, d, e, a, 14); R0(a, b, c, d, e, 15);
    R1(e, a, b, c, d, 16); R1(d, e, a, b, c, 17); R1(c, d, e, a, b, 18); R1(b, c, d, e, a, 19);
    R2(a, b, c, d, e, 20); R2(e, a, b, c, d, 21); R2(d, e, a, b, c, 22); R2(c, d, e, a, b, 23);
    R2(b, c, d, e, a, 24); R2(a, b, c, d, e, 25); R2(e, a, b, c, d, 26); R2(d, e, a, b, c, 27);
    R2(c, d, e, a, b, 28); R2(b, c, d, e, a, 29); R2(a, b, c, d, e, 30); R2(e, a, b, c, d, 31);
    R2(d, e, a, b, c, 32); R2(c, d, e, a, b, 33); R2(b, c, d, e, a, 34); R2(a, b, c, d, e, 35);
    R2(e, a, b, c, d, 36); R2(d, e, a, b, c, 37); R2(c, d, e, a, b, 38); R2(b, c, d, e, a, 39);
    R3(a, b, c, d, e, 40); R3(e, a, b, c, d, 41); R3(d, e, a, b, c, 42); R3(c, d, e, a, b, 43);
    R3(b, c, d, e, a, 44); R3(a, b, c, d, e, 45); R3(e, a, b, c, d, 46); R3(d, e, a, b, c, 47);
    R3(c, d, e, a, b, 48); R3(b, c, d, e, a, 49); R3(a, b, c, d, e, 50); R3(e, a, b, c, d, 51);
    R3(d, e, a, b, c, 52); R3(c, d, e, a, b, 53); R3(b, c, d, e, a, 54); R3(a, b, c, d, e, 55);
    R3(e, a, b, c, d, 56); R3(d, e, a, b, c, 57); R3(c, d, e, a, b, 58); R3(b, c, d, e, a, 59);
    R4(a, b, c, d, e, 60); R4(e, a, b, c, d, 61); R4(d, e, a, b, c, 62); R4(c, d, e, a, b, 63);
    R4(b, c, d, e, a, 64); R4(a, b, c, d, e, 65); R4(e, a, b, c, d, 66); R4(d, e, a, b, c, 67);
    R4(c, d, e, a, b, 68); R4(b, c, d, e, a, 69); R4(a, b, c, d, e, 70); R4(e, a, b, c, d, 71);
    R4(d, e, a, b, c, 72); R4(c, d, e, a, b, 73); R4(b, c, d, e, a, 74); R4(a, b, c, d, e, 75);
    R4(e, a, b, c, d, 76); R4(d, e, a, b, c, 77); R4(c, d, e, a, b, 78); R4(b, c, d, e, a, 79);
    /* Add the working vars back into context.state[] */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;
    /* Wipe variables */
    a = b = c = d = e = 0;
}

/* sha1_init - Initialize new context */

static void sha1_init(Il2CppSHA1Context* context)
{
    /* SHA1 initialization constants */
    context->state[0] = 0x67452301;
    context->state[1] = 0xEFCDAB89;
    context->state[2] = 0x98BADCFE;
    context->state[3] = 0x10325476;
    context->state[4] = 0xC3D2E1F0;
    context->count[0] = context->count[1] = 0;
}

/* Run your data through this. */

static void sha1_update(Il2CppSHA1Context* context, const uint8_t* data, uint32_t len)  /*
JHB */
{
    uint32_t i, j; /* JHB */

#ifdef VERBOSE
    SHAPrintContext(context, "before");
#endif
    j = (context->count[0] >> 3) & 63;
    if ((context->count[0] += len << 3) < (len << 3)) context->count[1]++;
    context->count[1] += (len >> 29);
    if ((j + len) > 63)
    {
        memcpy(&context->buffer[j], data, (i = 64 - j));
        SHA1Transform(context->state, context->buffer);
        for (; i + 63 < len; i += 64)
        {
            SHA1Transform(context->state, &data[i]);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&context->buffer[j], &data[i], len - i);
#ifdef VERBOSE
    SHAPrintContext(context, "after ");
#endif
}

/* Add padding and return the message digest. */

static void sha1_final(Il2CppSHA1Context* context, unsigned char digest[20])
{
    uint32_t i; /* JHB */
    unsigned char finalcount[8];

    for (i = 0; i < 8; i++)
    {
        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
            >> ((3 - (i & 3)) * 8)) & 255); /* Endian independent */
    }
    sha1_update(context, (unsigned char *)"\200", 1);
    while ((context->count[0] & 504) != 448)
    {
        sha1_update(context, (unsigned char *)"\0", 1);
    }
    sha1_update(context, finalcount, 8);  /* Should cause a SHA1Transform()
*/
    for (i = 0; i < 20; i++)
    {
        digest[i] = (unsigned char)
            ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
    }
    /* Wipe variables */
    i = 0;  /* JHB */
    memset(context->buffer, 0, 64);
    memset(context->state, 0, 20);
    memset(context->count, 0, 8);
    memset(finalcount, 0, 8);   /* SWR */
    SHA1Transform(context->state, context->buffer);
}

/**
 * sha1_get_digest:
 */
void sha1_get_digest(const uint8_t *buffer, int buffer_size, uint8_t digest[20])
{
    Il2CppSHA1Context ctx;

    sha1_init(&ctx);
    sha1_update(&ctx, buffer, buffer_size);
    sha1_final(&ctx, digest);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\sha1.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\StringUtils.cpp---------------
.
.
#include "il2cpp-config.h"
#include "../char-conversions.h"
#include "il2cpp-object-internals.h"
#include "utils/Functional.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "External/utfcpp/source/utf8.h"
#include <stdarg.h>

namespace il2cpp
{
namespace utils
{
    std::string StringUtils::Printf(const char* format, ...)
    {
        va_list argsToCheckSize;
        int n;
        std::string ret;

        va_start(argsToCheckSize, format);
#if IL2CPP_COMPILER_MSVC
        // MS vsnprintf always returns -1 if string doesn't fit, rather than
        // the needed size. Used their 'special' function instead to get required size
        n = _vscprintf_p(format, argsToCheckSize);
#else
        // use a temporary buffer as some docs indicate we cannot pass NULL to vsnprintf
        char buf[1];
        n = vsnprintf(buf, 0, format, argsToCheckSize);
#endif
        if (n == -1)
            return NULL;

        ret.resize(n + 1, 0);
        va_end(argsToCheckSize);

        va_list argsToFormat;

        va_start(argsToFormat, format);
        n = vsnprintf(&ret[0], ret.size(), format, argsToFormat);
        va_end(argsToFormat);

        IL2CPP_ASSERT(n < (int)ret.size());

        if (n == -1)
            return NULL;

        // The v*printf methods might put a trailing NUL character, which should not not be in a
        // std::string, so strip it out.
        if (!ret.empty() && ret[ret.size() - 1] == '\0')
            ret = ret.substr(0, ret.size() - 1);

        return ret;
    }

    std::string StringUtils::NPrintf(const char* format, size_t max_n, ...)
    {
        va_list argsToCheckSize;
        size_t n;
        std::string ret;

        va_start(argsToCheckSize, max_n);
#if IL2CPP_COMPILER_MSVC
        // MS vsnprintf always returns -1 if string doesn't fit, rather than
        // the needed size. Used their 'special' function instead to get required size
        n = _vscprintf_p(format, argsToCheckSize);
#else
        // use a temporary buffer as some docs indicate we cannot pass NULL to vsnprintf
        char buf[1];
        n = vsnprintf(buf, 0, format, argsToCheckSize);
#endif
        if (n == -1)
            return NULL;

        n = (max_n < ++n) ? max_n : n;

        ret.resize(n, 0);
        va_end(argsToCheckSize);

        va_list argsToFormat;

        va_start(argsToFormat, max_n);
        n = vsnprintf(&ret[0], n, format, argsToFormat);
        va_end(argsToFormat);

        IL2CPP_ASSERT(n < ret.size());

        if (n == -1)
            return NULL;

        // The v*printf methods might put a trailing NUL character, which should not not be in a
        // std::string, so strip it out.
        if (!ret.empty() && ret[ret.size() - 1] == '\0')
            ret = ret.substr(0, ret.size() - 1);

        return ret;
    }

    std::string StringUtils::Utf16ToUtf8(const Il2CppChar* utf16String)
    {
        return Utf16ToUtf8(utf16String, -1);
    }

    std::string StringUtils::Utf16ToUtf8(const Il2CppChar* utf16String, int maximumSize)
    {
        const Il2CppChar* ptr = utf16String;
        size_t length = 0;
        while (*ptr)
        {
            ptr++;
            length++;
            if (maximumSize != -1 && length == maximumSize)
                break;
        }

        std::string utf8String;
        utf8String.reserve(length);
        utf8::unchecked::utf16to8(utf16String, ptr, std::back_inserter(utf8String));

        return utf8String;
    }

    std::string StringUtils::Utf16ToUtf8(const UTF16String& utf16String)
    {
        return Utf16ToUtf8(utf16String.c_str(), static_cast<int>(utf16String.length()));
    }

    UTF16String StringUtils::Utf8ToUtf16(const char* utf8String)
    {
        return Utf8ToUtf16(utf8String, strlen(utf8String));
    }

    UTF16String StringUtils::Utf8ToUtf16(const char* utf8String, size_t length)
    {
        UTF16String utf16String;

        if (utf8::is_valid(utf8String, utf8String + length))
        {
            utf16String.reserve(length);
            utf8::unchecked::utf8to16(utf8String, utf8String + length, std::back_inserter(utf16String));
        }

        return utf16String;
    }

    UTF16String StringUtils::Utf8ToUtf16(const std::string& utf8String)
    {
        return Utf8ToUtf16(utf8String.c_str(), utf8String.length());
    }

    char* StringUtils::StringDuplicate(const char *strSource)
    {
        char* result = NULL;

        if (!strSource)
            return NULL;

        size_t length = strlen(strSource) + 1;

        if ((result = (char*)IL2CPP_MALLOC(length)))
#if IL2CPP_COMPILER_MSVC
            strcpy_s(result, length, strSource);
#elif IL2CPP_TARGET_LINUX
            strncpy(result, strSource, length);
#else
            strlcpy(result, strSource, length);
#endif

        return result;
    }

    Il2CppChar* StringUtils::StringDuplicate(const Il2CppChar* strSource, size_t length)
    {
        size_t byteLengthWithNullTerminator = sizeof(Il2CppChar) * (length + 1);
        Il2CppChar* utf16name = (Il2CppChar*)IL2CPP_MALLOC(byteLengthWithNullTerminator);
        memcpy(utf16name, strSource, byteLengthWithNullTerminator);

        return utf16name;
    }

    void StringUtils::StringDelete(const char* str)
    {
        IL2CPP_FREE((void*)str);
    }

    bool StringUtils::EndsWith(const std::string& string, const std::string& suffix)
    {
        const size_t stringLength = string.length();
        const size_t suffixLength = suffix.length();

        if (suffixLength > stringLength)
            return false;

        return string.rfind(suffix.c_str(), stringLength - suffixLength, suffixLength) != std::string::npos;
    }

    Il2CppChar* StringUtils::GetChars(Il2CppString* str)
    {
        return str->chars;
    }

    int32_t StringUtils::GetLength(Il2CppString* str)
    {
        return str->length;
    }
} /* utils */
} /* il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\utils\StringUtils.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\AndroidRuntime.cpp---------------
.
.
#include "AndroidRuntime.h"
#include "il2cpp-config.h"
#include "utils/StringUtils.h"

namespace il2cpp
{
namespace vm
{
    static Il2CppAndroidUpStateFunc s_func = NULL;

    void AndroidRuntime::SetNetworkUpStateFunc(Il2CppAndroidUpStateFunc func)
    {
        s_func = func;
    }

    bool AndroidRuntime::GetNetworkInterfaceUpState(Il2CppString* ifName, bool* isUp)
    {
        if (s_func)
        {
            std::string name = utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(ifName));
            return s_func(name.c_str(), (uint8_t*)isUp);
        }
        return false;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\AndroidRuntime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Array.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/gc_wrapper.h"
#include "gc/GarbageCollector.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Profiler.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include <memory>

namespace il2cpp
{
namespace vm
{
    Il2CppArray* Array::Clone(Il2CppArray* arr)
    {
        Il2CppClass *typeInfo = arr->klass;
        const uint32_t elem_size = il2cpp::vm::Array::GetElementSize(typeInfo);

        if (arr->bounds == NULL)
        {
            il2cpp_array_size_t len = il2cpp::vm::Array::GetLength(arr);
            Il2CppArray *clone = (Il2CppArray*)il2cpp::vm::Array::NewFull(typeInfo, &len, NULL);
            memcpy(il2cpp::vm::Array::GetFirstElementAddress(clone), il2cpp::vm::Array::GetFirstElementAddress(arr), elem_size * len);

            gc::GarbageCollector::SetWriteBarrier((void**)il2cpp::vm::Array::GetFirstElementAddress(clone), elem_size * len);

            return clone;
        }

        il2cpp_array_size_t size = elem_size;
        std::vector<il2cpp_array_size_t> lengths(typeInfo->rank);
        std::vector<il2cpp_array_size_t> lowerBounds(typeInfo->rank);

        for (int i = 0; i < typeInfo->rank; ++i)
        {
            lengths[i] = arr->bounds[i].length;
            size *= arr->bounds[i].length;
            lowerBounds[i] = arr->bounds[i].lower_bound;
        }

        Il2CppArray* clone = il2cpp::vm::Array::NewFull(typeInfo, &lengths[0], &lowerBounds[0]);
        memcpy(il2cpp::vm::Array::GetFirstElementAddress(clone), il2cpp::vm::Array::GetFirstElementAddress(arr), size);

        gc::GarbageCollector::SetWriteBarrier((void**)il2cpp::vm::Array::GetFirstElementAddress(clone), size);

        return clone;
    }

    int32_t Array::GetElementSize(const Il2CppClass *klass)
    {
        IL2CPP_ASSERT(klass->rank);
        return klass->element_size;
    }

    uint32_t Array::GetLength(Il2CppArray* array)
    {
        return ARRAY_LENGTH_AS_INT32(array->max_length);
    }

    uint32_t Array::GetByteLength(Il2CppArray* array)
    {
        Il2CppClass *klass;
        il2cpp_array_size_t length;
        int i;

        klass = array->klass;

        if (array->bounds == NULL)
            length = array->max_length;
        else
        {
            length = 1;
            for (i = 0; i < klass->rank; ++i)
                length *= array->bounds[i].length;
        }

        return ARRAY_LENGTH_AS_INT32(length * GetElementSize(klass));
    }

    Il2CppArray* Array::New(Il2CppClass *elementTypeInfo, il2cpp_array_size_t length)
    {
        return NewSpecific(Class::GetArrayClass(elementTypeInfo, 1), length);
    }

    static void RaiseOverflowException()
    {
        vm::Exception::Raise(vm::Exception::GetOverflowException("Arithmetic operation resulted in an overflow."));
    }

    Il2CppArray* Array::NewSpecific(Il2CppClass *klass, il2cpp_array_size_t n)
    {
        Il2CppObject *o;
        Il2CppArray *ao;
        uint32_t elem_size;
        il2cpp_array_size_t byte_len;

        Class::Init(klass);
        IL2CPP_ASSERT(klass->rank);
        IL2CPP_ASSERT(klass->initialized);
        IL2CPP_ASSERT(klass->element_class->initialized);
        IL2CPP_ASSERT(klass->byval_arg.type == IL2CPP_TYPE_SZARRAY);

        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Array::NewSpecific, "Not checking for overflow");
        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Array::NewSpecific, "Handle allocations with a GC descriptor");

        if (n > IL2CPP_ARRAY_MAX_INDEX)
        {
            RaiseOverflowException();
            return NULL;
        }

        elem_size = il2cpp_array_element_size(klass);
        //if (CHECK_MUL_OVERFLOW_UN (n, elem_size)) {
        //  mono_gc_out_of_memory (MONO_ARRAY_MAX_SIZE);
        //  return NULL;
        //}
        byte_len = n * elem_size;
        //if (CHECK_ADD_OVERFLOW_UN (byte_len, sizeof (MonoArray))) {
        //  mono_gc_out_of_memory (MONO_ARRAY_MAX_SIZE);
        //  return NULL;
        //}
        byte_len += kIl2CppSizeOfArray;
        if (!klass->has_references)
        {
            o = Object::AllocatePtrFree(byte_len, klass);
#if NEED_TO_ZERO_PTRFREE
            ((Il2CppArray*)o)->bounds = NULL;
            memset((char*)o + sizeof(Il2CppObject), 0, byte_len - sizeof(Il2CppObject));
#endif
        }
        else if (klass->element_class->byval_arg.valuetype &&
                 ((GC_descr)klass->element_class->gc_desc & GC_DS_TAGS) == GC_DS_BITMAP)
        {
            o = (Il2CppObject*)GC_gcj_vector_malloc(byte_len, klass);
        }
#if IL2CPP_HAS_GC_DESCRIPTORS
        else if (klass->gc_desc != GC_NO_DESCRIPTOR)
        {
            o = Object::AllocateSpec(byte_len, klass);
        }
#endif
        else
        {
            o = Object::Allocate(byte_len, klass);
        }

        ao = (Il2CppArray*)o;
        ao->max_length = n;

#if IL2CPP_ENABLE_PROFILER
        if (Profiler::ProfileAllocations())
            Profiler::Allocation(o, klass);
#endif

        return ao;
    }

    Il2CppArray* Array::NewFull(Il2CppClass *array_class, il2cpp_array_size_t *lengths, il2cpp_array_size_t *lower_bounds)
    {
        il2cpp_array_size_t byte_len, len, bounds_size;
        Il2CppObject *o;
        Il2CppArray *array;
        int i;

        Class::Init(array_class);
        IL2CPP_ASSERT(array_class->rank);
        IL2CPP_ASSERT(array_class->initialized);
        IL2CPP_ASSERT(array_class->element_class->initialized);

        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Array::NewFull, "IGNORING non-zero based arrays!");
        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Array::NewFull, "Handle allocations with a GC descriptor");

        byte_len = il2cpp_array_element_size(array_class);
        len = 1;

        /* A single dimensional array with a 0 lower bound is the same as an szarray */
        if (array_class->rank == 1 && ((array_class->byval_arg.type == IL2CPP_TYPE_SZARRAY) || (lower_bounds && lower_bounds[0] == 0)))
        {
            /* A single dimensional array with a 0 lower bound should be an szarray */
            /* but the caller asked for an IL2CPP_TYPE_ARRAY, which insn't correct */
            IL2CPP_ASSERT(array_class->byval_arg.type == IL2CPP_TYPE_SZARRAY);

            len = lengths[0];
            if (len > IL2CPP_ARRAY_MAX_INDEX) //MONO_ARRAY_MAX_INDEX
                RaiseOverflowException();
            bounds_size = 0;
        }
        else
        {
            IL2CPP_ASSERT(array_class->byval_arg.type == IL2CPP_TYPE_ARRAY);

            bounds_size = sizeof(Il2CppArrayBounds) * array_class->rank;

            for (i = 0; i < array_class->rank; ++i)
            {
                if (lengths[i] > IL2CPP_ARRAY_MAX_INDEX)  //MONO_ARRAY_MAX_INDEX
                    RaiseOverflowException();
                //if (CHECK_MUL_OVERFLOW_UN (len, lengths [i]))
                //  mono_gc_out_of_memory (MONO_ARRAY_MAX_SIZE);
                len *= lengths[i];
            }
        }

        //if (CHECK_MUL_OVERFLOW_UN (byte_len, len))
        //  mono_gc_out_of_memory (MONO_ARRAY_MAX_SIZE);
        byte_len *= len;
        //if (CHECK_ADD_OVERFLOW_UN (byte_len, sizeof (MonoArray)))
        //  mono_gc_out_of_memory (MONO_ARRAY_MAX_SIZE);
        byte_len += kIl2CppSizeOfArray;
        if (bounds_size)
        {
            /* align */
            //if (CHECK_ADD_OVERFLOW_UN (byte_len, 3))
            //  mono_gc_out_of_memory (MONO_ARRAY_MAX_SIZE);
            byte_len = (byte_len + (IL2CPP_SIZEOF_VOID_P - 1)) & ~(IL2CPP_SIZEOF_VOID_P - 1);
            //if (CHECK_ADD_OVERFLOW_UN (byte_len, bounds_size))
            //  mono_gc_out_of_memory (MONO_ARRAY_MAX_SIZE);
            byte_len += bounds_size;
        }
        /*
         * Following three lines almost taken from mono_object_new ():
         * they need to be kept in sync.
         */
        if (!array_class->has_references)
        {
            o = Object::AllocatePtrFree(byte_len, array_class);
#if NEED_TO_ZERO_PTRFREE
            memset((char*)o + sizeof(Il2CppObject), 0, byte_len - sizeof(Il2CppObject));
#endif
        }
#if IL2CPP_HAS_GC_DESCRIPTORS
        else if (array_class->gc_desc != GC_NO_DESCRIPTOR)
        {
            o = Object::AllocateSpec(byte_len, array_class);
        }
#endif
        else
        {
            o = Object::Allocate(byte_len, array_class);
        }

        array = (Il2CppArray*)o;
        array->max_length = len;

        if (bounds_size)
        {
            Il2CppArrayBounds *bounds = (Il2CppArrayBounds*)((char*)array + byte_len - bounds_size);
            array->bounds = bounds;
            for (i = 0; i < array_class->rank; ++i)
            {
                bounds[i].length = lengths[i];
                if (lower_bounds)
                    bounds[i].lower_bound = ARRAY_LENGTH_AS_INT32(lower_bounds[i]);
            }
        }

#if IL2CPP_ENABLE_PROFILER
        if (Profiler::ProfileAllocations())
            Profiler::Allocation(o, array_class);
#endif

        return array;
    }

    char* Array::GetFirstElementAddress(Il2CppArray *array)
    {
        return reinterpret_cast<char*>(array) + kIl2CppSizeOfArray;
    }

    il2cpp_array_size_t Array::IndexFromIndices(Il2CppArray* thisPtr, int32_t const * indices)
    {
        int32_t i;
        il2cpp_array_size_t pos;
        Il2CppClass* ac;
        ac = thisPtr->klass;

        pos = indices[0] - thisPtr->bounds[0].lower_bound;
        for (i = 1; i < ac->rank; i++)
            pos = pos * thisPtr->bounds[i].length + indices[i] -
                thisPtr->bounds[i].lower_bound;

        return pos;
    }
} /* namespace vm */
} /* namespace il2cpp */

LIBIL2CPP_CODEGEN_API int32_t
il2cpp_array_element_size(Il2CppClass *ac)
{
    return il2cpp::vm::Array::GetElementSize(ac);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Array.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Assembly.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/Assembly.h"
#include "vm/AssemblyName.h"
#include "vm/MetadataCache.h"
#include "vm/Runtime.h"
#include "vm-utils/VmStringUtils.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-class-internals.h"

#include <vector>
#include <string>

namespace il2cpp
{
namespace vm
{
    static AssemblyVector s_Assemblies;

    AssemblyVector* Assembly::GetAllAssemblies()
    {
        return &s_Assemblies;
    }

    const Il2CppAssembly* Assembly::GetLoadedAssembly(const char* name)
    {
        for (AssemblyVector::const_iterator assembly = s_Assemblies.begin(); assembly != s_Assemblies.end(); ++assembly)
        {
            if (strcmp((*assembly)->aname.name, name) == 0)
                return *assembly;
        }

        return NULL;
    }

    Il2CppImage* Assembly::GetImage(const Il2CppAssembly* assembly)
    {
        return assembly->image;
    }

    void Assembly::GetReferencedAssemblies(const Il2CppAssembly* assembly, AssemblyNameVector* target)
    {
        for (int32_t sourceIndex = 0; sourceIndex < assembly->referencedAssemblyCount; sourceIndex++)
        {
            const Il2CppAssembly* refAssembly = MetadataCache::GetReferencedAssembly(assembly, sourceIndex);

            target->push_back(&refAssembly->aname);
        }
    }

    static bool ends_with(const char *str, const char *suffix)
    {
        if (!str || !suffix)
            return false;

        const size_t lenstr = strlen(str);
        const size_t lensuffix = strlen(suffix);
        if (lensuffix >  lenstr)
            return false;

        return strncmp(str + lenstr - lensuffix, suffix, lensuffix) == 0;
    }

    const Il2CppAssembly* Assembly::Load(const char* name)
    {
        const size_t len = strlen(name);
        utils::VmStringUtils::CaseInsensitiveComparer comparer;

        for (AssemblyVector::const_iterator assembly = s_Assemblies.begin(); assembly != s_Assemblies.end(); ++assembly)
        {
            if (comparer(name, (*assembly)->aname.name))
                return *assembly;
        }

        if (!ends_with(name, ".dll") && !ends_with(name, ".exe"))
        {
            char *tmp = new char[len + 5];

            memset(tmp, 0, len + 5);

            memcpy(tmp, name, len);
            memcpy(tmp + len, ".dll", 4);

            const Il2CppAssembly* result = Load(tmp);

            if (!result)
            {
                memcpy(tmp + len, ".exe", 4);
                result = Load(tmp);
            }

            delete[] tmp;

            return result;
        }
        else
        {
            for (AssemblyVector::const_iterator assembly = s_Assemblies.begin(); assembly != s_Assemblies.end(); ++assembly)
            {
                if (comparer(name, (*assembly)->image->name))
                    return *assembly;
            }

            return NULL;
        }
    }

    void Assembly::Register(const Il2CppAssembly* assembly)
    {
        s_Assemblies.push_back(assembly);
    }

    void Assembly::ClearAllAssemblies()
    {
        s_Assemblies.clear();
    }

    void Assembly::Initialize()
    {
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Assembly.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\AssemblyName.cpp---------------
.
.
#include "il2cpp-class-internals.h"
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"
#include "mono-structs.h"
#include "gc/WriteBarrier.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/AssemblyName.h"
#include "vm/Class.h"
#include "vm/MetadataCache.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Type.h"

#include <vector>
#include <string>
#include <cstdlib>

namespace il2cpp
{
namespace vm
{
    static Il2CppObject* CreateVersion(uint32_t major, uint32_t minor, uint32_t build, uint32_t revision)
    {
        static const MethodInfo* versionContructor = NULL;
        if (!versionContructor)
            versionContructor = Class::GetMethodFromName(il2cpp_defaults.version, ".ctor", 4);

        Il2CppObject* version = Object::New(il2cpp_defaults.version);
        void* args[4] = { &major, &minor, &build, &revision };
        Runtime::Invoke(versionContructor, version, args, NULL);

        return version;
    }

    static Il2CppObject* CreateCulture(const char* cultureName)
    {
        static const MethodInfo* createCultureMethod = NULL;
        if (!createCultureMethod)
            createCultureMethod = Class::GetMethodFromName(il2cpp_defaults.culture_info, "CreateCulture", 2);

        bool reference = false;
        void* args[2];
        if (cultureName != NULL)
            args[0] = String::New(cultureName);
        else
            args[0] = String::New("neutral");
        args[1] = &reference;
        return Runtime::Invoke(createCultureMethod, NULL, args, NULL);
    }

    bool AssemblyName::ParseName(Il2CppReflectionAssemblyName* aname, std::string assemblyName)
    {
        il2cpp::vm::TypeNameParseInfo info;
        il2cpp::vm::TypeNameParser parser(assemblyName, info, false);

        if (!parser.ParseAssembly())
            return false;

        const il2cpp::vm::TypeNameParseInfo::AssemblyName& parsedName = info.assembly_name();
        IL2CPP_OBJECT_SETREF(aname, name, String::New(parsedName.name.c_str()));
        aname->major = parsedName.major;
        aname->minor = parsedName.minor;
        aname->build = parsedName.build;
        aname->revision = parsedName.revision;
        aname->flags = parsedName.flags;
        aname->hashalg = parsedName.hash_alg;

        IL2CPP_OBJECT_SETREF(aname, version, CreateVersion(parsedName.major, parsedName.minor, parsedName.build, parsedName.revision));
        IL2CPP_OBJECT_SETREF(aname, cultureInfo, CreateCulture(parsedName.culture.c_str()));

        if (parsedName.public_key_token[0])
        {
            IL2CPP_OBJECT_SETREF(aname, keyToken, Array::New(il2cpp_defaults.byte_class, kPublicKeyByteLength));
            char* p = il2cpp_array_addr(aname->keyToken, char, 0);

            char buf[2] = { 0 };
            for (int i = 0, j = 0; i < kPublicKeyByteLength; i++)
            {
                buf[0] = parsedName.public_key_token[j++];
                *p = (char)(strtol(buf, NULL, 16) << 4);
                buf[0] = parsedName.public_key_token[j++];
                *p |= (char)strtol(buf, NULL, 16);
                p++;
            }
        }
        else
            IL2CPP_OBJECT_SETREF(aname, keyToken, Array::New(il2cpp_defaults.byte_class, 0));

        return true;
    }

    static char HexValueToLowercaseAscii(uint8_t hexValue)
    {
        if (hexValue < 10)
            return char(hexValue + 48);

        return char(hexValue + 87);
    }

    void AssemblyName::FillNativeAssemblyName(const Il2CppAssemblyName& aname, Il2CppMonoAssemblyName* nativeName)
    {
        nativeName->name = il2cpp::utils::StringUtils::StringDuplicate(aname.name);
        nativeName->culture = il2cpp::utils::StringUtils::StringDuplicate(aname.culture);
        nativeName->public_key = aname.public_key != NULL ? aname.public_key : NULL;
        nativeName->hash_alg = aname.hash_alg;
        nativeName->hash_len = aname.hash_len;
        nativeName->flags = aname.flags;
        nativeName->major = aname.major;
        nativeName->minor = aname.minor;
        nativeName->build = aname.build;
        nativeName->revision = aname.revision;

        //Mono public key token is stored as hexadecimal characters
        if (aname.public_key_token[0])
        {
            int j = 0;
            for (int i = 0; i < kPublicKeyByteLength; ++i)
            {
                uint8_t value = aname.public_key_token[i];
                nativeName->public_key_token.padding[j++] = HexValueToLowercaseAscii((value & 0xF0) >> 4);
                nativeName->public_key_token.padding[j++] = HexValueToLowercaseAscii(value & 0x0F);
            }
        }
    }

    static void PublicKeyTokenToCStringChunk(const uint8_t* public_key_token, void (*chunkReportFunc)(void* data, void* userData), void* userData)
    {
        char result[kPublicKeyByteLength * 2];
        memset(result, 0x00, kPublicKeyByteLength * 2);

        for (int i = 0; i < kPublicKeyByteLength; ++i)
        {
            uint8_t hi = (public_key_token[i] & 0xF0) >> 4;
            uint8_t lo = public_key_token[i] & 0x0F;

            result[i * 2] = HexValueToLowercaseAscii(hi);
            result[i * 2 + 1] = HexValueToLowercaseAscii(lo);
        }

        chunkReportFunc(result, userData);
    }

    static std::string PublicKeyTokenToString(const uint8_t* public_key_token)
    {
        std::string result(kPublicKeyByteLength * 2, '0');
        for (int i = 0; i < kPublicKeyByteLength; ++i)
        {
            uint8_t hi = (public_key_token[i] & 0xF0) >> 4;
            uint8_t lo = public_key_token[i] & 0x0F;

            result[i * 2] = HexValueToLowercaseAscii(hi);
            result[i * 2 + 1] = HexValueToLowercaseAscii(lo);
        }

        return result;
    }

    void AssemblyName::AssemblyNameReportChunked(const Il2CppAssemblyName& aname, void(*chunkReportFunction)(void* data, void* userData), void* userData)
    {
        const size_t bufferSize = 1024;
        char buffer[bufferSize];
        const char* literalPtr = NULL;

        chunkReportFunction(const_cast<char*>(aname.name), userData);
        literalPtr = ", Version=";
        chunkReportFunction(const_cast<char*>(literalPtr), userData);
        snprintf(buffer, bufferSize, "%d%s", aname.major, ".");
        chunkReportFunction(buffer, userData);
        snprintf(buffer, bufferSize, "%d%s", aname.minor, ".");
        chunkReportFunction(buffer, userData);
        snprintf(buffer, bufferSize, "%d%s", aname.build, ".");
        chunkReportFunction(buffer, userData);
        snprintf(buffer, bufferSize, "%d", aname.build);
        chunkReportFunction(buffer, userData);
        snprintf(buffer, bufferSize, "%d", aname.revision);
        chunkReportFunction(buffer, userData);
        literalPtr = ", Culture=";
        chunkReportFunction(const_cast<char*>(literalPtr), userData);
        chunkReportFunction(const_cast<char*>((aname.culture != NULL && strlen(aname.culture) != 0 ? aname.culture : "neutral")), userData);
        literalPtr = ", PublicKeyToken=";
        chunkReportFunction(const_cast<char*>(literalPtr), userData);
        if (aname.public_key_token[0])
            PublicKeyTokenToCStringChunk(aname.public_key_token, chunkReportFunction, userData);
        else
        {
            literalPtr = "null";
            chunkReportFunction(const_cast<char*>(literalPtr), userData);
        }

        literalPtr = (aname.flags & ASSEMBLYREF_RETARGETABLE_FLAG) ? ", Retargetable=Yes" : "";
        chunkReportFunction(const_cast<char*>(literalPtr), userData);
        if (strcmp(aname.name, "WindowsRuntimeMetadata") == 0)
        {
            literalPtr = ", ContentType=WindowsRuntime";
            chunkReportFunction(const_cast<char*>(literalPtr), userData);
        }
    }

    std::string AssemblyName::AssemblyNameToString(const Il2CppAssemblyName& aname)
    {
        std::string name;

        const size_t bufferSize = 1024;
        char buffer[bufferSize];

        name += aname.name;
        name += ", Version=";
        snprintf(buffer, bufferSize, "%d", aname.major);
        name += buffer;
        name += ".";
        snprintf(buffer, bufferSize, "%d", aname.minor);
        name += buffer;
        name += ".";
        snprintf(buffer, bufferSize, "%d", aname.build);
        name += buffer;
        name += ".";
        snprintf(buffer, bufferSize, "%d", aname.revision);
        name += buffer;
        name += ", Culture=";
        const char* culture = NULL;
        culture = aname.culture;
        name += (culture != NULL && strlen(culture) != 0 ? culture : "neutral");
        name += ", PublicKeyToken=";
        name += (aname.public_key_token[0] ? PublicKeyTokenToString(aname.public_key_token) : "null");
        name += ((aname.flags & ASSEMBLYREF_RETARGETABLE_FLAG) ? ", Retargetable=Yes" : "");

        if (strcmp(aname.name, "WindowsRuntimeMetadata") == 0)
            name += ", ContentType=WindowsRuntime";

        return name;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\AssemblyName.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\CCW.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "vm/Object.h"
#include "vm/CCW.h"
#include "vm/Class.h"
#include "vm/CachedCCWBase.h"
#include "vm/Exception.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/RCW.h"
#include "vm/Runtime.h"
#include "vm/ScopedThreadAttacher.h"
#include "vm/String.h"

namespace il2cpp
{
namespace vm
{
    struct ManagedObject : CachedCCWBase<ManagedObject>
    {
        inline ManagedObject(Il2CppObject* obj) :
            CachedCCWBase<ManagedObject>(obj)
        {
        }

        virtual il2cpp_hresult_t STDCALL QueryInterface(const Il2CppGuid& iid, void** object) IL2CPP_OVERRIDE
        {
            if (::memcmp(&iid, &Il2CppIUnknown::IID, sizeof(Il2CppGuid)) == 0
                || ::memcmp(&iid, &Il2CppIInspectable::IID, sizeof(Il2CppGuid)) == 0
                || ::memcmp(&iid, &Il2CppIAgileObject::IID, sizeof(Il2CppGuid)) == 0)
            {
                *object = GetIdentity();
                AddRefImpl();
                return IL2CPP_S_OK;
            }

            if (::memcmp(&iid, &Il2CppIManagedObjectHolder::IID, sizeof(Il2CppGuid)) == 0)
            {
                *object = static_cast<Il2CppIManagedObjectHolder*>(this);
                AddRefImpl();
                return IL2CPP_S_OK;
            }

            if (::memcmp(&iid, &Il2CppIMarshal::IID, sizeof(Il2CppGuid)) == 0)
            {
                *object = static_cast<Il2CppIMarshal*>(this);
                AddRefImpl();
                return IL2CPP_S_OK;
            }

            if (::memcmp(&iid, &Il2CppIWeakReferenceSource::IID, sizeof(Il2CppGuid)) == 0)
            {
                *object = static_cast<Il2CppIWeakReferenceSource*>(this);
                AddRefImpl();
                return IL2CPP_S_OK;
            }

            *object = NULL;
            return IL2CPP_E_NOINTERFACE;
        }
    };

    Il2CppIUnknown* CCW::CreateCCW(Il2CppObject* obj)
    {
        // check for ccw create function, which is implemented by objects that implement COM or Windows Runtime interfaces
        const Il2CppInteropData* interopData = obj->klass->interopData;
        if (interopData != NULL)
        {
            const CreateCCWFunc createCcw = interopData->createCCWFunction;

            if (createCcw != NULL)
                return createCcw(obj);
        }

        // otherwise create generic ccw object that "only" implements IUnknown, IMarshal, IInspectable, IAgileObject and IManagedObjectHolder interfaces
        void* memory = utils::Memory::Malloc(sizeof(ManagedObject));
        if (memory == NULL)
            Exception::RaiseOutOfMemoryException();
        return static_cast<Il2CppIManagedObjectHolder*>(new(memory) ManagedObject(obj));
    }

    Il2CppObject* CCW::Unpack(Il2CppIUnknown* unknown)
    {
        Il2CppIManagedObjectHolder* managedHolder;
        il2cpp_hresult_t hr = unknown->QueryInterface(Il2CppIManagedObjectHolder::IID, reinterpret_cast<void**>(&managedHolder));
        Exception::RaiseIfFailed(hr, true);

        Il2CppObject* instance = managedHolder->GetManagedObject();
        managedHolder->Release();

        IL2CPP_ASSERT(instance);
        return instance;
    }

    static Il2CppString* ValueToStringFallbackToEmpty(Il2CppObject* value)
    {
        Il2CppClass* klass = il2cpp::vm::Object::GetClass(value);
        const MethodInfo* toStringMethod = il2cpp::vm::Class::GetMethodFromName(klass, "ToString", 0);
        // check if the method we are to call is expecting a value type 'this' parameter or not.
        // handles edge case of enums where the 'value' is SomeEnum but the ToString method is Enum::ToString.
        // In this case, a boxed 'this' parameter is expected even though the object value is a valuetype.
        bool isValueTypeMethod = il2cpp::vm::Class::IsValuetype(il2cpp::vm::Method::GetClass(toStringMethod));

        Il2CppException* exception = NULL;
        Il2CppString* result = (Il2CppString*)il2cpp::vm::Runtime::Invoke(toStringMethod, isValueTypeMethod ? Object::Unbox(value) : value, NULL, &exception);
        if (exception != NULL)
            return String::Empty();

        return result;
    }

    static il2cpp_hresult_t HandleInvalidIPropertyConversionImpl(const std::string& exceptionMessage)
    {
        ScopedThreadAttacher scopedThreadAttacher; // Make sure we're attached before we create exceptions (aka allocate managed memory)

        Il2CppException* exception = Exception::GetInvalidCastException(exceptionMessage.c_str());
        Exception::PrepareExceptionForThrow(exception);
        Exception::StoreExceptionInfo(exception, ValueToStringFallbackToEmpty(exception));
        return exception->hresult;
    }

    il2cpp_hresult_t CCW::HandleInvalidIPropertyConversion(const char* fromType, const char* toType)
    {
        std::string message = il2cpp::utils::StringUtils::Printf("Object in an IPropertyValue is of type '%s', which cannot be converted to a '%s'.", fromType, toType);
        return HandleInvalidIPropertyConversionImpl(message);
    }

    il2cpp_hresult_t CCW::HandleInvalidIPropertyConversion(Il2CppObject* value, const char* fromType, const char* toType)
    {
        Il2CppString* valueStr = ValueToStringFallbackToEmpty(value);
        std::string message = il2cpp::utils::StringUtils::Printf(
            "Object in an IPropertyValue is of type '%s' with value '%s', which cannot be converted to a '%s'.",
            fromType,
            utils::StringUtils::Utf16ToUtf8(valueStr->chars, valueStr->length).c_str(),
            toType);
        return HandleInvalidIPropertyConversionImpl(message);
    }

    il2cpp_hresult_t CCW::HandleInvalidIPropertyArrayConversion(const char* fromArrayType, const char* fromElementType, const char* toElementType, il2cpp_array_size_t index)
    {
        std::string message = il2cpp::utils::StringUtils::Printf(
            "Object in an IPropertyValue is of type '%s' which cannot be converted to a '%s[]' due to array element '%d': Object in an IPropertyValue is of type '%s', which cannot be converted to a '%s'.",
            fromArrayType,
            toElementType,
            static_cast<int>(index),
            fromElementType,
            toElementType);
        return HandleInvalidIPropertyConversionImpl(message);
    }

    il2cpp_hresult_t CCW::HandleInvalidIPropertyArrayConversion(Il2CppObject* value, const char* fromArrayType, const char* fromElementType, const char* toElementType, il2cpp_array_size_t index)
    {
        Il2CppString* valueStr = ValueToStringFallbackToEmpty(value);
        std::string message = il2cpp::utils::StringUtils::Printf(
            "Object in an IPropertyValue is of type '%s' which cannot be converted to a '%s[]' due to array element '%d': Object in an IPropertyValue is of type '%s' with value '%s', which cannot be converted to a '%s'.",
            fromArrayType,
            toElementType,
            static_cast<int>(index),
            fromElementType,
            utils::StringUtils::Utf16ToUtf8(valueStr->chars, valueStr->length).c_str(),
            toElementType);
        return HandleInvalidIPropertyConversionImpl(message);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\CCW.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\CCWBase.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-string-types.h"
#include "CCWBase.h"
#include "metadata/GenericMetadata.h"
#include "os/WindowsRuntime.h"
#include "vm/Class.h"
#include "vm/GenericClass.h"
#include "vm/MetadataCache.h"
#include "vm/WeakReference.h"
#include "utils/StringUtils.h"

static inline const Il2CppClass* GetBoxedWindowsRuntimeClass(const Il2CppClass* typeDefinition, const Il2CppClass* genericArg)
{
    const Il2CppType* klass = &genericArg->byval_arg;
    const Il2CppGenericInst* inst = il2cpp::vm::MetadataCache::GetGenericInst(&klass, 1);
    Il2CppGenericClass* genericClass = il2cpp::metadata::GenericMetadata::GetGenericClass(typeDefinition, inst);
    return il2cpp::vm::GenericClass::GetClass(genericClass);
}

static inline bool CanPotentiallyBeBoxedToWindowsRuntime(const Il2CppClass* klass)
{
    if (il2cpp::vm::Class::IsInflated(klass))
        return false;

    if (il2cpp::vm::Class::IsValuetype(klass))
        return true;

    if (klass == il2cpp_defaults.string_class)
        return true;

    return false;
}

il2cpp_hresult_t il2cpp::vm::CCWBase::GetRuntimeClassNameImpl(Il2CppHString* className)
{
    const Il2CppClass* objectClass = GetManagedObjectInline()->klass;
    if (il2cpp_defaults.ireference_class != NULL && CanPotentiallyBeBoxedToWindowsRuntime(objectClass))
    {
        // For value types/strings we're supposed to return the name of its boxed representation, i.e. Windows.Foundation.IReference`1<T>
        objectClass = GetBoxedWindowsRuntimeClass(il2cpp_defaults.ireference_class, objectClass);
    }
    else if (il2cpp_defaults.ireferencearray_class != NULL && objectClass->rank > 0)
    {
        // For arrays of value types/strings we're supposed to return the name of its boxed representation too, i.e. Windows.Foundation.IReferenceArray`1<T>
        const Il2CppClass* elementClass = objectClass->element_class;
        if (CanPotentiallyBeBoxedToWindowsRuntime(elementClass))
        {
            objectClass = GetBoxedWindowsRuntimeClass(il2cpp_defaults.ireferencearray_class, elementClass);
        }
        else if (elementClass == il2cpp_defaults.object_class || strcmp(elementClass->image->assembly->aname.name, "WindowsRuntimeMetadata") == 0)
        {
            // Object arrays can be boxed, but objects cannot, so we need to special case it
            // For object and WindowsRuntime classes arrays, we also return Windows.Foundation.IReferenceArray`1<Object>
            return os::WindowsRuntime::CreateHString(utils::StringView<Il2CppNativeChar>(IL2CPP_NATIVE_STRING("Windows.Foundation.IReferenceArray`1<Object>")), className);
        }
    }

    const char* name = MetadataCache::GetWindowsRuntimeClassName(objectClass);
    if (name == NULL)
    {
        *className = NULL;
        return IL2CPP_S_OK;
    }

    UTF16String nameUtf16 = utils::StringUtils::Utf8ToUtf16(name);
    return os::WindowsRuntime::CreateHString(utils::StringView<Il2CppChar>(nameUtf16.c_str(), nameUtf16.length()), className);
}

Il2CppObject* STDCALL il2cpp::vm::CCWBase::GetManagedObject()
{
    return GetManagedObjectInline();
}

il2cpp_hresult_t STDCALL il2cpp::vm::CCWBase::GetWeakReference(Il2CppIWeakReference** weakReference)
{
    return WeakReference::Create(GetManagedObjectInline(), weakReference);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\CCWBase.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Class.cpp---------------
.
.
#include "il2cpp-config.h"
#include "mono-structs.h"
#include <algorithm>
#include "gc/GCHandle.h"
#include "metadata/ArrayMetadata.h"
#include "metadata/GenericMetadata.h"
#include "metadata/GenericMethod.h"
#include "metadata/FieldLayout.h"
#include "metadata/Il2CppTypeCompare.h"
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/GenericContainer.h"
#include "vm/Method.h"
#include "vm/Image.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataCache.h"
#include "vm/MetadataLock.h"
#include "vm/Method.h"
#include "vm/Property.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/Thread.h"
#include "vm/Type.h"
#include "vm/Object.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-runtime-stats.h"
#include "il2cpp-tabledefs.h"
#include "gc/GarbageCollector.h"
#include "utils/Il2CppHashMap.h"
#include "utils/InitOnce.h"
#include "utils/StringUtils.h"
#include "utils/HashUtils.h"
#include <string>
#include <memory.h>
#include <algorithm>
#include <limits>
#include <stdarg.h>

namespace il2cpp
{
namespace vm
{
    const int Class::IgnoreNumberOfArguments = -1;

    static int32_t s_FinalizerSlot = -1;
    static int32_t s_GetHashCodeSlot = -1;
    static Il2CppClass* s_EmptyClassList[] = {NULL};

    struct ClassContext
    {
        il2cpp::utils::dynamic_array<Il2CppClass*> m_staticFieldData;
    };
    static ClassContext* s_ClassContext = nullptr;

    static void SetupGCDescriptor(Il2CppClass* klass, const il2cpp::os::FastAutoLock& lock);
    static void GetBitmapNoInit(Il2CppClass* klass, size_t* bitmap, size_t& maxSetBit, size_t parentOffset, const il2cpp::os::FastAutoLock* lockPtr);
    static Il2CppClass* ResolveGenericInstanceType(Il2CppClass*, const il2cpp::vm::TypeNameParseInfo&, TypeSearchFlags searchFlags);
    static void SetupVTable(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock);
    static void AddStaticFieldData(Il2CppClass* klass);

    void Class::AllocateStaticData()
    {
        s_ClassContext = new ClassContext();
    }

    void Class::FreeStaticData()
    {
        delete s_ClassContext;
        s_ClassContext = nullptr;
    }

    Il2CppClass* Class::FromIl2CppType(const Il2CppType* type, bool throwOnError)
    {
        Il2CppClass* defaultClass = FromIl2CppTypeEnum(type->type);
        if (defaultClass != NULL)
            return defaultClass;

        switch (type->type)
        {
            case IL2CPP_TYPE_ARRAY:
            {
                Il2CppClass* elementClass = FromIl2CppType(type->data.array->etype, throwOnError);
                return Class::GetBoundedArrayClass(elementClass, type->data.array->rank, true);
            }
            case IL2CPP_TYPE_PTR:
                return Class::GetPtrClass(type->data.type);
            case IL2CPP_TYPE_FNPTR:
                return il2cpp_defaults.int_class;
            case IL2CPP_TYPE_SZARRAY:
            {
                Il2CppClass* elementClass = FromIl2CppType(type->data.type, throwOnError);
                return Class::GetArrayClass(elementClass, 1);
            }
            case IL2CPP_TYPE_CLASS:
            case IL2CPP_TYPE_VALUETYPE:
                return Type::GetClass(type);
            case IL2CPP_TYPE_GENERICINST:
                return GenericClass::GetClass(type->data.generic_class, throwOnError);
            case IL2CPP_TYPE_VAR:
                return Class::FromGenericParameter(Type::GetGenericParameterHandle(type));
            case IL2CPP_TYPE_MVAR:
                return Class::FromGenericParameter(Type::GetGenericParameterHandle(type));
            default:
                IL2CPP_NOT_IMPLEMENTED(Class::FromIl2CppType);
        }

        return NULL;
    }

    Il2CppClass* Class::FromIl2CppTypeEnum(Il2CppTypeEnum type)
    {
#define RETURN_DEFAULT_TYPE(fieldName) do { IL2CPP_ASSERT(il2cpp_defaults.fieldName); return il2cpp_defaults.fieldName; } while (false)

        switch (type)
        {
            case IL2CPP_TYPE_OBJECT:
                RETURN_DEFAULT_TYPE(object_class);
            case IL2CPP_TYPE_VOID:
                RETURN_DEFAULT_TYPE(void_class);
            case IL2CPP_TYPE_BOOLEAN:
                RETURN_DEFAULT_TYPE(boolean_class);
            case IL2CPP_TYPE_CHAR:
                RETURN_DEFAULT_TYPE(char_class);
            case IL2CPP_TYPE_I1:
                RETURN_DEFAULT_TYPE(sbyte_class);
            case IL2CPP_TYPE_U1:
                RETURN_DEFAULT_TYPE(byte_class);
            case IL2CPP_TYPE_I2:
                RETURN_DEFAULT_TYPE(int16_class);
            case IL2CPP_TYPE_U2:
                RETURN_DEFAULT_TYPE(uint16_class);
            case IL2CPP_TYPE_I4:
                RETURN_DEFAULT_TYPE(int32_class);
            case IL2CPP_TYPE_U4:
                RETURN_DEFAULT_TYPE(uint32_class);
            case IL2CPP_TYPE_I:
                RETURN_DEFAULT_TYPE(int_class);
            case IL2CPP_TYPE_U:
                RETURN_DEFAULT_TYPE(uint_class);
            case IL2CPP_TYPE_I8:
                RETURN_DEFAULT_TYPE(int64_class);
            case IL2CPP_TYPE_U8:
                RETURN_DEFAULT_TYPE(uint64_class);
            case IL2CPP_TYPE_R4:
                RETURN_DEFAULT_TYPE(single_class);
            case IL2CPP_TYPE_R8:
                RETURN_DEFAULT_TYPE(double_class);
            case IL2CPP_TYPE_STRING:
                RETURN_DEFAULT_TYPE(string_class);
            case IL2CPP_TYPE_TYPEDBYREF:
                RETURN_DEFAULT_TYPE(typed_reference_class);

            case IL2CPP_TYPE_IL2CPP_TYPE_INDEX:
                RETURN_DEFAULT_TYPE(systemtype_class);
            default:
                break;
        }

        return NULL;

#undef RETURN_DEFAULT_TYPE
    }

    Il2CppClass* Class::FromSystemType(Il2CppReflectionType *type)
    {
        Il2CppClass *klass = Class::FromIl2CppType(type->type);
        Class::Init(klass);
        return klass;
    }

    static void SetupInterfacesLocked(Il2CppClass* klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->generic_class)
        {
            Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(klass->generic_class);
            Il2CppGenericContext* context = &klass->generic_class->context;

            if (genericTypeDefinition->interfaces_count > 0 && klass->implementedInterfaces == NULL)
            {
                IL2CPP_ASSERT(genericTypeDefinition->interfaces_count == klass->interfaces_count);
                klass->implementedInterfaces = (Il2CppClass**)MetadataCalloc(genericTypeDefinition->interfaces_count, sizeof(Il2CppClass*));
                for (uint16_t i = 0; i < genericTypeDefinition->interfaces_count; i++)
                    klass->implementedInterfaces[i] = Class::FromIl2CppType(il2cpp::metadata::GenericMetadata::InflateIfNeeded(MetadataCache::GetInterfaceFromOffset(genericTypeDefinition, i), context, false));
            }
        }
        else if (klass->rank > 0)
        {
            if (klass->implementedInterfaces == NULL)
                il2cpp::metadata::ArrayMetadata::SetupArrayInterfaces(klass, lock);
        }
        else
        {
            if (klass->interfaces_count > 0 && klass->implementedInterfaces == NULL)
            {
                klass->implementedInterfaces = (Il2CppClass**)MetadataCalloc(klass->interfaces_count, sizeof(Il2CppClass*));
                for (uint16_t i = 0; i < klass->interfaces_count; i++)
                    klass->implementedInterfaces[i] = Class::FromIl2CppType(MetadataCache::GetInterfaceFromOffset(klass, i));
            }
        }

        if (klass->implementedInterfaces == NULL)
        {
            IL2CPP_ASSERT(klass->interfaces_count == 0);
            klass->implementedInterfaces = s_EmptyClassList;
        }
    }

    typedef Il2CppHashMap<Il2CppMetadataGenericParameterHandle, Il2CppClass*, utils::PassThroughHash<Il2CppMetadataGenericParameterHandle> > GenericParameterMap;
    static GenericParameterMap s_GenericParameterMap;

    Il2CppClass* Class::FromGenericParameter(Il2CppMetadataGenericParameterHandle param)
    {
        il2cpp::os::FastAutoLock lock(&g_MetadataLock);

        GenericParameterMap::const_iterator iter = s_GenericParameterMap.find(param);
        if (iter != s_GenericParameterMap.end())
            return iter->second;

        Il2CppClass* klass = (Il2CppClass*)MetadataCalloc(1, sizeof(Il2CppClass));
        klass->klass = klass;

        Il2CppGenericParameterInfo paramInfo = MetadataCache::GetGenericParameterInfo(param);

        IL2CPP_ASSERT(paramInfo.containerHandle != NULL);

        klass->name = paramInfo.name;
        klass->namespaze = "";

        klass->image = GenericContainer::GetDeclaringType(paramInfo.containerHandle)->image;

        klass->parent = il2cpp_defaults.object_class;
        klass->castClass = klass->element_class = klass;

        klass->flags = TYPE_ATTRIBUTE_PUBLIC;

        bool containerIsMethod = MetadataCache::GetGenericContainerIsMethod(paramInfo.containerHandle);

        MetadataCache::MakeGenericArgType(paramInfo.containerHandle, param, &klass->byval_arg);
        MetadataCache::MakeGenericArgType(paramInfo.containerHandle, param, &klass->this_arg);
        klass->this_arg.byref = true;

        klass->instance_size = sizeof(void*);
        klass->stack_slot_size = sizeof(void*);
        klass->thread_static_fields_size = -1;
        klass->native_size = -1;
        klass->size_inited = true;
        klass->typeHierarchyDepth = 1;

        PublishInitialized(klass);

        s_GenericParameterMap.insert(std::make_pair(param, klass));

        return klass;
    }

    Il2CppClass* Class::GetElementClass(Il2CppClass *klass)
    {
        return klass->element_class;
    }

    const Il2CppType* Class::GetEnumBaseType(Il2CppClass *klass)
    {
        if (klass->element_class == klass)
            /* SRE or broken types */
            return NULL;
        else
            return &klass->element_class->byval_arg;
    }

    const EventInfo* Class::GetEvents(Il2CppClass *klass, void* *iter)
    {
        if (!iter)
            return NULL;

        if (!*iter)
        {
            Class::SetupEvents(klass);
            if (klass->event_count == 0)
                return NULL;

            *iter = const_cast<EventInfo*>(klass->events);
            return klass->events;
        }

        const EventInfo* eventInfo = (const EventInfo*)*iter;
        eventInfo++;
        if (eventInfo < klass->events + klass->event_count)
        {
            *iter = const_cast<EventInfo*>(eventInfo);
            return eventInfo;
        }

        return NULL;
    }

    FieldInfo* Class::GetFields(Il2CppClass *klass, void* *iter)
    {
        if (!iter)
            return NULL;

        if (!*iter)
        {
            Class::SetupFields(klass);
            if (klass->field_count == 0)
                return NULL;

            *iter = klass->fields;
            return klass->fields;
        }

        FieldInfo* fieldAddress = (FieldInfo*)*iter;
        fieldAddress++;
        if (fieldAddress < klass->fields + klass->field_count)
        {
            *iter = fieldAddress;
            return fieldAddress;
        }

        return NULL;
    }

    FieldInfo* Class::GetFieldFromName(Il2CppClass *klass, const char* name)
    {
        while (klass)
        {
            void* iter = NULL;
            FieldInfo* field;
            while ((field = GetFields(klass, &iter)))
            {
                if (strcmp(name, Field::GetName(field)) != 0)
                    continue;

                return field;
            }

            klass = klass->parent;
        }

        return NULL;
    }

    const MethodInfo* Class::GetFinalizer(Il2CppClass *klass)
    {
        if (!klass->initialized)
            Class::Init(klass);

        if (!klass->has_finalize)
            return NULL;

        return klass->vtable[s_FinalizerSlot].method;
    }

    int32_t Class::GetInstanceSize(const Il2CppClass *klass)
    {
        IL2CPP_ASSERT(klass->size_inited);
        return klass->instance_size;
    }

    Il2CppClass* Class::GetInterfaces(Il2CppClass *klass, void* *iter)
    {
        if (!iter)
            return NULL;

        if (!*iter)
        {
            Class::SetupInterfaces(klass);
            if (klass->interfaces_count == 0)
                return NULL;

            *iter = &klass->implementedInterfaces[0];
            return klass->implementedInterfaces[0];
        }

        Il2CppClass** interfaceAddress = (Il2CppClass**)*iter;
        interfaceAddress++;
        if (interfaceAddress < &klass->implementedInterfaces[klass->interfaces_count])
        {
            *iter = interfaceAddress;
            return *interfaceAddress;
        }

        return NULL;
    }

    const MethodInfo* Class::GetMethods(Il2CppClass *klass, void* *iter)
    {
        if (!iter)
            return NULL;

        if (!*iter)
        {
            Class::SetupMethods(klass);
            if (klass->method_count == 0)
                return NULL;

            *iter = &klass->methods[0];
            return klass->methods[0];
        }

        const MethodInfo** methodAddress = (const MethodInfo**)*iter;
        methodAddress++;
        if (methodAddress < &klass->methods[klass->method_count])
        {
            *iter = methodAddress;
            return *methodAddress;
        }

        return NULL;
    }

    const MethodInfo* Class::GetMethodFromName(Il2CppClass *klass, const char* name, int argsCount)
    {
        return GetMethodFromNameFlags(klass, name, argsCount, 0);
    }

    const MethodInfo* Class::GetMethodFromNameFlags(Il2CppClass *klass, const char* name, int argsCount, int32_t flags)
    {
        return GetMethodFromNameFlagsAndSig(klass, name, argsCount, flags, NULL);
    }

    const MethodInfo* Class::GetMethodFromNameFlagsAndSig(Il2CppClass *klass, const char* name, int argsCount, int32_t flags, const Il2CppType** argTypes)
    {
        Class::Init(klass);

        while (klass != NULL)
        {
            void* iter = NULL;
            while (const MethodInfo* method = Class::GetMethods(klass, &iter))
            {
                if (method->name[0] == name[0] &&
                    (argsCount == IgnoreNumberOfArguments || method->parameters_count == argsCount) &&
                    ((method->flags & flags) == flags) &&
                    !strcmp(name, method->name))
                {
                    bool allArgTypeMatch = true;
                    if (argTypes != NULL && argsCount != IgnoreNumberOfArguments)
                    {
                        for (int i = 0; allArgTypeMatch && i < argsCount; i++)
                        {
                            allArgTypeMatch = metadata::Il2CppTypeEqualityComparer::AreEqual(method->parameters[i], argTypes[i]);
                        }
                    }

                    if (allArgTypeMatch)
                        return method;
                }
            }

            klass = klass->parent;
        }

        return NULL;
    }

    const MethodInfo* Class::GetGenericInstanceMethodFromDefintion(Il2CppClass* genericInstanceClass, const MethodInfo* methodDefinition)
    {
        IL2CPP_ASSERT(Class::IsInflated(genericInstanceClass));
        IL2CPP_ASSERT(metadata::Il2CppTypeEqualityComparer::AreEqual(genericInstanceClass->generic_class->type, &methodDefinition->klass->byval_arg));

        ptrdiff_t index = methodDefinition - methodDefinition->klass->methods[0];

        IL2CPP_ASSERT(index >= 0 && index < methodDefinition->klass->method_count);
        IL2CPP_ASSERT(index < genericInstanceClass->method_count);

        const MethodInfo* genericClassMethod = genericInstanceClass->methods[index];

        IL2CPP_ASSERT(genericClassMethod->genericMethod->methodDefinition == methodDefinition);

        return genericClassMethod;
    }

    const char* Class::GetName(Il2CppClass *klass)
    {
        return klass->name;
    }

    const char* Class::GetNamespace(Il2CppClass *klass)
    {
        return klass->namespaze;
    }

    Il2CppClass* Class::GetNestedTypes(Il2CppClass *klass, void* *iter)
    {
        if (!iter)
            return NULL;

        if (klass->generic_class)
        {
            IL2CPP_ASSERT(0 && "Class::GetNestedTypes should only be called on non-generic types and generic type definitions");
            return NULL;
        }

        if (!*iter)
        {
            Class::SetupNestedTypes(klass);
            if (klass->nested_type_count == 0)
                return NULL;

            *iter = &klass->nestedTypes[0];
            return klass->nestedTypes[0];
        }

        Il2CppClass** nestedTypeAddress = (Il2CppClass**)*iter;
        nestedTypeAddress++;
        if (nestedTypeAddress < &klass->nestedTypes[klass->nested_type_count])
        {
            *iter = nestedTypeAddress;
            return *nestedTypeAddress;
        }

        return NULL;
    }

    size_t Class::GetNumMethods(const Il2CppClass* klass)
    {
        return klass->method_count;
    }

    size_t Class::GetNumProperties(const Il2CppClass* klass)
    {
        return klass->property_count;
    }

    size_t Class::GetNumFields(const Il2CppClass* klass)
    {
        return klass->field_count;
    }

    Il2CppClass* Class::GetParent(Il2CppClass *klass)
    {
        return klass->parent;
    }

    const PropertyInfo* Class::GetProperties(Il2CppClass *klass, void* *iter)
    {
        if (!iter)
            return NULL;

        if (!*iter)
        {
            Class::SetupProperties(klass);
            if (klass->property_count == 0)
                return NULL;

            *iter = const_cast<PropertyInfo*>(klass->properties);
            return klass->properties;
        }

        const PropertyInfo* property = (const PropertyInfo*)*iter;
        property++;
        if (property < klass->properties + klass->property_count)
        {
            *iter = const_cast<PropertyInfo*>(property);
            return property;
        }

        return NULL;
    }

    const PropertyInfo* Class::GetPropertyFromName(Il2CppClass *klass, const char* name)
    {
        while (klass)
        {
            void* iter = NULL;
            while (const PropertyInfo* prop = GetProperties(klass, &iter))
            {
                if (strcmp(name, Property::GetName(prop)) != 0)
                    continue;

                return prop;
            }

            klass = klass->parent;
        }

        return NULL;
    }

    int32_t Class::GetValueSize(Il2CppClass *klass, uint32_t *align)
    {
        int32_t size;

        if (!klass->size_init_pending)
            SetupFields(klass);

        IL2CPP_ASSERT(klass->byval_arg.valuetype);

        if (!klass->size_inited)
        {
            // If the size of a value type is not intialized, we cannot continue.
            // This might mean this is a recursively defined struct, where one value type
            // has a field of anotehr value type, which in turn has the first as a field.
            // The runtime should throw a type load exception in this case.
            std::string message;
            message += "Could not load type '";
            if (strlen(klass->namespaze) != 0)
            {
                message += klass->namespaze;
                message += ":";
            }
            message += klass->name;
            message += "'";
            Class::SetClassInitializationError(klass, il2cpp::vm::Exception::GetTypeLoadException(message.c_str()));

            size = 1;
        }
        else
        {
            size = Class::GetInstanceSize(klass) - sizeof(Il2CppObject);
        }

        if (align)
            *align = klass->minimumAlignment;

        return size;
    }

    bool Class::HasParent(Il2CppClass *klass, Il2CppClass *parent)
    {
        Class::SetupTypeHierarchy(klass);
        Class::SetupTypeHierarchy(parent);

        return ClassInlines::HasParentUnsafe(klass, parent);
    }

    bool Class::IsAssignableFrom(Il2CppClass *klass, Il2CppClass *oklass)
    {
        // Cast to original class - fast path
        if (klass == oklass)
            return true;

        Class::Init(klass);
        Class::Init(oklass);

        // Following checks are always going to fail for interfaces
        if (!IsInterface(klass))
        {
            // Array
            if (klass->rank)
            {
                if (oklass->rank != klass->rank)
                    return false;

                if (Class::IsValuetype(oklass->castClass))
                {
                    // Full array covariance is defined only for reference types.
                    // For value types, array element reduced types must match
                    return klass->castClass == oklass->castClass;
                }

                return Class::IsAssignableFrom(klass->castClass, oklass->castClass);
            }
            // System.Object
            else if (klass == il2cpp_defaults.object_class)
            {
                return true;
            }
            // Left is System.Nullable<>
            else if (Class::IsNullable(klass))
            {
                if (Class::IsNullable(oklass))
                    IL2CPP_NOT_IMPLEMENTED(Class::IsAssignableFrom);
                Il2CppClass* nullableArg = Class::GetNullableArgument(klass);
                return Class::IsAssignableFrom(nullableArg, oklass);
            }

            if (klass->parent == il2cpp_defaults.multicastdelegate_class && klass->generic_class != NULL)
            {
                if (IsGenericClassAssignableFrom(klass, oklass, oklass))
                    return true;
            }

            return ClassInlines::HasParentUnsafe(oklass, klass);
        }

        if (klass->generic_class != NULL)
        {
            // checking for simple reference equality is not enough in this case because generic interface might have covariant and/or contravariant parameters
            for (Il2CppClass* iter = oklass; iter != NULL; iter = iter->parent)
            {
                if (IsGenericClassAssignableFrom(klass, iter, oklass))
                    return true;

                for (uint16_t i = 0; i < iter->interfaces_count; ++i)
                {
                    if (IsGenericClassAssignableFrom(klass, iter->implementedInterfaces[i], oklass))
                        return true;
                }

                for (uint16_t i = 0; i < iter->interface_offsets_count; ++i)
                {
                    if (IsGenericClassAssignableFrom(klass, iter->interfaceOffsets[i].interfaceType, oklass))
                        return true;
                }
            }
        }
        else
        {
            for (Il2CppClass* iter = oklass; iter != NULL; iter = iter->parent)
            {
                for (uint16_t i = 0; i < iter->interfaces_count; ++i)
                {
                    if (iter->implementedInterfaces[i] == klass)
                        return true;
                }

                // Check the interfaces we may have grafted on to the type (e.g IList,
                // ICollection, IEnumerable for array types).
                for (uint16_t i = 0; i < iter->interface_offsets_count; ++i)
                {
                    if (iter->interfaceOffsets[i].interfaceType == klass)
                        return true;
                }
            }
        }

        return false;
    }

    bool Class::IsAssignableFrom(Il2CppReflectionType * type, Il2CppReflectionType * c)
    {
        Il2CppClass *klass;
        Il2CppClass *klassc;

        klass = FromIl2CppType(type->type);
        klassc = FromIl2CppType(c->type);

        if (type->type->byref && !c->type->byref)
            return false;

        return IsAssignableFrom(klass, klassc);
    }

    bool Class::IsGeneric(const Il2CppClass *klass)
    {
        return klass->is_generic;
    }

    bool Class::IsInflated(const Il2CppClass *klass)
    {
        return klass->generic_class != NULL;
    }

    bool Class::IsGenericTypeDefinition(const Il2CppClass* klass)
    {
        return IsGeneric(klass) && !IsInflated(klass);
    }

    bool Class::IsSubclassOf(Il2CppClass *klass, Il2CppClass *klassc, bool check_interfaces)
    {
        Class::SetupTypeHierarchy(klass);
        Class::SetupTypeHierarchy(klassc);
        Class::SetupInterfaces(klass);

        if (check_interfaces && IsInterface(klassc) && !IsInterface(klass))
        {
            Il2CppClass *oklass = klass;

            while (oklass)
            {
                Class::SetupInterfaces(oklass);
                // TODO: we probably need to implement a faster check here
                for (uint16_t i = 0; i < oklass->interfaces_count; i++)
                {
                    if (oklass->implementedInterfaces[i] == klassc)
                        return true;
                }

                oklass = oklass->parent;
            }
        }
        else if (check_interfaces && IsInterface(klassc) && IsInterface(klass))
        {
            // TODO: we probably need to implement a faster check here
            for (uint16_t i = 0; i < klass->interfaces_count; i++)
            {
                if (klass->implementedInterfaces[i] == klassc)
                    return true;
            }
        }
        else
        {
            if (!IsInterface(klass) && ClassInlines::HasParentUnsafe(klass, klassc))
                return true;
        }

        /*
         * MS.NET thinks interfaces are a subclass of Object, so we think it as
         * well.
         */
        if (klassc == il2cpp_defaults.object_class)
            return true;

        return false;
    }

    enum FieldLayoutKind
    {
        FIELD_LAYOUT_INSTANCE,
        FIELD_LAYOUT_STATIC,
        FIELD_LAYOUT_THREADSTATIC,
    };

    static void SetupFieldOffsetsLocked(FieldLayoutKind fieldLayoutKind, Il2CppClass* klass, size_t size, const std::vector<size_t>& fieldOffsets, const il2cpp::os::FastAutoLock& lock)
    {
        IL2CPP_ASSERT(size < std::numeric_limits<uint32_t>::max());
        if (fieldLayoutKind == FIELD_LAYOUT_INSTANCE)
            klass->instance_size = static_cast<uint32_t>(size);
        if (fieldLayoutKind == FIELD_LAYOUT_STATIC)
            klass->static_fields_size = static_cast<uint32_t>(size);
        if (fieldLayoutKind == FIELD_LAYOUT_THREADSTATIC)
            klass->thread_static_fields_size = static_cast<uint32_t>(size);

        if (!(klass->flags & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT))
        {
            size_t fieldIndex = 0;
            for (uint16_t i = 0; i < klass->field_count; i++)
            {
                FieldInfo* field = klass->fields + i;
                if (fieldLayoutKind == FIELD_LAYOUT_INSTANCE && field->type->attrs & FIELD_ATTRIBUTE_STATIC)
                    continue;
                if (fieldLayoutKind == FIELD_LAYOUT_STATIC && !Field::IsNormalStatic(field))
                    continue;
                if (fieldLayoutKind == FIELD_LAYOUT_THREADSTATIC && !Field::IsThreadStatic(field))
                    continue;

                if (fieldLayoutKind == FIELD_LAYOUT_THREADSTATIC)
                {
                    field->offset = THREAD_STATIC_FIELD_OFFSET;
                    MetadataCache::AddThreadLocalStaticOffsetForFieldLocked(field, static_cast<int32_t>(fieldOffsets[fieldIndex]), lock);
                    fieldIndex++;
                    continue;
                }

                field->offset = static_cast<int32_t>(fieldOffsets[fieldIndex]);
                fieldIndex++;
            }
        }
    }

    static void ValidateFieldOffsets(FieldLayoutKind fieldLayoutKind, Il2CppClass* klass, size_t size, const std::vector<size_t>& fieldOffsets)
    {
        if (fieldLayoutKind == FIELD_LAYOUT_INSTANCE && klass->parent && !(klass->flags & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT))
            IL2CPP_ASSERT(klass->instance_size == size);
        if (fieldLayoutKind == FIELD_LAYOUT_STATIC)
            IL2CPP_ASSERT(klass->static_fields_size == size);
        if (fieldLayoutKind == FIELD_LAYOUT_THREADSTATIC)
            IL2CPP_ASSERT(klass->thread_static_fields_size == size);

        if (!(klass->flags & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT))
        {
            size_t fieldIndex = 0;
            for (uint16_t i = 0; i < klass->field_count; i++)
            {
                FieldInfo* field = klass->fields + i;
                if (fieldLayoutKind == FIELD_LAYOUT_INSTANCE && field->type->attrs & FIELD_ATTRIBUTE_STATIC)
                    continue;
                if (fieldLayoutKind == FIELD_LAYOUT_STATIC && !Field::IsNormalStatic(field))
                    continue;
                if (fieldLayoutKind == FIELD_LAYOUT_THREADSTATIC && !Field::IsThreadStatic(field))
                    continue;

                if (fieldLayoutKind == FIELD_LAYOUT_THREADSTATIC)
                {
                    IL2CPP_ASSERT(fieldOffsets[fieldIndex] == -1);
                    fieldIndex++;
                    continue;
                }

                IL2CPP_ASSERT(field->offset == fieldOffsets[fieldIndex]);
                fieldIndex++;
            }
        }
    }

    static size_t UpdateInstanceSizeForGenericClass(Il2CppClass* klass, size_t instanceSize)
    {
        // need to set this in case there are no fields in a generic instance type
        if (klass->generic_class)
        {
            const Il2CppClass* genericTypeDef = il2cpp::vm::MetadataCache::GetTypeInfoFromType(klass->generic_class->type);
            // If the generic class has an instance size, it was explictly set
            if (genericTypeDef->instance_size > 0 && genericTypeDef->instance_size > instanceSize)
                instanceSize = genericTypeDef->instance_size;

            klass->instance_size = static_cast<uint32_t>(instanceSize);
        }

        return instanceSize;
    }

    static void LayoutFieldsLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (Class::IsGeneric(klass))
            return;

        size_t instanceSize = 0;
        size_t actualSize = 0;
        if (klass->parent)
        {
            IL2CPP_ASSERT(klass->parent->size_inited);
            klass->has_references |= klass->parent->has_references;
            instanceSize = klass->parent->instance_size;
            actualSize = klass->parent->actualSize;
            if (klass->byval_arg.valuetype)
                klass->minimumAlignment = 1;
            else
                klass->minimumAlignment = klass->parent->minimumAlignment;
        }
        else
        {
            actualSize = instanceSize = sizeof(Il2CppObject);
            klass->minimumAlignment = sizeof(Il2CppObject*);
        }

        if (klass->field_count)
        {
            for (uint16_t i = 0; i < klass->field_count; i++)
            {
                FieldInfo* field = klass->fields + i;
                if (!Field::IsInstance(field))
                    continue;

                const Il2CppType* ftype = Type::GetUnderlyingType(field->type);
                if (Type::IsReference(ftype) || (Type::IsStruct(ftype) && Class::HasReferences(Class::FromIl2CppType(ftype))))
                    klass->has_references = true;
            }

            il2cpp::metadata::FieldLayout::FieldLayoutData layoutData;
            il2cpp::metadata::FieldLayout::FieldLayoutData staticLayoutData;
            il2cpp::metadata::FieldLayout::FieldLayoutData threadStaticLayoutData;

            // If a type has references, ignore any packing
            // All reference types must be aligned on a pointer sized boundary
            // And if it has references, it not blittable, and we can layout the type anyway we want
            uint8_t packingSize = klass->packingSize;
            if (klass->has_references)
                packingSize = 0;

            il2cpp::metadata::FieldLayout::LayoutInstanceFields(klass, instanceSize, actualSize, klass->minimumAlignment, packingSize, layoutData);

            instanceSize = layoutData.classSize;

            // This is a value type with no instance fields, but at least one static field.
            if (klass->byval_arg.valuetype && layoutData.FieldOffsets.size() == 0)
            {
                instanceSize = IL2CPP_SIZEOF_STRUCT_WITH_NO_INSTANCE_FIELDS + sizeof(Il2CppObject);
                klass->actualSize = IL2CPP_SIZEOF_STRUCT_WITH_NO_INSTANCE_FIELDS + sizeof(Il2CppObject);
            }

            instanceSize = UpdateInstanceSizeForGenericClass(klass, instanceSize);

            klass->size_inited = true;

            il2cpp::metadata::FieldLayout::LayoutStaticFields(klass, staticLayoutData);
            il2cpp::metadata::FieldLayout::LayoutThreadStaticFields(klass, threadStaticLayoutData);

            klass->minimumAlignment = layoutData.minimumAlignment;
            if (klass->generic_class != NULL || MetadataCache::StructLayoutSizeIsDefault(klass->typeMetadataHandle))
                klass->actualSize = static_cast<uint32_t>(layoutData.actualClassSize);
            else
                klass->actualSize = klass->instance_size;

            if (klass->image == il2cpp_defaults.corlib && !strcmp("Ephemeron", klass->name))
            {
                klass->has_references = false;
            }

            size_t staticSize = staticLayoutData.classSize;
            size_t threadStaticSize = threadStaticLayoutData.classSize;

            if (klass->generic_class)
            {
                SetupFieldOffsetsLocked(FIELD_LAYOUT_INSTANCE, klass, instanceSize, layoutData.FieldOffsets, lock);
                SetupFieldOffsetsLocked(FIELD_LAYOUT_STATIC, klass, staticSize, staticLayoutData.FieldOffsets, lock);
                SetupFieldOffsetsLocked(FIELD_LAYOUT_THREADSTATIC, klass, threadStaticSize, threadStaticLayoutData.FieldOffsets, lock);
            }
            else
            {
#if IL2CPP_ENABLE_VALIDATE_FIELD_LAYOUT
                ValidateFieldOffsets(FIELD_LAYOUT_INSTANCE, klass, instanceSize, layoutData.FieldOffsets);
                ValidateFieldOffsets(FIELD_LAYOUT_STATIC, klass, staticSize, staticLayoutData.FieldOffsets);
                ValidateFieldOffsets(FIELD_LAYOUT_THREADSTATIC, klass, threadStaticSize, threadStaticLayoutData.FieldOffsets);
#endif
            }
        }
        else
        {
            // need to set this in case there are no fields in a generic instance type
            instanceSize = UpdateInstanceSizeForGenericClass(klass, instanceSize);

            // Always set the actual size, as a derived class without fields could end up
            // with the wrong actual size (i.e. sizeof may be incorrect), if the last
            // field of the base class doesn't go to an alignment boundary and the compiler ABI
            // uses that extra space (as clang does).
            klass->actualSize = static_cast<uint32_t>(actualSize);
        }

        if (klass->static_fields_size)
        {
            klass->static_fields = il2cpp::gc::GarbageCollector::AllocateFixed(klass->static_fields_size, NULL);
            AddStaticFieldData(klass);
        }
        if (klass->thread_static_fields_size)
            klass->thread_static_fields_offset = il2cpp::vm::Thread::AllocThreadStaticData(klass->thread_static_fields_size);

        if (Class::IsValuetype(klass))
            klass->stack_slot_size = klass->instance_size - sizeof(Il2CppObject);
        else
            klass->stack_slot_size = sizeof(void*);
    }

    static void SetupFieldsFromDefinitionLocked(Il2CppClass* klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->field_count == 0)
        {
            klass->fields = NULL;
            return;
        }

        FieldInfo* fields = (FieldInfo*)MetadataCalloc(klass->field_count, sizeof(FieldInfo));
        FieldInfo* newField = fields;

        FieldIndex end = klass->field_count;
        for (FieldIndex fieldIndex = 0; fieldIndex < end; ++fieldIndex)
        {
            Il2CppMetadataFieldInfo fieldInfo = MetadataCache::GetFieldInfo(klass, fieldIndex);

            newField->type = fieldInfo.type;
            newField->name = fieldInfo.name;
            newField->parent = klass;
            newField->offset = MetadataCache::GetFieldOffsetFromIndexLocked(klass, fieldIndex, newField, lock);
            newField->token = fieldInfo.token;

            newField++;
        }

        klass->fields = fields;
    }

// passing lock to ensure we have acquired it. We can add asserts later
    void SetupFieldsLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->size_inited)
            return;

        klass->size_init_pending = true;

        if (klass->parent && !klass->parent->size_inited)
            SetupFieldsLocked(klass->parent, lock);

        if (klass->generic_class)
        {
            // for generic instance types, they just inflate the fields of their generic type definition
            // initialize the generic type's fields and delegate to the generic logic
            SetupFieldsLocked(GenericClass::GetTypeDefinition(klass->generic_class), lock);
            GenericClass::SetupFields(klass);
        }
        else
        {
            SetupFieldsFromDefinitionLocked(klass, lock);
        }

        if (!Class::IsGeneric(klass))
            LayoutFieldsLocked(klass, lock);

        // Set the init flags after a barrier so they are set after all data is written
        il2cpp::os::Atomic::FullMemoryBarrier();
        klass->size_init_pending = false;
        klass->size_inited = true;
    }

    void Class::SetupFields(Il2CppClass *klass)
    {
        if (!klass->size_inited)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            SetupFieldsLocked(klass, lock);
        }
    }

// passing lock to ensure we have acquired it. We can add asserts later
    void SetupMethodsLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if ((!klass->method_count && !klass->rank) || klass->methods)
            return;

        if (klass->generic_class)
        {
            Class::InitLocked(GenericClass::GetTypeDefinition(klass->generic_class), lock);
            GenericClass::SetupMethods(klass);
        }
        else if (klass->rank)
        {
            Class::InitLocked(klass->element_class, lock);
            SetupVTable(klass, lock);
        }
        else
        {
            if (klass->method_count == 0)
            {
                klass->methods = NULL;
                return;
            }

            klass->methods = (const MethodInfo**)MetadataCalloc(klass->method_count, sizeof(MethodInfo*));
            MethodInfo* methods = (MethodInfo*)MetadataCalloc(klass->method_count, sizeof(MethodInfo));
            MethodInfo* newMethod = methods;

            MethodIndex end = klass->method_count;

            for (MethodIndex index = 0; index < end; ++index)
            {
                Il2CppMetadataMethodInfo methodInfo = MetadataCache::GetMethodInfo(klass, index);

                newMethod->name = methodInfo.name;

                newMethod->methodPointer = MetadataCache::GetMethodPointer(klass->image, methodInfo.token);

                if (klass->byval_arg.valuetype)
                {
                    Il2CppMethodPointer adjustorThunk = MetadataCache::GetAdjustorThunk(klass->image, methodInfo.token);
                    if (adjustorThunk != NULL)
                        newMethod->virtualMethodPointer = adjustorThunk;
                }
                // We did not find an adjustor thunk, or maybe did not need to look for one. Let's get the real method pointer.
                if (newMethod->virtualMethodPointer == NULL)
                    newMethod->virtualMethodPointer = newMethod->methodPointer;

                newMethod->klass = klass;
                newMethod->return_type = methodInfo.return_type;

                newMethod->parameters_count = (uint8_t)methodInfo.parameterCount;

                const Il2CppType** parameters = (const Il2CppType**)MetadataCalloc(methodInfo.parameterCount, sizeof(Il2CppType*));
                for (uint16_t paramIndex = 0; paramIndex < methodInfo.parameterCount; ++paramIndex)
                {
                    Il2CppMetadataParameterInfo paramInfo = MetadataCache::GetParameterInfo(klass, methodInfo.handle, paramIndex);
                    parameters[paramIndex] = paramInfo.type;
                }
                newMethod->parameters = parameters;

                newMethod->flags = methodInfo.flags;
                newMethod->iflags = methodInfo.iflags;
                newMethod->slot = methodInfo.slot;
                newMethod->is_inflated = false;
                newMethod->token = methodInfo.token;
                newMethod->methodMetadataHandle = methodInfo.handle;
                newMethod->genericContainerHandle = MetadataCache::GetGenericContainerFromMethod(methodInfo.handle);
                if (newMethod->genericContainerHandle)
                    newMethod->is_generic = true;
                newMethod->has_full_generic_sharing_signature = false;
                newMethod->is_unmanaged_callers_only = methodInfo.isUnmangedCallersOnly;

                if (newMethod->virtualMethodPointer)
                {
                    newMethod->invoker_method = MetadataCache::GetMethodInvoker(klass->image, methodInfo.token);
                }
                else
                {
                    newMethod->invoker_method = Runtime::GetMissingMethodInvoker();
                    il2cpp::vm::Il2CppUnresolvedCallStubs stubs = MetadataCache::GetUnresovledCallStubs(newMethod);
                    newMethod->methodPointer = stubs.methodPointer;
                    newMethod->virtualMethodPointer = stubs.virtualMethodPointer;
                }


                klass->methods[index] = newMethod;

                newMethod++;
            }
        }
    }

    void Class::SetupMethods(Il2CppClass *klass)
    {
        if (klass->method_count || klass->rank)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            SetupMethodsLocked(klass, lock);
        }
    }

    void SetupNestedTypesLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->generic_class || klass->nestedTypes)
            return;

        if (klass->nested_type_count > 0)
        {
            klass->nestedTypes = (Il2CppClass**)MetadataCalloc(klass->nested_type_count, sizeof(Il2CppClass*));
            for (uint16_t i = 0; i < klass->nested_type_count; i++)
                klass->nestedTypes[i] = MetadataCache::GetNestedTypeFromOffset(klass, i);
        }
    }

    void Class::SetupNestedTypes(Il2CppClass *klass)
    {
        if (klass->generic_class || klass->nestedTypes)
            return;

        if (klass->nested_type_count)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            SetupNestedTypesLocked(klass, lock);
        }
    }

    static void SetupVTable(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->is_vtable_initialized)
            return;

        if (klass->generic_class)
        {
            Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(klass->generic_class);
            Il2CppGenericContext* context = &klass->generic_class->context;
            if (genericTypeDefinition->interface_offsets_count > 0 && klass->interfaceOffsets == NULL)
            {
                klass->interface_offsets_count = genericTypeDefinition->interface_offsets_count;
                klass->interfaceOffsets = (Il2CppRuntimeInterfaceOffsetPair*)MetadataCalloc(genericTypeDefinition->interface_offsets_count, sizeof(Il2CppRuntimeInterfaceOffsetPair));
                for (uint16_t i = 0; i < genericTypeDefinition->interface_offsets_count; i++)
                {
                    Il2CppInterfaceOffsetInfo interfaceOffset = MetadataCache::GetInterfaceOffsetInfo(genericTypeDefinition, i);
                    klass->interfaceOffsets[i].offset = interfaceOffset.offset;
                    klass->interfaceOffsets[i].interfaceType = Class::FromIl2CppType(il2cpp::metadata::GenericMetadata::InflateIfNeeded(interfaceOffset.interfaceType, context, false));
                }
            }

            if (genericTypeDefinition->vtable_count > 0)
            {
                klass->vtable_count = genericTypeDefinition->vtable_count;
                for (uint16_t i = 0; i < genericTypeDefinition->vtable_count; i++)
                {
                    const MethodInfo* method = MetadataCache::GetMethodInfoFromVTableSlot(genericTypeDefinition, i);

                    if (method && method->klass)
                    {
                        if (method && method->is_inflated)
                        {
                            const Il2CppGenericMethod* genericMethod = il2cpp::metadata::GenericMetadata::Inflate(method->genericMethod, context);
                            method = il2cpp::metadata::GenericMethod::GetMethod(genericMethod);
                        }
                        if (method && method->klass && Class::IsGeneric(method->klass))
                        {
                            method = il2cpp::metadata::GenericMethod::GetMethod(method, context->class_inst, NULL);
                        }
                    }

                    klass->vtable[i].method = method;
                    if (method != NULL)
                    {
                        // For default interface methods on generic interfaces we need to ensure that their rgctx's are initalized
                        if (method->klass != NULL && method->klass != klass && Method::IsDefaultInterfaceMethodOnGenericInstance(method))
                            Class::InitLocked(method->klass, lock);

                        if (method->virtualMethodPointer)
                            klass->vtable[i].methodPtr = method->virtualMethodPointer;
                        else if (method->is_inflated && !method->is_generic && !method->genericMethod->context.method_inst)
                            klass->vtable[i].methodPtr = MetadataCache::GetUnresovledCallStubs(method).virtualMethodPointer;
                        else
                            klass->vtable[i].methodPtr = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo()->methodPointer;
                    }
                    else
                    {
                        klass->vtable[i].method = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo();
                        klass->vtable[i].methodPtr = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo()->methodPointer;
                    }
                }
            }
        }
        else if (klass->rank)
        {
            Class::InitLocked(klass->element_class, lock);
            il2cpp::metadata::ArrayMetadata::SetupArrayVTable(klass, lock);
        }
        else
        {
            if (klass->interface_offsets_count > 0 && klass->interfaceOffsets == NULL)
            {
                klass->interfaceOffsets = (Il2CppRuntimeInterfaceOffsetPair*)MetadataCalloc(klass->interface_offsets_count, sizeof(Il2CppRuntimeInterfaceOffsetPair));
                for (uint16_t i = 0; i < klass->interface_offsets_count; i++)
                {
                    Il2CppInterfaceOffsetInfo interfaceOffset = MetadataCache::GetInterfaceOffsetInfo(klass, i);
                    klass->interfaceOffsets[i].offset = interfaceOffset.offset;
                    klass->interfaceOffsets[i].interfaceType = Class::FromIl2CppType(interfaceOffset.interfaceType);
                }
            }

            if (klass->vtable_count > 0)
            {
                for (uint16_t i = 0; i < klass->vtable_count; i++)
                {
                    const MethodInfo* method = MetadataCache::GetMethodInfoFromVTableSlot(klass, i);
                    klass->vtable[i].method = method;

                    if (method != NULL)
                    {
                        if (method->virtualMethodPointer)
                            klass->vtable[i].methodPtr = method->virtualMethodPointer;
                        else
                            klass->vtable[i].methodPtr = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo()->methodPointer;
                    }
                    else
                    {
                        klass->vtable[i].method = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo();
                        klass->vtable[i].methodPtr = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo()->methodPointer;
                    }
                }
            }
        }

        klass->is_vtable_initialized = 1;
    }

    static void SetupEventsLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->generic_class)
        {
            Class::InitLocked(GenericClass::GetTypeDefinition(klass->generic_class), lock);
            GenericClass::SetupEvents(klass);
        }
        else if (klass->rank > 0)
        {
            // do nothing, arrays have no events
            IL2CPP_ASSERT(klass->event_count == 0);
        }
        else if (klass->event_count != 0)
        {
            // we need methods initialized since we reference them via index below
            SetupMethodsLocked(klass, lock);

            EventInfo* events = (EventInfo*)MetadataCalloc(klass->event_count, sizeof(EventInfo));
            EventInfo* newEvent = events;

            EventIndex end = klass->event_count;

            for (EventIndex eventIndex = 0; eventIndex < end; ++eventIndex)
            {
                Il2CppMetadataEventInfo eventInfo = MetadataCache::GetEventInfo(klass, eventIndex);

                newEvent->eventType = eventInfo.type;
                newEvent->name = eventInfo.name;
                newEvent->parent = klass;
                newEvent->add = eventInfo.add;
                newEvent->remove = eventInfo.remove;
                newEvent->raise = eventInfo.raise;
                newEvent->token = eventInfo.token;

                newEvent++;
            }

            klass->events = events;
        }
    }

    void Class::SetupEvents(Il2CppClass *klass)
    {
        if (!klass->events && klass->event_count)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            SetupEventsLocked(klass, lock);
        }
    }

    static void SetupPropertiesLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->generic_class)
        {
            Class::InitLocked(GenericClass::GetTypeDefinition(klass->generic_class), lock);
            GenericClass::SetupProperties(klass);
        }
        else if (klass->property_count != 0)
        {
            // we need methods initialized since we reference them via index below
            SetupMethodsLocked(klass, lock);

            PropertyInfo* properties = (PropertyInfo*)MetadataCalloc(klass->property_count, sizeof(PropertyInfo));
            PropertyInfo* newProperty = properties;

            PropertyIndex end = klass->property_count;

            for (PropertyIndex propertyIndex = 0; propertyIndex < end; ++propertyIndex)
            {
                Il2CppMetadataPropertyInfo propertyInfo = MetadataCache::GetPropertyInfo(klass, propertyIndex);

                newProperty->name = propertyInfo.name;
                newProperty->parent = klass;
                newProperty->get = propertyInfo.get;
                newProperty->set = propertyInfo.set;
                newProperty->attrs = propertyInfo.attrs;
                newProperty->token = propertyInfo.token;

                newProperty++;
            }

            klass->properties = properties;
        }
    }

    void Class::SetupProperties(Il2CppClass *klass)
    {
        if (!klass->properties && klass->property_count)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            SetupPropertiesLocked(klass, lock);
        }
    }

    static void SetupTypeHierarchyLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->typeHierarchy != NULL)
            return;

        if (klass->parent && !klass->parent->typeHierarchy)
            SetupTypeHierarchyLocked(klass->parent, lock);
        if (klass->parent)
            klass->typeHierarchyDepth = klass->parent->typeHierarchyDepth + 1;
        else
            klass->typeHierarchyDepth = 1;

        klass->typeHierarchy = (Il2CppClass**)MetadataCalloc(klass->typeHierarchyDepth, sizeof(Il2CppClass*));

        if (klass->parent)
        {
            klass->typeHierarchy[klass->typeHierarchyDepth - 1] = klass;
            memcpy(klass->typeHierarchy, klass->parent->typeHierarchy, klass->parent->typeHierarchyDepth * sizeof(void*));
        }
        else
        {
            klass->typeHierarchy[0] = klass;
        }
    }

    void Class::SetupTypeHierarchy(Il2CppClass *klass)
    {
        if (klass->typeHierarchy == NULL)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            SetupTypeHierarchyLocked(klass, lock);
        }
    }

    void Class::SetupInterfaces(Il2CppClass *klass)
    {
        if (klass->implementedInterfaces == NULL)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            SetupInterfacesLocked(klass, lock);
        }
    }

    static void SetupBlittableForGenericInstanceType(Il2CppClass *klass)
    {
        for (int i = 0; i < klass->field_count; i++)
            if (Field::IsInstance(&klass->fields[i]) && !Class::FromIl2CppType(klass->fields[i].type)->is_blittable)
                return;

        klass->is_blittable = true;
    }

    bool Class::InitLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->initialized)
            return true;
        if (klass->init_pending)
            return true;
        if (klass->initializationExceptionGCHandle)
            return false;

        if (klass->generic_class && (klass->flags & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT))
        {
            std::string message;
            message += "Could not load type '";
            message += klass->namespaze;
            message += ":";
            message += klass->name;
            message += "' because generic types cannot have explicit layout.";
            Class::SetClassInitializationError(klass, il2cpp::vm::Exception::GetTypeLoadException(message.c_str()));
            return false;
        }

        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Class::Init, "Audit and compare to mono version");

        klass->init_pending = true;

        klass->genericRecursionDepth++;

        if (klass->generic_class)
        {
            Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(klass->generic_class);
            InitLocked(genericTypeDefinition, lock);
            klass->is_blittable = genericTypeDefinition->is_blittable;
        }

        if (klass->byval_arg.type == IL2CPP_TYPE_ARRAY || klass->byval_arg.type == IL2CPP_TYPE_SZARRAY)
        {
            Il2CppClass *element_class = klass->element_class;
            if (!element_class->initialized)
                InitLocked(element_class, lock);
        }

        SetupInterfacesLocked(klass, lock);

        if (klass->parent && !klass->parent->initialized)
            InitLocked(klass->parent, lock);

        SetupMethodsLocked(klass, lock);
        SetupTypeHierarchyLocked(klass, lock);
        SetupVTable(klass, lock);
        if (!klass->size_inited)
            SetupFieldsLocked(klass, lock);

        // If this is generic instance class and it's generic type definition is not blittable,
        // check each field to see if all fields are blittable, in which case the generic instance is blittable
        if (!klass->is_blittable && klass->generic_class)
            SetupBlittableForGenericInstanceType(klass);

        if (klass->initializationExceptionGCHandle)
        {
            klass->init_pending = false;
            return false;
        }

        SetupEventsLocked(klass, lock);
        SetupPropertiesLocked(klass, lock);
        SetupNestedTypesLocked(klass, lock);

        if (klass == il2cpp_defaults.object_class)
        {
            for (uint16_t slot = 0; slot < klass->vtable_count; slot++)
            {
                const MethodInfo* vmethod = klass->vtable[slot].method;
                if (!strcmp(vmethod->name, "GetHashCode"))
                    s_GetHashCodeSlot = slot;
                else if (!strcmp(vmethod->name, "Finalize"))
                    s_FinalizerSlot = slot;
            }
            IL2CPP_ASSERT(s_FinalizerSlot > 0);
            IL2CPP_ASSERT(s_GetHashCodeSlot > 0);
        }

        bool canBeInstantiated = !Class::IsGeneric(klass) && !il2cpp::metadata::GenericMetadata::ContainsGenericParameters(klass);

        if (canBeInstantiated)
        {
            SetupGCDescriptor(klass, lock);

            if (klass->generic_class)
            {
                // This should be kept last.  InflateRGCTXLocked may need initialized data from the class we are initializing
                if (klass->genericRecursionDepth < il2cpp::metadata::GenericMetadata::GetMaximumRuntimeGenericDepth() || il2cpp::vm::Runtime::IsLazyRGCTXInflationEnabled())
                    klass->rgctx_data = il2cpp::metadata::GenericMetadata::InflateRGCTXLocked(klass->image, klass->token, &klass->generic_class->context, lock);
            }
        }

        Class::PublishInitialized(klass);

        ++il2cpp_runtime_stats.initialized_class_count;

        return true;
    }

    bool Class::InitSizeAndFieldLayoutLocked(Il2CppClass* klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (klass->size_inited)
            return true;
        if (klass->size_init_pending)
            return true;
        if (klass->initializationExceptionGCHandle)
            return false;

        if (!Class::IsGeneric(klass))
            SetupFieldsLocked(klass, lock);

        return true;
    }

    void Class::Init(Il2CppClass *klass)
    {
        IL2CPP_ASSERT(klass);

        if (!klass->initialized)
        {
            il2cpp::os::FastAutoLock lock(&g_MetadataLock);
            IL2CPP_ASSERT(!klass->init_pending);
            InitLocked(klass, lock);
        }
    }

    void Class::SetClassInitializationError(Il2CppClass *klass, Il2CppException* error)
    {
        klass->initializationExceptionGCHandle = gc::GCHandle::New(error, false);
        PublishInitialized(klass);
    }

    void Class::PublishInitialized(Il2CppClass *klass)
    {
        // Update the initialized flags last, so that other threads can't see the class as initialized
        // until after everything else is set up.
        il2cpp::os::Atomic::FullMemoryBarrier();

        klass->initialized = true;
        klass->initialized_and_no_error = !klass->initializationExceptionGCHandle;
        klass->init_pending = false;
    }

    Il2CppClass* Class::FromName(const Il2CppImage* image, const char* namespaze, const char *name)
    {
        return Image::ClassFromName(image, namespaze, name);
    }

    Il2CppClass* Class::GetArrayClass(Il2CppClass *element_class, uint32_t rank)
    {
        return GetBoundedArrayClass(element_class, rank, false);
    }

    Il2CppClass* Class::GetBoundedArrayClass(Il2CppClass *eclass, uint32_t rank, bool bounded)
    {
        return il2cpp::metadata::ArrayMetadata::GetBoundedArrayClass(eclass, rank, bounded);
    }

    Il2CppClass* Class::GetInflatedGenericInstanceClass(Il2CppClass* klass, const Il2CppType** types, uint32_t typeCount)
    {
        return GetInflatedGenericInstanceClass(klass, MetadataCache::GetGenericInst(types, typeCount));
    }

    Il2CppClass* Class::GetInflatedGenericInstanceClass(Il2CppClass* klass, const Il2CppGenericInst* genericInst)
    {
        IL2CPP_ASSERT(Class::IsGeneric(klass));

        Il2CppGenericClass* gclass = il2cpp::metadata::GenericMetadata::GetGenericClass(klass, genericInst);
        return GenericClass::GetClass(gclass);
    }

    Il2CppClass* Class::InflateGenericClass(Il2CppClass* klass, Il2CppGenericContext *context)
    {
        const Il2CppType* inflated = InflateGenericType(&klass->byval_arg, context);

        return FromIl2CppType(inflated);
    }

    const Il2CppType* Class::InflateGenericType(const Il2CppType* type, Il2CppGenericContext* context)
    {
        return il2cpp::metadata::GenericMetadata::InflateIfNeeded(type, context, true);
    }

    bool Class::HasDefaultConstructor(Il2CppClass* klass)
    {
        const char ctorName[] = ".ctor";
        void* iter = NULL;
        while (const MethodInfo* method = Class::GetMethods(klass, &iter))
        {
            if (strncmp(method->name, ctorName, utils::StringUtils::LiteralLength(ctorName)) == 0 && method->parameters_count == 0)
                return true;
        }

        return false;
    }

    int Class::GetArrayElementSize(const Il2CppClass *klass)
    {
        const Il2CppType *type = &klass->byval_arg;

    handle_enum:
        switch (type->type)
        {
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_BOOLEAN:
                return 1;

            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_CHAR:
                return 2;

            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_R4:
                return 4;

            case IL2CPP_TYPE_I:
            case IL2CPP_TYPE_U:
            case IL2CPP_TYPE_PTR:
            case IL2CPP_TYPE_CLASS:
            case IL2CPP_TYPE_STRING:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_SZARRAY:
            case IL2CPP_TYPE_ARRAY:
            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:
                return sizeof(Il2CppObject*);

            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_R8:
                return 8;

            case IL2CPP_TYPE_VALUETYPE:
                if (Type::IsEnum(type))
                {
                    type = Class::GetEnumBaseType(Type::GetClass(type));
                    klass = klass->element_class;
                    goto handle_enum;
                }
                return Class::GetInstanceSize(klass) - sizeof(Il2CppObject);

            case IL2CPP_TYPE_GENERICINST:
                type = &GenericClass::GetTypeDefinition(type->data.generic_class)->byval_arg;
                goto handle_enum;

            case IL2CPP_TYPE_VOID:
                return 0;

            default:
                // g_error ("unknown type 0x%02x in mono_class_array_element_size", type->type);
                IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Class::GetArrayElementSize, "Should throw a nice error");
        }

        return -1;
    }

    const Il2CppType* Class::GetType(Il2CppClass *klass, const TypeNameParseInfo &info)
    {
        // Attempt to resolve a generic type definition.
        if (Class::IsGeneric(klass))
            klass = ResolveGenericInstanceType(klass, info, kTypeSearchFlagNone);

        bool bounded = false;

        std::vector<int32_t>::const_iterator it = info.modifiers().begin();

        if (info.is_bounded())
        {
            bounded = false;
        }

        while (it != info.modifiers().end())
        {
            if (*it == 0)
            {
                // byref is always the last modifier, so we can return here.
                return &klass->this_arg;
            }

            if (*it == -1)
            {
                klass = Class::GetPtrClass(klass);
            }
            else if (*it == -2)
            {
                bounded = true;
            }
            else
            {
                klass = Class::GetBoundedArrayClass(klass, *it, bounded);
            }

            ++it;
        }

        if (klass == NULL)
            return NULL;

        return &klass->byval_arg;
    }

    bool Class::HasAttribute(Il2CppClass *klass, Il2CppClass *attr_class)
    {
        return Reflection::HasAttribute(klass, attr_class);
    }

    const Il2CppImage* Class::GetImage(Il2CppClass *klass)
    {
        return klass->image;
    }

    Il2CppMetadataGenericContainerHandle Class::GetGenericContainer(Il2CppClass *klass)
    {
        return klass->genericContainerHandle;
    }

    const MethodInfo* Class::GetCCtor(Il2CppClass *klass)
    {
        if (!klass->has_cctor)
            return NULL;

        return GetMethodFromNameFlags(klass, ".cctor", IgnoreNumberOfArguments, METHOD_ATTRIBUTE_SPECIAL_NAME);
    }

    const char* Class::GetFieldDefaultValue(const FieldInfo *field, const Il2CppType** type)
    {
        return reinterpret_cast<const char*>(MetadataCache::GetFieldDefaultValue(field, type));
    }

    int Class::GetFieldMarshaledSize(const FieldInfo *field)
    {
        int marshaledFieldSize = MetadataCache::GetFieldMarshaledSizeForField(field);
        if (marshaledFieldSize != -1)
            return marshaledFieldSize;

        if (field->type->type == IL2CPP_TYPE_BOOLEAN)
            return 4;
        if (field->type->type == IL2CPP_TYPE_CHAR)
            return 1;

        size_t size = il2cpp::metadata::FieldLayout::GetTypeSizeAndAlignment(field->type).size;
        IL2CPP_ASSERT(size < static_cast<size_t>(std::numeric_limits<int>::max()));
        return static_cast<int>(size);
    }

    int Class::GetFieldMarshaledAlignment(const FieldInfo *field)
    {
        if (MetadataCache::GetFieldMarshaledSizeForField(field) == 0)
        {
            // We have no marshaled field size, so ignore marshaled alignment for this field.
            return 0;
        }

        if (field->type->type == IL2CPP_TYPE_BOOLEAN)
            return 4;
        if (field->type->type == IL2CPP_TYPE_CHAR)
            return 1;

        uint8_t alignment = il2cpp::metadata::FieldLayout::GetTypeSizeAndAlignment(field->type).alignment;
        return static_cast<int>(alignment);
    }

    Il2CppClass* Class::GetPtrClass(const Il2CppType* type)
    {
        return GetPtrClass(Class::FromIl2CppType(type));
    }

    Il2CppClass* Class::GetPtrClass(Il2CppClass* elementClass)
    {
        // Check if the pointer class was created before taking the g_MetadataLock
        Il2CppClass* pointerClass = MetadataCache::GetPointerType(elementClass);
        if (pointerClass)
            return pointerClass;

        il2cpp::os::FastAutoLock lock(&g_MetadataLock);

        // Check if the pointer class was created while we were waiting for the g_MetadataLock
        pointerClass = MetadataCache::GetPointerType(elementClass);
        if (pointerClass)
            return pointerClass;

        pointerClass = (Il2CppClass*)MetadataCalloc(1, sizeof(Il2CppClass));
        pointerClass->klass = pointerClass;

        pointerClass->namespaze = elementClass->namespaze;
        pointerClass->name = il2cpp::utils::StringUtils::StringDuplicate(il2cpp::utils::StringUtils::Printf("%s*", elementClass->name).c_str());

        pointerClass->image = elementClass->image;
        pointerClass->flags = TYPE_ATTRIBUTE_CLASS | (elementClass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK);
        pointerClass->instance_size = sizeof(void*);
        pointerClass->stack_slot_size = sizeof(void*);
        pointerClass->size_inited = true;

        pointerClass->this_arg.type = pointerClass->byval_arg.type = IL2CPP_TYPE_PTR;
        pointerClass->this_arg.data.type = pointerClass->byval_arg.data.type = &elementClass->byval_arg;
        pointerClass->this_arg.byref = true;

        pointerClass->parent = NULL;
        pointerClass->typeHierarchyDepth = 1;
        pointerClass->castClass = pointerClass->element_class = elementClass;

        PublishInitialized(pointerClass);

        MetadataCache::AddPointerTypeLocked(elementClass, pointerClass, lock);

        return pointerClass;
    }

    bool Class::HasReferences(Il2CppClass *klass)
    {
        if (!klass->size_inited)
        {
            SetupFields(klass);

            if (!klass->size_inited)
            {
                abort();
                /* Be conservative */
                return true;
            }
        }

        return klass->has_references;
    }

    static void AddStaticFieldData(Il2CppClass* klass)
    {
        // The m_staticFieldData collect is used by liveness checking with the GC lock held
        // Use the GC lock to add to this array

        gc::GarbageCollector::CallWithAllocLockHeld([](void* klass) {
            s_ClassContext->m_staticFieldData.push_back((Il2CppClass*)klass);
            return (void*)nullptr;
        }, klass);

        il2cpp_runtime_stats.class_static_data_size += klass->static_fields_size;
    }

    const il2cpp::utils::dynamic_array<Il2CppClass*>& Class::GetStaticFieldData()
    {
        // Must be called with the GC lock held!
        return s_ClassContext->m_staticFieldData;
    }

    const size_t kWordSize = (8 * sizeof(size_t));

    static inline void set_bit(size_t* bitmap, size_t index)
    {
        bitmap[index / kWordSize] |= (size_t)1 << (index % kWordSize);
    }

    size_t Class::GetBitmapSize(const Il2CppClass* klass)
    {
        size_t maxBytes = klass->instance_size / kWordSize + 1;
        size_t maxWords = 1 + (maxBytes / sizeof(size_t));
        return sizeof(size_t) * maxWords;
    }

    void Class::GetBitmap(Il2CppClass* klass, size_t* bitmap, size_t& maxSetBit)
    {
        Class::Init(klass);
        return il2cpp::vm::GetBitmapNoInit(klass, bitmap, maxSetBit, 0, NULL);
    }

    const char *Class::GetAssemblyName(const Il2CppClass *klass)
    {
        return klass->image->name;
    }

    const char *Class::GetAssemblyNameNoExtension(const Il2CppClass *klass)
    {
        return klass->image->nameNoExt;
    }

    void GetBitmapNoInit(Il2CppClass* klass, size_t* bitmap, size_t& maxSetBit, size_t parentOffset, const il2cpp::os::FastAutoLock* lockPtr)
    {
        Il2CppClass* currentClass = klass;

        while (currentClass)
        {
            for (uint16_t index = 0; index < currentClass->field_count; index++)
            {
                FieldInfo* field = currentClass->fields + index;
                if (field->type->attrs & (FIELD_ATTRIBUTE_STATIC | FIELD_ATTRIBUTE_HAS_FIELD_RVA))
                    continue;

                IL2CPP_ASSERT(!field->type->byref);

                size_t offset = parentOffset + field->offset;

                const Il2CppType* type = Type::GetUnderlyingType(field->type);

                switch (type->type)
                {
                    case IL2CPP_TYPE_I1:
                    case IL2CPP_TYPE_U1:
                    case IL2CPP_TYPE_BOOLEAN:
                    case IL2CPP_TYPE_I2:
                    case IL2CPP_TYPE_U2:
                    case IL2CPP_TYPE_CHAR:
                    case IL2CPP_TYPE_I4:
                    case IL2CPP_TYPE_U4:
                    case IL2CPP_TYPE_I8:
                    case IL2CPP_TYPE_U8:
                    case IL2CPP_TYPE_I:
                    case IL2CPP_TYPE_U:
                    case IL2CPP_TYPE_R4:
                    case IL2CPP_TYPE_R8:
                    case IL2CPP_TYPE_PTR:
                    case IL2CPP_TYPE_FNPTR:
                        break;
                    case IL2CPP_TYPE_STRING:
                    case IL2CPP_TYPE_SZARRAY:
                    case IL2CPP_TYPE_CLASS:
                    case IL2CPP_TYPE_OBJECT:
                    case IL2CPP_TYPE_ARRAY:
                    case IL2CPP_TYPE_VAR:
                    case IL2CPP_TYPE_MVAR:
                        IL2CPP_ASSERT(0 == (offset % sizeof(void*)));
                        set_bit(bitmap, offset / sizeof(void*));
                        maxSetBit = std::max(maxSetBit, offset / sizeof(void*));
                        break;
                    case IL2CPP_TYPE_GENERICINST:
                        if (!Type::IsValueType(type))
                        {
                            IL2CPP_ASSERT(0 == (offset % sizeof(void*)));
                            set_bit(bitmap, offset / sizeof(void*));
                            maxSetBit = std::max(maxSetBit, offset / sizeof(void*));
                            break;
                        }
                        else
                        {
                            /* fall through */
                        }
                    case IL2CPP_TYPE_VALUETYPE:
                    {
                        Il2CppClass* fieldClass = Class::FromIl2CppType(field->type);
                        if (lockPtr == NULL)
                            Class::Init(fieldClass);
                        else
                            Class::InitLocked(fieldClass, *lockPtr);
                        if (fieldClass->has_references)
                            GetBitmapNoInit(fieldClass, bitmap, maxSetBit, offset - sizeof(Il2CppObject) /* nested field offset includes padding for boxed structure. Remove for struct fields */, lockPtr);
                        break;
                    }
                    default:
                        IL2CPP_NOT_IMPLEMENTED(Class::GetClassBitmap);
                        break;
                }
            }

            currentClass = currentClass->parent;
        }
    }

    void SetupGCDescriptor(Il2CppClass* klass, const il2cpp::os::FastAutoLock& lock)
    {
        if (!klass->has_references)
        {
            klass->gc_desc = il2cpp::gc::GarbageCollector::MakeEmptyDescriptor();
            return;
        }

        const size_t kMaxAllocaSize = 1024;
        size_t bitmapSize = Class::GetBitmapSize(klass);
        size_t* bitmap = NULL;
        std::vector<size_t> buffer(0);

        if (bitmapSize > kMaxAllocaSize)
        {
            buffer.resize(bitmapSize / sizeof(size_t));
            bitmap = (size_t*)&buffer[0];
        }
        else
        {
            bitmap = (size_t*)alloca(bitmapSize);
        }

        memset(bitmap, 0, bitmapSize);
        size_t maxSetBit = 0;
        GetBitmapNoInit(klass, bitmap, maxSetBit, 0, &lock);

        if (klass == il2cpp_defaults.string_class)
            klass->gc_desc = il2cpp::gc::GarbageCollector::MakeDescriptorForString();
        else if (klass->rank)
            klass->gc_desc = il2cpp::gc::GarbageCollector::MakeDescriptorForArray();
        else
            klass->gc_desc = il2cpp::gc::GarbageCollector::MakeDescriptorForObject(bitmap, (int)maxSetBit + 1);
    }

#define CHECK_IF_NULL(v)    \
    if ( (v) == NULL && (searchFlags & kTypeSearchFlagThrowOnError) != 0 ) \
        Exception::Raise (Exception::GetTypeLoadException (info)); \
    if ( (v) == NULL ) \
        return NULL;

    static Il2CppClass * resolve_generic_instance_internal(const il2cpp::vm::TypeNameParseInfo &info, Il2CppClass *generic_class, const Il2CppType** generic_arguments, TypeSearchFlags searchFlags)
    {
        Il2CppClass *klass = NULL;

        Il2CppMetadataGenericContainerHandle containerHandle = Class::GetGenericContainer(generic_class);
        uint32_t type_argc = MetadataCache::GetGenericContainerCount(containerHandle);
        if (type_argc != info.type_arguments().size())
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentException("name", "The number of generic arguments provided doesn't equal the arity of the generic type definition."));

        if (info.assembly_name().name.empty())
        {
            const Il2CppImage* image = Image::GetExecutingImage();
            klass = MetadataCache::GetGenericInstanceType(generic_class, generic_arguments, type_argc);

            if (klass == NULL && image != Image::GetCorlib())
            {
                // Try mscorlib
                image = (Il2CppImage*)Image::GetCorlib();
                klass = MetadataCache::GetGenericInstanceType(generic_class, generic_arguments, type_argc);
            }
        }
        else
        {
            const Il2CppAssembly *assembly = Assembly::Load(info.assembly_name().name.c_str());

            CHECK_IF_NULL(assembly);

            Il2CppImage *image = (Il2CppImage*)Assembly::GetImage(assembly);

            CHECK_IF_NULL(image);

            klass = MetadataCache::GetGenericInstanceType(generic_class, generic_arguments, type_argc);
        }

        return klass;
    }

    static Il2CppClass* ResolveGenericInstanceType(Il2CppClass* klass, const TypeNameParseInfo& info, TypeSearchFlags searchFlags)
    {
        if (info.has_generic_arguments())
        {
            const Il2CppType** generic_arguments = (const Il2CppType**)alloca(info.type_arguments().size() * sizeof(const Il2CppType*));

            int i = 0;
            std::vector<TypeNameParseInfo>::const_iterator it = info.type_arguments().begin();
            while (it != info.type_arguments().end())
            {
                const Il2CppType * generic_argument = Class::il2cpp_type_from_type_info(*it, searchFlags);

                CHECK_IF_NULL(generic_argument);

                generic_arguments[i] = generic_argument;

                ++it;
                ++i;
            }

            klass = resolve_generic_instance_internal(info, klass, generic_arguments, searchFlags);

            CHECK_IF_NULL(klass);
        }

        if (klass != NULL)
            Class::Init(klass);

        return klass;
    }

    static Il2CppClass* resolve_parse_info_internal(const TypeNameParseInfo& info, TypeSearchFlags searchFlags)
    {
        Il2CppClass *klass = NULL;

        if (info.assembly_name().name.empty())
        {
            const Il2CppImage* image;
            bool dontUseExecutingImage = searchFlags & kTypeSearchFlagDontUseExecutingImage;
            if (dontUseExecutingImage)
            {
                image = Image::GetCorlib();
            }
            else
            {
                image = Image::GetExecutingImage();
            }

            klass = Image::FromTypeNameParseInfo(image, info, searchFlags & kTypeSearchFlagIgnoreCase);

            // First, try mscorlib
            if (klass == NULL && image != Image::GetCorlib())
                klass = Image::FromTypeNameParseInfo(Image::GetCorlib(), info, searchFlags & kTypeSearchFlagIgnoreCase);

            // If we did not find it, now look in all loaded assemblies, except the ones we have tried already.
            if (klass == NULL && !dontUseExecutingImage)
            {
                for (auto assembly : *Assembly::GetAllAssemblies())
                {
                    auto currentImage = Assembly::GetImage(assembly);
                    if (currentImage != Image::GetCorlib() && currentImage != image)
                    {
                        klass = Image::FromTypeNameParseInfo(currentImage, info, searchFlags & kTypeSearchFlagIgnoreCase);
                        if (klass != NULL)
                            break;
                    }
                }
            }
        }
        else
        {
            const Il2CppAssembly *assembly = Assembly::Load(info.assembly_name().name.c_str());

            CHECK_IF_NULL(assembly);

            Il2CppImage *image = (Il2CppImage*)Assembly::GetImage(assembly);

            CHECK_IF_NULL(image);

            klass = Image::FromTypeNameParseInfo(image, info, searchFlags & kTypeSearchFlagIgnoreCase);
        }

        return klass;
    }

    const Il2CppType* Class::il2cpp_type_from_type_info(const TypeNameParseInfo& info, TypeSearchFlags searchFlags)
    {
        Il2CppClass *klass = resolve_parse_info_internal(info, searchFlags);

        CHECK_IF_NULL(klass);

        klass = ResolveGenericInstanceType(klass, info, searchFlags);

        CHECK_IF_NULL(klass);

        const Il2CppType *type = Class::GetType(klass, info);

        CHECK_IF_NULL(type);

        return type;
    }

    Il2CppClass* Class::GetDeclaringType(Il2CppClass* klass)
    {
        return klass->declaringType;
    }

    const MethodInfo* Class::GetVirtualMethod(Il2CppClass *klass, const MethodInfo *virtualMethod)
    {
        IL2CPP_ASSERT(klass->is_vtable_initialized);

        if ((virtualMethod->flags & METHOD_ATTRIBUTE_FINAL) || !(virtualMethod->flags & METHOD_ATTRIBUTE_VIRTUAL))
            return virtualMethod;

        Il2CppClass* methodDeclaringType = virtualMethod->klass;
        const MethodInfo* vtableSlotMethod;
        if (Class::IsInterface(methodDeclaringType))
        {
            const VirtualInvokeData* invokeData = ClassInlines::GetInterfaceInvokeDataFromVTable(klass, methodDeclaringType, virtualMethod->slot);
            if (invokeData == NULL)
                return NULL;
            vtableSlotMethod = invokeData->method;
        }
        else
        {
            IL2CPP_ASSERT(virtualMethod->slot < klass->vtable_count);
            vtableSlotMethod = klass->vtable[virtualMethod->slot].method;
        }

        if (Method::IsGenericInstanceMethod(virtualMethod))
            return il2cpp::metadata::GenericMethod::GetGenericVirtualMethod(vtableSlotMethod, virtualMethod);
        return vtableSlotMethod;
    }

    static bool is_generic_argument(Il2CppType* type)
    {
        return type->type == IL2CPP_TYPE_VAR || type->type == IL2CPP_TYPE_VAR;
    }

    Il2CppClass* Class::GenericParamGetBaseType(Il2CppClass* klass)
    {
        Il2CppType* type = &klass->byval_arg;
        IL2CPP_ASSERT(is_generic_argument(type));

        Il2CppMetadataGenericParameterHandle gparam = type->data.genericParameterHandle;

        Il2CppClass** constraints = GetOrCreateMonoGenericParameterInfo(gparam)->constraints;

        Il2CppClass* base_class = il2cpp_defaults.object_class;

        if (constraints)
        {
            for (int i = 0; constraints[i]; ++i)
            {
                Il2CppClass* constraint = constraints[i];

                if (IsInterface(constraint))
                    continue;

                Il2CppType* constraint_type = &constraint->byval_arg;
                if (is_generic_argument(constraint_type))
                {
                    Il2CppMetadataGenericParameterHandle constraint_param = constraint_type->data.genericParameterHandle;
                    Il2CppGenericParameterInfo constraint_info = MetadataCache::GetGenericParameterInfo(constraint_param);
                    if ((constraint_info.flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT) == 0 &&
                        (constraint_info.flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_NOT_NULLABLE_VALUE_TYPE_CONSTRAINT) == 0)
                        continue;
                }

                base_class = constraint;
            }
        }

        if (base_class == il2cpp_defaults.object_class)
        {
            Il2CppGenericParameterInfo gparamInfo = MetadataCache::GetGenericParameterInfo(gparam);
            if ((gparamInfo.flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_NOT_NULLABLE_VALUE_TYPE_CONSTRAINT) != 0)
                base_class = il2cpp_defaults.value_type_class;
        }

        return base_class;
    }

    MonoGenericParameterInfo* Class::GetOrCreateMonoGenericParameterInfo(Il2CppMetadataGenericParameterHandle parameterHandle)
    {
        Il2CppGenericParameterInfo paramInfo = il2cpp::vm::MetadataCache::GetGenericParameterInfo(parameterHandle);

        MonoGenericParameterInfo *monoParam = (MonoGenericParameterInfo*)il2cpp::vm::Reflection::GetMonoGenericParameterInfo(parameterHandle);
        if (monoParam == NULL)
        {
            monoParam = (MonoGenericParameterInfo*)IL2CPP_MALLOC(sizeof(MonoGenericParameterInfo));
            monoParam->flags = paramInfo.flags;
            monoParam->token = paramInfo.num;
            monoParam->name = paramInfo.name;
            monoParam->pklass = NULL;
            if (paramInfo.containerHandle)
                monoParam->pklass = il2cpp::vm::MetadataCache::GetContainerDeclaringType(paramInfo.containerHandle);

            int16_t constraintsCount = il2cpp::vm::MetadataCache::GetGenericConstraintCount(parameterHandle);
            monoParam->constraints = (Il2CppClass**)IL2CPP_MALLOC(sizeof(Il2CppClass*) * (constraintsCount + 1));
            for (int i = 0; i < constraintsCount; ++i)
            {
                const Il2CppType *constraintType = il2cpp::vm::MetadataCache::GetGenericParameterConstraintFromIndex(parameterHandle, i);
                monoParam->constraints[i] = il2cpp::vm::Class::FromIl2CppType(constraintType);
            }

            monoParam->constraints[constraintsCount] = NULL;

            il2cpp::vm::Reflection::SetMonoGenericParameterInfo(parameterHandle, monoParam);
        }

        return monoParam;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Class.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ClassInlines.cpp---------------
.
.
#include "ClassInlines.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/Method.h"
#include "vm/RCW.h"
#include "gc/GCHandle.h"
#include "metadata/GenericMethod.h"

namespace il2cpp
{
namespace vm
{
    Il2CppClass* ClassInlines::InitFromCodegenSlow(Il2CppClass *klass)
    {
        IL2CPP_ASSERT(klass != il2cpp_defaults.il2cpp_fully_shared_type);

        Class::Init(klass);

        if (klass->initializationExceptionGCHandle)
            il2cpp::vm::Exception::Raise((Il2CppException*)gc::GCHandle::GetTarget(klass->initializationExceptionGCHandle));

        return klass;
    }

    Il2CppClass* ClassInlines::InitFromCodegenSlow(Il2CppClass *klass, bool throwOnError)
    {
        IL2CPP_ASSERT(klass != il2cpp_defaults.il2cpp_fully_shared_type);

        if (throwOnError)
            return InitFromCodegenSlow(klass);

        Class::Init(klass);

        if (klass->initializationExceptionGCHandle)
            return NULL;

        return klass;
    }

    const MethodInfo* ClassInlines::InitRgctxFromCodegenSlow(const MethodInfo* method)
    {
        il2cpp::metadata::GenericMethod::InflateRGCTX(method);
        return method;
    }

    NORETURN static void RaiseExceptionForNotFoundInterface(const Il2CppClass* klass, const Il2CppClass* itf, Il2CppMethodSlot slot)
    {
        std::string message;
        message = "Attempt to access method '" + Type::GetName(&itf->byval_arg, IL2CPP_TYPE_NAME_FORMAT_IL) + "." + Method::GetName(itf->methods[slot])
            + "' on type '" + Type::GetName(&klass->byval_arg, IL2CPP_TYPE_NAME_FORMAT_IL) + "' failed.";
        Exception::Raise(il2cpp::vm::Exception::GetMethodAccessException(message.c_str()));
    }

    const VirtualInvokeData* ClassInlines::GetInterfaceInvokeDataFromVTableSlowPath(const Il2CppClass* klass, const Il2CppClass* itf, Il2CppMethodSlot slot)
    {
        if (itf->generic_class != NULL)
        {
            for (uint16_t i = 0; i < klass->interface_offsets_count; ++i)
            {
                const Il2CppRuntimeInterfaceOffsetPair* pair = klass->interfaceOffsets + i;
                if (Class::IsGenericClassAssignableFromVariance(itf, pair->interfaceType, klass))
                {
                    IL2CPP_ASSERT(pair->offset + slot < klass->vtable_count);
                    return &klass->vtable[pair->offset + slot];
                }
            }
        }

        return NULL;
    }

    const VirtualInvokeData& ClassInlines::GetInterfaceInvokeDataFromVTableSlowPath(Il2CppObject* obj, const Il2CppClass* itf, Il2CppMethodSlot slot)
    {
        const Il2CppClass* klass = obj->klass;
        const VirtualInvokeData* data;

        data = GetInterfaceInvokeDataFromVTableSlowPath(klass, itf, slot);
        if (data)
            return *data;

        if (klass->is_import_or_windows_runtime)
        {
            Il2CppComObject* rcw = static_cast<Il2CppComObject*>(obj);

            // It might be null if it's called on a dead (already released) or fake object
            if (rcw->identity != NULL)
            {
                const VirtualInvokeData* invokeData = RCW::GetComInterfaceInvokeData(rcw, itf, slot);
                if (invokeData != NULL)
                {
                    // Nothing will be referencing these types directly, so we need to initialize them here
                    Class::Init(invokeData->method->klass);
                    return *invokeData;
                }
            }
        }

        RaiseExceptionForNotFoundInterface(klass, itf, slot);
        IL2CPP_UNREACHABLE;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ClassInlines.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ClassLibraryPAL.cpp---------------
.
.
#include "vm/Class.h"
#include "vm/ClassLibraryPAL.h"
#include "os/ClassLibraryPAL/pal_mirror_structs.h"

#if IL2CPP_DEBUG && !RUNTIME_NONE
#define IL2CPP_ENABLE_PAL_MIRROR_CHECK 1
#else
#define IL2CPP_ENABLE_PAL_MIRROR_CHECK 0
#endif

namespace il2cpp
{
namespace vm
{
#if IL2CPP_ENABLE_PAL_MIRROR_CHECK

    static Il2CppClass* GetSysKlass()
    {
        static Il2CppClass* sysKlass = NULL;
        if (!sysKlass)
        {
            Il2CppClass *interop = Class::FromName(il2cpp_defaults.corlib, "", "Interop");
            if (interop == NULL)
                return NULL;

            void* iter = NULL;
            while (auto nestedType = Class::GetNestedTypes(interop, &iter))
            {
                if (strcmp(nestedType->name, "Sys") == 0)
                {
                    sysKlass = nestedType;
                    break;
                }
            }
        }

        return sysKlass;
    }

    template<typename MirrorStructType>
    static void CheckStructSizeForInteropSys(const char* nameInClassLibrary)
    {
        do
        {
            Il2CppClass* sysClass = GetSysKlass();
            if (sysClass == NULL)
                return;

            void* iter = NULL;
            while (Il2CppClass* nestedType = Class::GetNestedTypes(sysClass, &iter))
            {
                if (!strcmp(nestedType->name, nameInClassLibrary))
                {
                    IL2CPP_ASSERT(nestedType->native_size == sizeof(MirrorStructType));
                    return;
                }
            }
            IL2CPP_ASSERT(0 && "Item not found");
        }
        while (0);
    }

#endif

    void ClassLibraryPAL::Initialize()
    {
#if IL2CPP_ENABLE_PAL_MIRROR_CHECK
        CheckStructSizeForInteropSys<struct FileStatus>("FileStatus");
#endif
    }
} // namespace vm
} // namepsace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ClassLibraryPAL.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\COM.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "vm/Array.h"
#include "vm/COM.h"
#include "vm/Exception.h"
#include "vm/PlatformInvoke.h"
#include "vm/Reflection.h"
#include "os/COM.h"

namespace il2cpp
{
namespace vm
{
    void COM::MarshalVariant(Il2CppObject* obj, Il2CppVariant* variant)
    {
        IL2CPP_ASSERT(variant);
        os::COM::VariantInit(variant);

        if (!obj)
            return;

        if (obj->klass == il2cpp_defaults.sbyte_class)
        {
            variant->n1.n2.type = IL2CPP_VT_I1;
            variant->n1.n2.n3.cVal = *static_cast<int8_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.byte_class)
        {
            variant->n1.n2.type = IL2CPP_VT_UI1;
            variant->n1.n2.n3.bVal = *static_cast<uint8_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.int16_class)
        {
            variant->n1.n2.type = IL2CPP_VT_I2;
            variant->n1.n2.n3.iVal = *static_cast<int16_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.uint16_class)
        {
            variant->n1.n2.type = IL2CPP_VT_UI2;
            variant->n1.n2.n3.uiVal = *static_cast<uint16_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.int32_class)
        {
            variant->n1.n2.type = IL2CPP_VT_I4;
            variant->n1.n2.n3.lVal = *static_cast<int32_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.uint32_class)
        {
            variant->n1.n2.type = IL2CPP_VT_UI4;
            variant->n1.n2.n3.ulVal = *static_cast<uint32_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.int64_class)
        {
            variant->n1.n2.type = IL2CPP_VT_I8;
            variant->n1.n2.n3.llVal = *static_cast<int64_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.uint64_class)
        {
            variant->n1.n2.type = IL2CPP_VT_UI8;
            variant->n1.n2.n3.ullVal = *static_cast<uint64_t*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.single_class)
        {
            variant->n1.n2.type = IL2CPP_VT_R4;
            variant->n1.n2.n3.fltVal = *static_cast<float*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.double_class)
        {
            variant->n1.n2.type = IL2CPP_VT_R8;
            variant->n1.n2.n3.dblVal = *static_cast<double*>(Object::Unbox(obj));
        }
        else if (obj->klass == il2cpp_defaults.boolean_class)
        {
            variant->n1.n2.type = IL2CPP_VT_BOOL;
            variant->n1.n2.n3.boolVal = *static_cast<bool*>(Object::Unbox(obj)) ? IL2CPP_VARIANT_TRUE : IL2CPP_VARIANT_FALSE;
        }
        else if (obj->klass == il2cpp_defaults.string_class)
        {
            variant->n1.n2.type = IL2CPP_VT_BSTR;
            variant->n1.n2.n3.bstrVal = PlatformInvoke::MarshalCSharpStringToCppBString(reinterpret_cast<Il2CppString*>(obj));
        }
        else if (obj->klass == il2cpp_defaults.dbnull_class)
        {
            variant->n1.n2.type = IL2CPP_VT_NULL;
        }
        else if (obj->klass == il2cpp_defaults.error_wrapper_class)
        {
            variant->n1.n2.type = IL2CPP_VT_ERROR;
            variant->n1.n2.n3.scode = reinterpret_cast<Il2CppErrorWrapper*>(obj)->errorCode;
        }
        else if (obj->klass == il2cpp_defaults.missing_class)
        {
            variant->n1.n2.type = IL2CPP_VT_ERROR;
            variant->n1.n2.n3.scode = IL2CPP_DISP_E_PARAMNOTFOUND;
        }
        else
        {
            Exception::Raise(IL2CPP_E_INVALIDARG, true);
        }
    }

    Il2CppObject* COM::MarshalVariantResult(const Il2CppVariant* variant)
    {
        IL2CPP_ASSERT(variant);
        switch (variant->n1.n2.type)
        {
            case IL2CPP_VT_EMPTY:
                return NULL;
            case IL2CPP_VT_NULL:
                return Reflection::GetDBNullObject();
            case IL2CPP_VT_ERROR:
            {
                int32_t val = variant->n1.n2.n3.scode;
                return Object::Box(il2cpp_defaults.int32_class, &val);
            }
            case IL2CPP_VT_I1:
            {
                char val = variant->n1.n2.n3.cVal;
                return Object::Box(il2cpp_defaults.sbyte_class, &val);
            }
            case IL2CPP_VT_UI1:
            {
                uint8_t val = variant->n1.n2.n3.bVal;
                return Object::Box(il2cpp_defaults.byte_class, &val);
            }
            case IL2CPP_VT_I2:
            {
                int16_t val = variant->n1.n2.n3.iVal;
                return Object::Box(il2cpp_defaults.int16_class, &val);
            }
            case IL2CPP_VT_UI2:
            {
                uint16_t val = variant->n1.n2.n3.uiVal;
                return Object::Box(il2cpp_defaults.uint16_class, &val);
            }
            case IL2CPP_VT_I4:
            {
                int32_t val = variant->n1.n2.n3.lVal;
                return Object::Box(il2cpp_defaults.int32_class, &val);
            }
            case IL2CPP_VT_UI4:
            {
                uint32_t val = variant->n1.n2.n3.ulVal;
                return Object::Box(il2cpp_defaults.uint32_class, &val);
            }
            case IL2CPP_VT_I8:
            {
                int64_t val = variant->n1.n2.n3.llVal;
                return Object::Box(il2cpp_defaults.int64_class, &val);
            }
            case IL2CPP_VT_UI8:
            {
                uint64_t val = variant->n1.n2.n3.ullVal;
                return Object::Box(il2cpp_defaults.uint64_class, &val);
            }
            case IL2CPP_VT_R4:
            {
                float val = variant->n1.n2.n3.fltVal;
                return Object::Box(il2cpp_defaults.single_class, &val);
            }
            case IL2CPP_VT_R8:
            {
                double val = variant->n1.n2.n3.dblVal;
                return Object::Box(il2cpp_defaults.double_class, &val);
            }
            case IL2CPP_VT_BOOL:
            {
                IL2CPP_ASSERT(variant->n1.n2.n3.boolVal == IL2CPP_VARIANT_FALSE || variant->n1.n2.n3.boolVal == IL2CPP_VARIANT_TRUE);
                bool value = variant->n1.n2.n3.boolVal != IL2CPP_VARIANT_FALSE;
                return Object::Box(il2cpp_defaults.boolean_class, &value);
            }
            case IL2CPP_VT_BSTR:
                return reinterpret_cast<Il2CppObject*>(PlatformInvoke::MarshalCppBStringToCSharpStringResult(variant->n1.n2.n3.bstrVal));
            default:
                Exception::Raise(IL2CPP_E_INVALIDARG, true);
                return NULL;
        }
    }

    void COM::DestroyVariant(Il2CppVariant* variant)
    {
        const il2cpp_hresult_t hr = os::COM::VariantClear(variant);
        vm::Exception::RaiseIfFailed(hr, true);
    }

    Il2CppSafeArray* COM::MarshalSafeArray(uint16_t variantType, Il2CppArray* managedArray)
    {
        if (!managedArray)
            return NULL;

        Il2CppSafeArrayBound bounds[1];
        bounds[0].element_count = Array::GetLength(managedArray);
        bounds[0].lower_bound = 0;
        Il2CppSafeArray* safeArray = os::COM::SafeArrayCreate(variantType, 1, bounds);
        if (!safeArray)
            Exception::Raise(IL2CPP_E_OUTOFMEMORY, true);

        void* data;
        il2cpp_hresult_t hr = os::COM::SafeArrayAccessData(safeArray, &data);
        if (IL2CPP_HR_FAILED(hr))
        {
            os::COM::SafeArrayDestroy(safeArray);
            Exception::Raise(hr, true);
        }

        ::memcpy(data, Array::GetFirstElementAddress(managedArray), Array::GetByteLength(managedArray));

        hr = os::COM::SafeArrayUnaccessData(safeArray);
        if (IL2CPP_HR_FAILED(hr))
        {
            os::COM::SafeArrayDestroy(safeArray);
            Exception::Raise(hr, true);
        }

        return safeArray;
    }

    Il2CppArray* COM::MarshalSafeArrayResult(uint16_t variantType, Il2CppClass* type, Il2CppSafeArray* safeArray)
    {
        if (!safeArray)
            return NULL;

        uint16_t actualVariantType;
        il2cpp_hresult_t hr = os::COM::SafeArrayGetVartype(safeArray, &actualVariantType);
        vm::Exception::RaiseIfFailed(hr, true);
        if (actualVariantType != variantType)
            Exception::Raise(IL2CPP_E_INVALIDARG, true);

        const uint32_t actualDimentionCount = os::COM::SafeArrayGetDim(safeArray);
        if (actualDimentionCount != 1)
            Exception::Raise(IL2CPP_E_INVALIDARG, true);

        int32_t lowerBound;
        hr = os::COM::SafeArrayGetLBound(safeArray, 1, &lowerBound);
        vm::Exception::RaiseIfFailed(hr, true);

        int32_t upperBound;
        hr = os::COM::SafeArrayGetUBound(safeArray, 1, &upperBound);
        vm::Exception::RaiseIfFailed(hr, true);

        const il2cpp_array_size_t size = static_cast<il2cpp_array_size_t>(upperBound - lowerBound + 1);
        Il2CppArray* managedArray = Array::New(type, size);

        void* data;
        hr = os::COM::SafeArrayAccessData(safeArray, &data);
        vm::Exception::RaiseIfFailed(hr, true);

        ::memcpy(Array::GetFirstElementAddress(managedArray), data, Array::GetByteLength(managedArray));

        hr = os::COM::SafeArrayUnaccessData(safeArray);
        vm::Exception::RaiseIfFailed(hr, true);

        return managedArray;
    }

    Il2CppSafeArray* COM::MarshalSafeArrayBString(Il2CppArray* managedArray)
    {
        if (!managedArray)
            return NULL;

        const uint32_t size = Array::GetLength(managedArray);

        Il2CppSafeArrayBound bounds[1];
        bounds[0].element_count = size;
        bounds[0].lower_bound = 0;
        Il2CppSafeArray* safeArray = os::COM::SafeArrayCreate(IL2CPP_VT_BSTR, 1, bounds);
        if (!safeArray)
            Exception::Raise(IL2CPP_E_OUTOFMEMORY, true);

        Il2CppChar** data;
        il2cpp_hresult_t hr = os::COM::SafeArrayAccessData(safeArray, reinterpret_cast<void**>(&data));
        if (IL2CPP_HR_FAILED(hr))
        {
            os::COM::SafeArrayDestroy(safeArray);
            Exception::Raise(hr, true);
        }

        for (uint32_t i = 0; i < size; ++i)
        {
            Il2CppString* managedString = il2cpp_array_get(managedArray, Il2CppString*, i);
            hr = PlatformInvoke::MarshalCSharpStringToCppBStringNoThrow(managedString, data + i);
            if (IL2CPP_HR_FAILED(hr))
            {
                os::COM::SafeArrayUnaccessData(safeArray);
                os::COM::SafeArrayDestroy(safeArray);
                Exception::Raise(hr, true);
            }
        }

        hr = os::COM::SafeArrayUnaccessData(safeArray);
        if (IL2CPP_HR_FAILED(hr))
        {
            os::COM::SafeArrayDestroy(safeArray);
            Exception::Raise(hr, true);
        }

        return safeArray;
    }

    Il2CppArray* COM::MarshalSafeArrayBStringResult(Il2CppClass* type, Il2CppSafeArray* safeArray)
    {
        if (!safeArray)
            return NULL;

        uint16_t actualVariantType;
        il2cpp_hresult_t hr = os::COM::SafeArrayGetVartype(safeArray, &actualVariantType);
        vm::Exception::RaiseIfFailed(hr, true);
        if (actualVariantType != IL2CPP_VT_BSTR)
            Exception::Raise(IL2CPP_E_INVALIDARG, true);

        const uint32_t actualDimentionCount = os::COM::SafeArrayGetDim(safeArray);
        if (actualDimentionCount != 1)
            Exception::Raise(IL2CPP_E_INVALIDARG, true);

        int32_t lowerBound;
        hr = os::COM::SafeArrayGetLBound(safeArray, 1, &lowerBound);
        vm::Exception::RaiseIfFailed(hr, true);

        int32_t upperBound;
        hr = os::COM::SafeArrayGetUBound(safeArray, 1, &upperBound);
        vm::Exception::RaiseIfFailed(hr, true);

        const il2cpp_array_size_t size = static_cast<il2cpp_array_size_t>(upperBound - lowerBound + 1);
        Il2CppArray* managedArray = Array::New(il2cpp_defaults.string_class, size);

        Il2CppChar** data;
        hr = os::COM::SafeArrayAccessData(safeArray, reinterpret_cast<void**>(&data));
        vm::Exception::RaiseIfFailed(hr, true);

        for (il2cpp_array_size_t i = 0; i < size; ++i)
            il2cpp_array_setref(managedArray, i, PlatformInvoke::MarshalCppBStringToCSharpStringResult(data[i]));

        hr = os::COM::SafeArrayUnaccessData(safeArray);
        vm::Exception::RaiseIfFailed(hr, true);

        return managedArray;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\COM.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\COMEntryPoints.cpp---------------
.
.
#include "il2cpp-config.h"
#include "COMEntryPoints.h"

#include "il2cpp-windowsruntime-types.h"
#include "os/Mutex.h"
#include "os/WindowsRuntime.h"
#include "utils/StringUtils.h"
#include "vm/Exception.h"
#include "vm/MetadataCache.h"
#include "vm/Runtime.h"

#include <map>

struct HStringLess
{
    bool operator()(Il2CppHString left, Il2CppHString right) const
    {
        uint32_t lengthLeft = 0;
        uint32_t lengthRight = 0;

        auto charsLeft = il2cpp::os::WindowsRuntime::GetHStringBuffer(left, &lengthLeft);
        il2cpp::vm::Exception::RaiseIfError(charsLeft.GetError());
        auto charsRight = il2cpp::os::WindowsRuntime::GetHStringBuffer(right, &lengthRight);
        il2cpp::vm::Exception::RaiseIfError(charsRight.GetError());

        if (lengthLeft != lengthRight)
            return lengthLeft < lengthRight;

        return memcmp(charsLeft.Get(), charsRight.Get(), sizeof(Il2CppChar) * lengthLeft) < 0;
    }
};

struct ActivationFactoryWrapper
{
    ActivationFactoryWrapper(const std::pair<Il2CppIActivationFactory*, Il2CppHString>& factoryNamePair) :
        m_Factory(factoryNamePair.first),
        m_Name(factoryNamePair.second)
    {
        // NOTE: No add ref here since this constructor is only called with newly created factory
        // Also, name is already pre-duplicated since we cannot deal with hresult failure in a constructor
    }

    ActivationFactoryWrapper(const ActivationFactoryWrapper&); // = delete;
    ActivationFactoryWrapper& operator=(const ActivationFactoryWrapper&); // = delete;

    ~ActivationFactoryWrapper()
    {
        m_Factory->Release();

        il2cpp_hresult_t hr = il2cpp::os::WindowsRuntime::DeleteHString(m_Name);
        IL2CPP_ASSERT(IL2CPP_HR_SUCCEEDED(hr));
    }

    operator Il2CppIActivationFactory*() const
    {
        return m_Factory;
    }

private:
    Il2CppIActivationFactory* m_Factory;
    Il2CppHString m_Name;
};

typedef std::map<Il2CppHString, ActivationFactoryWrapper, HStringLess> FactoryCache;
static FactoryCache s_FactoryCache;
static baselib::ReentrantLock s_FactoryCacheMutex;
static bool s_InitializedIl2CppFromWindowsRuntime;

typedef Il2CppIActivationFactory* (*FactoryCreationFunction)();

// Returns:
//    IL2CPP_S_OK - on success
//    IL2CPP_E_INVALIDARG - if className or factory is null
//    IL2CPP_REGDB_E_CLASSNOTREG - if class was not found
extern "C" IL2CPP_EXPORT il2cpp_hresult_t STDCALL DllGetActivationFactory(Il2CppHString className, Il2CppIActivationFactory** factory)
{
    if (className == nullptr || factory == nullptr)
        return IL2CPP_E_INVALIDARG;

    il2cpp::os::FastAutoLock lock(&s_FactoryCacheMutex);

    if (!s_InitializedIl2CppFromWindowsRuntime)
    {
        if (!il2cpp::vm::Runtime::Init())
            return IL2CPP_COR_E_EXECUTIONENGINE;

        s_InitializedIl2CppFromWindowsRuntime = true;
    }

    FactoryCache::iterator it = s_FactoryCache.find(className);
    if (it != s_FactoryCache.end())
    {
        Il2CppIActivationFactory* cachedFactory = it->second;
        cachedFactory->AddRef();
        *factory = cachedFactory;
        return IL2CPP_S_OK;
    }

    uint32_t classNameLength;
    auto classNameUtf16 = il2cpp::os::WindowsRuntime::GetHStringBuffer(className, &classNameLength);
    il2cpp::vm::Exception::RaiseIfError(classNameUtf16.GetError());
    std::string classNameUtf8 = il2cpp::utils::StringUtils::Utf16ToUtf8(classNameUtf16.Get(), classNameLength);
    FactoryCreationFunction factoryCreationFunction = reinterpret_cast<FactoryCreationFunction>(il2cpp::vm::MetadataCache::GetWindowsRuntimeFactoryCreationFunction(classNameUtf8.c_str()));

    if (factoryCreationFunction == NULL)
        return IL2CPP_REGDB_E_CLASSNOTREG;

    Il2CppHString duplicatedClassName;
    il2cpp_hresult_t hr = il2cpp::os::WindowsRuntime::DuplicateHString(className, &duplicatedClassName);
    if (IL2CPP_HR_FAILED(hr))
        return hr;

    std::pair<FactoryCache::iterator, bool> insertionResult = s_FactoryCache.insert(std::make_pair(duplicatedClassName, std::make_pair(factoryCreationFunction(), duplicatedClassName)));
    IL2CPP_ASSERT(insertionResult.second && "Factory was already in the hash map!");

    Il2CppIActivationFactory* createdFactory = insertionResult.first->second;
    createdFactory->AddRef();
    *factory = createdFactory;
    return IL2CPP_S_OK;
}

extern "C" IL2CPP_EXPORT long STDCALL DllCanUnloadNow()
{
    if (!s_InitializedIl2CppFromWindowsRuntime)
        return IL2CPP_S_OK;

    // TO DO: we need to track all instantiated COM objects in order to implement this correctly
    return IL2CPP_S_FALSE;
}

void il2cpp::vm::COMEntryPoints::FreeCachedData()
{
    s_FactoryCache.clear();
}

// Prevent function name mangling on Windows/x86
// The reason this needs to live here and not os layer is because if this file is not compiled,
// those linker directives will cause unresolved external symbol errors
#if IL2CPP_TARGET_WINDOWS && defined(_M_IX86)
#pragma comment(linker, "/EXPORT:DllGetActivationFactory=_DllGetActivationFactory@8")
#pragma comment(linker, "/EXPORT:DllCanUnloadNow=_DllCanUnloadNow@0")
#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\COMEntryPoints.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ComObjectBase.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Atomic.h"
#include "vm/COM.h"
#include "vm/ComObjectBase.h"

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::GetIids(uint32_t* iidCount, Il2CppGuid** iids)
{
    *iidCount = 0;
    *iids = NULL;
    return IL2CPP_S_OK;
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::GetRuntimeClassName(Il2CppHString* className)
{
    return GetRuntimeClassNameImpl(className);
}

il2cpp_hresult_t il2cpp::vm::ComObjectBase::GetRuntimeClassNameImpl(Il2CppHString* className)
{
    *className = NULL;
    return IL2CPP_S_OK;
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::GetTrustLevel(int32_t* trustLevel)
{
    *trustLevel = 0;
    return IL2CPP_S_OK;
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::GetUnmarshalClass(const Il2CppGuid& iid, void* object, uint32_t context, void* reserved, uint32_t flags, Il2CppGuid* clsid)
{
    Il2CppIMarshal* freeThreadedMarshaler;
    il2cpp_hresult_t hr = GetFreeThreadedMarshalerNoAddRef(&freeThreadedMarshaler);
    if (IL2CPP_HR_FAILED(hr))
        return hr;

    return freeThreadedMarshaler->GetUnmarshalClass(iid, object, context, reserved, flags, clsid);
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::GetMarshalSizeMax(const Il2CppGuid& iid, void* object, uint32_t context, void* reserved, uint32_t flags, uint32_t* size)
{
    Il2CppIMarshal* freeThreadedMarshaler;
    il2cpp_hresult_t hr = GetFreeThreadedMarshalerNoAddRef(&freeThreadedMarshaler);
    if (IL2CPP_HR_FAILED(hr))
        return hr;

    return freeThreadedMarshaler->GetMarshalSizeMax(iid, object, context, reserved, flags, size);
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::MarshalInterface(Il2CppIStream* stream, const Il2CppGuid& iid, void* object, uint32_t context, void* reserved, uint32_t flags)
{
    Il2CppIMarshal* freeThreadedMarshaler;
    il2cpp_hresult_t hr = GetFreeThreadedMarshalerNoAddRef(&freeThreadedMarshaler);
    if (IL2CPP_HR_FAILED(hr))
        return hr;

    return freeThreadedMarshaler->MarshalInterface(stream, iid, object, context, reserved, flags);
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::UnmarshalInterface(Il2CppIStream* stream, const Il2CppGuid& iid, void** object)
{
    Il2CppIMarshal* freeThreadedMarshaler;
    il2cpp_hresult_t hr = GetFreeThreadedMarshalerNoAddRef(&freeThreadedMarshaler);
    if (IL2CPP_HR_FAILED(hr))
        return hr;

    return freeThreadedMarshaler->UnmarshalInterface(stream, iid, object);
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::ReleaseMarshalData(Il2CppIStream* stream)
{
    Il2CppIMarshal* freeThreadedMarshaler;
    il2cpp_hresult_t hr = GetFreeThreadedMarshalerNoAddRef(&freeThreadedMarshaler);
    if (IL2CPP_HR_FAILED(hr))
        return hr;

    return freeThreadedMarshaler->ReleaseMarshalData(stream);
}

il2cpp_hresult_t STDCALL il2cpp::vm::ComObjectBase::DisconnectObject(uint32_t reserved)
{
    Il2CppIMarshal* freeThreadedMarshaler;
    il2cpp_hresult_t hr = GetFreeThreadedMarshalerNoAddRef(&freeThreadedMarshaler);
    if (IL2CPP_HR_FAILED(hr))
        return hr;

    return freeThreadedMarshaler->DisconnectObject(reserved);
}

il2cpp_hresult_t il2cpp::vm::ComObjectBase::GetFreeThreadedMarshalerNoAddRef(Il2CppIMarshal** destination)
{
    Il2CppIMarshal* freeThreadedMarshaler = m_FreeThreadedMarshaler;
    if (freeThreadedMarshaler == NULL)
    {
        // We don't really want to aggregate FTM, as then we'd have to store its IUnknown too
        // So we pass NULL as the first parameter
        Il2CppIUnknown* freeThreadedMarshalerUnknown;
        il2cpp_hresult_t hr = COM::CreateFreeThreadedMarshaler(NULL, &freeThreadedMarshalerUnknown);
        if (IL2CPP_HR_FAILED(hr))
            return hr;

        hr = freeThreadedMarshalerUnknown->QueryInterface(Il2CppIMarshal::IID, reinterpret_cast<void**>(&freeThreadedMarshaler));
        freeThreadedMarshalerUnknown->Release();
        if (IL2CPP_HR_FAILED(hr))
            return hr;

        if (os::Atomic::CompareExchangePointer<Il2CppIMarshal>(&m_FreeThreadedMarshaler, freeThreadedMarshaler, NULL) != NULL)
        {
            freeThreadedMarshaler->Release();
            freeThreadedMarshaler = m_FreeThreadedMarshaler;
        }
    }

    *destination = freeThreadedMarshaler;
    return IL2CPP_S_OK;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ComObjectBase.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Domain.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "vm/Thread.h"
#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"

namespace il2cpp
{
namespace vm
{
    Il2CppDomain* Domain::S_domain = NULL;

    Il2CppDomain* Domain::GetCurrent()
    {
        if (S_domain)
            return S_domain;

        // allocate using gc memory since we hold onto object references
        S_domain = (Il2CppDomain*)il2cpp::gc::GarbageCollector::AllocateFixed(sizeof(Il2CppDomain), NULL);
        gc::WriteBarrier::GenericStore(&S_domain->ephemeron_tombstone, Object::New(il2cpp_defaults.object_class));

        return S_domain;
    }

    Il2CppDomain* Domain::GetRoot()
    {
        // just one domain for now
        return GetCurrent();
    }

    void Domain::ContextInit(Il2CppDomain *domain)
    {
        Il2CppClass* klass = Class::FromName(il2cpp_defaults.corlib, "System.Runtime.Remoting.Contexts", "Context");
        Il2CppAppContext* context = (Il2CppAppContext*)Object::New(klass);

        // To match Mono's implementation we do not call the constructor here. If we do, context_id will be 1, which
        // is not correct.
        context->domain_id = domain->domain_id;
        context->context_id = 0;

        gc::WriteBarrier::GenericStore(&domain->default_context, context);
    }

    void Domain::ContextSet(Il2CppAppContext* context)
    {
        IL2CPP_OBJECT_SETREF(il2cpp::vm::Thread::Current()->GetInternalThread(), current_appcontext, (Il2CppObject*)context);
    }

    Il2CppAppContext* Domain::ContextGet()
    {
        return (Il2CppAppContext*)il2cpp::vm::Thread::Current()->GetInternalThread()->current_appcontext;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Domain.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Enum.cpp---------------
.
.
#include "vm/Enum.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "gc/WriteBarrier.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Reflection.h"
#include "vm/GenericClass.h"
#include "vm/Field.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "utils/MemoryRead.h"

namespace il2cpp
{
namespace vm
{
    static uint64_t GetEnumFieldValue(Il2CppClass* enumType, FieldInfo* field)
    {
        const Il2CppType* type = NULL;
        const char* ptr = Class::GetFieldDefaultValue(field, &type);

        switch (Class::GetEnumBaseType(enumType)->type)
        {
            case IL2CPP_TYPE_I1: // Sign extend
                return static_cast<int64_t>(static_cast<int8_t>(*ptr));

            case IL2CPP_TYPE_U1:
                return (uint8_t)*ptr;

            case IL2CPP_TYPE_CHAR:
                return utils::ReadChar(ptr);

            case IL2CPP_TYPE_I2: // Sign extend
                return static_cast<int64_t>(static_cast<int16_t>(utils::Read16(ptr)));

            case IL2CPP_TYPE_U2:
                return utils::Read16(ptr);

            case IL2CPP_TYPE_I4: // Sign extend
                return static_cast<int64_t>(static_cast<int32_t>(utils::ReadCompressedInt32(&ptr)));

            case IL2CPP_TYPE_U4:
                return utils::ReadCompressedUInt32(&ptr);

            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U:
            case IL2CPP_TYPE_I:
                return utils::Read64(ptr);

            default:
                IL2CPP_ASSERT(0);
                return 0;
        }
    }

    bool Enum::GetEnumValuesAndNames(Il2CppClass* enumType, Il2CppArray** values, Il2CppArray** names)
    {
        size_t nvalues = Class::GetNumFields(enumType) ? Class::GetNumFields(enumType) - 1 : 0;
        bool sorted = true;

        gc::WriteBarrier::GenericStore(values, vm::Array::New(il2cpp_defaults.uint64_class, (il2cpp_array_size_t)nvalues));
        uint64_t field_value, previous_value = 0;
        gc::WriteBarrier::GenericStore(names, vm::Array::New(il2cpp_defaults.string_class, (il2cpp_array_size_t)nvalues));

        if (enumType->generic_class)
            enumType = GenericClass::GetTypeDefinition(enumType->generic_class);

        FieldInfo* field;
        void* iter = NULL;

        int j = 0;
        while ((field = Class::GetFields(enumType, &iter)))
        {
            if (strcmp("value__", field->name) == 0)
                continue;

            if (Field::IsDeleted(field))
                continue;

            il2cpp_array_setref(*names, j, il2cpp::vm::String::New(Field::GetName(field)));

            field_value = GetEnumFieldValue(enumType, field);
            il2cpp_array_set(*values, uint64_t, j, field_value);

            if (previous_value > field_value)
                sorted = false;

            previous_value = field_value;

            j++;
        }

        return sorted;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Enum.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Event.cpp---------------
.
.
#include "vm/Event.h"
#include "il2cpp-class-internals.h"

namespace il2cpp
{
namespace vm
{
    uint32_t Event::GetToken(const EventInfo *eventInfo)
    {
        return eventInfo->token;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Event.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Exception.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/WriteBarrier.h"
#include "os/MarshalStringAlloc.h"
#include "os/WindowsRuntime.h"
#include "metadata/GenericMetadata.h"
#include "vm/Array.h"
#include "vm/AssemblyName.h"
#include "vm/Class.h"
#include "vm/CCW.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/StackTrace.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "Image.h"
#include "../utils/StringUtils.h"
#include "../utils/StringViewUtils.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm-utils/Debugger.h"
#include "vm-utils/VmStringUtils.h"
#include "vm-utils/DebugSymbolReader.h"

namespace il2cpp
{
namespace vm
{
    void Exception::PrepareExceptionForThrow(Il2CppException* ex, MethodInfo* lastManagedFrame)
    {
#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::HandleException(ex);
#endif

        if (ex->trace_ips == NULL)
        {
            // Only write the stack trace if there is not one already in the exception.
            // When we exit managed try/finally and try/catch blocks with an exception, this method is
            // called with the original exception which already has the proper stack trace.
            // Getting the stack trace again here will lose the frames between the original throw
            // and the finally or catch block.
            const StackFrames& frames = *StackTrace::GetStackFrames();

            Il2CppArray* ips = NULL;
            Il2CppArray* raw_ips = NULL;
            size_t numberOfFrames = frames.size();
            if (numberOfFrames == 0 && lastManagedFrame != NULL)
            {
                // We didn't get any call stack. If we have one frame from codegen, use it.
                if (utils::DebugSymbolReader::DebugSymbolsAvailable())
                {
                    Il2CppStackFrame *stackFrame = (Il2CppStackFrame*)vm::Object::New(il2cpp_defaults.stack_frame_class);
                    IL2CPP_OBJECT_SETREF(stackFrame, method, vm::Reflection::GetMethodObject(lastManagedFrame, NULL));

                    ips = Array::New(il2cpp_defaults.stack_frame_class, 1);
                    il2cpp_array_setref(ips, 0, stackFrame);
                }
                else
                {
                    ips = Array::New(il2cpp_defaults.int_class, 1);
                    il2cpp_array_set(ips, const MethodInfo*, 0, lastManagedFrame);
                }
            }
            else
            {
                size_t i = numberOfFrames - 1;
                if (utils::DebugSymbolReader::DebugSymbolsAvailable())
                {
                    ips = Array::New(il2cpp_defaults.stack_frame_class, numberOfFrames);
                }
                else
                {
                    ips = Array::New(il2cpp_defaults.int_class, numberOfFrames);
                }

                raw_ips = Array::New(il2cpp_defaults.int_class, numberOfFrames);
                for (size_t frame = 0; frame != frames.size() && i >= 0; ++frame, --i)
                {
                    const Il2CppStackFrameInfo& stackFrameInfo = frames[frame];

                    if (utils::DebugSymbolReader::DebugSymbolsAvailable())
                    {
                        Il2CppStackFrame *stackFrame = (Il2CppStackFrame*)vm::Object::New(il2cpp_defaults.stack_frame_class);

                        IL2CPP_OBJECT_SETREF(stackFrame, method, vm::Reflection::GetMethodObject(stackFrameInfo.method, NULL));
                        stackFrame->line = stackFrameInfo.sourceCodeLineNumber;
                        stackFrame->il_offset = stackFrameInfo.ilOffset;
                        if (stackFrameInfo.filePath != NULL && strlen(stackFrameInfo.filePath) != 0)
                            IL2CPP_OBJECT_SETREF(stackFrame, filename, il2cpp::vm::String::New(stackFrameInfo.filePath));

                        il2cpp_array_setref(ips, i, stackFrame);
                    }
                    else
                    {
                        il2cpp_array_set(ips, const MethodInfo*, i, stackFrameInfo.method);
                    }
                    il2cpp_array_set(raw_ips, uintptr_t, i, stackFrameInfo.raw_ip);
                }
            }

            IL2CPP_ASSERT(ips != NULL);
            IL2CPP_OBJECT_SETREF(ex, trace_ips, ips);
            IL2CPP_OBJECT_SETREF(ex, native_trace_ips, raw_ips);
        }
    }

    NORETURN void Exception::Raise(Il2CppException* ex, MethodInfo* lastManagedFrame)
    {
        PrepareExceptionForThrow(ex, lastManagedFrame);
        throw Il2CppExceptionWrapper(ex);
    }

    NORETURN void Exception::Rethrow(Il2CppException* ex)
    {
        throw Il2CppExceptionWrapper(ex);
    }

    NORETURN void Exception::RaiseOutOfMemoryException()
    {
        RaiseOutOfMemoryException(utils::StringView<Il2CppChar>::Empty());
    }

    NORETURN void Exception::RaiseOutOfMemoryException(const utils::StringView<Il2CppChar>& msg)
    {
        Raise(GetOutOfMemoryException(msg));
    }

    NORETURN void Exception::RaiseNullReferenceException()
    {
        RaiseNullReferenceException(utils::StringView<Il2CppChar>::Empty());
    }

    NORETURN void Exception::RaiseNullReferenceException(const utils::StringView<Il2CppChar>& msg)
    {
        Raise(GetNullReferenceException(msg));
    }

    NORETURN void Exception::RaiseDivideByZeroException()
    {
        Raise(GetDivideByZeroException());
    }

    NORETURN void Exception::RaiseIndexOutOfRangeException()
    {
        Raise(GetIndexOutOfRangeException());
    }

    NORETURN void Exception::RaiseOverflowException()
    {
        Raise(GetOverflowException());
    }

    NORETURN void Exception::RaiseArgumentOutOfRangeException(const char* msg)
    {
        Raise(GetArgumentOutOfRangeException(msg));
    }

    static NORETURN void RaiseFromIl2CppError(const utils::Il2CppError& error)
    {
        utils::Il2CppErrorCode errorCode = error.GetErrorCode();
        if (errorCode == utils::NotSupported)
            Exception::Raise(Exception::GetNotSupportedException(error.GetErrorMessage().c_str()));
        if (errorCode == utils::ComError)
            Exception::Raise(error.GetHr(), false);
        if (errorCode == utils::UnauthorizedAccess)
            Exception::Raise(Exception::GetUnauthorizedAccessException(error.GetErrorMessage().c_str()));

        Exception::Raise(Exception::GetSystemException());
    }

    void Exception::RaiseIfError(const utils::Il2CppError& error)
    {
        if (error.GetErrorCode() != utils::NoError)
            RaiseFromIl2CppError(error);
    }

    inline static Il2CppException* TryGetExceptionFromRestrictedErrorInfo(Il2CppIRestrictedErrorInfo* errorInfo)
    {
        Il2CppILanguageExceptionErrorInfo* languageExceptionInfo;
        il2cpp_hresult_t hr = errorInfo->QueryInterface(Il2CppILanguageExceptionErrorInfo::IID, reinterpret_cast<void**>(&languageExceptionInfo));
        if (IL2CPP_HR_SUCCEEDED(hr))
        {
            Il2CppIUnknown* languageException;
            hr = languageExceptionInfo->GetLanguageException(&languageException);
            languageExceptionInfo->Release();

            if (IL2CPP_HR_SUCCEEDED(hr) && languageException != NULL) // It can succeed and return null exception if there's no exception info
            {
                Il2CppIManagedObjectHolder* managedObjectHolder;
                hr = languageException->QueryInterface(Il2CppIManagedObjectHolder::IID, reinterpret_cast<void**>(&managedObjectHolder));
                languageException->Release();

                if (IL2CPP_HR_SUCCEEDED(hr))
                {
                    Il2CppException* exception = reinterpret_cast<Il2CppException*>(managedObjectHolder->GetManagedObject());
                    managedObjectHolder->Release();

                    // TODO: set restricted error info instead of releaseing it here
                    errorInfo->Release();
                    return exception;
                }
            }
        }

        return NULL;
    }

    inline static UTF16String GetMessageFromRestrictedErrorInfo(Il2CppIRestrictedErrorInfo* errorInfo)
    {
        UTF16String result;
        il2cpp_hresult_t error;
        Il2CppChar* bstrDescription;
        Il2CppChar* bstrRestrictedDescription;
        Il2CppChar* bstrCapabilitySid;

        il2cpp_hresult_t hr = errorInfo->GetErrorDetails(&bstrDescription, &error, &bstrRestrictedDescription, &bstrCapabilitySid);
        if (IL2CPP_HR_SUCCEEDED(hr))
        {
            int descriptionLength = 0;
            int restrictedDescriptionLength = 0;

            if (bstrDescription != NULL)
                os::MarshalStringAlloc::GetBStringLength(bstrDescription, &descriptionLength);

            if (bstrRestrictedDescription != NULL)
                os::MarshalStringAlloc::GetBStringLength(bstrRestrictedDescription, &restrictedDescriptionLength);

            result.append(bstrDescription, descriptionLength);
            if (restrictedDescriptionLength > 0)
            {
                result.append(kIl2CppNewLine);
                result.append(bstrRestrictedDescription, restrictedDescriptionLength);
            }

            if (bstrDescription != NULL)
                os::MarshalStringAlloc::FreeBString(bstrDescription);

            if (bstrRestrictedDescription != NULL)
                os::MarshalStringAlloc::FreeBString(bstrRestrictedDescription);

            if (bstrCapabilitySid != NULL)
                os::MarshalStringAlloc::FreeBString(bstrCapabilitySid);
        }

        return result;
    }

// When doing COM interop, any unrecognized hresult gets turned into a COMException
// When doing Windows Runtime interop, any unrecognized hresult gets turned into a System.Exception
// Go figure.
    Il2CppException* Exception::Get(il2cpp_hresult_t hresult, bool defaultToCOMException)
    {
        UTF16String message;

        Il2CppIRestrictedErrorInfo* errorInfo = os::WindowsRuntime::GetRestrictedErrorInfo();
        if (errorInfo != NULL)
        {
            // First, try retrieving the original exception from restricted error info
            Il2CppException* exception = TryGetExceptionFromRestrictedErrorInfo(errorInfo);
            if (exception != NULL)
                return exception;

            // If we got here, restricted error info contained no existing managed exception
            message = GetMessageFromRestrictedErrorInfo(errorInfo);

            // To do: instead of releasing it here, store it on the exception that we're about to return
            errorInfo->Release();
        }

        switch (hresult)
        {
            case IL2CPP_E_NOTIMPL:
                return FromNameMsg(Image::GetCorlib(), "System", "NotImplementedException", STRING_TO_STRINGVIEW(message));

            case IL2CPP_E_NOINTERFACE:
                return GetInvalidCastException(STRING_TO_STRINGVIEW(message));

            case IL2CPP_E_POINTER:
                return GetNullReferenceException(STRING_TO_STRINGVIEW(message));

            case IL2CPP_COR_E_OPERATIONCANCELED:
                return FromNameMsg(Image::GetCorlib(), "System", "OperationCanceledException", STRING_TO_STRINGVIEW(message));

            case IL2CPP_E_ACCESS_DENIED:
                return GetUnauthorizedAccessException(STRING_TO_STRINGVIEW(message));

            case IL2CPP_E_OUTOFMEMORY:
                return GetOutOfMemoryException(STRING_TO_STRINGVIEW(message));

            case IL2CPP_E_INVALIDARG:
                return GetArgumentException(utils::StringView<Il2CppChar>::Empty(), STRING_TO_STRINGVIEW(message));

            case IL2CPP_COR_E_OBJECTDISPOSED:
            case IL2CPP_RO_E_CLOSED:
                return FromNameMsg(Image::GetCorlib(), "System", "ObjectDisposedException", STRING_TO_STRINGVIEW(message), hresult);

            case IL2CPP_E_FAIL:
            {
                if (message.empty())
                    message = utils::StringUtils::Utf8ToUtf16("Unspecified error");

                return FromNameMsg(Image::GetCorlib(), "System.Runtime.InteropServices", "COMException", STRING_TO_STRINGVIEW(message), hresult);
            }

            case IL2CPP_COR_E_PLATFORMNOTSUPPORTED:
            {
                if (message.empty())
                    message = utils::StringUtils::Utf8ToUtf16("Operation is not supported on this platform.");

                return GetPlatformNotSupportedException(STRING_TO_STRINGVIEW(message));
            }

            case IL2CPP_E_FILE_NOT_FOUND:
                return GetFileNotFoundException(STRING_TO_STRINGVIEW(message));

            default:
                return defaultToCOMException
                    ? Exception::FromNameMsg(vm::Image::GetCorlib(), "System.Runtime.InteropServices", "COMException", STRING_TO_STRINGVIEW(message), hresult)
                    : Exception::FromNameMsg(vm::Image::GetCorlib(), "System", "Exception", STRING_TO_STRINGVIEW(message), hresult);
        }
    }

    NORETURN void Exception::Raise(il2cpp_hresult_t hresult, bool defaultToCOMException)
    {
        Raise(Get(hresult, defaultToCOMException));
    }

    Il2CppException* Exception::FromNameMsg(const Il2CppImage* image, const char *name_space, const char *name, const char *msg)
    {
        UTF16String utf16Msg;

        if (msg != NULL)
            utf16Msg = utils::StringUtils::Utf8ToUtf16(msg);

        return FromNameMsg(image, name_space, name, STRING_TO_STRINGVIEW(utf16Msg));
    }

    Il2CppException* Exception::FromNameMsg(const Il2CppImage* image, const char* name_space, const char* name, const utils::StringView<Il2CppChar>& msg)
    {
        Il2CppClass* exceptionClass = Class::FromName(image, name_space, name);
        Il2CppException* ex = (Il2CppException*)Object::New(exceptionClass);
        Runtime::ObjectInit((Il2CppObject*)ex);

        if (msg.Length() > 0)
            IL2CPP_OBJECT_SETREF(ex, message, String::NewUtf16(msg));

        return ex;
    }

    Il2CppException* Exception::FromNameMsg(const Il2CppImage* image, const char *name_space, const char* name, const utils::StringView<Il2CppChar>& msg, il2cpp_hresult_t hresult)
    {
        Il2CppException* ex = FromNameMsg(image, name_space, name, msg);
        ex->hresult = hresult;
        return ex;
    }

    Il2CppException * Exception::GetArgumentException(const char *arg, const char *msg)
    {
        Il2CppException* ex = FromNameMsg(Image::GetCorlib(), "System", "ArgumentException", msg);

        if (arg)
        {
            Il2CppArgumentException *argex = (Il2CppArgumentException*)ex;
            IL2CPP_OBJECT_SETREF(argex, argName, String::New(arg));
        }

        return ex;
    }

    Il2CppException* Exception::GetArgumentException(const utils::StringView<Il2CppChar>& arg, const utils::StringView<Il2CppChar>& msg)
    {
        Il2CppException* ex = FromNameMsg(Image::GetCorlib(), "System", "ArgumentException", msg);

        if (arg.Length() > 0)
        {
            Il2CppArgumentException *argex = (Il2CppArgumentException*)ex;
            IL2CPP_OBJECT_SETREF(argex, argName, String::NewUtf16(arg));
        }

        return ex;
    }

    Il2CppException * Exception::GetArgumentNullException(const char *arg)
    {
        Il2CppException* ex = FromNameMsg(Image::GetCorlib(), "System", "ArgumentNullException", NULL);

        if (arg)
        {
            Il2CppArgumentException *argex = (Il2CppArgumentException*)ex;
            IL2CPP_OBJECT_SETREF(argex, argName, String::New(arg));
        }

        return ex;
    }

    Il2CppException * Exception::GetArgumentOutOfRangeException(const char *arg)
    {
        Il2CppException* ex = FromNameMsg(Image::GetCorlib(), "System", "ArgumentOutOfRangeException", NULL);

        if (arg)
        {
            Il2CppArgumentException *argex = (Il2CppArgumentException*)ex;
            IL2CPP_OBJECT_SETREF(argex, argName, String::New(arg));
        }

        return ex;
    }

    Il2CppException * Exception::GetTypeInitializationException(const char *msg, Il2CppException* innerException)
    {
        Il2CppException* ex = FromNameMsg(Image::GetCorlib(), "System", "TypeInitializationException", msg);

        if (innerException != NULL)
            IL2CPP_OBJECT_SETREF(ex, inner_ex, innerException);

        return ex;
    }

    Il2CppException* Exception::GetInvalidCastException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "InvalidCastException", msg);
    }

    Il2CppException* Exception::GetInvalidCastException(const utils::StringView<Il2CppChar>& msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "InvalidCastException", msg);
    }

    Il2CppException* Exception::GetIndexOutOfRangeException()
    {
        return GetIndexOutOfRangeException(utils::StringView<Il2CppChar>::Empty());
    }

    Il2CppException* Exception::GetIndexOutOfRangeException(const utils::StringView<Il2CppChar>& msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "IndexOutOfRangeException", msg);
    }

    Il2CppException* Exception::GetNullReferenceException(const utils::StringView<Il2CppChar>& msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "NullReferenceException", msg);
    }

    Il2CppException* Exception::GetTypeLoadException()
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "TypeLoadException", NULL);
    }

    Il2CppException* Exception::GetTypeLoadException(const TypeNameParseInfo& info)
    {
        std::string assemblyNameStr;
        const TypeNameParseInfo::AssemblyName& assemblyName = info.assembly_name();

        if (!assemblyName.name.empty())
        {
            utils::VmStringUtils::CaseInsensitiveComparer comparer;
            if (comparer(assemblyName.name, "WindowsRuntimeMetadata"))
                return GetTypeLoadExceptionForWindowsRuntimeType(STRING_TO_STRINGVIEW(info.ns()), STRING_TO_STRINGVIEW(info.name()));

            assemblyNameStr += assemblyName.name;
            assemblyNameStr += ", Version=";

            const size_t bufferSize = 16;
            char buffer[bufferSize];
            snprintf(buffer, bufferSize, "%d.", assemblyName.major);
            assemblyNameStr += buffer;
            snprintf(buffer, bufferSize, "%d.", assemblyName.minor);
            assemblyNameStr += buffer;
            snprintf(buffer, bufferSize, "%d.", assemblyName.build);
            assemblyNameStr += buffer;
            snprintf(buffer, bufferSize, "%d", assemblyName.revision);
            assemblyNameStr += buffer;

            if (!assemblyName.culture.empty())
            {
                assemblyNameStr += ", Culture=";
                assemblyNameStr += assemblyName.culture;
                assemblyNameStr += ", PublicKeyToken=";
            }
            else
            {
                assemblyNameStr += ", Culture=neutral, PublicKeyToken=";
            }

            assemblyNameStr += assemblyName.public_key_token[0] ? assemblyName.public_key_token : "null";
        }

        return GetTypeLoadException(STRING_TO_STRINGVIEW(info.ns()), STRING_TO_STRINGVIEW(info.name()), STRING_TO_STRINGVIEW(assemblyNameStr));
    }

    Il2CppException* Exception::GetTypeLoadException(const utils::StringView<char>& namespaze, const utils::StringView<char>& typeName, const utils::StringView<char>& assemblyName)
    {
        std::string exceptionMessage = "Could not load type '";

        if (!namespaze.IsEmpty())
        {
            exceptionMessage.append(namespaze.Str(), namespaze.Length());
            exceptionMessage.push_back('.');
        }

        exceptionMessage.append(typeName.Str(), typeName.Length());
        exceptionMessage += "' from assembly '";

        if (assemblyName.IsEmpty())
        {
            exceptionMessage += AssemblyName::AssemblyNameToString(Image::GetAssembly(Image::GetCorlib())->aname);
        }
        else
        {
            exceptionMessage.append(assemblyName.Str(), assemblyName.Length());
        }

        exceptionMessage += "'.";
        return Exception::GetTypeLoadException(exceptionMessage.c_str());
    }

    Il2CppException* Exception::GetTypeLoadExceptionForWindowsRuntimeType(const utils::StringView<char>& namespaze, const utils::StringView<char>& typeName)
    {
        std::string typeLoadExceptionMessage = "Could not find Windows Runtime type '";

        if (namespaze.Length() != 0)
        {
            typeLoadExceptionMessage.append(namespaze.Str(), namespaze.Length());
            typeLoadExceptionMessage.push_back('.');
        }

        typeLoadExceptionMessage.append(typeName.Str(), typeName.Length());
        typeLoadExceptionMessage += "'.";

        Il2CppException* typeLoadException = Exception::GetTypeLoadException(typeLoadExceptionMessage.c_str());

        // If there's no '.' in neither typeName and namespace specified, it means there is no namespace specified
        // Therefore exception information should contain inner exception saying format is not recognized
        if (namespaze.Length() == 0 && typeName.Find('.') == utils::StringView<char>::NPos())
        {
            const char kInnerExceptionMessage[] = "The provided identity format is not recognized. (Exception from HRESULT: 0x80132003)";
            Il2CppException* innerException = Exception::GetArgumentException("", kInnerExceptionMessage);
            innerException->hresult = 0x80132003;
            IL2CPP_OBJECT_SETREF(typeLoadException, inner_ex, innerException);
        }

        return typeLoadException;
    }

    Il2CppException* Exception::GetOutOfMemoryException(const utils::StringView<Il2CppChar>& msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "OutOfMemoryException", msg);
    }

    Il2CppException* Exception::GetOverflowException()
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "OverflowException", NULL);
    }

    Il2CppException* Exception::GetOverflowException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "OverflowException", msg);
    }

    Il2CppException* Exception::GetFormatException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "FormatException", msg);
    }

    Il2CppException* Exception::GetSystemException()
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "SystemException", NULL);
    }

    Il2CppException* Exception::GetNotSupportedException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "NotSupportedException", msg);
    }

    Il2CppException* Exception::GetArrayTypeMismatchException()
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "ArrayTypeMismatchException", NULL);
    }

    Il2CppException* Exception::GetTypeLoadException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "TypeLoadException", msg);
    }

    Il2CppException* Exception::GetEntryPointNotFoundException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "EntryPointNotFoundException", msg);
    }

    Il2CppException* Exception::GetAmbiguousImplementationException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System.Runtime", "AmbiguousImplementationException", msg);
    }

    Il2CppException* Exception::GetDllNotFoundException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "DllNotFoundException", msg);
    }

    Il2CppException * Exception::GetInvalidOperationException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "InvalidOperationException", msg);
    }

    Il2CppException* Exception::GetThreadInterruptedException()
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System.Threading", "ThreadInterruptedException", NULL);
    }

    Il2CppException* Exception::GetThreadAbortException()
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System.Threading", "ThreadAbortException", NULL);
    }

    Il2CppException* Exception::GetThreadStateException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System.Threading", "ThreadStateException", msg);
    }

    Il2CppException* Exception::GetSynchronizationLockException(const char* msg)
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System.Threading", "SynchronizationLockException", msg);
    }

    Il2CppException * Exception::GetMissingMethodException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "MissingMethodException", msg);
    }

    Il2CppException * Exception::GetMarshalDirectiveException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System.Runtime.InteropServices", "MarshalDirectiveException", msg);
    }

    Il2CppException * Exception::GetTargetException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System.Reflection", "TargetException", msg);
    }

    Il2CppException* Exception::GetMethodAccessException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "MethodAccessException", msg);
    }

    Il2CppException * Exception::GetExecutionEngineException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "ExecutionEngineException", msg);
    }

    Il2CppException* Exception::GetUnauthorizedAccessException(const utils::StringView<Il2CppChar>& msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "UnauthorizedAccessException", msg);
    }

    Il2CppException* Exception::GetUnauthorizedAccessException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "UnauthorizedAccessException", msg);
    }

    Il2CppException * Exception::GetMaximumNestedGenericsException()
    {
        int currentLimit = metadata::GenericMetadata::GetMaximumRuntimeGenericDepth();
        return GetNotSupportedException(utils::StringUtils::Printf(MAXIMUM_NESTED_GENERICS_EXCEPTION_MESSAGE, currentLimit).c_str());
    }

    Il2CppException* Exception::GetDivideByZeroException()
    {
        return FromNameMsg(vm::Image::GetCorlib(), "System", "DivideByZeroException", NULL);
    }

    Il2CppException* Exception::GetPlatformNotSupportedException(const utils::StringView<Il2CppChar>& msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System", "PlatformNotSupportedException", msg);
    }

    Il2CppException* Exception::GetFileLoadException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System.IO", "FileLoadException", msg);
    }

    Il2CppException* Exception::GetFileNotFoundException(const utils::StringView<Il2CppChar>& msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System.IO", "FileNotFoundException", msg);
    }

    Il2CppException* Exception::GetCustomAttributeFormatException(const char* msg)
    {
        return FromNameMsg(Image::GetCorlib(), "System.Reflection", "CustomAttributeFormatException", msg);
    }

    void Exception::StoreExceptionInfo(Il2CppException* ex, Il2CppString* exceptionString)
    {
        // To do: try retrieving IRestrictedErrorInfo here
        os::WindowsRuntime::OriginateLanguageException(ex->hresult, ex, exceptionString, CCW::GetOrCreate);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Exception.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Field.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/StringUtils.h"
#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "vm/Class.h"
#include "vm/GenericClass.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Type.h"
#include <memory>
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"
#include "utils/MemoryRead.h"
#include "vm-utils/BlobReader.h"
#include "Thread.h"

namespace il2cpp
{
namespace vm
{
    const char* Field::GetName(const FieldInfo *field)
    {
        return field->name;
    }

    Il2CppClass* Field::GetParent(FieldInfo *field)
    {
        return field->parent;
    }

    int Field::GetFlags(FieldInfo *field)
    {
        return field->type->attrs;
    }

    size_t Field::GetOffset(FieldInfo *field)
    {
        return field->offset;
    }

    void Field::GetValue(Il2CppObject *obj, FieldInfo *field, void *value)
    {
        void *src;

        IL2CPP_ASSERT(obj);

        IL2CPP_ASSERT(!(field->type->attrs & FIELD_ATTRIBUTE_STATIC));

        src = (char*)obj + field->offset;
        SetValueRaw(field->type, value, src, true);
    }

    uint32_t Field::GetToken(const FieldInfo *field)
    {
        return field->token;
    }

    Il2CppObject* Field::GetValueObject(FieldInfo *field, Il2CppObject *obj)
    {
        Il2CppClass* fieldType = Class::FromIl2CppType(field->type);

        if (field->type->attrs & FIELD_ATTRIBUTE_LITERAL)
        {
            if (fieldType->byval_arg.valuetype)
            {
                void* value = alloca(fieldType->instance_size - sizeof(Il2CppObject));
                Field::GetDefaultFieldValue(field, value);
                return Object::Box(fieldType, value);
            }
            else
            {
                Il2CppObject* value;
                Field::GetDefaultFieldValue(field, &value);
                return value;
            }
        }

        void* fieldAddress;
        if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
        {
            if (field->offset == THREAD_STATIC_FIELD_OFFSET)
            {
                Runtime::ClassInit(field->parent);
                int threadStaticFieldOffset = MetadataCache::GetThreadLocalStaticOffsetForField(field);
                void* threadStaticData = Thread::GetThreadStaticData(field->parent->thread_static_fields_offset);
                fieldAddress = static_cast<uint8_t*>(threadStaticData) + threadStaticFieldOffset;
            }
            else
            {
                Runtime::ClassInit(field->parent);
                fieldAddress = static_cast<uint8_t*>(field->parent->static_fields) + field->offset;
            }
        }
        else
        {
            IL2CPP_ASSERT(obj);
            fieldAddress = reinterpret_cast<uint8_t*>(obj) + field->offset;
        }

        return Object::Box(fieldType, fieldAddress);
    }

    const Il2CppType* Field::GetType(FieldInfo *field)
    {
        return field->type;
    }

    bool Field::HasAttribute(FieldInfo *field, Il2CppClass *attr_class)
    {
        return Reflection::HasAttribute(field, attr_class);
    }

    bool Field::IsDeleted(FieldInfo *field)
    {
        return false;
    }

    void Field::SetValue(Il2CppObject *obj, const FieldInfo *field, void *value)
    {
        void *dest;

        IL2CPP_ASSERT(!(field->type->attrs & FIELD_ATTRIBUTE_STATIC));

        dest = (char*)obj + field->offset;
        SetValueRaw(field->type, dest, value, false);
    }

    void Field::GetDefaultFieldValue(FieldInfo *field, void *value)
    {
        const Il2CppType* type = NULL;
        const char* data;

        data = Class::GetFieldDefaultValue(field, &type);
        utils::BlobReader::GetConstantValueFromBlob(field->parent->image, type->type, data, value);
    }

    void Field::StaticGetValue(FieldInfo *field, void *value)
    {
        StaticGetValueInternal(field, value, NULL);
    }

    void Field::StaticGetValueForThread(FieldInfo* field, void* value, Il2CppInternalThread* thread)
    {
        StaticGetValueInternal(field, value, thread);
    }

    void Field::StaticGetValueInternal(FieldInfo* field, void* value, Il2CppInternalThread* thread)
    {
        void *src = NULL;

        IL2CPP_ASSERT(field->type->attrs & FIELD_ATTRIBUTE_STATIC);

        if (field->type->attrs & FIELD_ATTRIBUTE_LITERAL)
        {
            GetDefaultFieldValue(field, value);
            return;
        }

        // ensure parent is initialized so that static fields memory has been allocated
        Class::SetupFields(field->parent);

        if (field->offset == THREAD_STATIC_FIELD_OFFSET)
        {
            int threadStaticFieldOffset = MetadataCache::GetThreadLocalStaticOffsetForField(field);

            void* threadStaticData = thread == NULL ? Thread::GetThreadStaticData(field->parent->thread_static_fields_offset) : Thread::GetThreadStaticDataForThread(field->parent->thread_static_fields_offset, thread);
            IL2CPP_ASSERT(NULL != threadStaticData);

            src = ((char*)threadStaticData) + threadStaticFieldOffset;
        }
        else
        {
            src = ((char*)field->parent->static_fields) + field->offset;
        }

        SetValueRaw(field->type, value, src, true);
    }

    void Field::StaticSetValue(FieldInfo *field, void *value)
    {
        void *dest = NULL;

        IL2CPP_ASSERT(field->type->attrs & FIELD_ATTRIBUTE_STATIC);
        IL2CPP_ASSERT(!(field->type->attrs & FIELD_ATTRIBUTE_LITERAL));

        // ensure parent is initialized so that static fields memory has been allocated
        Class::Init(field->parent);

        if (field->offset == THREAD_STATIC_FIELD_OFFSET)
        {
            int threadStaticFieldOffset = MetadataCache::GetThreadLocalStaticOffsetForField(field);
            void* threadStaticData = Thread::GetThreadStaticData(field->parent->thread_static_fields_offset);
            dest = ((char*)threadStaticData) + threadStaticFieldOffset;
        }
        else
        {
            dest = ((char*)field->parent->static_fields) + field->offset;
        }

        SetValueRaw(field->type, dest, value, false);
    }

    void Field::SetInstanceFieldValueObject(Il2CppObject* objectInstance, FieldInfo* field, Il2CppObject* value)
    {
        IL2CPP_ASSERT(!(field->type->attrs & FIELD_ATTRIBUTE_LITERAL));
        IL2CPP_ASSERT(!field->type->valuetype);
        gc::WriteBarrier::GenericStore((Il2CppObject**)(reinterpret_cast<uint8_t*>(objectInstance) + field->offset), value);
    }

    void Field::SetValueRaw(const Il2CppType *type, void *dest, void *value, bool deref_pointer)
    {
        int t;
        if (type->byref)
        {
            /* object fields cannot be byref, so we don't need a
               wbarrier here */
            void* *p = (void**)dest;
            *p = value;
            return;
        }
        t = type->type;
    handle_enum:
        switch (t)
        {
            case IL2CPP_TYPE_BOOLEAN:
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_U1:
            {
                uint8_t *p = (uint8_t*)dest;
                *p = value ? *(uint8_t*)value : 0;
                return;
            }
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_U2:
            {
                uint16_t *p = (uint16_t*)dest;
                *p = value ? *(uint16_t*)value : 0;
                return;
            }
            case IL2CPP_TYPE_CHAR:
            {
                Il2CppChar* p = (Il2CppChar*)dest;
                *p = value ? *(Il2CppChar*)value : 0;
                return;
            }
#if IL2CPP_SIZEOF_VOID_P == 4
            case IL2CPP_TYPE_I:
            case IL2CPP_TYPE_U:
#endif
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_U4:
            {
                int32_t *p = (int32_t*)dest;
                *p = value ? *(int32_t*)value : 0;
                return;
            }
#if IL2CPP_SIZEOF_VOID_P == 8
            case IL2CPP_TYPE_I:
            case IL2CPP_TYPE_U:
#endif
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U8:
            {
                int64_t *p = (int64_t*)dest;
                *p = value ? *(int64_t*)value : 0;
                return;
            }
            case IL2CPP_TYPE_R4:
            {
                float *p = (float*)dest;
                *p = value ? *(float*)value : 0;
                return;
            }
            case IL2CPP_TYPE_R8:
            {
                double *p = (double*)dest;
                *p = value ? *(double*)value : 0;
                return;
            }
            case IL2CPP_TYPE_STRING:
            case IL2CPP_TYPE_SZARRAY:
            case IL2CPP_TYPE_CLASS:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_ARRAY:
                gc::WriteBarrier::GenericStore((void**)dest, (deref_pointer ? *(void**)value : value));
                return;
            case IL2CPP_TYPE_FNPTR:
            case IL2CPP_TYPE_PTR:
            {
                void* *p = (void**)dest;
                *p = deref_pointer ? *(void**)value : value;
                return;
            }
            case IL2CPP_TYPE_VALUETYPE:
                /* note that 't' and 'type->type' can be different */
                if (type->type == IL2CPP_TYPE_VALUETYPE && Type::IsEnum(type))
                {
                    t = Class::GetEnumBaseType(Type::GetClass(type))->type;
                    goto handle_enum;
                }
                else
                {
                    Il2CppClass *klass = Class::FromIl2CppType(type);
                    int size = Class::GetValueSize(klass, NULL);
                    if (value == NULL)
                    {
                        memset(dest, 0, size);
                    }
                    else
                    {
                        memcpy(dest, value, size);
                        gc::GarbageCollector::SetWriteBarrier(reinterpret_cast<void**>(dest), size);
                    }
                }
                return;
            case IL2CPP_TYPE_GENERICINST:
                t = GenericClass::GetTypeDefinition(type->data.generic_class)->byval_arg.type;
                goto handle_enum;
            default:
                IL2CPP_ASSERT(0);
        }
    }

    const char* Field::GetData(FieldInfo *field)
    {
        if (field->type->attrs & FIELD_ATTRIBUTE_HAS_DEFAULT)
        {
            const Il2CppType* type = NULL;
            return Class::GetFieldDefaultValue(field, &type);
        }
        else if (field->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)
        {
            IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Field::GetData, "This works for array initialization data. Revisit any other RVA use case.");
            const Il2CppType* type = NULL;
            return Class::GetFieldDefaultValue(field, &type);
        }
        else
        {
            return NULL;
        }
    }

    bool Field::IsInstance(FieldInfo* field)
    {
        return (field->type->attrs & FIELD_ATTRIBUTE_STATIC) == 0;
    }

    bool Field::IsNormalStatic(FieldInfo* field)
    {
        if ((field->type->attrs & FIELD_ATTRIBUTE_STATIC) == 0)
            return false;

        if (field->offset == THREAD_STATIC_FIELD_OFFSET)
            return false;

        if ((field->type->attrs & FIELD_ATTRIBUTE_LITERAL) != 0)
            return false;

        return true;
    }

    bool Field::IsThreadStatic(FieldInfo* field)
    {
        if ((field->type->attrs & FIELD_ATTRIBUTE_STATIC) == 0)
            return false;

        if (field->offset != THREAD_STATIC_FIELD_OFFSET)
            return false;

        if ((field->type->attrs & FIELD_ATTRIBUTE_LITERAL) != 0)
            return false;

        return true;
    }

    void* Field::GetInstanceFieldDataPointer(void* instance, FieldInfo* field)
    {
        IL2CPP_ASSERT(il2cpp::vm::Field::IsInstance(field));

        uint8_t* fieldPointer = ((uint8_t*)instance) + GetOffset(field);
        return field->parent->byval_arg.valuetype ? fieldPointer - sizeof(Il2CppObject) : fieldPointer;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Field.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\GenericClass.cpp---------------
.
.
#include "il2cpp-config.h"
#include "metadata/GenericMetadata.h"
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "utils/Memory.h"
#include "vm/Class.h"
#include "vm/GenericClass.h"
#include "vm/Exception.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataCache.h"
#include "vm/MetadataLock.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-runtime-metadata.h"
#include "il2cpp-runtime-stats.h"

namespace il2cpp
{
namespace vm
{
    void GenericClass::SetupMethods(Il2CppClass* genericInstanceType)
    {
        Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(genericInstanceType->generic_class);
        uint16_t methodCount = genericTypeDefinition->method_count;
        IL2CPP_ASSERT(genericTypeDefinition->method_count == genericInstanceType->method_count);

        if (methodCount == 0)
        {
            genericInstanceType->methods = NULL;
            return;
        }

        const MethodInfo** methods = (const MethodInfo**)MetadataCalloc(methodCount, sizeof(MethodInfo*));

        for (uint16_t methodIndex = 0; methodIndex < methodCount; ++methodIndex)
        {
            const MethodInfo* methodDefinition = genericTypeDefinition->methods[methodIndex];
            methods[methodIndex] = metadata::GenericMetadata::Inflate(methodDefinition, GenericClass::GetContext(genericInstanceType->generic_class));
        }

        genericInstanceType->methods = methods;

        il2cpp_runtime_stats.method_count += methodCount;
    }

    static void InflatePropertyDefinition(const PropertyInfo* propertyDefinition, PropertyInfo* newProperty, Il2CppClass* declaringClass, Il2CppGenericContext* context)
    {
        newProperty->attrs = propertyDefinition->attrs;
        newProperty->parent = declaringClass;
        newProperty->name = propertyDefinition->name;
        newProperty->token = propertyDefinition->token;

        if (propertyDefinition->get)
            newProperty->get = metadata::GenericMetadata::Inflate(propertyDefinition->get, context);
        if (propertyDefinition->set)
            newProperty->set = metadata::GenericMetadata::Inflate(propertyDefinition->set, context);
    }

    void GenericClass::SetupProperties(Il2CppClass* genericInstanceType)
    {
        Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(genericInstanceType->generic_class);
        uint16_t propertyCount = genericTypeDefinition->property_count;
        IL2CPP_ASSERT(genericTypeDefinition->property_count == genericInstanceType->property_count);

        if (propertyCount == 0)
        {
            genericInstanceType->properties = NULL;
            return;
        }

        PropertyInfo* properties = (PropertyInfo*)MetadataCalloc(propertyCount, sizeof(PropertyInfo));
        PropertyInfo* property = properties;

        for (uint16_t propertyIndex = 0; propertyIndex < propertyCount; ++propertyIndex)
        {
            InflatePropertyDefinition(genericTypeDefinition->properties + propertyIndex, property, genericInstanceType, GenericClass::GetContext(genericInstanceType->generic_class));
            property++;
        }

        genericInstanceType->properties = properties;
    }

    static void InflateEventDefinition(const EventInfo* eventDefinition, EventInfo* newEvent, Il2CppClass* declaringClass, Il2CppGenericContext* context)
    {
        newEvent->eventType = metadata::GenericMetadata::InflateIfNeeded(eventDefinition->eventType, context, false);
        newEvent->name = eventDefinition->name;
        newEvent->parent = declaringClass;
        newEvent->token = eventDefinition->token;

        if (eventDefinition->add)
            newEvent->add = metadata::GenericMetadata::Inflate(eventDefinition->add, context);
        if (eventDefinition->raise)
            newEvent->raise = metadata::GenericMetadata::Inflate(eventDefinition->raise, context);
        if (eventDefinition->remove)
            newEvent->remove = metadata::GenericMetadata::Inflate(eventDefinition->remove, context);
    }

    void GenericClass::SetupEvents(Il2CppClass* genericInstanceType)
    {
        Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(genericInstanceType->generic_class);
        uint16_t eventCount = genericTypeDefinition->event_count;
        IL2CPP_ASSERT(genericTypeDefinition->event_count == genericInstanceType->event_count);

        if (eventCount == 0)
        {
            genericInstanceType->events = NULL;
            return;
        }

        EventInfo* events = (EventInfo*)MetadataCalloc(eventCount, sizeof(EventInfo));
        EventInfo* event = events;

        for (uint16_t eventIndex = 0; eventIndex < eventCount; ++eventIndex)
        {
            InflateEventDefinition(genericTypeDefinition->events + eventIndex, event, genericInstanceType, GenericClass::GetContext(genericInstanceType->generic_class));
            event++;
        }

        genericInstanceType->events = events;
    }

    static FieldInfo* InflateFieldDefinition(const FieldInfo* fieldDefinition, FieldInfo* newField, Il2CppClass* declaringClass, Il2CppGenericContext* context)
    {
        newField->type = metadata::GenericMetadata::InflateIfNeeded(fieldDefinition->type, context, false);
        newField->name = fieldDefinition->name;
        newField->parent = declaringClass;
        newField->offset = fieldDefinition->offset;
        newField->token = fieldDefinition->token;

        return newField;
    }

    void GenericClass::SetupFields(Il2CppClass* genericInstanceType)
    {
        Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(genericInstanceType->generic_class);
        uint16_t fieldCount = genericTypeDefinition->field_count;
        IL2CPP_ASSERT(genericTypeDefinition->field_count == genericInstanceType->field_count);

        if (fieldCount == 0)
        {
            genericInstanceType->fields = NULL;
            return;
        }

        FieldInfo* fields = (FieldInfo*)MetadataCalloc(fieldCount, sizeof(FieldInfo));
        FieldInfo* field = fields;

        for (uint16_t fieldIndex = 0; fieldIndex < fieldCount; ++fieldIndex)
        {
            InflateFieldDefinition(genericTypeDefinition->fields + fieldIndex, field, genericInstanceType, GenericClass::GetContext(genericInstanceType->generic_class));
            field++;
        }

        genericInstanceType->fields = fields;
    }

    Il2CppClass* GenericClass::GetClass(Il2CppGenericClass* gclass, bool throwOnError)
    {
        Il2CppClass* cachedClass = os::Atomic::LoadPointerRelaxed(&gclass->cached_class);
        if (cachedClass)
            return cachedClass;
        return CreateClass(gclass, throwOnError);
    }

    Il2CppClass* GenericClass::CreateClass(Il2CppGenericClass *gclass, bool throwOnError)
    {
        Il2CppClass* definition = GetTypeDefinition(gclass);
        if (definition == NULL)
        {
            if (throwOnError)
                vm::Exception::Raise(vm::Exception::GetMaximumNestedGenericsException());
            return NULL;
        }

        os::FastAutoLock lock(&g_MetadataLock);

        if (!gclass->cached_class)
        {
            Il2CppClass* klass = (Il2CppClass*)MetadataCalloc(1, sizeof(Il2CppClass) + (sizeof(VirtualInvokeData) * definition->vtable_count));
            klass->klass = klass;

            klass->name = definition->name;
            klass->namespaze = definition->namespaze;

            klass->image = definition->image;
            klass->flags = definition->flags;
            //klass->type_token = definition->type_token;
            klass->generic_class = gclass;

            Il2CppClass* genericTypeDefinition = GenericClass::GetTypeDefinition(klass->generic_class);
            Il2CppGenericContext* context = &klass->generic_class->context;

            if (genericTypeDefinition->parent)
                klass->parent = Class::FromIl2CppType(metadata::GenericMetadata::InflateIfNeeded(&genericTypeDefinition->parent->byval_arg, context, false));

            if (genericTypeDefinition->declaringType)
                klass->declaringType = Class::FromIl2CppType(metadata::GenericMetadata::InflateIfNeeded(&genericTypeDefinition->declaringType->byval_arg, context, false));

            klass->this_arg.type = klass->byval_arg.type = IL2CPP_TYPE_GENERICINST;
            klass->this_arg.data.generic_class = klass->byval_arg.data.generic_class = gclass;
            klass->this_arg.byref = true;
            klass->byval_arg.valuetype = genericTypeDefinition->byval_arg.valuetype;

            klass->event_count = definition->event_count;
            klass->field_count = definition->field_count;
            klass->interfaces_count = definition->interfaces_count;
            klass->method_count = definition->method_count;
            klass->property_count = definition->property_count;

            klass->enumtype = definition->enumtype;
            klass->element_class = klass->castClass = klass;

            klass->has_cctor = definition->has_cctor;
            klass->cctor_finished_or_no_cctor = !definition->has_cctor;

            klass->has_finalize = definition->has_finalize;
            klass->native_size = klass->thread_static_fields_offset = -1;
            klass->token = definition->token;
            klass->interopData = MetadataCache::GetInteropDataForType(&klass->byval_arg);

            if (GenericClass::GetTypeDefinition(klass->generic_class) == il2cpp_defaults.generic_nullable_class)
            {
                klass->element_class = klass->castClass = Class::FromIl2CppType(klass->generic_class->context.class_inst->type_argv[0]);
                klass->nullabletype = true;
            }

            if (klass->enumtype)
                klass->element_class = klass->castClass = definition->element_class;

            klass->is_import_or_windows_runtime = definition->is_import_or_windows_runtime;

            // Do not update gclass->cached_class until `klass` is fully initialized
            // And do so with an atomic barrier so no threads observer the writes out of order
            il2cpp::os::Atomic::ExchangePointer(&gclass->cached_class, klass);
        }

        return gclass->cached_class;
    }

    Il2CppGenericContext* GenericClass::GetContext(Il2CppGenericClass *gclass)
    {
        return &gclass->context;
    }

    Il2CppClass* GenericClass::GetTypeDefinition(Il2CppGenericClass *gclass)
    {
        return MetadataCache::GetTypeInfoFromType(gclass->type);
    }

    bool GenericClass::IsEnum(Il2CppGenericClass *gclass)
    {
        return IsValueType(gclass) && GetTypeDefinition(gclass)->enumtype;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\GenericClass.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\GenericContainer.cpp---------------
.
.
#include "il2cpp-config.h"
#include "GenericContainer.h"
#include "MetadataCache.h"

namespace il2cpp
{
namespace vm
{
    Il2CppClass* GenericContainer::GetDeclaringType(Il2CppMetadataGenericContainerHandle handle)
    {
        return MetadataCache::GetContainerDeclaringType(handle);
    }

    Il2CppMetadataGenericParameterHandle GenericContainer::GetGenericParameter(Il2CppMetadataGenericContainerHandle handle, uint16_t index)
    {
        return MetadataCache::GetGenericParameterFromIndex(handle, index);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\GenericContainer.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\GlobalMetadata.cpp---------------
.
.
#include "GlobalMetadata.h"

#include "il2cpp-config.h"


#include <map>
#include <limits>
#include <il2cpp-runtime-metadata.h>
#include "il2cpp-class-internals.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-runtime-stats.h"
#include "gc/GarbageCollector.h"
#include "metadata/ArrayMetadata.h"
#include "metadata/CustomAttributeDataReader.h"
#include "metadata/CustomAttributeCreator.h"
#include "metadata/GenericMetadata.h"
#include "metadata/GenericMethod.h"
#include "metadata/Il2CppTypeCompare.h"
#include "metadata/Il2CppTypeHash.h"
#include "metadata/Il2CppGenericContextCompare.h"
#include "metadata/Il2CppGenericContextHash.h"
#include "metadata/Il2CppGenericInstCompare.h"
#include "metadata/Il2CppGenericInstHash.h"
#include "metadata/Il2CppGenericMethodCompare.h"
#include "metadata/Il2CppGenericMethodHash.h"
#include "metadata/Il2CppSignature.h"
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "utils/CallOnce.h"
#include "utils/Collections.h"
#include "utils/HashUtils.h"
#include "utils/Il2CppHashMap.h"
#include "utils/Il2CppHashSet.h"
#include "utils/InitOnce.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "utils/PathUtils.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/GenericClass.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataLoader.h"
#include "vm/MetadataLock.h"
#include "vm/Exception.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "vm-utils/MethodDefinitionKey.h"
#include "vm-utils/NativeSymbol.h"
#include "vm-utils/VmStringUtils.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

#include "GlobalMetadataFileInternals.h"

typedef struct Il2CppImageGlobalMetadata
{
    TypeDefinitionIndex typeStart;
    TypeDefinitionIndex exportedTypeStart;
    CustomAttributeIndex customAttributeStart;
    MethodIndex entryPointIndex;
    const Il2CppImage* image;
} Il2CppImageGlobalMetadata;

static int32_t s_MetadataImagesCount = 0;
static Il2CppImageGlobalMetadata* s_MetadataImagesTable = NULL;

static TypeDefinitionIndex GetIndexForTypeDefinitionInternal(const Il2CppTypeDefinition* typeDefinition);
static Il2CppClass* GetTypeInfoFromTypeDefinitionIndex(TypeDefinitionIndex index);
static Il2CppClass* FromTypeDefinition(TypeDefinitionIndex index);
static GenericParameterIndex GetIndexForGenericParameter(Il2CppMetadataGenericParameterHandle handle);
static Il2CppMetadataGenericParameterHandle GetGenericParameterFromIndexInternal(GenericParameterIndex index);

static void* s_GlobalMetadata;
static const Il2CppGlobalMetadataHeader* s_GlobalMetadataHeader;
static const Il2CppGenericMethod** s_GenericMethodTable = NULL;

static const MethodInfo** s_MethodInfoDefinitionTable = NULL;

static Il2CppString** s_StringLiteralTable = NULL;

static il2cpp::utils::OnceFlag s_CustomAttributesOnceFlag;
static int s_CustomAttributesCount;

static const Il2CppCodeRegistration * s_GlobalMetadata_CodeRegistration;
static const Il2CppMetadataRegistration * s_Il2CppMetadataRegistration;

static Il2CppClass** s_TypeInfoTable = NULL;
static Il2CppClass** s_TypeInfoDefinitionTable = NULL;

static const int kBitIsValueType = 1;
static const int kBitIsEnum = 2;
static const int kBitHasFinalizer = 3;
static const int kBitHasStaticConstructor = 4;
static const int kBitIsBlittable = 5;
static const int kBitIsImportOrWindowsRuntime = 6;
static const int kPackingSize = 7;     // This uses 4 bits from bit 7 to bit 10
static const int kPackingSizeIsDefault = 11;
static const int kClassSizeIsDefault = 12;
static const int kSpecifiedPackingSize = 13; // This uses 4 bits from bit 13 to bit 16
static const int kBitIsByRefLike = 17;

template<typename T>
static T MetadataOffset(const void* metadata, size_t sectionOffset, size_t itemIndex)
{
    return reinterpret_cast<T>(reinterpret_cast<uint8_t*>(const_cast<void*>(metadata)) + sectionOffset) + itemIndex;
}

static const char* GetStringFromIndex(StringIndex index)
{
    IL2CPP_ASSERT(index <= s_GlobalMetadataHeader->stringSize);
    return MetadataOffset<const char*>(s_GlobalMetadata, s_GlobalMetadataHeader->stringOffset, index);
}

static const char* GetWindowsRuntimeStringFromIndex(StringIndex index)
{
    IL2CPP_ASSERT(index <= s_GlobalMetadataHeader->windowsRuntimeStringsSize);
    return MetadataOffset<const char*>(s_GlobalMetadata, s_GlobalMetadataHeader->windowsRuntimeStringsOffset, index);
}

static const Il2CppMethodDefinition* GetMethodDefinitionFromIndex(MethodIndex index)
{
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->methodsSize / sizeof(Il2CppMethodDefinition));
    return MetadataOffset<const Il2CppMethodDefinition*>(s_GlobalMetadata, s_GlobalMetadataHeader->methodsOffset, index);
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetMethodInfoFromMethodDefinitionIndex(MethodIndex index)
{
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->methodsSize / sizeof(Il2CppMethodDefinition));

    return utils::InitOnce(&s_MethodInfoDefinitionTable[index], &g_MetadataLock, [index](il2cpp::os::FastAutoLock& _)
    {
        const Il2CppMethodDefinition* methodDefinition = GetMethodDefinitionFromIndex(index);
        Il2CppClass* typeInfo = GetTypeInfoFromTypeDefinitionIndex(methodDefinition->declaringType);
        il2cpp::vm::Class::SetupMethods(typeInfo);
        const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(typeInfo->typeMetadataHandle);
        return typeInfo->methods[index - typeDefinition->methodStart];
    });
}

static const Il2CppEventDefinition* GetEventDefinitionFromIndex(const Il2CppImage* image, EventIndex index)
{
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->eventsSize / sizeof(Il2CppEventDefinition));
    const Il2CppEventDefinition* events = (const Il2CppEventDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->eventsOffset);
    return events + index;
}

static const Il2CppPropertyDefinition* GetPropertyDefinitionFromIndex(const Il2CppImage* image, PropertyIndex index)
{
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->propertiesSize / sizeof(Il2CppPropertyDefinition));
    const Il2CppPropertyDefinition* properties = (const Il2CppPropertyDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->propertiesOffset);
    return properties + index;
}

static const Il2CppParameterDefinition* GetParameterDefinitionFromIndex(const Il2CppImage* image, ParameterIndex index)
{
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->parametersSize / sizeof(Il2CppParameterDefinition));
    const Il2CppParameterDefinition* parameters = (const Il2CppParameterDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->parametersOffset);
    return parameters + index;
}

static const Il2CppGenericMethod* GetGenericMethodFromIndex(GenericMethodIndex index)
{
    IL2CPP_ASSERT(index < s_Il2CppMetadataRegistration->methodSpecsCount);

    return il2cpp::utils::InitOnce(&s_GenericMethodTable[index], &il2cpp::vm::g_MetadataLock, [index](il2cpp::os::FastAutoLock& _)
    {
        const Il2CppMethodSpec* methodSpec = s_Il2CppMetadataRegistration->methodSpecs + index;
        const MethodInfo* methodDefinition = il2cpp::vm::GlobalMetadata::GetMethodInfoFromMethodDefinitionIndex(methodSpec->methodDefinitionIndex);
        const Il2CppGenericInst* classInst = NULL;
        const Il2CppGenericInst* methodInst = NULL;
        if (methodSpec->classIndexIndex != -1)
        {
            IL2CPP_ASSERT(methodSpec->classIndexIndex < s_Il2CppMetadataRegistration->genericInstsCount);
            classInst = s_Il2CppMetadataRegistration->genericInsts[methodSpec->classIndexIndex];
        }
        if (methodSpec->methodIndexIndex != -1)
        {
            IL2CPP_ASSERT(methodSpec->methodIndexIndex < s_Il2CppMetadataRegistration->genericInstsCount);
            methodInst = s_Il2CppMetadataRegistration->genericInsts[methodSpec->methodIndexIndex];
        }
        return il2cpp::vm::MetadataCache::GetGenericMethod(methodDefinition, classInst, methodInst);
    });
}

static const MethodInfo* GetMethodInfoFromEncodedIndex(EncodedMethodIndex methodIndex)
{
    Il2CppMetadataUsage usage = GetEncodedIndexType(methodIndex);

    uint32_t index = GetDecodedMethodIndex(methodIndex);

    switch (GetEncodedIndexType(methodIndex))
    {
        case kIl2CppMetadataUsageMethodRef:
            return il2cpp::metadata::GenericMethod::GetMethod(GetGenericMethodFromIndex(index));
        case kIl2CppMetadataUsageMethodDef:
            return il2cpp::vm::GlobalMetadata::GetMethodInfoFromMethodDefinitionIndex(index);
        case kIl2CppMetadataUsageInvalid:
        {
            switch (index)
            {
                case kIl2CppInvalidMetadataUsageNoData:
                    return NULL;
                case kIl2CppInvalidMetadataUsageAmbiguousMethod:
                    return il2cpp::vm::Method::GetAmbiguousMethodInfo();
                default:
                    IL2CPP_ASSERT(0);
                    break;
            }
        }
        default:
            IL2CPP_ASSERT(0);
            break;
    }

    return NULL;
}

static Il2CppString* GetStringLiteralFromIndex(StringLiteralIndex index)
{
    if (index == kStringLiteralIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) < s_GlobalMetadataHeader->stringLiteralSize / sizeof(Il2CppStringLiteral) && "Invalid string literal index ");

    if (s_StringLiteralTable[index])
        return s_StringLiteralTable[index];

    const Il2CppStringLiteral* stringLiteral = (const Il2CppStringLiteral*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->stringLiteralOffset) + index;
    Il2CppString* newString = il2cpp::vm::String::NewLen((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->stringLiteralDataOffset + stringLiteral->dataIndex, stringLiteral->length);
    Il2CppString* prevString = il2cpp::os::Atomic::CompareExchangePointer<Il2CppString>(s_StringLiteralTable + index, newString, NULL);
    if (prevString == NULL)
    {
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)s_StringLiteralTable + index);
        return newString;
    }
    return prevString;
}

static FieldInfo* GetFieldInfoFromIndex(EncodedMethodIndex index)
{
    IL2CPP_ASSERT(s_GlobalMetadataHeader->fieldRefsSize >= 0 && index <= static_cast<uint32_t>(s_GlobalMetadataHeader->fieldRefsSize / sizeof(Il2CppFieldRef)));

    const Il2CppFieldRef* fieldRef = MetadataOffset<const Il2CppFieldRef*>(s_GlobalMetadata, s_GlobalMetadataHeader->fieldRefsOffset, index);
    const Il2CppClass* typeInfo = il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeIndex(fieldRef->typeIndex);
    return typeInfo->fields + fieldRef->fieldIndex;
}

void il2cpp::vm::GlobalMetadata::Register(const Il2CppCodeRegistration* const codeRegistration, const Il2CppMetadataRegistration* const metadataRegistration, const Il2CppCodeGenOptions* const codeGenOptions)
{
    s_GlobalMetadata_CodeRegistration = codeRegistration;
    s_Il2CppMetadataRegistration = metadataRegistration;
}

typedef void (*Il2CppTypeUpdater)(Il2CppType*);

static void InitializeTypeHandle(Il2CppType* type)
{
    type->data.typeHandle = il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(type->data.__klassIndex);
}

static void ClearTypeHandle(Il2CppType* type)
{
    type->data.__klassIndex = GetIndexForTypeDefinitionInternal(reinterpret_cast<const Il2CppTypeDefinition*>(type->data.typeHandle));
}

static void InitializeGenericParameterHandle(Il2CppType* type)
{
    type->data.genericParameterHandle = GetGenericParameterFromIndexInternal(type->data.__genericParameterIndex);
}

static void ClearGenericParameterHandle(Il2CppType* type)
{
    type->data.__genericParameterIndex = GetIndexForGenericParameter(reinterpret_cast<Il2CppMetadataGenericParameterHandle>(type->data.genericParameterHandle));
}

static void ProcessIl2CppTypeDefinitions(Il2CppTypeUpdater updateTypeDef, Il2CppTypeUpdater updateGenericParam)
{
    for (int32_t i = 0; i < s_Il2CppMetadataRegistration->typesCount; i++)
    {
        const Il2CppType* type = s_Il2CppMetadataRegistration->types[i];
        switch (type->type)
        {
            case IL2CPP_TYPE_VOID:
            case IL2CPP_TYPE_BOOLEAN:
            case IL2CPP_TYPE_CHAR:
            case IL2CPP_TYPE_I1:
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_R8:
            case IL2CPP_TYPE_STRING:
            case IL2CPP_TYPE_VALUETYPE:
            case IL2CPP_TYPE_CLASS:
            case IL2CPP_TYPE_I:
            case IL2CPP_TYPE_U:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_TYPEDBYREF:
                // The Il2Cpp conversion process writes these types in a writeable section
                // So we can const_cast them here safely
                updateTypeDef(const_cast<Il2CppType*>(type));
                break;
            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:
                updateGenericParam(const_cast<Il2CppType*>(type));
                break;
            default:
                // Nothing do to
                break;
        }
    }
}

bool il2cpp::vm::GlobalMetadata::Initialize(int32_t* imagesCount, int32_t* assembliesCount)
{
    s_GlobalMetadata = vm::MetadataLoader::LoadMetadataFile("global-metadata.dat");
    if (!s_GlobalMetadata)
        return false;

    s_GlobalMetadataHeader = (const Il2CppGlobalMetadataHeader*)s_GlobalMetadata;
    IL2CPP_ASSERT(s_GlobalMetadataHeader->sanity == 0xFAB11BAF);
    IL2CPP_ASSERT(s_GlobalMetadataHeader->version == 31);
    IL2CPP_ASSERT(s_GlobalMetadataHeader->stringLiteralOffset == sizeof(Il2CppGlobalMetadataHeader));

    s_MetadataImagesCount = *imagesCount = s_GlobalMetadataHeader->imagesSize / sizeof(Il2CppImageDefinition);
    *assembliesCount = s_GlobalMetadataHeader->assembliesSize / sizeof(Il2CppAssemblyDefinition);

    // Pre-allocate these arrays so we don't need to lock when reading later.
    // These arrays hold the runtime metadata representation for metadata explicitly
    // referenced during conversion. There is a corresponding table of same size
    // in the converted metadata, giving a description of runtime metadata to construct.
    s_MetadataImagesTable = (Il2CppImageGlobalMetadata*)IL2CPP_CALLOC(s_MetadataImagesCount, sizeof(Il2CppImageGlobalMetadata));
    s_TypeInfoTable = (Il2CppClass**)IL2CPP_CALLOC(s_Il2CppMetadataRegistration->typesCount, sizeof(Il2CppClass*));
    s_TypeInfoDefinitionTable = (Il2CppClass**)IL2CPP_CALLOC(s_GlobalMetadataHeader->typeDefinitionsSize / sizeof(Il2CppTypeDefinition), sizeof(Il2CppClass*));
    s_MethodInfoDefinitionTable = (const MethodInfo**)IL2CPP_CALLOC(s_GlobalMetadataHeader->methodsSize / sizeof(Il2CppMethodDefinition), sizeof(MethodInfo*));
    s_GenericMethodTable = (const Il2CppGenericMethod**)IL2CPP_CALLOC(s_Il2CppMetadataRegistration->methodSpecsCount, sizeof(Il2CppGenericMethod*));

    ProcessIl2CppTypeDefinitions(InitializeTypeHandle, InitializeGenericParameterHandle);

    return true;
}

void il2cpp::vm::GlobalMetadata::InitializeAllMethodMetadata()
{
    for (size_t i = 0; i < s_Il2CppMetadataRegistration->metadataUsagesCount; i++)
    {
        uintptr_t* metadataPointer = reinterpret_cast<uintptr_t*>(s_Il2CppMetadataRegistration->metadataUsages[i]);
        Il2CppMetadataUsage usage = GetEncodedIndexType(static_cast<uint32_t>(*metadataPointer));
        switch (usage)
        {
            case kIl2CppMetadataUsageTypeInfo:
            case kIl2CppMetadataUsageMethodDef:
            case kIl2CppMetadataUsageMethodRef:
                InitializeRuntimeMetadata(metadataPointer, false);
                break;
            default:
                break;
        }
    }
}

// This method can be called from multiple threads, so it does have a data race. However, each
// thread is reading from the same read-only metadata, so each thread will set the same values.
// Therefore, we can safely ignore thread sanitizer issues in this method.
void* il2cpp::vm::GlobalMetadata::InitializeRuntimeMetadata(uintptr_t* metadataPointer, bool throwOnError) IL2CPP_DISABLE_TSAN
{
    // This must be the only read of *metadataPointer
    // This code has no locks and we need to ensure that we only read metadataPointer once
    // so we don't read it once as an encoded token and once as an initialized pointer
    uintptr_t metadataValue = (uintptr_t)os::Atomic::ReadPtrVal((intptr_t*)metadataPointer);

    if (IsRuntimeMetadataInitialized(metadataValue))
        return (void*)metadataValue;

    uint32_t encodedToken = static_cast<uint32_t>(metadataValue);
    Il2CppMetadataUsage usage = GetEncodedIndexType(encodedToken);
    uint32_t decodedIndex = GetDecodedMethodIndex(encodedToken);

    void* initialized = NULL;

    switch (usage)
    {
        case kIl2CppMetadataUsageTypeInfo:
            initialized = (void*)il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeIndex(decodedIndex, throwOnError);
            break;
        case kIl2CppMetadataUsageIl2CppType:
            initialized = (void*)il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(decodedIndex);
            break;
        case kIl2CppMetadataUsageMethodDef:
        case kIl2CppMetadataUsageMethodRef:
            initialized = (void*)GetMethodInfoFromEncodedIndex(encodedToken);
            break;
        case kIl2CppMetadataUsageFieldInfo:
            initialized = (void*)GetFieldInfoFromIndex(decodedIndex);
            break;
        case kIl2CppMetadataUsageStringLiteral:
            initialized = (void*)GetStringLiteralFromIndex(decodedIndex);
            break;
        case kIl2CppMetadataUsageFieldRva:
            const Il2CppType* unused;
            initialized = (void*)GetFieldDefaultValue(GetFieldInfoFromIndex(decodedIndex), &unused);
            {
                const size_t MappedFieldDataAlignment = 8; // Should match System.Reflection.Metadata.ManagedPEBuilder.MappedFieldDataAlignment
                IL2CPP_ASSERT(((uintptr_t)initialized % MappedFieldDataAlignment) == 0);
            }
            break;
        case kIl2CppMetadataUsageInvalid:
            break;
        default:
            IL2CPP_NOT_IMPLEMENTED(il2cpp::vm::GlobalMetadata::InitializeMethodMetadata);
            break;
    }

    IL2CPP_ASSERT(IsRuntimeMetadataInitialized(initialized) && "ERROR: The low bit of the metadata item is still set, alignment issue");

    if (initialized != NULL)
    {
        // Set the metadata pointer last, with a barrier, so it is the last item written
        il2cpp::os::Atomic::PublishPointer((void**)metadataPointer, initialized);
    }

    return initialized;
}

void il2cpp::vm::GlobalMetadata::InitializeStringLiteralTable()
{
    s_StringLiteralTable = (Il2CppString**)il2cpp::gc::GarbageCollector::AllocateFixed(s_GlobalMetadataHeader->stringLiteralSize / sizeof(Il2CppStringLiteral) * sizeof(Il2CppString*), NULL);
}

void il2cpp::vm::GlobalMetadata::InitializeWindowsRuntimeTypeNamesTables(WindowsRuntimeTypeNameToClassMap& windowsRuntimeTypeNameToClassMap, ClassToWindowsRuntimeTypeNameMap& classToWindowsRuntimeTypeNameMap)
{
    int32_t typeCount = s_GlobalMetadataHeader->windowsRuntimeTypeNamesSize / sizeof(Il2CppWindowsRuntimeTypeNamePair);
    const Il2CppWindowsRuntimeTypeNamePair* windowsRuntimeTypeNames = MetadataOffset<Il2CppWindowsRuntimeTypeNamePair*>(s_GlobalMetadata, s_GlobalMetadataHeader->windowsRuntimeTypeNamesOffset, 0);

    windowsRuntimeTypeNameToClassMap.resize(typeCount / 2 + 1);
    classToWindowsRuntimeTypeNameMap.resize(typeCount);

    for (int32_t i = 0; i < typeCount; i++)
    {
        Il2CppWindowsRuntimeTypeNamePair typeNamePair = windowsRuntimeTypeNames[i];
        const char* name = GetWindowsRuntimeStringFromIndex(typeNamePair.nameIndex);
        const Il2CppType* type = GetIl2CppTypeFromIndex(typeNamePair.typeIndex);
        Il2CppClass* klass = Class::FromIl2CppType(type);

        if (!Class::IsNullable(klass))
        {
            // Don't add nullable types to name -> klass map because IReference`1<T> and Nullable`1<T>
            // share windows runtime type names, and that would cause a collision.
            windowsRuntimeTypeNameToClassMap.insert(std::make_pair(name, klass));
        }

        classToWindowsRuntimeTypeNameMap.insert(std::make_pair(klass, name));
    }
}

void il2cpp::vm::GlobalMetadata::InitializeUnresolvedSignatureTable(Il2CppUnresolvedSignatureMap& unresolvedSignatureMap)
{
    unresolvedSignatureMap.resize(s_GlobalMetadata_CodeRegistration->unresolvedIndirectCallCount);

    for (uint32_t i = 0; i < s_GlobalMetadata_CodeRegistration->unresolvedIndirectCallCount; ++i)
    {
        const Il2CppMetadataRange* range = MetadataOffset<Il2CppMetadataRange*>(s_GlobalMetadata, s_GlobalMetadataHeader->unresolvedIndirectCallParameterRangesOffset, i);
        il2cpp::metadata::Il2CppSignature signature;
        signature.Count = range->length;
        signature.Types = (const Il2CppType**)MetadataMalloc(range->length * sizeof(Il2CppType*));

        for (int j = 0; j < range->length; ++j)
        {
            TypeIndex typeIndex = *MetadataOffset<TypeIndex*>(s_GlobalMetadata, s_GlobalMetadataHeader->unresolvedIndirectCallParameterTypesOffset, range->start + j);
            const Il2CppType* type = GetIl2CppTypeFromIndex(typeIndex);
            signature.Types[j] = type;
        }

        unresolvedSignatureMap.insert(std::make_pair(signature, i));
    }
}

void il2cpp::vm::GlobalMetadata::InitializeGenericMethodTable(Il2CppMethodTableMap& methodTableMap)
{
    methodTableMap.resize(s_Il2CppMetadataRegistration->genericMethodTableCount);

    for (int32_t i = 0; i < s_Il2CppMetadataRegistration->genericMethodTableCount; i++)
    {
        const Il2CppGenericMethodFunctionsDefinitions* genericMethodIndices = s_Il2CppMetadataRegistration->genericMethodTable + i;
        const Il2CppGenericMethod* genericMethod = GetGenericMethodFromIndex(genericMethodIndices->genericMethodIndex);
        methodTableMap.insert(std::make_pair(genericMethod, &genericMethodIndices->indices));
    }
}

static void ClearStringLiteralTable()
{
    il2cpp::gc::GarbageCollector::FreeFixed(s_StringLiteralTable);
    s_StringLiteralTable = NULL;
}

static void FreeAndNull(void** pointer)
{
    IL2CPP_FREE(*pointer);
    *pointer = NULL;
}

void il2cpp::vm::GlobalMetadata::Clear()
{
    ClearStringLiteralTable();

    FreeAndNull((void**)&s_MethodInfoDefinitionTable);
    FreeAndNull((void**)&s_GenericMethodTable);
    FreeAndNull((void**)&s_TypeInfoTable);
    FreeAndNull((void**)&s_TypeInfoDefinitionTable);

    ProcessIl2CppTypeDefinitions(ClearTypeHandle, ClearGenericParameterHandle);

    vm::MetadataLoader::UnloadMetadataFile(s_GlobalMetadata);
    s_GlobalMetadataHeader = NULL;
    s_GlobalMetadata = NULL;

    s_GlobalMetadata_CodeRegistration = NULL;
    s_Il2CppMetadataRegistration = NULL;
}

void il2cpp::vm::GlobalMetadata::BuildIl2CppImage(Il2CppImage* image, ImageIndex imageIndex, AssemblyIndex* imageAssemblyIndex)
{
    const Il2CppImageDefinition* imagesDefinitions = (const Il2CppImageDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->imagesOffset);

    const Il2CppImageDefinition* imageDefinition = imagesDefinitions + imageIndex;

    image->name = GetStringFromIndex(imageDefinition->nameIndex);

    *imageAssemblyIndex = imageDefinition->assemblyIndex;
    image->typeCount = imageDefinition->typeCount;
    image->exportedTypeCount = imageDefinition->exportedTypeCount;
    image->token = imageDefinition->token;
    image->customAttributeCount = imageDefinition->customAttributeCount;

    Il2CppImageGlobalMetadata* metadataImage = s_MetadataImagesTable + imageIndex;
    metadataImage->typeStart = imageDefinition->typeStart;
    metadataImage->customAttributeStart = imageDefinition->customAttributeStart;
    metadataImage->entryPointIndex = imageDefinition->entryPointIndex;
    metadataImage->exportedTypeStart = imageDefinition->exportedTypeStart;
    metadataImage->image = image;

    image->metadataHandle = reinterpret_cast<Il2CppMetadataImageHandle>(metadataImage);
}

void il2cpp::vm::GlobalMetadata::BuildIl2CppAssembly(Il2CppAssembly* assembly, AssemblyIndex assemblyIndex, ImageIndex* assemblyImageIndex)
{
    const Il2CppAssemblyDefinition* assemblyDefinitions = (const Il2CppAssemblyDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->assembliesOffset);
    const Il2CppAssemblyDefinition* assemblyDefinition = assemblyDefinitions + assemblyIndex;

    assembly->token = assemblyDefinition->token;
    assembly->referencedAssemblyStart = assemblyDefinition->referencedAssemblyStart;
    assembly->referencedAssemblyCount = assemblyDefinition->referencedAssemblyCount;

    Il2CppAssemblyName* assemblyName = &assembly->aname;
    const Il2CppAssemblyNameDefinition* assemblyNameDefinition = &assemblyDefinition->aname;

    assemblyName->name = GetStringFromIndex(assemblyNameDefinition->nameIndex);
    assemblyName->culture = GetStringFromIndex(assemblyNameDefinition->cultureIndex);
    assemblyName->public_key = (const uint8_t*)GetStringFromIndex(assemblyNameDefinition->publicKeyIndex);
    assemblyName->hash_alg = assemblyNameDefinition->hash_alg;
    assemblyName->hash_len = assemblyNameDefinition->hash_len;
    assemblyName->flags = assemblyNameDefinition->flags;
    assemblyName->major = assemblyNameDefinition->major;
    assemblyName->minor = assemblyNameDefinition->minor;
    assemblyName->build = assemblyNameDefinition->build;
    assemblyName->revision = assemblyNameDefinition->revision;
    memcpy(assemblyName->public_key_token, assemblyNameDefinition->public_key_token, sizeof(assemblyNameDefinition->public_key_token));

    *assemblyImageIndex = assemblyDefinition->imageIndex;
}

static const Il2CppImageGlobalMetadata* GetImageMetadata(const Il2CppImage* image)
{
    return reinterpret_cast<const Il2CppImageGlobalMetadata*>(image->metadataHandle);
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetAssemblyEntryPoint(const Il2CppImage* image)
{
    const Il2CppImageGlobalMetadata* imageMetadata = GetImageMetadata(image);

    if (imageMetadata == NULL || imageMetadata->entryPointIndex == -1)
        return NULL;

    return GetMethodInfoFromMethodDefinitionIndex(imageMetadata->entryPointIndex);
}

Il2CppMetadataTypeHandle il2cpp::vm::GlobalMetadata::GetAssemblyTypeHandle(const Il2CppImage* image, AssemblyTypeIndex index)
{
    const Il2CppImageGlobalMetadata* imageMetadata = GetImageMetadata(image);

    IL2CPP_ASSERT(index >= 0 && index < static_cast<AssemblyTypeIndex>(image->typeCount));
    TypeDefinitionIndex typeDefintionIndex = imageMetadata->typeStart + index;
    return GetTypeHandleFromIndex(typeDefintionIndex);
}

const Il2CppAssembly* il2cpp::vm::GlobalMetadata::GetReferencedAssembly(const Il2CppAssembly* assembly, int32_t referencedAssemblyTableIndex, const Il2CppAssembly assembliesTable[], int assembliesCount)
{
    IL2CPP_ASSERT(referencedAssemblyTableIndex < assembly->referencedAssemblyCount);

    referencedAssemblyTableIndex = assembly->referencedAssemblyStart + referencedAssemblyTableIndex;

    IL2CPP_ASSERT(referencedAssemblyTableIndex >= 0 && static_cast<uint32_t>(referencedAssemblyTableIndex) <= s_GlobalMetadataHeader->referencedAssembliesSize / sizeof(int32_t));
    const int32_t* referenceAssemblyIndicies = (const int32_t*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->referencedAssembliesOffset);
    return assembliesTable + referenceAssemblyIndicies[referencedAssemblyTableIndex];
}

Il2CppMetadataTypeHandle il2cpp::vm::GlobalMetadata::GetAssemblyExportedTypeHandle(const Il2CppImage* image, AssemblyExportedTypeIndex index)
{
    if (index == kTypeDefinitionIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && index < static_cast<AssemblyExportedTypeIndex>(image->exportedTypeCount));

    const Il2CppImageGlobalMetadata* imageMetadata = GetImageMetadata(image);

    int32_t exportedTypeIndex = imageMetadata->exportedTypeStart + index;

    IL2CPP_ASSERT(exportedTypeIndex >= 0 && static_cast<uint32_t>(exportedTypeIndex) < s_GlobalMetadataHeader->exportedTypeDefinitionsSize / sizeof(TypeDefinitionIndex));
    TypeDefinitionIndex* exportedTypes = (TypeDefinitionIndex*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->exportedTypeDefinitionsOffset);
    TypeDefinitionIndex typeDefintionIndex =  *(exportedTypes + exportedTypeIndex);

    return GetTypeHandleFromIndex(typeDefintionIndex);
}

static const Il2CppTypeDefinition* GetTypeDefinitionForIndex(TypeDefinitionIndex index)
{
    if (index == kTypeDefinitionIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) < s_GlobalMetadataHeader->typeDefinitionsSize / sizeof(Il2CppTypeDefinition));
    const Il2CppTypeDefinition* typeDefinitions = (const Il2CppTypeDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->typeDefinitionsOffset);
    return typeDefinitions + index;
}

static TypeDefinitionIndex GetIndexForTypeDefinitionInternal(const Il2CppTypeDefinition* typeDefinition)
{
    IL2CPP_ASSERT(typeDefinition);
    const Il2CppTypeDefinition* typeDefinitions = (const Il2CppTypeDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->typeDefinitionsOffset);

    IL2CPP_ASSERT(typeDefinition >= typeDefinitions && typeDefinition < typeDefinitions + s_GlobalMetadataHeader->typeDefinitionsSize / sizeof(Il2CppTypeDefinition));

    ptrdiff_t index = typeDefinition - typeDefinitions;
    IL2CPP_ASSERT(index <= std::numeric_limits<TypeDefinitionIndex>::max());
    return static_cast<TypeDefinitionIndex>(index);
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeDefinitionIndex(TypeDefinitionIndex index)
{
    if (index == kTypeIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) < s_GlobalMetadataHeader->typeDefinitionsSize / sizeof(Il2CppTypeDefinition));

    return utils::InitOnce(&s_TypeInfoDefinitionTable[index], &il2cpp::vm::g_MetadataLock, [index](il2cpp::os::FastAutoLock& _) { return FromTypeDefinition(index); });
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle(Il2CppMetadataTypeHandle handle)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(handle);
    return GetTypeInfoFromTypeDefinitionIndex(GetIndexForTypeDefinitionInternal(typeDefinition));
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetTypeInfoFromType(const Il2CppType* type)
{
    return GetTypeInfoFromHandle(type->data.typeHandle);
}

const Il2CppType* il2cpp::vm::GlobalMetadata::GetInterfaceFromOffset(const Il2CppClass* klass, TypeInterfaceIndex offset)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    IL2CPP_ASSERT(offset >= 0 && offset < typeDefinition->interfaces_count);

    InterfacesIndex index = typeDefinition->interfacesStart + offset;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->interfacesSize / sizeof(TypeIndex));
    const TypeIndex* interfaceIndices = (const TypeIndex*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->interfacesOffset);

    return GetIl2CppTypeFromIndex(interfaceIndices[index]);
}

Il2CppInterfaceOffsetInfo il2cpp::vm::GlobalMetadata::GetInterfaceOffsetInfo(const Il2CppClass* klass, TypeInterfaceOffsetIndex index)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    IL2CPP_ASSERT(index >= 0 && index < typeDefinition->interface_offsets_count);

    index = index + typeDefinition->interfaceOffsetsStart;
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->interfaceOffsetsSize / sizeof(Il2CppInterfaceOffsetPair));
    const Il2CppInterfaceOffsetPair* interfaceOffsets = (const Il2CppInterfaceOffsetPair*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->interfaceOffsetsOffset);

    return
        {
            GetIl2CppTypeFromIndex(interfaceOffsets[index].interfaceTypeIndex),
            interfaceOffsets[index].offset
        };
}

Il2CppMetadataTypeHandle il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(TypeDefinitionIndex typeIndex)
{
    return reinterpret_cast<Il2CppMetadataTypeHandle>(GetTypeDefinitionForIndex(typeIndex));
}

Il2CppMetadataTypeHandle il2cpp::vm::GlobalMetadata::GetTypeHandleFromType(const Il2CppType* type)
{
    IL2CPP_ASSERT(type->type == IL2CPP_TYPE_CLASS || type->type == IL2CPP_TYPE_VALUETYPE);
    return type->data.typeHandle;
}

bool il2cpp::vm::GlobalMetadata::TypeIsNested(Il2CppMetadataTypeHandle handle)
{
    return reinterpret_cast<const Il2CppTypeDefinition*>(handle)->declaringTypeIndex != kTypeIndexInvalid;
}

bool il2cpp::vm::GlobalMetadata::TypeIsValueType(Il2CppMetadataTypeHandle handle)
{
    return (reinterpret_cast<const Il2CppTypeDefinition*>(handle)->bitfield >> (kBitIsValueType - 1)) & 0x1;
}

bool il2cpp::vm::GlobalMetadata::StructLayoutPackIsDefault(Il2CppMetadataTypeHandle handle)
{
    return (reinterpret_cast<const Il2CppTypeDefinition*>(handle)->bitfield >> (kPackingSizeIsDefault - 1)) & 0x1;
}

bool il2cpp::vm::GlobalMetadata::StructLayoutSizeIsDefault(Il2CppMetadataTypeHandle handle)
{
    return (reinterpret_cast<const Il2CppTypeDefinition*>(handle)->bitfield >> (kClassSizeIsDefault - 1)) & 0x1;
}

std::pair<const char*, const char*> il2cpp::vm::GlobalMetadata::GetTypeNamespaceAndName(Il2CppMetadataTypeHandle handle)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(handle);
    return std::make_pair
        (
        GetStringFromIndex(typeDefinition->namespaceIndex),
        GetStringFromIndex(typeDefinition->nameIndex)
        );
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetNestedTypeFromOffset(const Il2CppClass* klass, TypeNestedTypeIndex offset)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    IL2CPP_ASSERT(offset >= 0 && offset < typeDefinition->nested_type_count);

    NestedTypeIndex index = typeDefinition->nestedTypesStart + offset;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->nestedTypesSize / sizeof(TypeDefinitionIndex));

    const TypeDefinitionIndex* nestedTypeIndices = (const TypeDefinitionIndex*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->nestedTypesOffset);

    return GetTypeInfoFromTypeDefinitionIndex(nestedTypeIndices[index]);
}

Il2CppMetadataTypeHandle il2cpp::vm::GlobalMetadata::GetNestedTypes(Il2CppMetadataTypeHandle handle, void** iter)
{
    if (!iter)
        return NULL;

    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(handle);

    const TypeDefinitionIndex* nestedTypeIndices = (const TypeDefinitionIndex*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->nestedTypesOffset);

    if (!*iter)
    {
        if (typeDefinition->nested_type_count == 0)
            return NULL;

        *iter = (void*)(nestedTypeIndices + typeDefinition->nestedTypesStart);
        return GetTypeHandleFromIndex(nestedTypeIndices[typeDefinition->nestedTypesStart]);
    }

    TypeDefinitionIndex* nestedTypeAddress = (TypeDefinitionIndex*)*iter;
    nestedTypeAddress++;
    ptrdiff_t index = nestedTypeAddress - nestedTypeIndices;

    if (index < typeDefinition->nestedTypesStart + typeDefinition->nested_type_count)
    {
        *iter = nestedTypeAddress;
        return GetTypeHandleFromIndex(*nestedTypeAddress);
    }

    return NULL;
}

static void InitializeCustomAttributesCaches(void* param)
{
    s_CustomAttributesCount = 0;
    for (int i = 0; i < s_MetadataImagesCount; i++)
    {
        s_CustomAttributesCount += s_MetadataImagesTable[i].image->customAttributeCount;
    }
}

static int CompareTokens(const void* pkey, const void* pelem)
{
    return (int)(((Il2CppCustomAttributeDataRange*)pkey)->token - ((Il2CppCustomAttributeDataRange*)pelem)->token);
}

static const Il2CppImageGlobalMetadata* GetImageForCustomAttributeIndex(CustomAttributeIndex index)
{
    for (int32_t imageIndex = 0; imageIndex < s_MetadataImagesCount; imageIndex++)
    {
        const Il2CppImageGlobalMetadata* imageMetadta = s_MetadataImagesTable + imageIndex;
        IL2CPP_ASSERT(index >= 0);
        if (index >= imageMetadta->customAttributeStart && static_cast<uint32_t>(index) < (imageMetadta->customAttributeStart + imageMetadta->image->customAttributeCount))
            return imageMetadta;
    }

    IL2CPP_ASSERT(0 && "Failed to find owning image for custom attribute index");
    return NULL;
}

static CustomAttributeIndex GetCustomAttributeIndex(const Il2CppCustomAttributeDataRange* attrDataRange)
{
    if (attrDataRange == NULL)
        return kCustomAttributeIndexInvalid;

    const Il2CppCustomAttributeDataRange* attributeTypeRangeStart = MetadataOffset<const Il2CppCustomAttributeDataRange*>(s_GlobalMetadata, s_GlobalMetadataHeader->attributeDataRangeOffset, 0);

    CustomAttributeIndex index = (CustomAttributeIndex)(attrDataRange - attributeTypeRangeStart);

    IL2CPP_ASSERT(index >= 0 && index < (CustomAttributeIndex)(s_GlobalMetadataHeader->attributeDataRangeSize / sizeof(Il2CppCustomAttributeDataRange)));

    return index;
}

static const Il2CppImage* GetCustomAttributeImageFromHandle(Il2CppMetadataCustomAttributeHandle handle)
{
    if (handle == NULL)
        return NULL;

    const Il2CppCustomAttributeDataRange *dataRange = reinterpret_cast<const Il2CppCustomAttributeDataRange*>(handle);

    CustomAttributeIndex index = GetCustomAttributeIndex(dataRange);
    const Il2CppImageGlobalMetadata* imageMetadata = GetImageForCustomAttributeIndex(index);
    if (imageMetadata == NULL)
        return NULL;

    return imageMetadata->image;
}

static CustomAttributeIndex GetCustomAttributeIndex(const Il2CppImage* image, uint32_t token)
{
    const Il2CppCustomAttributeDataRange* attrDataRange = reinterpret_cast<const Il2CppCustomAttributeDataRange*>(il2cpp::vm::GlobalMetadata::GetCustomAttributeTypeToken(image, token));
    return GetCustomAttributeIndex(attrDataRange);
}

Il2CppMetadataCustomAttributeHandle il2cpp::vm::GlobalMetadata::GetCustomAttributeTypeToken(const Il2CppImage* image, uint32_t token)
{
    const Il2CppCustomAttributeDataRange* attributeTypeRange = MetadataOffset<const Il2CppCustomAttributeDataRange*>(s_GlobalMetadata, s_GlobalMetadataHeader->attributeDataRangeOffset, 0);

    Il2CppCustomAttributeDataRange key = {0};
    key.token = token;

    const Il2CppImageGlobalMetadata* imageMetadata = GetImageMetadata(image);
    const Il2CppCustomAttributeDataRange* res = (const Il2CppCustomAttributeDataRange*)bsearch(&key, attributeTypeRange + imageMetadata->customAttributeStart, image->customAttributeCount, sizeof(Il2CppCustomAttributeDataRange), CompareTokens);
    return reinterpret_cast<Il2CppMetadataCustomAttributeHandle>(res);
}

static il2cpp::metadata::CustomAttributeDataReader CreateCustomAttributeDataReader(Il2CppMetadataCustomAttributeHandle handle, const Il2CppImage* image)
{
    if (handle == NULL)
        return il2cpp::metadata::CustomAttributeDataReader::Empty();

    Il2CppCustomAttributeDataRange* range = (Il2CppCustomAttributeDataRange*)handle;
    const Il2CppCustomAttributeDataRange* next = range + 1;

    void* start = MetadataOffset<uint8_t*>(s_GlobalMetadata, s_GlobalMetadataHeader->attributeDataOffset, range->startOffset);
    void* end = MetadataOffset<uint8_t*>(s_GlobalMetadata, s_GlobalMetadataHeader->attributeDataOffset, next->startOffset);

    return il2cpp::metadata::CustomAttributeDataReader(image, start, end);
}

il2cpp::metadata::CustomAttributeDataReader il2cpp::vm::GlobalMetadata::GetCustomAttributeDataReader(const Il2CppImage* image, uint32_t token)
{
    return CreateCustomAttributeDataReader(GetCustomAttributeTypeToken(image, token), image);
}

il2cpp::metadata::CustomAttributeDataReader il2cpp::vm::GlobalMetadata::GetCustomAttributeDataReader(Il2CppMetadataCustomAttributeHandle handle)
{
    return CreateCustomAttributeDataReader(handle, GetCustomAttributeImageFromHandle(handle));
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetMethodInfoFromVTableSlot(const Il2CppClass* klass, int32_t vTableSlot)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    uint32_t index = typeDefinition->vtableStart + vTableSlot;
    IL2CPP_ASSERT(index >= 0 && index <= s_GlobalMetadataHeader->vtableMethodsSize / sizeof(EncodedMethodIndex));
    const EncodedMethodIndex* vTableMethodReferences = (const EncodedMethodIndex*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->vtableMethodsOffset);
    EncodedMethodIndex vTableMethodReference = vTableMethodReferences[index];
    return GetMethodInfoFromEncodedIndex(vTableMethodReference);
}

static int CompareFieldDefaultValues(const void* pkey, const void* pelem)
{
    return (int)(((Il2CppFieldDefaultValue*)pkey)->fieldIndex - ((Il2CppFieldDefaultValue*)pelem)->fieldIndex);
}

static const Il2CppFieldDefaultValue* GetFieldDefaultValueEntry(const FieldInfo* field)
{
    Il2CppClass* parent = field->parent;
    FieldIndex fieldIndex = (FieldIndex)(field - parent->fields);

    if (il2cpp::vm::Type::IsGenericInstance(&parent->byval_arg))
        parent = il2cpp::vm::GenericClass::GetTypeDefinition(parent->generic_class);

    fieldIndex += reinterpret_cast<const Il2CppTypeDefinition*>(parent->typeMetadataHandle)->fieldStart;

    Il2CppFieldDefaultValue key;
    key.fieldIndex = fieldIndex;

    const Il2CppFieldDefaultValue *start = (const Il2CppFieldDefaultValue*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->fieldDefaultValuesOffset);
    const Il2CppFieldDefaultValue* res = (const Il2CppFieldDefaultValue*)bsearch(&key, start, s_GlobalMetadataHeader->fieldDefaultValuesSize / sizeof(Il2CppFieldDefaultValue), sizeof(Il2CppFieldDefaultValue), CompareFieldDefaultValues);
    return res;
}

static const uint8_t* GetFieldOrParameterDefalutValue(uint32_t index)
{
    if (index == kDefaultValueIndexNull)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && index <= s_GlobalMetadataHeader->fieldAndParameterDefaultValueDataSize / sizeof(uint8_t));
    const uint8_t* defaultValuesData =  (const uint8_t*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->fieldAndParameterDefaultValueDataOffset);
    return defaultValuesData + index;
}

const uint8_t* il2cpp::vm::GlobalMetadata::GetFieldDefaultValue(const FieldInfo* field, const Il2CppType** type)
{
    const Il2CppFieldDefaultValue* entry = GetFieldDefaultValueEntry(field);

    if (entry != NULL)
    {
        *type = GetIl2CppTypeFromIndex(entry->typeIndex);
        return GetFieldOrParameterDefalutValue(entry->dataIndex);
    }

    return NULL;
}

static int CompareParameterDefaultValues(const void* pkey, const void* pelem)
{
    return (int)(((Il2CppParameterDefaultValue*)pkey)->parameterIndex - ((Il2CppParameterDefaultValue*)pelem)->parameterIndex);
}

static const Il2CppParameterDefaultValue * GetParameterDefaultValueEntry(const MethodInfo* method, int32_t parameterPosition)
{
    if (il2cpp::vm::Method::IsGenericInstance(method))
        method = il2cpp::vm::MetadataCache::GetGenericMethodDefinition(method);

    IL2CPP_ASSERT(!il2cpp::vm::Method::IsGenericInstance(method));

    const Il2CppMethodDefinition* methodDefinition = reinterpret_cast<const Il2CppMethodDefinition*>(method->methodMetadataHandle);
    if (methodDefinition == NULL)
        return NULL;

    ParameterIndex parameterIndex = methodDefinition->parameterStart + parameterPosition;
    Il2CppParameterDefaultValue key;
    key.parameterIndex = parameterIndex;

    const Il2CppParameterDefaultValue *start = (const Il2CppParameterDefaultValue*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->parameterDefaultValuesOffset);
    const Il2CppParameterDefaultValue* res = (const Il2CppParameterDefaultValue*)bsearch(&key, start, s_GlobalMetadataHeader->parameterDefaultValuesSize / sizeof(Il2CppParameterDefaultValue), sizeof(Il2CppParameterDefaultValue), CompareParameterDefaultValues);
    return res;
}

const uint8_t* il2cpp::vm::GlobalMetadata::GetParameterDefaultValue(const MethodInfo* method, int32_t parameterPosition, const Il2CppType** type, bool* isExplicitySetNullDefaultValue)
{
    *isExplicitySetNullDefaultValue = false;
    const Il2CppParameterDefaultValue* parameterDefaultValue = GetParameterDefaultValueEntry(method, parameterPosition);

    if (parameterDefaultValue != NULL)
    {
        *type = GetIl2CppTypeFromIndex(parameterDefaultValue->typeIndex);
        *isExplicitySetNullDefaultValue = parameterDefaultValue->dataIndex == kDefaultValueIndexNull;
        return GetFieldOrParameterDefalutValue(parameterDefaultValue->dataIndex);
    }

    return NULL;
}

static TypeDefinitionIndex GetIndexForTypeDefinition(const Il2CppClass* klass)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);
    return GetIndexForTypeDefinitionInternal(typeDefinition);
}

uint32_t il2cpp::vm::GlobalMetadata::GetFieldOffset(const Il2CppClass* klass, int32_t fieldIndexInType, FieldInfo* field)
{
    uint32_t typeIndex = GetIndexForTypeDefinition(klass);
    IL2CPP_ASSERT(typeIndex <= static_cast<uint32_t>(s_Il2CppMetadataRegistration->typeDefinitionsSizesCount));
    int32_t offset = s_Il2CppMetadataRegistration->fieldOffsets[typeIndex][fieldIndexInType];
    return offset;
}

static int CompareFieldMarshaledSize(const void* pkey, const void* pelem)
{
    return (int)(((Il2CppFieldMarshaledSize*)pkey)->fieldIndex - ((Il2CppFieldMarshaledSize*)pelem)->fieldIndex);
}

int il2cpp::vm::GlobalMetadata::GetFieldMarshaledSizeForField(const FieldInfo* field)
{
    Il2CppClass* parent = field->parent;
    size_t fieldIndex = (field - parent->fields);

    if (il2cpp::vm::Type::IsGenericInstance(&parent->byval_arg))
        parent = il2cpp::vm::GenericClass::GetTypeDefinition(parent->generic_class);

    fieldIndex += reinterpret_cast<const Il2CppTypeDefinition*>(parent->typeMetadataHandle)->fieldStart;

    const Il2CppFieldMarshaledSize *start = (const Il2CppFieldMarshaledSize*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->fieldMarshaledSizesOffset);

    Il2CppFieldMarshaledSize key;
    key.fieldIndex = (FieldIndex)fieldIndex;
    const Il2CppFieldMarshaledSize* res = (const Il2CppFieldMarshaledSize*)bsearch(&key, start, s_GlobalMetadataHeader->fieldMarshaledSizesSize / sizeof(Il2CppFieldMarshaledSize), sizeof(Il2CppFieldMarshaledSize), CompareFieldMarshaledSize);

    if (res != NULL)
        return res->size;
    return -1;
}

static const Il2CppFieldDefinition* GetFieldDefinitionFromIndex(const Il2CppImage* image, FieldIndex index)
{
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->fieldsSize / sizeof(Il2CppFieldDefinition));
    const Il2CppFieldDefinition* fields = (const Il2CppFieldDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->fieldsOffset);
    return fields + index;
}

Il2CppMetadataFieldInfo il2cpp::vm::GlobalMetadata::GetFieldInfo(const Il2CppClass* klass, TypeFieldIndex fieldIndex)
{
    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    IL2CPP_ASSERT(typeDefinition != NULL);
    IL2CPP_ASSERT(fieldIndex >= 0 && fieldIndex < typeDefinition->field_count);
    IL2CPP_ASSERT(typeDefinition->fieldStart != kFieldIndexInvalid);

    const Il2CppFieldDefinition* fieldDefinition = GetFieldDefinitionFromIndex(klass->image, typeDefinition->fieldStart + fieldIndex);

    return {
            GetIl2CppTypeFromIndex(fieldDefinition->typeIndex),
            GetStringFromIndex(fieldDefinition->nameIndex),
            fieldDefinition->token
    };
}

Il2CppMetadataMethodInfo il2cpp::vm::GlobalMetadata::GetMethodInfo(const Il2CppClass* klass, TypeMethodIndex index)
{
    const uint16_t kFlagIsUnmanagedCallersOnly = 0x8000;

    const Il2CppTypeDefinition* typeDefinition = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    IL2CPP_ASSERT(typeDefinition != NULL);
    IL2CPP_ASSERT(index >= 0 && index < typeDefinition->method_count);
    IL2CPP_ASSERT(typeDefinition->methodStart != kMethodIndexInvalid);

    const Il2CppMethodDefinition* methodDefinition = GetMethodDefinitionFromIndex(typeDefinition->methodStart + index);

    return {
            reinterpret_cast<Il2CppMetadataMethodDefinitionHandle>(methodDefinition),
            GetStringFromIndex(methodDefinition->nameIndex),
            GetIl2CppTypeFromIndex(methodDefinition->returnType),
            methodDefinition->token,
            methodDefinition->flags,
            (uint16_t)(methodDefinition->iflags & ~kFlagIsUnmanagedCallersOnly),
            methodDefinition->slot,
            methodDefinition->parameterCount,
            (bool)(methodDefinition->iflags & kFlagIsUnmanagedCallersOnly),
    };
}

Il2CppMetadataParameterInfo il2cpp::vm::GlobalMetadata::GetParameterInfo(const Il2CppClass* klass, Il2CppMetadataMethodDefinitionHandle handle, MethodParameterIndex paramIndex)
{
    const Il2CppMethodDefinition* methodDefinition = reinterpret_cast<const Il2CppMethodDefinition*>(handle);

    IL2CPP_ASSERT(methodDefinition != NULL);
    IL2CPP_ASSERT(paramIndex >= 0 && paramIndex < methodDefinition->parameterCount);

    const Il2CppParameterDefinition* parameterDefinition = GetParameterDefinitionFromIndex(klass->image, methodDefinition->parameterStart + paramIndex);

    return {
            GetStringFromIndex(parameterDefinition->nameIndex),
            parameterDefinition->token,
            GetIl2CppTypeFromIndex(parameterDefinition->typeIndex),
    };
}

Il2CppMetadataPropertyInfo il2cpp::vm::GlobalMetadata::GetPropertyInfo(const Il2CppClass* klass, TypePropertyIndex index)
{
    const Il2CppTypeDefinition* typeDefintion = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    IL2CPP_ASSERT(typeDefintion != NULL);
    IL2CPP_ASSERT(index >= 0 && index < typeDefintion->property_count);
    IL2CPP_ASSERT(typeDefintion->propertyStart != kPropertyIndexInvalid);

    const Il2CppPropertyDefinition* propertyDefintion = GetPropertyDefinitionFromIndex(klass->image, typeDefintion->propertyStart + index);

    return {
            GetStringFromIndex(propertyDefintion->nameIndex),
            propertyDefintion->get != kMethodIndexInvalid ? klass->methods[propertyDefintion->get] : NULL,
            propertyDefintion->set != kMethodIndexInvalid ? klass->methods[propertyDefintion->set] : NULL,
            propertyDefintion->attrs,
            propertyDefintion->token,
    };
}

Il2CppMetadataEventInfo il2cpp::vm::GlobalMetadata::GetEventInfo(const Il2CppClass* klass, TypeEventIndex index)
{
    const Il2CppTypeDefinition* typeDefintion = reinterpret_cast<const Il2CppTypeDefinition*>(klass->typeMetadataHandle);

    IL2CPP_ASSERT(typeDefintion != NULL);
    IL2CPP_ASSERT(index >= 0 && index < typeDefintion->event_count);

    const Il2CppEventDefinition* eventDefintion = GetEventDefinitionFromIndex(klass->image, typeDefintion->eventStart + index);

    return {
            GetStringFromIndex(eventDefintion->nameIndex),
            GetIl2CppTypeFromIndex(eventDefintion->typeIndex),
            eventDefintion->add != kMethodIndexInvalid ? klass->methods[eventDefintion->add] : NULL,
            eventDefintion->remove != kMethodIndexInvalid ? klass->methods[eventDefintion->remove] : NULL,
            eventDefintion->raise != kMethodIndexInvalid ? klass->methods[eventDefintion->raise] : NULL,
            eventDefintion->token,
    };
}

uint32_t il2cpp::vm::GlobalMetadata::GetReturnParameterToken(Il2CppMetadataMethodDefinitionHandle handle)
{
    const Il2CppMethodDefinition* methodDefinition = reinterpret_cast<const Il2CppMethodDefinition*>(handle);

    IL2CPP_ASSERT(methodDefinition != NULL);

    return methodDefinition->returnParameterToken;
}

static const Il2CppGenericContainer* GetGenericContainerFromIndexInternal(GenericContainerIndex index)
{
    if (index == kGenericContainerIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->genericContainersSize / sizeof(Il2CppGenericContainer));
    const Il2CppGenericContainer* genericContainers = (const Il2CppGenericContainer*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->genericContainersOffset);
    return genericContainers + index;
}

static Il2CppMetadataGenericContainerHandle GetGenericContainerFromIndex(GenericContainerIndex index)
{
    const Il2CppGenericContainer* container = GetGenericContainerFromIndexInternal(index);
    return reinterpret_cast<Il2CppMetadataGenericContainerHandle>(container);
}

Il2CppMetadataGenericContainerHandle il2cpp::vm::GlobalMetadata::GetGenericContainerFromGenericClass(const Il2CppGenericClass* genericClass)
{
    const Il2CppTypeDefinition* genericType = reinterpret_cast<const Il2CppTypeDefinition*>(GetTypeHandleFromType(genericClass->type));
    return GetGenericContainerFromIndex(genericType->genericContainerIndex);
}

Il2CppMetadataGenericContainerHandle il2cpp::vm::GlobalMetadata::GetGenericContainerFromMethod(Il2CppMetadataMethodDefinitionHandle handle)
{
    const Il2CppMethodDefinition* methodDefinition = reinterpret_cast<const Il2CppMethodDefinition*>(handle);
    return GetGenericContainerFromIndex(methodDefinition->genericContainerIndex);
}

const Il2CppGenericMethod* il2cpp::vm::GlobalMetadata::GetGenericMethodFromTokenMethodTuple(const Il2CppTokenIndexMethodTuple* tuple)
{
    return GetGenericMethodFromIndex(tuple->__genericMethodIndex);
}

static Il2CppMetadataGenericParameterHandle GetGenericParameterFromIndexInternal(GenericParameterIndex index)
{
    if (index == kGenericParameterIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->genericParametersSize / sizeof(Il2CppGenericParameter));
    const Il2CppGenericParameter* genericParameters = (const Il2CppGenericParameter*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->genericParametersOffset);
    return reinterpret_cast<Il2CppMetadataGenericParameterHandle>(genericParameters + index);
}

Il2CppMetadataGenericParameterHandle il2cpp::vm::GlobalMetadata::GetGenericParameterFromType(const Il2CppType* type)
{
    IL2CPP_ASSERT(type->type == IL2CPP_TYPE_VAR || type->type == IL2CPP_TYPE_MVAR);
    return type->data.genericParameterHandle;
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetContainerDeclaringType(Il2CppMetadataGenericContainerHandle handle)
{
    const Il2CppGenericContainer* genericContainer = reinterpret_cast<const Il2CppGenericContainer*>(handle);

    if (genericContainer->is_method)
        return GetMethodInfoFromMethodDefinitionIndex(genericContainer->ownerIndex)->klass;

    return GetTypeInfoFromTypeDefinitionIndex(genericContainer->ownerIndex);
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetParameterDeclaringType(Il2CppMetadataGenericParameterHandle handle)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);

    const Il2CppGenericContainer* genericContainer =  GetGenericContainerFromIndexInternal(genericParameter->ownerIndex);

    if (genericContainer->is_method)
        return GetMethodInfoFromMethodDefinitionIndex(genericContainer->ownerIndex)->klass;

    return GetTypeInfoFromTypeDefinitionIndex(genericContainer->ownerIndex);
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetParameterDeclaringMethod(Il2CppMetadataGenericParameterHandle handle)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);

    const Il2CppGenericContainer* genericContainer =  GetGenericContainerFromIndexInternal(genericParameter->ownerIndex);

    if (genericContainer->is_method)
        return GetMethodInfoFromMethodDefinitionIndex(genericContainer->ownerIndex);

    return NULL;
}

Il2CppMetadataGenericParameterHandle il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex(Il2CppMetadataGenericContainerHandle handle, GenericContainerParameterIndex index)
{
    const Il2CppGenericContainer* genericContainer = reinterpret_cast<const Il2CppGenericContainer*>(handle);

    IL2CPP_ASSERT(index >= 0 && index < genericContainer->type_argc);

    return GetGenericParameterFromIndexInternal(genericContainer->genericParameterStart + index);
}

const Il2CppType* il2cpp::vm::GlobalMetadata::GetGenericParameterConstraintFromIndex(Il2CppMetadataGenericParameterHandle handle, GenericParameterConstraintIndex index)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);

    IL2CPP_ASSERT(index >= 0 && index < genericParameter->constraintsCount);

    index = genericParameter->constraintsStart + index;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->genericParameterConstraintsSize / sizeof(TypeIndex));
    const TypeIndex* constraintIndices = (const TypeIndex*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->genericParameterConstraintsOffset);

    return GetIl2CppTypeFromIndex(constraintIndices[index]);
}

static GenericParameterIndex GetIndexForGenericParameter(Il2CppMetadataGenericParameterHandle handle)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);
    const Il2CppGenericParameter* genericParameters = (const Il2CppGenericParameter*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->genericParametersOffset);

    IL2CPP_ASSERT(genericParameter >= genericParameters && genericParameter < genericParameters + s_GlobalMetadataHeader->genericParametersSize / sizeof(Il2CppGenericParameter));

    ptrdiff_t index = genericParameter - genericParameters;
    IL2CPP_ASSERT(index <= std::numeric_limits<GenericParameterIndex>::max());
    return static_cast<GenericParameterIndex>(index);
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetGenericInstanceMethod(const MethodInfo* genericMethodDefinition, const Il2CppGenericContext* context)
{
    const MethodInfo* method = genericMethodDefinition;
    const Il2CppGenericInst* classInst = context->class_inst;
    const Il2CppGenericInst* methodInst = context->method_inst;
    if (genericMethodDefinition->is_inflated)
    {
        IL2CPP_ASSERT(genericMethodDefinition->klass->generic_class);
        classInst = genericMethodDefinition->klass->generic_class->context.class_inst;
        method = genericMethodDefinition->genericMethod->methodDefinition;
    }

    return il2cpp::metadata::GenericMethod::GetMethod(method, classInst, methodInst);
}

const Il2CppType* il2cpp::vm::GlobalMetadata::GetTypeFromRgctxDefinition(const Il2CppRGCTXDefinition* rgctxDef)
{
    IL2CPP_ASSERT(rgctxDef->type == IL2CPP_RGCTX_DATA_TYPE || rgctxDef->type == IL2CPP_RGCTX_DATA_CLASS);
    return GetIl2CppTypeFromIndex(((const Il2CppRGCTXDefinitionData*)rgctxDef->data)->__typeIndex);
}

const Il2CppGenericMethod* il2cpp::vm::GlobalMetadata::GetGenericMethodFromRgctxDefinition(const Il2CppRGCTXDefinition* rgctxDef)
{
    IL2CPP_ASSERT(rgctxDef->type == IL2CPP_RGCTX_DATA_METHOD);
    return GetGenericMethodFromIndex(((const Il2CppRGCTXDefinitionData*)rgctxDef->data)->__methodIndex);
}

std::pair<const Il2CppType*, const MethodInfo*> il2cpp::vm::GlobalMetadata::GetConstrainedCallFromRgctxDefinition(const Il2CppRGCTXDefinition* rgctxDef)
{
    IL2CPP_ASSERT(rgctxDef->type == IL2CPP_RGCTX_DATA_CONSTRAINED);

    const Il2CppRGCTXConstrainedData* constrainedData = (const Il2CppRGCTXConstrainedData*)rgctxDef->data;

    const Il2CppType* type = GetIl2CppTypeFromIndex(constrainedData->__typeIndex);
    const MethodInfo* method = GetMethodInfoFromEncodedIndex(constrainedData->__encodedMethodIndex);
    return std::make_pair(type, method);
}

enum PackingSize
{
    Zero,
    One,
    Two,
    Four,
    Eight,
    Sixteen,
    ThirtyTwo,
    SixtyFour,
    OneHundredTwentyEight
};

static uint8_t ConvertPackingSizeEnumToValue(PackingSize packingSize)
{
    switch (packingSize)
    {
        case Zero:
            return 0;
        case One:
            return 1;
        case Two:
            return 2;
        case Four:
            return 4;
        case Eight:
            return 8;
        case Sixteen:
            return 16;
        case ThirtyTwo:
            return 32;
        case SixtyFour:
            return 64;
        case OneHundredTwentyEight:
            return 128;
        default:
            Assert(0 && "Invalid packing size!");
            return 0;
    }
}

int32_t il2cpp::vm::GlobalMetadata::StructLayoutPack(Il2CppMetadataTypeHandle handle)
{
    return ConvertPackingSizeEnumToValue(static_cast<PackingSize>((reinterpret_cast<const Il2CppTypeDefinition*>(handle)->bitfield >> (kSpecifiedPackingSize - 1)) & 0xF));
}

static const Il2CppImage* GetImageForTypeDefinitionIndex(TypeDefinitionIndex index)
{
    for (int32_t imageIndex = 0; imageIndex < s_MetadataImagesCount; imageIndex++)
    {
        const Il2CppImageGlobalMetadata* imageMetadata = s_MetadataImagesTable + imageIndex;
        IL2CPP_ASSERT(index >= 0);
        if (index >= imageMetadata->typeStart && static_cast<uint32_t>(index) < (imageMetadata->typeStart + imageMetadata->image->typeCount))
            return imageMetadata->image;
    }

    IL2CPP_ASSERT(0 && "Failed to find owning image for type defintion index");
    return NULL;
}

static Il2CppClass* FromTypeDefinition(TypeDefinitionIndex index)
{
    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) < s_GlobalMetadataHeader->typeDefinitionsSize / sizeof(Il2CppTypeDefinition));
    const Il2CppTypeDefinition* typeDefinitions = (const Il2CppTypeDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->typeDefinitionsOffset);
    const Il2CppTypeDefinition* typeDefinition = typeDefinitions + index;
    const Il2CppTypeDefinitionSizes* typeDefinitionSizes = s_Il2CppMetadataRegistration->typeDefinitionsSizes[index];
    Il2CppClass* typeInfo = (Il2CppClass*)IL2CPP_CALLOC(1, sizeof(Il2CppClass) + (sizeof(VirtualInvokeData) * typeDefinition->vtable_count));
    typeInfo->klass = typeInfo;
    typeInfo->image = GetImageForTypeDefinitionIndex(index);
    typeInfo->name = GetStringFromIndex(typeDefinition->nameIndex);
    typeInfo->namespaze = GetStringFromIndex(typeDefinition->namespaceIndex);
    typeInfo->byval_arg = *il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDefinition->byvalTypeIndex);
    typeInfo->this_arg = typeInfo->byval_arg;
    typeInfo->this_arg.byref = true;
    typeInfo->this_arg.valuetype = 0;
    typeInfo->typeMetadataHandle = reinterpret_cast<const Il2CppMetadataTypeHandle>(typeDefinition);
    typeInfo->genericContainerHandle = GetGenericContainerFromIndex(typeDefinition->genericContainerIndex);
    typeInfo->instance_size = typeDefinitionSizes->instance_size;
    typeInfo->actualSize = typeDefinitionSizes->instance_size;     // actualySize is instance_size for compiler generated values
    typeInfo->native_size = typeDefinitionSizes->native_size;
    typeInfo->static_fields_size = typeDefinitionSizes->static_fields_size;
    typeInfo->thread_static_fields_size = typeDefinitionSizes->thread_static_fields_size;
    typeInfo->thread_static_fields_offset = -1;
    typeInfo->flags = typeDefinition->flags;
    typeInfo->enumtype = (typeDefinition->bitfield >> (kBitIsEnum - 1)) & 0x1;
    typeInfo->is_generic = typeDefinition->genericContainerIndex != kGenericContainerIndexInvalid;     // generic if we have a generic container
    typeInfo->has_finalize = (typeDefinition->bitfield >> (kBitHasFinalizer - 1)) & 0x1;
    typeInfo->has_cctor = (typeDefinition->bitfield >> (kBitHasStaticConstructor - 1)) & 0x1;
    typeInfo->cctor_finished_or_no_cctor = !typeInfo->has_cctor;
    typeInfo->is_blittable = (typeDefinition->bitfield >> (kBitIsBlittable - 1)) & 0x1;
    typeInfo->is_import_or_windows_runtime = (typeDefinition->bitfield >> (kBitIsImportOrWindowsRuntime - 1)) & 0x1;
    typeInfo->packingSize = ConvertPackingSizeEnumToValue(static_cast<PackingSize>((typeDefinition->bitfield >> (kPackingSize - 1)) & 0xF));
    typeInfo->is_byref_like = (typeDefinition->bitfield >> (kBitIsByRefLike - 1)) & 0x1;
    typeInfo->method_count = typeDefinition->method_count;
    typeInfo->property_count = typeDefinition->property_count;
    typeInfo->field_count = typeDefinition->field_count;
    typeInfo->event_count = typeDefinition->event_count;
    typeInfo->nested_type_count = typeDefinition->nested_type_count;
    typeInfo->vtable_count = typeDefinition->vtable_count;
    typeInfo->interfaces_count = typeDefinition->interfaces_count;
    typeInfo->interface_offsets_count = typeDefinition->interface_offsets_count;
    typeInfo->token = typeDefinition->token;
    typeInfo->interopData = il2cpp::vm::MetadataCache::GetInteropDataForType(&typeInfo->byval_arg);

    if (typeDefinition->parentIndex != kTypeIndexInvalid)
        typeInfo->parent = il2cpp::vm::Class::FromIl2CppType(il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDefinition->parentIndex));

    if (typeDefinition->declaringTypeIndex != kTypeIndexInvalid)
        typeInfo->declaringType = il2cpp::vm::Class::FromIl2CppType(il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDefinition->declaringTypeIndex));

    typeInfo->castClass = typeInfo->element_class = typeInfo;
    if (typeInfo->enumtype)
        typeInfo->castClass = typeInfo->element_class = il2cpp::vm::Class::FromIl2CppType(il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(typeDefinition->elementTypeIndex));

    return typeInfo;
}

const Il2CppType* il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(TypeIndex index)
{
    if (index == kTypeIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index < s_Il2CppMetadataRegistration->typesCount && "Invalid type index ");

    return s_Il2CppMetadataRegistration->types[index];
}

uint32_t il2cpp::vm::GlobalMetadata::GetGenericContainerCount(Il2CppMetadataGenericContainerHandle handle)
{
    const Il2CppGenericContainer* container = reinterpret_cast<const Il2CppGenericContainer*>(handle);
    return container != NULL ? container->type_argc : 0;
}

void il2cpp::vm::GlobalMetadata::MakeGenericArgType(Il2CppMetadataGenericContainerHandle containerHandle, Il2CppMetadataGenericParameterHandle paramHandle, Il2CppType* arg)
{
    const Il2CppGenericContainer* container = reinterpret_cast<const Il2CppGenericContainer*>(containerHandle);

    arg->type = container->is_method ? IL2CPP_TYPE_MVAR : IL2CPP_TYPE_VAR;
    arg->data.genericParameterHandle = paramHandle;
}

bool il2cpp::vm::GlobalMetadata::GetGenericContainerIsMethod(Il2CppMetadataGenericContainerHandle handle)
{
    const Il2CppGenericContainer* container = reinterpret_cast<const Il2CppGenericContainer*>(handle);
    IL2CPP_ASSERT(container != NULL);
    return container != NULL ? container->is_method : false;
}

int16_t il2cpp::vm::GlobalMetadata::GetGenericConstraintCount(Il2CppMetadataGenericParameterHandle handle)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);
    return genericParameter->constraintsCount;
}

const char* il2cpp::vm::GlobalMetadata::GetGenericParameterName(Il2CppMetadataGenericParameterHandle handle)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);
    return GetStringFromIndex(genericParameter->nameIndex);
}

Il2CppGenericParameterInfo il2cpp::vm::GlobalMetadata::GetGenericParameterInfo(Il2CppMetadataGenericParameterHandle handle)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);

    return {
            reinterpret_cast<Il2CppMetadataGenericContainerHandle>(GetGenericContainerFromIndexInternal(genericParameter->ownerIndex)),
            GetStringFromIndex(genericParameter->nameIndex),
            genericParameter->num,
            genericParameter->flags
    };
}

uint16_t il2cpp::vm::GlobalMetadata::GetGenericParameterFlags(Il2CppMetadataGenericParameterHandle handle)
{
    const Il2CppGenericParameter* genericParameter = reinterpret_cast<const Il2CppGenericParameter*>(handle);
    return genericParameter->flags;
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetMethodInfoFromCatchPoint(const Il2CppCatchPoint* cp)
{
    return GetMethodInfoFromMethodDefinitionIndex(cp->__methodDefinitionIndex);
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetMethodInfoFromSequencePoint(const Il2CppSequencePoint* seqPoint)
{
    return GetMethodInfoFromMethodDefinitionIndex(seqPoint->__methodDefinitionIndex);
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeSourcePair(const Il2CppTypeSourceFilePair* pair)
{
    return GetTypeInfoFromTypeDefinitionIndex(pair->__klassIndex);
}

Il2CppClass* il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeIndex(TypeIndex index, bool throwOnError)
{
    if (index == kTypeIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index < s_Il2CppMetadataRegistration->typesCount && "Invalid type index ");

    return utils::InitOnce(&s_TypeInfoTable[index], &g_MetadataLock, [index, throwOnError](il2cpp::os::FastAutoLock& _)
    {
        const Il2CppType* type = s_Il2CppMetadataRegistration->types[index];

        Il2CppClass *klass = Class::FromIl2CppType(type, throwOnError);
        if (klass != NULL)
            ClassInlines::InitFromCodegenSlow(klass, throwOnError);
        return klass;
    });
}

const MethodInfo* il2cpp::vm::GlobalMetadata::GetMethodInfoFromMethodHandle(Il2CppMetadataMethodDefinitionHandle handle)
{
    const Il2CppMethodDefinition* methodDefinition = reinterpret_cast<const Il2CppMethodDefinition*>(handle);
    const Il2CppMethodDefinition* methods = (const Il2CppMethodDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->methodsOffset);

    const MethodIndex index = static_cast<MethodIndex>(methodDefinition - methods);

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) <= s_GlobalMetadataHeader->methodsSize / sizeof(Il2CppMethodDefinition));

    return GetMethodInfoFromMethodDefinitionIndex(index);
}

#if IL2CPP_ENABLE_NATIVE_STACKTRACES
void il2cpp::vm::GlobalMetadata::GetAllManagedMethods(std::vector<MethodDefinitionKey>& managedMethods)
{
    size_t methodDefinitionsCount = s_GlobalMetadataHeader->methodsSize / sizeof(Il2CppMethodDefinition);
    managedMethods.reserve(methodDefinitionsCount + s_Il2CppMetadataRegistration->genericMethodTableCount);

    const Il2CppTypeDefinition* typeDefinitions = (const Il2CppTypeDefinition*)((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->typeDefinitionsOffset);
    for (int32_t i = 0; i < s_MetadataImagesCount; i++)
    {
        const Il2CppImageGlobalMetadata* image = s_MetadataImagesTable + i;

        for (size_t j = 0; j < image->image->typeCount; j++)
        {
            const Il2CppTypeDefinition* type = typeDefinitions + image->typeStart + j;

            for (uint16_t u = 0; u < type->method_count; u++)
            {
                const Il2CppMethodDefinition* methodDefinition = GetMethodDefinitionFromIndex(type->methodStart + u);
                MethodDefinitionKey currentMethodList;
                currentMethodList.methodHandle = reinterpret_cast<Il2CppMetadataMethodDefinitionHandle>(methodDefinition);
                currentMethodList.method = il2cpp::vm::MetadataCache::GetMethodPointer(image->image, methodDefinition->token);
                if (currentMethodList.method)
                    managedMethods.push_back(currentMethodList);
            }
        }
    }

    for (int32_t i = 0; i < s_Il2CppMetadataRegistration->genericMethodTableCount; i++)
    {
        const Il2CppGenericMethodFunctionsDefinitions* genericMethodIndices = s_Il2CppMetadataRegistration->genericMethodTable + i;

        MethodDefinitionKey currentMethodList;

        GenericMethodIndex genericMethodIndex = genericMethodIndices->genericMethodIndex;

        IL2CPP_ASSERT(genericMethodIndex < s_Il2CppMetadataRegistration->methodSpecsCount);
        const Il2CppMethodSpec* methodSpec = s_Il2CppMetadataRegistration->methodSpecs + genericMethodIndex;
        const Il2CppMethodDefinition* methodDefinition = GetMethodDefinitionFromIndex(methodSpec->methodDefinitionIndex);
        currentMethodList.methodHandle = reinterpret_cast<Il2CppMetadataMethodDefinitionHandle>(methodDefinition);

        IL2CPP_ASSERT(genericMethodIndices->indices.methodIndex < static_cast<int32_t>(s_GlobalMetadata_CodeRegistration->genericMethodPointersCount));
        currentMethodList.method = s_GlobalMetadata_CodeRegistration->genericMethodPointers[genericMethodIndices->indices.methodIndex];

        managedMethods.push_back(currentMethodList);
    }
}

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\GlobalMetadata.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Il2CppHStringReference.cpp---------------
.
.
#include "il2cpp-config.h"
#include <il2cpp-object-internals.h>
#include "Il2CppHStringReference.h"
#include "vm/WindowsRuntime.h"

namespace il2cpp
{
namespace vm
{
    Il2CppHStringReference::Il2CppHStringReference(const utils::StringView<Il2CppNativeChar>& str)
    {
        il2cpp::vm::WindowsRuntime::CreateHStringReference(str, &m_Header, &m_String);
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Il2CppHStringReference.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Image.cpp---------------
.
.
#include "il2cpp-config.h"
#include <vector>
#include <map>
#include <limits>
#include "os/Mutex.h"
#include "utils/StringUtils.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Image.h"
#include "vm/MetadataCache.h"
#include "vm/Reflection.h"
#include "vm/StackTrace.h"
#include "vm/Type.h"
#include "utils/HashUtils.h"
#include "utils/Il2CppHashMap.h"
#include "utils/MemoryMappedFile.h"
#include "utils/StringUtils.h"
#include "vm-utils/VmStringUtils.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

struct NamespaceAndNamePairHash
{
    size_t operator()(const std::pair<const char*, const char*>& pair) const
    {
        return il2cpp::utils::HashUtils::Combine(il2cpp::utils::StringUtils::Hash(pair.first), il2cpp::utils::StringUtils::Hash(pair.second));
    }
};

struct NamespaceAndNamePairEquals
{
    bool operator()(const std::pair<const char*, const char*>& p1, const std::pair<const char*, const char*>& p2) const
    {
        return !strcmp(p1.first, p2.first) && !strcmp(p1.second, p2.second);
    }
};

struct NamespaceAndNamePairLess
{
    bool operator()(const std::pair<const char*, const char*>& p1, const std::pair<const char*, const char*>& p2) const
    {
        int namespaceCompare = strcmp(p1.first, p2.first);

        if (namespaceCompare < 0)
            return true;

        if (namespaceCompare > 0)
            return false;

        return strcmp(p1.second, p2.second) < 0;
    }
};

struct Il2CppNameToTypeHandleHashTable : public Il2CppHashMap<std::pair<const char*, const char*>, Il2CppMetadataTypeHandle, NamespaceAndNamePairHash, NamespaceAndNamePairEquals>
{
    typedef Il2CppHashMap<std::pair<const char*, const char*>, Il2CppMetadataTypeHandle, NamespaceAndNamePairHash, NamespaceAndNamePairEquals> Base;
    Il2CppNameToTypeHandleHashTable() : Base()
    {
    }
};

namespace il2cpp
{
namespace vm
{
    const Il2CppAssembly* Image::GetAssembly(const Il2CppImage* image)
    {
        return image->assembly;
    }

    typedef il2cpp::vm::StackFrames::const_reverse_iterator StackReverseIterator;

    static bool IsSystemType(Il2CppClass* klass)
    {
        return strcmp(klass->namespaze, "System") == 0 && strcmp(klass->name, "Type") == 0;
    }

    static bool IsSystemReflectionAssembly(Il2CppClass* klass)
    {
        return strcmp(klass->namespaze, "System.Reflection") == 0 && strcmp(klass->name, "Assembly") == 0;
    }

    static StackReverseIterator GetNextImageFromStack(StackReverseIterator first, StackReverseIterator last)
    {
        for (StackReverseIterator it = first; it != last; it++)
        {
            Il2CppClass* klass = it->method->klass;
            if (klass->image != NULL && !IsSystemType(klass) && !IsSystemReflectionAssembly(klass))
            {
                return it;
            }
        }

        return last;
    }

    const Il2CppImage* Image::GetExecutingImage()
    {
        const il2cpp::vm::StackFrames& stack = *StackTrace::GetStackFrames();
        StackReverseIterator imageIt = GetNextImageFromStack(stack.rbegin(), stack.rend());

        if (imageIt != stack.rend())
        {
            return imageIt->method->klass->image;
        }

        // Fallback to corlib if no image is found
        return const_cast<Il2CppImage*>(Image::GetCorlib());
    }

    const Il2CppImage* Image::GetCallingImage()
    {
        const il2cpp::vm::StackFrames& stack = *StackTrace::GetStackFrames();
        StackReverseIterator imageIt = GetNextImageFromStack(stack.rbegin(), stack.rend());

        if (imageIt != stack.rend())
        {
            imageIt = GetNextImageFromStack(++imageIt, stack.rend());

            if (imageIt != stack.rend())
            {
                return imageIt->method->klass->image;
            }
        }

        // Fallback to corlib if no image is found
        return const_cast<Il2CppImage*>(Image::GetCorlib());
    }

    const char * Image::GetName(const Il2CppImage* image)
    {
        return image->name;
    }

    const char * Image::GetFileName(const Il2CppImage* image)
    {
        return image->name;
    }

    const MethodInfo* Image::GetEntryPoint(const Il2CppImage* image)
    {
        return MetadataCache::GetAssemblyEntryPoint(image);
    }

    Il2CppImage* Image::GetCorlib()
    {
        return il2cpp_defaults.corlib;
    }

    static baselib::ReentrantLock s_ClassFromNameMutex;

    static void AddNestedTypesToNametoClassHashTable(Il2CppNameToTypeHandleHashTable* hashTable, const char *namespaze, const std::string& parentName, Il2CppMetadataTypeHandle handle)
    {
        std::pair<const char*, const char*> namespaceAndName = MetadataCache::GetTypeNamespaceAndName(handle);

        std::string name = parentName + "/" + namespaceAndName.second;
        char *pName = (char*)IL2CPP_CALLOC(name.size() + 1, sizeof(char));
        strcpy(pName, name.c_str());

        hashTable->insert(std::make_pair(std::make_pair(namespaze, (const char*)pName), handle));

        void *iter = NULL;
        while (Il2CppMetadataTypeHandle nestedClass = MetadataCache::GetNestedTypes(handle, &iter))
            AddNestedTypesToNametoClassHashTable(hashTable, namespaze, name, nestedClass);
    }

    static void AddNestedTypesToNametoClassHashTable(const Il2CppImage* image, Il2CppMetadataTypeHandle handle)
    {
        std::pair<const char*, const char*> namespaceAndName = MetadataCache::GetTypeNamespaceAndName(handle);

        void *iter = NULL;
        while (Il2CppMetadataTypeHandle nestedClass = MetadataCache::GetNestedTypes(handle, &iter))
        {
            AddNestedTypesToNametoClassHashTable(image->nameToClassHashTable, namespaceAndName.first, namespaceAndName.second, nestedClass);
        }
    }

// This must be called when the s_ClassFromNameMutex is held.
    static void AddTypeToNametoClassHashTable(const Il2CppImage* image, Il2CppMetadataTypeHandle typeHandle)
    {
        if (typeHandle == NULL)
            return;

        // don't add nested types
        if (MetadataCache::TypeIsNested(typeHandle))
            return;

        if (image != il2cpp_defaults.corlib)
            AddNestedTypesToNametoClassHashTable(image, typeHandle);

        image->nameToClassHashTable->insert(std::make_pair(MetadataCache::GetTypeNamespaceAndName(typeHandle), typeHandle));
    }

    void Image::InitNestedTypes(const Il2CppImage *image)
    {
        for (uint32_t index = 0; index < image->typeCount; index++)
        {
            Il2CppMetadataTypeHandle handle = MetadataCache::GetAssemblyTypeHandle(image, index);

            // don't add nested types
            if (MetadataCache::TypeIsNested(handle))
                return;

            AddNestedTypesToNametoClassHashTable(image, handle);
        }

        for (uint32_t index = 0; index < image->exportedTypeCount; index++)
        {
            Il2CppMetadataTypeHandle handle = MetadataCache::GetAssemblyExportedTypeHandle(image, index);

            // don't add nested types
            if (MetadataCache::TypeIsNested(handle))
                return;

            AddNestedTypesToNametoClassHashTable(image, handle);
        }
    }

    Il2CppClass* Image::ClassFromName(const Il2CppImage* image, const char* namespaze, const char *name)
    {
        if (!image->nameToClassHashTable)
        {
            os::FastAutoLock lock(&s_ClassFromNameMutex);
            if (!image->nameToClassHashTable)
            {
                image->nameToClassHashTable = new Il2CppNameToTypeHandleHashTable();
                for (uint32_t index = 0; index < image->typeCount; index++)
                {
                    AddTypeToNametoClassHashTable(image, MetadataCache::GetAssemblyTypeHandle(image, index));
                }

                for (uint32_t index = 0; index < image->exportedTypeCount; index++)
                {
                    AddTypeToNametoClassHashTable(image, MetadataCache::GetAssemblyExportedTypeHandle(image, index));
                }
            }
        }

        Il2CppNameToTypeHandleHashTable::const_iterator iter = image->nameToClassHashTable->find(std::make_pair(namespaze, name));
        if (iter != image->nameToClassHashTable->end())
            return MetadataCache::GetTypeInfoFromHandle(iter->second);

        return NULL;
    }

    static bool IsExported(const Il2CppClass* type)
    {
        if ((type->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK) == TYPE_ATTRIBUTE_PUBLIC)
        {
            return true;
        }

        if ((type->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK) == TYPE_ATTRIBUTE_NESTED_PUBLIC)
        {
            IL2CPP_ASSERT(type->declaringType);
            return IsExported(type->declaringType);
        }

        return false;
    }

    void Image::GetTypes(const Il2CppImage* image, bool exportedOnly, TypeVector* target)
    {
        uint32_t typeCount = Image::GetNumTypes(image);
        target->reserve(typeCount);

        for (uint32_t sourceIndex = 0; sourceIndex < typeCount; sourceIndex++)
        {
            const Il2CppClass* type = Image::GetType(image, sourceIndex);
            if (strcmp(type->name, "<Module>") == 0)
            {
                continue;
            }
            if (exportedOnly && !IsExported(type))
            {
                continue;
            }

            target->push_back(type);
        }
    }

    Il2CppArray* Image::GetTypes(const Il2CppImage* image, bool exportedOnly)
    {
        TypeVector types;
        GetTypes(image, exportedOnly, &types);
        Il2CppArray* result = Array::New(il2cpp_defaults.monotype_class, (il2cpp_array_size_t)types.size());
        size_t index = 0;
        for (vm::TypeVector::const_iterator type = types.begin(); type != types.end(); ++type)
        {
            Il2CppReflectionType* reflectionType = Reflection::GetTypeObject(&(*type)->byval_arg);
            il2cpp_array_setref(result, index, reflectionType);
            index++;
        }

        return result;
    }

    uint32_t Image::GetNumTypes(const Il2CppImage* image)
    {
        return image->typeCount;
    }

    const Il2CppClass* Image::GetType(const Il2CppImage* image, AssemblyTypeIndex index)
    {
        IL2CPP_ASSERT(index <= std::numeric_limits<AssemblyTypeIndex>::max());
        return MetadataCache::GetTypeInfoFromHandle(MetadataCache::GetAssemblyTypeHandle(image, index));
    }

    static bool StringsMatch(const char* left, const char* right, bool ignoreCase)
    {
        if (!ignoreCase)
        {
            return strcmp(left, right) == 0;
        }
        else
        {
            utils::VmStringUtils::CaseInsensitiveComparer comparer;
            return comparer(left, right);
        }
    }

    static bool ClassMatches(Il2CppMetadataTypeHandle typeHandle, const char* namespaze, bool ignoreCase, const char* name)
    {
        if (MetadataCache::TypeIsNested(typeHandle))
            return false;

        std::pair<const char*, const char*> namespaceAndName = MetadataCache::GetTypeNamespaceAndName(typeHandle);
        return StringsMatch(name, namespaceAndName.second, ignoreCase) && StringsMatch(namespaze, namespaceAndName.first, ignoreCase);
    }

    static Il2CppClass* FindClassMatching(const Il2CppImage* image, const char* namespaze, const char *name, bool ignoreCase)
    {
        for (uint32_t i = 0; i < image->typeCount; i++)
        {
            Il2CppMetadataTypeHandle typeHandle = MetadataCache::GetAssemblyTypeHandle(image, i);
            if (ClassMatches(typeHandle, namespaze, ignoreCase, name))
                return MetadataCache::GetTypeInfoFromHandle(typeHandle);
        }

        return NULL;
    }

    static Il2CppClass* FindExportedClassMatching(const Il2CppImage* image, const char* namespaze, const char *name, bool ignoreCase)
    {
        for (uint32_t i = 0; i < image->exportedTypeCount; i++)
        {
            Il2CppMetadataTypeHandle typeHandle = MetadataCache::GetAssemblyExportedTypeHandle(image, i);
            if (ClassMatches(typeHandle, namespaze, ignoreCase, name))
                return MetadataCache::GetTypeInfoFromHandle(typeHandle);
        }

        return NULL;
    }

    static Il2CppClass* FindNestedType(Il2CppClass* klass, const char* name, bool ignoreCase)
    {
        void* iter = NULL;
        while (Il2CppClass* nestedType = Class::GetNestedTypes(klass, &iter))
        {
            if (StringsMatch(name, nestedType->name, ignoreCase))
                return nestedType;
        }

        return NULL;
    }

    Il2CppClass* Image::FromTypeNameParseInfo(const Il2CppImage* image, const TypeNameParseInfo &info, bool ignoreCase)
    {
        const char* ns = info.ns().c_str();
        const char* name = info.name().c_str();
        Il2CppClass *parent_class = FindClassMatching(image, ns, name, ignoreCase);

        if (parent_class == NULL)
        {
            parent_class = FindExportedClassMatching(image, ns, name, ignoreCase);
            if (parent_class == NULL)
                return NULL;
        }

        std::vector<std::string>::const_iterator it = info.nested().begin();

        while (it != info.nested().end())
        {
            parent_class = FindNestedType(parent_class, (*it).c_str(), ignoreCase);

            if (parent_class == NULL)
                return NULL;

            ++it;
        }

        return parent_class;
    }

    static baselib::ReentrantLock s_Mutex;
    static std::vector<Image::EmbeddedResourceData> s_CachedResourceData;
    static std::map<Il2CppReflectionAssembly*, void*> s_CachedMemoryMappedResourceFiles;

    void Image::CacheMemoryMappedResourceFile(Il2CppReflectionAssembly* assembly, void* memoryMappedFile)
    {
        os::FastAutoLock lock(&s_Mutex);
        s_CachedMemoryMappedResourceFiles[assembly] = memoryMappedFile;
    }

    void* Image::GetCachedMemoryMappedResourceFile(Il2CppReflectionAssembly* assembly)
    {
        os::FastAutoLock lock(&s_Mutex);
        std::map<Il2CppReflectionAssembly*, void*>::iterator entry = s_CachedMemoryMappedResourceFiles.find(assembly);
        if (entry != s_CachedMemoryMappedResourceFiles.end())
            return entry->second;

        return NULL;
    }

    void Image::CacheResourceData(EmbeddedResourceRecord record, void* data)
    {
        os::FastAutoLock lock(&s_Mutex);
        s_CachedResourceData.push_back(EmbeddedResourceData(record, data));
    }

    void* Image::GetCachedResourceData(const Il2CppImage* image, const std::string& name)
    {
        os::FastAutoLock lock(&s_Mutex);
        for (std::vector<EmbeddedResourceData>::iterator it = s_CachedResourceData.begin(); it != s_CachedResourceData.end(); ++it)
        {
            if (it->record.image == image && it->record.name == name)
                return it->data;
        }

        return NULL;
    }

    void Image::ClearCachedResourceData()
    {
        os::FastAutoLock lock(&s_Mutex);
        for (std::map<Il2CppReflectionAssembly*, void*>::iterator i = s_CachedMemoryMappedResourceFiles.begin(); i != s_CachedMemoryMappedResourceFiles.end(); ++i)
            utils::MemoryMappedFile::Unmap(i->second);

        s_CachedMemoryMappedResourceFiles.clear();
        s_CachedResourceData.clear();
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Image.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\InternalCalls.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/InternalCalls.h"
#include "vm/Runtime.h"

#include <map>
#include <string>

typedef std::map<std::string, Il2CppMethodPointer> ICallMap;
static ICallMap s_InternalCalls;

namespace il2cpp
{
namespace vm
{
    void InternalCalls::Add(const char* name, Il2CppMethodPointer method)
    {
        //ICallMap::iterator res = s_InternalCalls.find(name);

        // TODO: Don't assert right now because Unity adds some icalls multiple times.
        //if (res != icalls.end())
        //  IL2CPP_ASSERT(0 && "Adding internal call twice!");

        IL2CPP_ASSERT(method);

        s_InternalCalls[name] = method;
    }

    Il2CppMethodPointer InternalCalls::Resolve(const char* name)
    {
        // Try to find the whole name first, then search using just type::method
        // if parameters were passed
        // ex: First, System.Foo::Bar(System.Int32)
        // Then, System.Foo::Bar
        ICallMap::iterator res = s_InternalCalls.find(name);

        if (res != s_InternalCalls.end())
            return res->second;

        std::string shortName(name);
        size_t index = shortName.find('(');

        if (index != std::string::npos)
        {
            shortName = shortName.substr(0, index);
            res = s_InternalCalls.find(shortName);

            if (res != s_InternalCalls.end())
                return res->second;
        }

        return NULL;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\InternalCalls.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\LastError.cpp---------------
.
.
#include "LastError.h"
#include "Thread.h"
#include "os/LastError.h"

namespace il2cpp
{
namespace vm
{
    int32_t LastError::s_LastErrorThreadLocalStorageOffset = -1;

    uint32_t LastError::GetLastError()
    {
        if (s_LastErrorThreadLocalStorageOffset == -1)
            return 0;

        return *(uint32_t*)Thread::GetThreadStaticData(s_LastErrorThreadLocalStorageOffset);
    }

    void LastError::SetLastError(uint32_t error)
    {
        IL2CPP_ASSERT(s_LastErrorThreadLocalStorageOffset != -1);

        uint32_t* lastErrorTls = (uint32_t*)Thread::GetThreadStaticData(s_LastErrorThreadLocalStorageOffset);
        *lastErrorTls = error;
    }

    void LastError::StoreLastError()
    {
        SetLastError(os::LastError::GetLastError());
    }

    void LastError::InitializeLastErrorThreadStatic()
    {
        if (s_LastErrorThreadLocalStorageOffset == -1)
            s_LastErrorThreadLocalStorageOffset = Thread::AllocThreadStaticData(sizeof(uint32_t));
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\LastError.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Liveness.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/GarbageCollector.h"
#include <utils/dynamic_array.h>
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/Field.h"
#include "vm/Liveness.h"
#include "vm/Type.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"

#define MARK_OBJ(obj) \
    do { \
        (obj)->klass = (Il2CppClass*)(((size_t)(obj)->klass) | (size_t)1); \
    } while (0)

#define CLEAR_OBJ(obj) \
    do { \
        (obj)->klass = (Il2CppClass*)(((size_t)(obj)->klass) & ~(size_t)1); \
    } while (0)

#define IS_MARKED(obj) \
    (((size_t)(obj)->klass) & (size_t)1)

#define GET_CLASS(obj) \
    ((Il2CppClass*)(((size_t)(obj)->klass) & ~(size_t)1))

namespace il2cpp
{
namespace vm
{
    /* number of sub elements of an array to process before recursing
    * we take a depth first approach to use stack space rather than re-allocating
    * processing array which requires restarting world to ensure allocator lock is not held
    */
    const int kArrayElementsPerChunk = 256;

    /* how far we recurse processing array elements before we stop. Prevents stack overflow */
    const int kMaxTraverseRecursionDepth = 128;

    struct CustomGrowableBlockArray;

    struct LivenessState
    {
        LivenessState(Il2CppClass* filter, uint32_t maxCount, Liveness::register_object_callback callback, void*callback_userdata, Liveness::ReallocateArrayCallback reallocateArray);
        ~LivenessState();

        void Finalize();
        void Reset();
        void TraverseObjects();
        void FilterObjects();

        static void TraverseGenericObject(Il2CppObject* object, LivenessState* state);
        static void TraverseObject(Il2CppObject* object, LivenessState* state);
        static void TraverseGCDescriptor(Il2CppObject* object, LivenessState* state);
        static bool TraverseObjectInternal(Il2CppObject* object, bool isStruct, Il2CppClass* klass, LivenessState* state);
        static void TraverseArray(Il2CppArray* array, LivenessState* state);
        static bool AddProcessObject(Il2CppObject* object, LivenessState* state);
        static bool ShouldProcessValue(Il2CppObject* val, Il2CppClass* filter);
        static bool FieldCanContainReferences(FieldInfo* field);

        static bool ShouldTraverseObjects(size_t index, int32_t recursion_depth)
        {
            // Add kArrayElementsPerChunk objects at a time and then traverse
            return ((index + 1) & (kArrayElementsPerChunk - 1)) == 0 && recursion_depth < kMaxTraverseRecursionDepth;
        }

        CustomGrowableBlockArray* all_objects;

        Il2CppClass*          filter;

        CustomGrowableBlockArray* process_array;

        void*               callback_userdata;

        Liveness::register_object_callback filter_callback;
        Liveness::ReallocateArrayCallback reallocateArray;

        int32_t               traverse_depth; // track recursion. Prevent stack overflow by limiting recurion
    };

#define kBlockSize (8 * 1024)
#define kArrayElementsPerBlock ((kBlockSize - 3 *sizeof (void*)) / sizeof (void*))

    struct CustomArrayBlock
    {
        Il2CppObject** next_item;
        CustomArrayBlock *prev_block;
        CustomArrayBlock *next_block;
        Il2CppObject* p_data[kArrayElementsPerBlock];
    };

    struct CustomBlockArrayIterator;
    struct CustomGrowableBlockArray
    {
        CustomArrayBlock *first_block;
        CustomArrayBlock *current_block;
        CustomBlockArrayIterator *iterator;

        CustomGrowableBlockArray(LivenessState *state);

        bool IsEmpty();
        void PushBack(Il2CppObject* value, LivenessState *state);
        Il2CppObject* PopBack();
        void ResetIterator();
        Il2CppObject* Next();
        void Clear();
        void Destroy(LivenessState *state);
    };

    struct CustomBlockArrayIterator
    {
        CustomGrowableBlockArray *array;
        CustomArrayBlock *current_block;
        Il2CppObject** current_position;
    };

    CustomGrowableBlockArray::CustomGrowableBlockArray(LivenessState *state)
    {
        current_block = (CustomArrayBlock*)state->reallocateArray(NULL, kBlockSize, state->callback_userdata);
        current_block->prev_block = NULL;
        current_block->next_block = NULL;
        current_block->next_item = current_block->p_data;
        first_block = current_block;

        iterator = new CustomBlockArrayIterator();
        iterator->array = this;
        iterator->current_block = first_block;
        iterator->current_position = first_block->p_data;
    }

    bool CustomGrowableBlockArray::IsEmpty()
    {
        return first_block->next_item == first_block->p_data;
    }

    void CustomGrowableBlockArray::PushBack(Il2CppObject* value, LivenessState *state)
    {
        if (current_block->next_item == current_block->p_data + kArrayElementsPerBlock)
        {
            CustomArrayBlock* new_block = current_block->next_block;
            if (current_block->next_block == NULL)
            {
                new_block = (CustomArrayBlock*)state->reallocateArray(NULL, kBlockSize, state->callback_userdata);
                new_block->next_block = NULL;
                new_block->prev_block = current_block;
                new_block->next_item = new_block->p_data;
                current_block->next_block = new_block;
            }
            current_block = new_block;
        }
        *current_block->next_item++ = value;
    }

    Il2CppObject* CustomGrowableBlockArray::PopBack()
    {
        if (current_block->next_item == current_block->p_data)
        {
            if (current_block->prev_block == NULL)
                return NULL;
            current_block = current_block->prev_block;
            current_block->next_item = current_block->p_data + kArrayElementsPerBlock;
        }
        return *--current_block->next_item;
    }

    void CustomGrowableBlockArray::ResetIterator()
    {
        iterator->current_block = first_block;
        iterator->current_position = first_block->p_data;
    }

    Il2CppObject* CustomGrowableBlockArray::Next()
    {
        if (iterator->current_position != iterator->current_block->next_item)
            return *iterator->current_position++;
        if (iterator->current_block->next_block == NULL)
            return NULL;
        iterator->current_block = iterator->current_block->next_block;
        iterator->current_position = iterator->current_block->p_data;
        if (iterator->current_position == iterator->current_block->next_item)
            return NULL;
        return *iterator->current_position++;
    }

    void CustomGrowableBlockArray::Clear()
    {
        CustomArrayBlock *block = first_block;
        while (block != NULL)
        {
            block->next_item = block->p_data;
            block = block->next_block;
        }
    }

    void CustomGrowableBlockArray::Destroy(LivenessState *state)
    {
        CustomArrayBlock *block = first_block;
        while (block != NULL)
        {
            CustomArrayBlock *data_block = block;
            block = block->next_block;
            state->reallocateArray(data_block, 0, state->callback_userdata);
        }
        delete iterator;
        delete this;
    }

    LivenessState::LivenessState(Il2CppClass* filter, uint32_t maxCount, Liveness::register_object_callback callback, void*callback_userdata, Liveness::ReallocateArrayCallback reallocateArray) :
        all_objects(NULL),
        filter(NULL),
        process_array(NULL),
        callback_userdata(NULL),
        filter_callback(NULL),
        reallocateArray(reallocateArray),
        traverse_depth(0)
    {
// construct liveness_state;
// allocate memory for the following structs
// all_objects: contains a list of all referenced objects to be able to clean the vtable bits after the traversal
// process_array. array that contains the objcets that should be processed. this should run depth first to reduce memory usage
// if all_objects run out of space, run through list, add objects that match the filter, clear bit in vtable and then clear the array.

        this->filter = filter;

        this->callback_userdata = callback_userdata;
        this->filter_callback = callback;

        all_objects = new CustomGrowableBlockArray(this);
        process_array = new CustomGrowableBlockArray(this);
    }

    LivenessState::~LivenessState()
    {
        all_objects->Destroy(this);
        process_array->Destroy(this);
    }

    void LivenessState::Finalize()
    {
        all_objects->ResetIterator();
        Il2CppObject* object = all_objects->Next();
        while (object != NULL)
        {
            CLEAR_OBJ(object);
            object = all_objects->Next();
        }
    }

    void LivenessState::Reset()
    {
        process_array->Clear();
    }

    void LivenessState::TraverseObjects()
    {
        Il2CppObject* object = NULL;

        traverse_depth++;
        while (!process_array->IsEmpty())
        {
            object = process_array->PopBack();
            TraverseGenericObject(object, this);
        }
        traverse_depth--;
    }

    void LivenessState::FilterObjects()
    {
        Il2CppObject* filtered_objects[64];
        int32_t num_objects = 0;

        Il2CppObject* value = all_objects->Next();
        while (value)
        {
            Il2CppObject* object = value;
            if (ShouldProcessValue(object, filter))
                filtered_objects[num_objects++] = object;
            if (num_objects == 64)
            {
                filter_callback(filtered_objects, 64, callback_userdata);
                num_objects = 0;
            }
            value = all_objects->Next();
        }

        if (num_objects != 0)
            filter_callback(filtered_objects, num_objects, callback_userdata);
    }

    void LivenessState::TraverseGenericObject(Il2CppObject* object, LivenessState* state)
    {
        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(LivenessState::TraverseGenericObject, "Use GC bitmap when we have one");

#if IL2CPP_HAS_GC_DESCRIPTORS
        size_t gc_desc = (size_t)(GET_CLASS(object)->gc_desc);

        if (gc_desc & (size_t)1)
            TraverseGCDescriptor(object, state);
        else
#endif
        if (GET_CLASS(object)->rank)
            TraverseArray((Il2CppArray*)object, state);
        else
            TraverseObject(object, state);
    }

    void LivenessState::TraverseObject(Il2CppObject* object, LivenessState* state)
    {
        TraverseObjectInternal(object, false, GET_CLASS(object), state);
    }

    void LivenessState::TraverseGCDescriptor(Il2CppObject* object, LivenessState* state)
    {
#define WORDSIZE ((int)sizeof(size_t)*8)
        int i = 0;
        size_t mask = (size_t)(GET_CLASS(object)->gc_desc);

        IL2CPP_ASSERT(mask & (size_t)1);

        for (i = 0; i < WORDSIZE - 2; i++)
        {
            size_t offset = ((size_t)1 << (WORDSIZE - 1 - i));
            if (mask & offset)
            {
                Il2CppObject* val = *(Il2CppObject**)(((char*)object) + i * sizeof(void*));
                AddProcessObject(val, state);
            }
        }
    }

    bool LivenessState::TraverseObjectInternal(Il2CppObject* object, bool isStruct, Il2CppClass* klass, LivenessState* state)
    {
        FieldInfo *field;
        Il2CppClass *p;
        bool added_objects = false;

        IL2CPP_ASSERT(object);

        if (!klass->size_inited)
        {
            IL2CPP_ASSERT(isStruct);
            return false;
        }

        // subtract the added offset for the vtable. This is added to the offset even though it is a struct
        if (isStruct)
            object--;

        for (p = klass; p != NULL; p = p->parent)
        {
            void* iter = NULL;
            while ((field = Class::GetFields(p, &iter)))
            {
                if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
                    continue;

                if (!FieldCanContainReferences(field))
                    continue;

                if (Type::IsStruct(field->type))
                {
                    char* offseted = (char*)object;
                    offseted += field->offset;
                    if (Type::IsGenericInstance(field->type))
                    {
                        IL2CPP_ASSERT(field->type->data.generic_class->cached_class);
                        added_objects |= TraverseObjectInternal((Il2CppObject*)offseted, true, field->type->data.generic_class->cached_class, state);
                    }
                    else
                        added_objects |= TraverseObjectInternal((Il2CppObject*)offseted, true, Type::GetClass(field->type), state);
                    continue;
                }

                if (field->offset == THREAD_STATIC_FIELD_OFFSET)
                {
                    IL2CPP_ASSERT(0);
                }
                else
                {
                    Il2CppObject* val = NULL;
                    Field::GetValue(object, field, &val);
                    added_objects |= AddProcessObject(val, state);
                }
            }
        }

        return added_objects;
    }

    void LivenessState::TraverseArray(Il2CppArray* array, LivenessState* state)
    {
        size_t i = 0;
        bool has_references;
        Il2CppObject* object = (Il2CppObject*)array;
        Il2CppClass* element_class;
        size_t elementClassSize;
        size_t array_length;

        IL2CPP_ASSERT(object);

        element_class = GET_CLASS(object)->element_class;
        has_references = !Class::IsValuetype(element_class);
        IL2CPP_ASSERT(element_class->size_inited != 0);

        FieldInfo* field;
        void* iter = NULL;
        while ((field = Class::GetFields(element_class, &iter)))
        {
            has_references |= FieldCanContainReferences(field);
            if (has_references)
                break;
        }

        if (!has_references)
            return;

        array_length = Array::GetLength(array);
        if (element_class->byval_arg.valuetype)
        {
            size_t items_processed = 0;
            elementClassSize = Class::GetArrayElementSize(element_class);
            for (i = 0; i < array_length; i++)
            {
                Il2CppObject* object = (Il2CppObject*)il2cpp_array_addr_with_size(array, (int32_t)elementClassSize, i);
                if (TraverseObjectInternal(object, 1, element_class, state))
                    items_processed++;

                // Add 64 objects at a time and then traverse
                if (ShouldTraverseObjects(items_processed, state->traverse_depth))
                    state->TraverseObjects();
            }
        }
        else
        {
            size_t items_processed = 0;
            for (i = 0; i < array_length; i++)
            {
                Il2CppObject* val =  il2cpp_array_get(array, Il2CppObject*, i);
                if (AddProcessObject(val, state))
                    items_processed++;

                // Add 64 objects at a time and then traverse
                if (ShouldTraverseObjects(items_processed, state->traverse_depth))
                    state->TraverseObjects();
            }
        }
    }

    bool LivenessState::AddProcessObject(Il2CppObject* object, LivenessState* state)
    {
        if (!object || IS_MARKED(object))
            return false;

        bool has_references = GET_CLASS(object)->has_references;
        if (has_references || ShouldProcessValue(object, state->filter))
        {
            state->all_objects->PushBack(object, state);
            MARK_OBJ(object);
        }
        // Check if klass has further references - if not skip adding
        if (has_references)
        {
            state->process_array->PushBack(object, state);
            return true;
        }

        return false;
    }

    bool LivenessState::ShouldProcessValue(Il2CppObject* val, Il2CppClass* filter)
    {
        Il2CppClass* val_class = GET_CLASS(val);
        if (filter && !ClassInlines::HasParentUnsafe(val_class, filter))
            return false;

        return true;
    }

    bool LivenessState::FieldCanContainReferences(FieldInfo* field)
    {
        if (Type::IsStruct(field->type))
            return true;
        if (field->type->attrs & FIELD_ATTRIBUTE_LITERAL)
            return false;
        if (field->type->type == IL2CPP_TYPE_STRING)
            return false;
        return Type::IsReference(field->type);
    }

    void* Liveness::AllocateStruct(Il2CppClass* filter, int max_object_count, register_object_callback callback, void* userdata, ReallocateArrayCallback reallocateArray)
    {
        // ensure filter is initialized so we can do fast (and lock free) check HasParentUnsafe
        Class::SetupTypeHierarchy(filter);
        LivenessState* state = new LivenessState(filter, max_object_count, callback, userdata, reallocateArray);
        // no allocations can happen beyond this point
        return state;
    }

    void Liveness::FreeStruct(void* state)
    {
        LivenessState* lstate = (LivenessState*)state;
        delete lstate;
    }

    void Liveness::Finalize(void* state)
    {
        LivenessState* lstate = (LivenessState*)state;
        lstate->Finalize();
    }

    void Liveness::FromRoot(Il2CppObject* root, void* state)
    {
        LivenessState* liveness_state = (LivenessState*)state;
        liveness_state->Reset();

        liveness_state->process_array->PushBack(root, liveness_state);

        liveness_state->TraverseObjects();

        //Filter objects and call callback to register found objects
        liveness_state->FilterObjects();
    }

    void Liveness::FromStatics(void* state)
    {
        LivenessState* liveness_state = (LivenessState*)state;
        const il2cpp::utils::dynamic_array<Il2CppClass*>& classesWithStatics = Class::GetStaticFieldData();

        liveness_state->Reset();

        for (il2cpp::utils::dynamic_array<Il2CppClass*>::const_iterator iter = classesWithStatics.begin();
             iter != classesWithStatics.end();
             iter++)
        {
            Il2CppClass* klass = *iter;
            FieldInfo *field;
            if (!klass)
                continue;
            if (klass->image == il2cpp_defaults.corlib)
                continue;
            if (klass->size_inited == 0)
                continue;

            void* fieldIter = NULL;
            while ((field = Class::GetFields(klass, &fieldIter)))
            {
                if (!vm::Field::IsNormalStatic(field))
                    continue;
                if (!LivenessState::FieldCanContainReferences(field))
                    continue;

                if (Type::IsStruct(field->type))
                {
                    char* offseted = (char*)klass->static_fields;
                    offseted += field->offset;
                    if (Type::IsGenericInstance(field->type))
                    {
                        IL2CPP_ASSERT(field->type->data.generic_class->cached_class);
                        LivenessState::TraverseObjectInternal((Il2CppObject*)offseted, true, field->type->data.generic_class->cached_class, liveness_state);
                    }
                    else
                    {
                        LivenessState::TraverseObjectInternal((Il2CppObject*)offseted, true, Type::GetClass(field->type), liveness_state);
                    }
                }
                else
                {
                    Il2CppObject* val = NULL;

                    Field::StaticGetValue(field, &val);

                    if (val)
                    {
                        LivenessState::AddProcessObject(val, liveness_state);
                    }
                }
            }
        }
        liveness_state->TraverseObjects();
        //Filter objects and call callback to register found objects
        liveness_state->FilterObjects();
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Liveness.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MarshalAlloc.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MarshalAlloc.h"
#include "os/MarshalAlloc.h"
#include "os/ThreadLocalValue.h"
#include "vm/Exception.h"
#include <deque>

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace vm
{
#if _DEBUG
    static os::ThreadLocalValue s_Allocations;

    static baselib::ReentrantLock s_AllocationStorageMutex;
    static std::deque<std::vector<std::map<void*, size_t> > > s_AllocationStorage;

    static std::vector<std::map<void*, size_t> >& GetAllocationsForCurrentThread()
    {
        std::vector<std::map<void*, size_t> >* ptr = NULL;
        s_Allocations.GetValue(reinterpret_cast<void**>(&ptr));
        if (ptr == NULL)
        {
            os::FastAutoLock lock(&s_AllocationStorageMutex);
            s_AllocationStorage.push_back(std::vector<std::map<void*, size_t> >());
            ptr = &s_AllocationStorage.back();
            s_Allocations.SetValue(ptr);
        }

        return *ptr;
    }

    static std::map<void*, size_t>* GetAllocationsForCurrentFrame()
    {
        std::vector<std::map<void*, size_t> >& currentThreadAllocations = GetAllocationsForCurrentThread();
        if (currentThreadAllocations.size() > 0)
            return &currentThreadAllocations.back();

        return NULL;
    }

#endif

    void* MarshalAlloc::Allocate(size_t size)
    {
        void* ptr = os::MarshalAlloc::Allocate(size);

#if _DEBUG
        std::map<void*, size_t>* allocations = GetAllocationsForCurrentFrame();
        if (allocations != NULL)
            (*allocations)[ptr] = size;
#endif

        return ptr;
    }

    void* MarshalAlloc::ReAlloc(void* ptr, size_t size)
    {
        void* realloced = os::MarshalAlloc::ReAlloc(ptr, size);

#if _DEBUG
        std::map<void*, size_t>* allocations = GetAllocationsForCurrentFrame();
        if (allocations != NULL)
        {
            if (ptr != NULL && ptr != realloced)
            {
                std::map<void*, size_t>::iterator found = allocations->find(ptr);
                IL2CPP_ASSERT(found != allocations->end() && "Invalid call to MarshalAlloc::ReAlloc. The pointer is not in the allocation list.");
                allocations->erase(found);
            }

            (*allocations)[realloced] = size;
        }
#endif

        return realloced;
    }

    void MarshalAlloc::Free(void* ptr)
    {
#if _DEBUG
        std::map<void*, size_t>* allocations = GetAllocationsForCurrentFrame();
        if (allocations != NULL)
        {
            std::map<void*, size_t>::iterator found = allocations->find(ptr);
            if (found != allocations->end()) // It might not be necessarily allocated by us, e.g. we might be freeing memory that's returned from native P/Invoke call
                allocations->erase(found);
        }
#endif

        os::MarshalAlloc::Free(ptr);
    }

    void* MarshalAlloc::AllocateHGlobal(size_t size)
    {
        return os::MarshalAlloc::AllocateHGlobal(size);
    }

    void* MarshalAlloc::ReAllocHGlobal(void* ptr, size_t size)
    {
        return os::MarshalAlloc::ReAllocHGlobal(ptr, size);
    }

    void MarshalAlloc::FreeHGlobal(void* ptr)
    {
        os::MarshalAlloc::FreeHGlobal(ptr);
    }

#if _DEBUG

    void MarshalAlloc::PushAllocationFrame()
    {
        GetAllocationsForCurrentThread().push_back(std::map<void*, size_t>());
    }

    void MarshalAlloc::PopAllocationFrame()
    {
        GetAllocationsForCurrentThread().pop_back();
    }

    bool MarshalAlloc::HasUnfreedAllocations()
    {
        std::map<void*, size_t>* allocations = GetAllocationsForCurrentFrame();
        return allocations != NULL && allocations->size() > 0;
    }

    void MarshalAlloc::ClearAllTrackedAllocations()
    {
        std::map<void*, size_t>* allocations = GetAllocationsForCurrentFrame();
        if (allocations != NULL)
            allocations->clear();
    }

#endif
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MarshalAlloc.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MemoryInformation.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MemoryInformation.h"
#include "gc/GarbageCollector.h"
#include "gc/GCHandle.h"
#include "metadata/ArrayMetadata.h"
#include "metadata/GenericMetadata.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/MetadataCache.h"
#include "vm/Type.h"
#include "utils/Memory.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"

#include <map>
#include <limits>

namespace il2cpp
{
namespace vm
{
namespace MemoryInformation
{
    struct GatherMetadataContext
    {
        uint32_t currentIndex;
        std::map<Il2CppClass*, uint32_t> allTypes;
    };

    static void GatherMetadataCallback(Il2CppClass* type, void* context)
    {
        if (type->initialized)
        {
            GatherMetadataContext* ctx = static_cast<GatherMetadataContext*>(context);
            ctx->allTypes.insert(std::make_pair(type, ctx->currentIndex++));
        }
    }

    static inline int FindTypeInfoIndexInMap(const std::map<Il2CppClass*, uint32_t>& allTypes, Il2CppClass* typeInfo)
    {
        std::map<Il2CppClass*, uint32_t>::const_iterator it = allTypes.find(typeInfo);

        if (it == allTypes.end())
            return -1;

        return it->second;
    }

    static inline void GatherMetadata(Il2CppMetadataSnapshot& metadata)
    {
        GatherMetadataContext gatherMetadataContext = { 0 };
        const AssemblyVector* allAssemblies = Assembly::GetAllAssemblies();

        for (AssemblyVector::const_iterator it = allAssemblies->begin(); it != allAssemblies->end(); it++)
        {
            const Il2CppImage& image = *(*it)->image;

            for (uint32_t i = 0; i < image.typeCount; i++)
            {
                Il2CppClass* type = MetadataCache::GetTypeInfoFromHandle(MetadataCache::GetAssemblyTypeHandle(&image, i));
                if (type->initialized)
                    gatherMetadataContext.allTypes.insert(std::make_pair(type, gatherMetadataContext.currentIndex++));
            }
        }

        metadata::ArrayMetadata::WalkArrays(GatherMetadataCallback, &gatherMetadataContext);
        metadata::ArrayMetadata::WalkSZArrays(GatherMetadataCallback, &gatherMetadataContext);
        metadata::GenericMetadata::WalkAllGenericClasses(GatherMetadataCallback, &gatherMetadataContext);
        MetadataCache::WalkPointerTypes(GatherMetadataCallback, &gatherMetadataContext);

        const std::map<Il2CppClass*, uint32_t>& allTypes = gatherMetadataContext.allTypes;
        metadata.typeCount = static_cast<uint32_t>(allTypes.size());
        metadata.types = static_cast<Il2CppMetadataType*>(IL2CPP_CALLOC(metadata.typeCount, sizeof(Il2CppMetadataType)));

        for (std::map<Il2CppClass*, uint32_t>::const_iterator it = allTypes.begin(); it != allTypes.end(); it++)
        {
            Il2CppClass* typeInfo = it->first;

            uint32_t index = it->second;
            Il2CppMetadataType& type = metadata.types[index];

            if (typeInfo->rank > 0)
            {
                type.flags = static_cast<Il2CppMetadataTypeFlags>(kArray | (kArrayRankMask & (typeInfo->rank << 16)));
                type.baseOrElementTypeIndex = FindTypeInfoIndexInMap(allTypes, typeInfo->element_class);
            }
            else
            {
                type.flags = (typeInfo->byval_arg.valuetype || typeInfo->byval_arg.type == IL2CPP_TYPE_PTR) ? kValueType : kNone;
                type.fieldCount = 0;

                if (typeInfo->field_count > 0)
                {
                    type.fields = static_cast<Il2CppMetadataField*>(IL2CPP_CALLOC(typeInfo->field_count, sizeof(Il2CppMetadataField)));

                    for (int i = 0; i < typeInfo->field_count; i++)
                    {
                        Il2CppMetadataField& field = metadata.types[index].fields[type.fieldCount];
                        FieldInfo* fieldInfo = typeInfo->fields + i;
                        field.typeIndex = FindTypeInfoIndexInMap(allTypes, Class::FromIl2CppType(fieldInfo->type));

                        // This will happen if fields type is not initialized
                        // It's OK to skip it, because it means the field is guaranteed to be null on any object
                        if (field.typeIndex == -1)
                            continue;

                        //literals have no actual storage, and are not relevant in this context.
                        if ((fieldInfo->type->attrs & FIELD_ATTRIBUTE_LITERAL) != 0)
                            continue;

                        field.isStatic = (fieldInfo->type->attrs & FIELD_ATTRIBUTE_STATIC) != 0;
                        field.offset = fieldInfo->offset;
                        field.name = fieldInfo->name;
                        type.fieldCount++;
                    }
                }

                type.staticsSize = typeInfo->static_fields_size;

                if (type.staticsSize > 0 && typeInfo->static_fields != NULL)
                {
                    type.statics = static_cast<uint8_t*>(IL2CPP_MALLOC(type.staticsSize));
                    memcpy(type.statics, typeInfo->static_fields, type.staticsSize);
                }

                Il2CppClass* baseType = Class::GetParent(typeInfo);
                type.baseOrElementTypeIndex = baseType != NULL ? FindTypeInfoIndexInMap(allTypes, baseType) : -1;
            }

            type.assemblyName = typeInfo->image->assembly->aname.name;

            std::string typeName = Type::GetName(&typeInfo->byval_arg, IL2CPP_TYPE_NAME_FORMAT_IL);
            type.name = static_cast<char*>(IL2CPP_CALLOC(typeName.length() + 1, sizeof(char)));
            memcpy(type.name, typeName.c_str(), typeName.length() + 1);

            type.typeInfoAddress = reinterpret_cast<uint64_t>(typeInfo);
            type.size = (typeInfo->byval_arg.valuetype) != 0 ? (typeInfo->instance_size - sizeof(Il2CppObject)) : typeInfo->instance_size;
        }
    }

    struct SectionIterationContext
    {
        Il2CppManagedMemorySection* currentSection;
    };

    static void AllocateMemoryForSection(void* context, void* sectionStart, void* sectionEnd)
    {
        SectionIterationContext* ctx = static_cast<SectionIterationContext*>(context);
        Il2CppManagedMemorySection& section = *ctx->currentSection;

        section.sectionStartAddress = reinterpret_cast<uint64_t>(sectionStart);

        ptrdiff_t sectionSize = static_cast<uint8_t*>(sectionEnd) - static_cast<uint8_t*>(sectionStart);

        if (sizeof(void*) > 4) // This assert is only valid on 64-bit
            IL2CPP_ASSERT(sectionSize <= static_cast<ptrdiff_t>(std::numeric_limits<uint32_t>::max()));

        section.sectionSize = static_cast<uint32_t>(sectionSize);
        section.sectionBytes = static_cast<uint8_t*>(IL2CPP_MALLOC(section.sectionSize));

        ctx->currentSection++;
    }

    static void CopyHeapSection(void* context, void* sectionStart, void* sectionEnd)
    {
        SectionIterationContext* ctx = static_cast<SectionIterationContext*>(context);
        Il2CppManagedMemorySection& section = *ctx->currentSection;

        IL2CPP_ASSERT(section.sectionStartAddress == reinterpret_cast<uint64_t>(sectionStart));
        IL2CPP_ASSERT(section.sectionSize == static_cast<uint8_t*>(sectionEnd) - static_cast<uint8_t*>(sectionStart));
        memcpy(section.sectionBytes, sectionStart, section.sectionSize);

        ctx->currentSection++;
    }

    static void* CaptureHeapInfo(void* voidManagedHeap)
    {
        Il2CppManagedHeap& heap = *(Il2CppManagedHeap*)voidManagedHeap;

        heap.sectionCount = static_cast<uint32_t>(il2cpp::gc::GarbageCollector::GetSectionCount());
        heap.sections = static_cast<Il2CppManagedMemorySection*>(IL2CPP_CALLOC(heap.sectionCount, sizeof(Il2CppManagedMemorySection)));

        SectionIterationContext iterationContext = { heap.sections };
        il2cpp::gc::GarbageCollector::ForEachHeapSection(&iterationContext, AllocateMemoryForSection);

        return NULL;
    }

    static void FreeIL2CppManagedHeap(Il2CppManagedHeap& heap)
    {
        for (uint32_t i = 0; i < heap.sectionCount; i++)
        {
            IL2CPP_FREE(heap.sections[i].sectionBytes);
        }

        IL2CPP_FREE(heap.sections);
    }

    struct VerifyHeapSectionStillValidIterationContext
    {
        Il2CppManagedMemorySection* currentSection;
        bool wasValid;
    };

    static void VerifyHeapSectionIsStillValid(void* context, void* sectionStart, void* sectionEnd)
    {
        VerifyHeapSectionStillValidIterationContext* iterationContext = (VerifyHeapSectionStillValidIterationContext*)context;
        if (iterationContext->currentSection->sectionSize != static_cast<uint8_t*>(sectionEnd) - static_cast<uint8_t*>(sectionStart))
            iterationContext->wasValid = false;
        else if (iterationContext->currentSection->sectionStartAddress != reinterpret_cast<uint64_t>(sectionStart))
            iterationContext->wasValid = false;

        iterationContext->currentSection++;
    }

    static bool IsIL2CppManagedHeapStillValid(Il2CppManagedHeap& heap)
    {
        if (heap.sectionCount != static_cast<uint32_t>(il2cpp::gc::GarbageCollector::GetSectionCount()))
            return false;

        VerifyHeapSectionStillValidIterationContext iterationContext = { heap.sections, true };
        il2cpp::gc::GarbageCollector::ForEachHeapSection(&iterationContext, VerifyHeapSectionIsStillValid);

        return iterationContext.wasValid;
    }

// The difficulty in capturing the managed snapshot is that we need to do quite some work with the world stopped,
// to make sure that our snapshot is "valid", and didn't change as we were copying it. However, stopping the world,
// makes it so you cannot take any lock or allocations. We deal with it like this:
//
// 1) We take note of the amount of heap sections and their sizes, and we allocate memory to copy them into.
// 2) We stop the world.
// 3) We check if the amount of heapsections and their sizes didn't change in the mean time. If they did, try again.
// 4) Now, with the world still stopped, we memcpy() the memory from the real heapsections, into the memory that we
//    allocated for their copies.
// 5) Start the world again.

    static inline void CaptureManagedHeap(Il2CppManagedHeap& heap)
    {
        for (;;)
        {
            il2cpp::gc::GarbageCollector::CallWithAllocLockHeld(CaptureHeapInfo, &heap);

            il2cpp::gc::GarbageCollector::StopWorld();

            if (IsIL2CppManagedHeapStillValid(heap))
                break;

            il2cpp::gc::GarbageCollector::StartWorld();

            FreeIL2CppManagedHeap(heap);
        }

        SectionIterationContext iterationContext = { heap.sections };
        il2cpp::gc::GarbageCollector::ForEachHeapSection(&iterationContext, CopyHeapSection);

        il2cpp::gc::GarbageCollector::StartWorld();
    }

    struct GCHandleTargetIterationContext
    {
        std::vector<Il2CppObject*> managedObjects;
    };

    static void GCHandleIterationCallback(Il2CppObject* managedObject, void* context)
    {
        GCHandleTargetIterationContext* ctx = static_cast<GCHandleTargetIterationContext*>(context);
        ctx->managedObjects.push_back(managedObject);
    }

    static inline void CaptureGCHandleTargets(Il2CppGCHandles& gcHandles)
    {
        GCHandleTargetIterationContext gcHandleTargetIterationContext;
        il2cpp::gc::GCHandle::WalkStrongGCHandleTargets(GCHandleIterationCallback, &gcHandleTargetIterationContext);

        const std::vector<Il2CppObject*>& trackedObjects = gcHandleTargetIterationContext.managedObjects;
        gcHandles.trackedObjectCount = static_cast<uint32_t>(trackedObjects.size());
        gcHandles.pointersToObjects = static_cast<uint64_t*>(IL2CPP_CALLOC(gcHandles.trackedObjectCount, sizeof(uint64_t)));

        for (uint32_t i = 0; i < gcHandles.trackedObjectCount; i++)
            gcHandles.pointersToObjects[i] = reinterpret_cast<uint64_t>(trackedObjects[i]);
    }

    void FillRuntimeInformation(Il2CppRuntimeInformation& runtimeInfo)
    {
        runtimeInfo.pointerSize = static_cast<uint32_t>(sizeof(void*));
        runtimeInfo.objectHeaderSize = static_cast<uint32_t>(sizeof(Il2CppObject));
        runtimeInfo.arrayHeaderSize = static_cast<uint32_t>(kIl2CppSizeOfArray);
        runtimeInfo.arraySizeOffsetInHeader = kIl2CppOffsetOfArrayLength;
        runtimeInfo.arrayBoundsOffsetInHeader = kIl2CppOffsetOfArrayBounds;
        runtimeInfo.allocationGranularity = static_cast<uint32_t>(2 * sizeof(void*));
    }

    struct il2cpp_heap_chunk
    {
        void* start;
        uint32_t size;
    };

    void ReportIL2CppClasses(ClassReportFunc callback, void* context)
    {
        const AssemblyVector* allAssemblies = Assembly::GetAllAssemblies();

        for (AssemblyVector::const_iterator it = allAssemblies->begin(); it != allAssemblies->end(); it++)
        {
            const Il2CppImage& image = *(*it)->image;

            for (uint32_t i = 0; i < image.typeCount; i++)
            {
                Il2CppClass* type = MetadataCache::GetTypeInfoFromHandle(MetadataCache::GetAssemblyTypeHandle(&image, i));
                if (type->initialized)
                    callback(type, context);
            }
        }

        metadata::ArrayMetadata::WalkArrays(callback, context);
        metadata::ArrayMetadata::WalkSZArrays(callback, context);
        metadata::GenericMetadata::WalkAllGenericClasses(callback, context);
        MetadataCache::WalkPointerTypes(callback, context);
    }

    void ReportGcHeapSection(void * context, void * start, void * end)
    {
        il2cpp_heap_chunk chunk;
        chunk.start = start;
        //todo: change back to size_t once we change the memory profiler format and mono to use size_t for reporting chunk size
        chunk.size = (uint32_t)((uint8_t *)end - (uint8_t *)start);
        IterationContext* ctxPtr = reinterpret_cast<IterationContext*>(context);
        ctxPtr->callback(&chunk, ctxPtr->userData);
    }

    void ReportGcHandleTarget(Il2CppObject * obj, void * context)
    {
        IterationContext* ctxPtr = reinterpret_cast<IterationContext*>(context);
        ctxPtr->callback(obj, ctxPtr->userData);
    }

    Il2CppManagedMemorySnapshot* CaptureManagedMemorySnapshot()
    {
        Il2CppManagedMemorySnapshot* snapshot = static_cast<Il2CppManagedMemorySnapshot*>(IL2CPP_MALLOC_ZERO(sizeof(Il2CppManagedMemorySnapshot)));

        GatherMetadata(snapshot->metadata);
        CaptureManagedHeap(snapshot->heap);
        CaptureGCHandleTargets(snapshot->gcHandles);
        FillRuntimeInformation(snapshot->runtimeInformation);

        return snapshot;
    }

    void FreeCapturedManagedMemorySnapshot(Il2CppManagedMemorySnapshot* snapshot)
    {
        FreeIL2CppManagedHeap(snapshot->heap);

        IL2CPP_FREE(snapshot->gcHandles.pointersToObjects);

        Il2CppMetadataSnapshot& metadata = snapshot->metadata;

        for (uint32_t i = 0; i < metadata.typeCount; i++)
        {
            if ((metadata.types[i].flags & kArray) == 0)
            {
                IL2CPP_FREE(metadata.types[i].fields);
                IL2CPP_FREE(metadata.types[i].statics);
            }

            IL2CPP_FREE(metadata.types[i].name);
        }

        IL2CPP_FREE(metadata.types);
        IL2CPP_FREE(snapshot);
    }
} // namespace MemoryInformation
} // namespace vm
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MemoryInformation.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MetadataAlloc.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MetadataAlloc.h"
#include "il2cpp-class-internals.h"
#include "utils/MemoryPool.h"
#if IL2CPP_SANITIZE_ADDRESS
#include "utils/MemoryPoolAddressSanitizer.h"
#endif
namespace il2cpp
{
namespace vm
{
#if IL2CPP_SANITIZE_ADDRESS
    typedef utils::MemoryPoolAddressSanitizer MemoryPoolType;
#else
    typedef utils::MemoryPool MemoryPoolType;
#endif

// we allocate these dynamically on runtime initialization
// because the pool uses standard allocators, and we want to give embedding
// client the chance to install their own allocator callbacks
    static MemoryPoolType* s_MetadataMemoryPool;
    static MemoryPoolType* s_GenericClassMemoryPool;
    static MemoryPoolType* s_GenericMethodMemoryPool;

// This initial size (256k/512k) allows us enough room to initialize metadata
// an empty Unity project and have a bit of room leftover.
    const size_t kInitialRegionSize = IL2CPP_SIZEOF_VOID_P * 64 * 1024;

    void MetadataAllocInitialize()
    {
#if IL2CPP_SANITIZE_ADDRESS
        s_MetadataMemoryPool = new utils::MemoryPoolAddressSanitizer(kInitialRegionSize);
        s_GenericClassMemoryPool = new utils::MemoryPoolAddressSanitizer();
        s_GenericMethodMemoryPool = new utils::MemoryPoolAddressSanitizer();
#else
        s_MetadataMemoryPool = new utils::MemoryPool(kInitialRegionSize);
        // these can use the default smaller initial pool size
        s_GenericClassMemoryPool = new utils::MemoryPool();
        s_GenericMethodMemoryPool = new utils::MemoryPool();
#endif
    }

    void MetadataAllocCleanup()
    {
        delete s_MetadataMemoryPool;
        s_MetadataMemoryPool = NULL;
        delete s_GenericClassMemoryPool;
        s_GenericClassMemoryPool = NULL;
        delete s_GenericMethodMemoryPool;
        s_GenericMethodMemoryPool = NULL;
    }

    void* MetadataMalloc(size_t size)
    {
        return s_MetadataMemoryPool->Malloc(size);
    }

    void* MetadataCalloc(size_t count, size_t size)
    {
        return s_MetadataMemoryPool->Calloc(count, size);
    }

    Il2CppGenericClass* MetadataAllocGenericClass()
    {
        return (Il2CppGenericClass*)s_GenericClassMemoryPool->Calloc(1, sizeof(Il2CppGenericClass));
    }

    Il2CppGenericMethod* MetadataAllocGenericMethod()
    {
        return (Il2CppGenericMethod*)s_GenericMethodMemoryPool->Calloc(1, sizeof(Il2CppGenericMethod));
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MetadataAlloc.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MetadataCache.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MetadataCache.h"
#include "GlobalMetadata.h"

#include <map>
#include <limits>
#include "il2cpp-tabledefs.h"
#include "il2cpp-runtime-stats.h"
#include "gc/GarbageCollector.h"
#include "metadata/ArrayMetadata.h"
#include "metadata/GenericMetadata.h"
#include "metadata/GenericMethod.h"
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "utils/CallOnce.h"
#include "utils/Collections.h"
#include "utils/Il2CppHashSet.h"
#include "utils/Memory.h"
#include "utils/PathUtils.h"
#include "vm/Assembly.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/GenericClass.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataLoader.h"
#include "vm/MetadataLock.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "vm-utils/MethodDefinitionKey.h"
#include "vm-utils/NativeSymbol.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

typedef Il2CppReaderWriterLockedHashMap<Il2CppClass*, Il2CppClass*> PointerTypeMap;

typedef Il2CppHashSet<const Il2CppGenericMethod*, il2cpp::metadata::Il2CppGenericMethodHash, il2cpp::metadata::Il2CppGenericMethodCompare> Il2CppGenericMethodSet;
typedef Il2CppGenericMethodSet::const_iterator Il2CppGenericMethodSetIter;
static Il2CppGenericMethodSet s_GenericMethodSet;

struct Il2CppMetadataCache
{
    il2cpp::os::FastReaderReaderWriterLock m_CacheLock;
    PointerTypeMap m_PointerTypes;
};

static Il2CppMetadataCache s_MetadataCache;
static int32_t s_ImagesCount = 0;
static Il2CppImage* s_ImagesTable = NULL;
static int32_t s_AssembliesCount = 0;
static Il2CppAssembly* s_AssembliesTable = NULL;


typedef Il2CppReaderWriterLockedHashSet<const Il2CppGenericInst*, il2cpp::metadata::Il2CppGenericInstHash, il2cpp::metadata::Il2CppGenericInstCompare> Il2CppGenericInstSet;
static Il2CppGenericInstSet s_GenericInstSet;

typedef il2cpp::vm::Il2CppMethodTableMap::const_iterator Il2CppMethodTableMapIter;
static il2cpp::vm::Il2CppMethodTableMap s_MethodTableMap;

typedef il2cpp::vm::Il2CppUnresolvedSignatureMap::const_iterator Il2CppUnresolvedSignatureMapIter;
static il2cpp::vm::Il2CppUnresolvedSignatureMap *s_pUnresolvedSignatureMap;

typedef Il2CppHashMap<FieldInfo*, int32_t, il2cpp::utils::PointerHash<FieldInfo> > Il2CppThreadLocalStaticOffsetHashMap;
typedef Il2CppThreadLocalStaticOffsetHashMap::iterator Il2CppThreadLocalStaticOffsetHashMapIter;
static Il2CppThreadLocalStaticOffsetHashMap s_ThreadLocalStaticOffsetMap;

static const Il2CppCodeRegistration * s_Il2CppCodeRegistration;
static const Il2CppMetadataRegistration* s_MetadataCache_Il2CppMetadataRegistration;
static const Il2CppCodeGenOptions* s_Il2CppCodeGenOptions;

static il2cpp::vm::WindowsRuntimeTypeNameToClassMap s_WindowsRuntimeTypeNameToClassMap;
static il2cpp::vm::ClassToWindowsRuntimeTypeNameMap s_ClassToWindowsRuntimeTypeNameMap;

struct InteropDataToTypeConverter
{
    inline const Il2CppType* operator()(const Il2CppInteropData& interopData) const
    {
        return interopData.type;
    }
};

typedef il2cpp::utils::collections::ArrayValueMap<const Il2CppType*, Il2CppInteropData, InteropDataToTypeConverter, il2cpp::metadata::Il2CppTypeLess, il2cpp::metadata::Il2CppTypeEqualityComparer> InteropDataMap;
static InteropDataMap s_InteropData;

struct WindowsRuntimeFactoryTableEntryToTypeConverter
{
    inline const Il2CppType* operator()(const Il2CppWindowsRuntimeFactoryTableEntry& entry) const
    {
        return entry.type;
    }
};

typedef il2cpp::utils::collections::ArrayValueMap<const Il2CppType*, Il2CppWindowsRuntimeFactoryTableEntry, WindowsRuntimeFactoryTableEntryToTypeConverter, il2cpp::metadata::Il2CppTypeLess, il2cpp::metadata::Il2CppTypeEqualityComparer> WindowsRuntimeFactoryTable;
static WindowsRuntimeFactoryTable s_WindowsRuntimeFactories;

template<typename K, typename V>
struct PairToKeyConverter
{
    inline const K& operator()(const std::pair<K, V>& pair) const
    {
        return pair.first;
    }
};

typedef il2cpp::utils::collections::ArrayValueMap<const Il2CppGuid*, std::pair<const Il2CppGuid*, Il2CppClass*>, PairToKeyConverter<const Il2CppGuid*, Il2CppClass*> > GuidToClassMap;
static GuidToClassMap s_GuidToNonImportClassMap;

void il2cpp::vm::MetadataCache::Register(const Il2CppCodeRegistration* const codeRegistration, const Il2CppMetadataRegistration* const metadataRegistration, const Il2CppCodeGenOptions* const codeGenOptions)
{
    il2cpp::vm::GlobalMetadata::Register(codeRegistration, metadataRegistration, codeGenOptions);

    s_Il2CppCodeRegistration = codeRegistration;
    s_MetadataCache_Il2CppMetadataRegistration = metadataRegistration;
    s_Il2CppCodeGenOptions = codeGenOptions;
}

Il2CppClass* il2cpp::vm::MetadataCache::GetTypeInfoFromTypeIndex(const Il2CppImage *image, TypeIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeIndex(index);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetMethodInfoFromMethodDefinitionIndex(const Il2CppImage *image, MethodIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetMethodInfoFromMethodDefinitionIndex(index);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetAssemblyEntryPoint(const Il2CppImage* image)
{
    return il2cpp::vm::GlobalMetadata::GetAssemblyEntryPoint(image);
}

Il2CppMetadataTypeHandle il2cpp::vm::MetadataCache::GetAssemblyTypeHandle(const Il2CppImage* image, AssemblyTypeIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetAssemblyTypeHandle(image, index);
}

Il2CppMetadataTypeHandle il2cpp::vm::MetadataCache::GetAssemblyExportedTypeHandle(const Il2CppImage* image, AssemblyExportedTypeIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetAssemblyExportedTypeHandle(image, index);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetMethodInfoFromMethodHandle(Il2CppMetadataMethodDefinitionHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetMethodInfoFromMethodHandle(handle);
}

bool il2cpp::vm::MetadataCache::Initialize()
{
    if (!il2cpp::vm::GlobalMetadata::Initialize(&s_ImagesCount, &s_AssembliesCount))
    {
        return false;
    }

    il2cpp::metadata::GenericMetadata::RegisterGenericClasses(s_MetadataCache_Il2CppMetadataRegistration->genericClasses, s_MetadataCache_Il2CppMetadataRegistration->genericClassesCount);
    il2cpp::metadata::GenericMetadata::SetMaximumRuntimeGenericDepth(s_Il2CppCodeGenOptions->maximumRuntimeGenericDepth);
    il2cpp::metadata::GenericMetadata::SetGenericVirtualIterations(s_Il2CppCodeGenOptions->recursiveGenericIterations);

    s_GenericInstSet.Resize(s_MetadataCache_Il2CppMetadataRegistration->genericInstsCount);
    for (int32_t i = 0; i < s_MetadataCache_Il2CppMetadataRegistration->genericInstsCount; i++)
    {
        bool inserted = s_GenericInstSet.Add(s_MetadataCache_Il2CppMetadataRegistration->genericInsts[i]);
        IL2CPP_ASSERT(inserted);
    }

    s_InteropData.assign_external(s_Il2CppCodeRegistration->interopData, s_Il2CppCodeRegistration->interopDataCount);
    s_WindowsRuntimeFactories.assign_external(s_Il2CppCodeRegistration->windowsRuntimeFactoryTable, s_Il2CppCodeRegistration->windowsRuntimeFactoryCount);

    // Pre-allocate these arrays so we don't need to lock when reading later.
    // These arrays hold the runtime metadata representation for metadata explicitly
    // referenced during conversion. There is a corresponding table of same size
    // in the converted metadata, giving a description of runtime metadata to construct.
    s_ImagesTable = (Il2CppImage*)IL2CPP_CALLOC(s_ImagesCount, sizeof(Il2CppImage));
    s_AssembliesTable = (Il2CppAssembly*)IL2CPP_CALLOC(s_AssembliesCount, sizeof(Il2CppAssembly));

    // setup all the Il2CppImages. There are not many and it avoid locks later on
    for (int32_t imageIndex = 0; imageIndex < s_ImagesCount; imageIndex++)
    {
        Il2CppImage* image = s_ImagesTable + imageIndex;

        AssemblyIndex imageAssemblyIndex;
        il2cpp::vm::GlobalMetadata::BuildIl2CppImage(image, imageIndex, &imageAssemblyIndex);

        image->assembly = const_cast<Il2CppAssembly*>(GetAssemblyFromIndex(imageAssemblyIndex));

        std::string nameNoExt = il2cpp::utils::PathUtils::PathNoExtension(image->name);
        image->nameNoExt = (char*)IL2CPP_CALLOC(nameNoExt.size() + 1, sizeof(char));
        strcpy(const_cast<char*>(image->nameNoExt), nameNoExt.c_str());

        for (uint32_t codeGenModuleIndex = 0; codeGenModuleIndex < s_Il2CppCodeRegistration->codeGenModulesCount; ++codeGenModuleIndex)
        {
            if (strcmp(image->name, s_Il2CppCodeRegistration->codeGenModules[codeGenModuleIndex]->moduleName) == 0)
                image->codeGenModule = s_Il2CppCodeRegistration->codeGenModules[codeGenModuleIndex];
        }
        IL2CPP_ASSERT(image->codeGenModule);
        image->dynamic = false;
    }

    // setup all the Il2CppAssemblies.
    for (int32_t assemblyIndex = 0; assemblyIndex < s_ImagesCount; assemblyIndex++)
    {
        Il2CppAssembly* assembly = s_AssembliesTable + assemblyIndex;

        ImageIndex assemblyImageIndex;
        il2cpp::vm::GlobalMetadata::BuildIl2CppAssembly(assembly, assemblyIndex, &assemblyImageIndex);

        assembly->image = il2cpp::vm::MetadataCache::GetImageFromIndex(assemblyImageIndex);

        Assembly::Register(assembly);
    }

    InitializeUnresolvedSignatureTable();

#if IL2CPP_ENABLE_NATIVE_STACKTRACES
    std::vector<MethodDefinitionKey> managedMethods;
    il2cpp::vm::GlobalMetadata::GetAllManagedMethods(managedMethods);
    il2cpp::utils::NativeSymbol::RegisterMethods(managedMethods);
#endif
    return true;
}

void il2cpp::vm::MetadataCache::ExecuteEagerStaticClassConstructors()
{
    for (int32_t i = 0; i < s_AssembliesCount; i++)
    {
        const Il2CppImage* image = s_AssembliesTable[i].image;
        if (image->codeGenModule->staticConstructorTypeIndices != NULL)
        {
            TypeDefinitionIndex* indexPointer = image->codeGenModule->staticConstructorTypeIndices;
            while (*indexPointer) // 0 terminated
            {
                Il2CppMetadataTypeHandle handle = GetTypeHandleFromIndex(image, *indexPointer);
                Il2CppClass* klass = GlobalMetadata::GetTypeInfoFromHandle(handle);
                Runtime::ClassInit(klass);
                indexPointer++;
            }
        }
    }
}

typedef void(*Il2CppModuleInitializerMethodPointer)(const MethodInfo*);

void il2cpp::vm::MetadataCache::ExecuteModuleInitializers()
{
    for (int32_t i = 0; i < s_AssembliesCount; i++)
    {
        const Il2CppImage* image = s_AssembliesTable[i].image;
        if (image->codeGenModule->moduleInitializer != NULL)
        {
            Il2CppModuleInitializerMethodPointer moduleInitializer = (Il2CppModuleInitializerMethodPointer)image->codeGenModule->moduleInitializer;
            moduleInitializer(NULL);
        }
    }
}

void ClearGenericMethodTable()
{
    s_MethodTableMap.clear();
}

void ClearWindowsRuntimeTypeNamesTables()
{
    s_ClassToWindowsRuntimeTypeNameMap.clear();
}

void il2cpp::vm::MetadataCache::InitializeGuidToClassTable()
{
    Il2CppInteropData* interopData = s_Il2CppCodeRegistration->interopData;
    uint32_t interopDataCount = s_Il2CppCodeRegistration->interopDataCount;
    std::vector<std::pair<const Il2CppGuid*, Il2CppClass*> > guidToNonImportClassMap;
    guidToNonImportClassMap.reserve(interopDataCount);

    for (uint32_t i = 0; i < interopDataCount; i++)
    {
        // It's important to check for non-import types because type projections will have identical GUIDs (e.g. IEnumerable<T> and IIterable<T>)
        if (interopData[i].guid != NULL)
        {
            Il2CppClass* klass = il2cpp::vm::Class::FromIl2CppType(interopData[i].type);
            if (!klass->is_import_or_windows_runtime)
                guidToNonImportClassMap.push_back(std::make_pair(interopData[i].guid, klass));
        }
    }

    s_GuidToNonImportClassMap.assign(guidToNonImportClassMap);
}

// this is called later in the intialization cycle with more systems setup like GC
void il2cpp::vm::MetadataCache::InitializeGCSafe()
{
    il2cpp::vm::GlobalMetadata::InitializeStringLiteralTable();
    il2cpp::vm::GlobalMetadata::InitializeGenericMethodTable(s_MethodTableMap);
    il2cpp::vm::GlobalMetadata::InitializeWindowsRuntimeTypeNamesTables(s_WindowsRuntimeTypeNameToClassMap, s_ClassToWindowsRuntimeTypeNameMap);
    InitializeGuidToClassTable();
}

void ClearImageNames()
{
    for (int32_t imageIndex = 0; imageIndex < s_ImagesCount; imageIndex++)
    {
        Il2CppImage* image = s_ImagesTable + imageIndex;
        IL2CPP_FREE((void*)image->nameNoExt);
    }
}

void il2cpp::vm::MetadataCache::Clear()
{
    ClearGenericMethodTable();
    ClearWindowsRuntimeTypeNamesTables();

    delete s_pUnresolvedSignatureMap;

    Assembly::ClearAllAssemblies();

    ClearImageNames();

    IL2CPP_FREE(s_ImagesTable);
    s_ImagesTable = NULL;
    s_ImagesCount = 0;

    IL2CPP_FREE(s_AssembliesTable);
    s_AssembliesTable = NULL;
    s_AssembliesCount = 0;

    s_GenericMethodSet.clear();

    metadata::ArrayMetadata::Clear();

    s_GenericInstSet.Clear();

    s_Il2CppCodeRegistration = NULL;
    s_Il2CppCodeGenOptions = NULL;

    il2cpp::metadata::GenericMetadata::Clear();
    il2cpp::metadata::GenericMethod::ClearStatics();

    il2cpp::vm::GlobalMetadata::Clear();
}

void il2cpp::vm::MetadataCache::InitializeUnresolvedSignatureTable()
{
    s_pUnresolvedSignatureMap = new Il2CppUnresolvedSignatureMap();
    il2cpp::vm::GlobalMetadata::InitializeUnresolvedSignatureTable(*s_pUnresolvedSignatureMap);
}

Il2CppClass* il2cpp::vm::MetadataCache::GetGenericInstanceType(Il2CppClass* genericTypeDefinition, const Il2CppType** genericArgumentTypes, uint32_t genericArgumentCount)
{
    const Il2CppGenericInst* inst = il2cpp::vm::MetadataCache::GetGenericInst(genericArgumentTypes, genericArgumentCount);
    Il2CppGenericClass* genericClass = il2cpp::metadata::GenericMetadata::GetGenericClass(genericTypeDefinition, inst);
    return il2cpp::vm::GenericClass::GetClass(genericClass);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetGenericInstanceMethod(const MethodInfo* genericMethodDefinition, const Il2CppType** genericArgumentTypes, uint32_t genericArgumentCount)
{
    Il2CppGenericContext context = { NULL, GetGenericInst(genericArgumentTypes, genericArgumentCount) };
    return il2cpp::vm::GlobalMetadata::GetGenericInstanceMethod(genericMethodDefinition, &context);
}

const Il2CppGenericContext* il2cpp::vm::MetadataCache::GetMethodGenericContext(const MethodInfo* method)
{
    if (!method->is_inflated)
    {
        IL2CPP_NOT_IMPLEMENTED(Image::GetMethodGenericContext);
        return NULL;
    }

    return &method->genericMethod->context;
}

const MethodInfo* il2cpp::vm::MetadataCache::GetGenericMethodDefinition(const MethodInfo* method)
{
    if (!method->is_inflated)
    {
        IL2CPP_NOT_IMPLEMENTED(Image::GetGenericMethodDefinition);
        return NULL;
    }

    return method->genericMethod->methodDefinition;
}

Il2CppClass* il2cpp::vm::MetadataCache::GetPointerType(Il2CppClass* type)
{
    Il2CppClass* pointerClass;
    if (s_MetadataCache.m_PointerTypes.TryGet(type, &pointerClass))
        return pointerClass;
    return NULL;
}

Il2CppClass* il2cpp::vm::MetadataCache::GetWindowsRuntimeClass(const char* fullName)
{
    WindowsRuntimeTypeNameToClassMap::iterator it = s_WindowsRuntimeTypeNameToClassMap.find(fullName);
    if (it != s_WindowsRuntimeTypeNameToClassMap.end())
        return it->second;

    return NULL;
}

const char* il2cpp::vm::MetadataCache::GetWindowsRuntimeClassName(const Il2CppClass* klass)
{
    ClassToWindowsRuntimeTypeNameMap::iterator it = s_ClassToWindowsRuntimeTypeNameMap.find(klass);
    if (it != s_ClassToWindowsRuntimeTypeNameMap.end())
        return it->second;

    return NULL;
}

Il2CppMethodPointer il2cpp::vm::MetadataCache::GetWindowsRuntimeFactoryCreationFunction(const char* fullName)
{
    Il2CppClass* klass = GetWindowsRuntimeClass(fullName);
    if (klass == NULL)
        return NULL;

    WindowsRuntimeFactoryTable::iterator factoryEntry = s_WindowsRuntimeFactories.find_first(&klass->byval_arg);
    if (factoryEntry == s_WindowsRuntimeFactories.end())
        return NULL;

    return factoryEntry->createFactoryFunction;
}

Il2CppClass* il2cpp::vm::MetadataCache::GetClassForGuid(const Il2CppGuid* guid)
{
    IL2CPP_ASSERT(guid != NULL);

    GuidToClassMap::iterator it = s_GuidToNonImportClassMap.find_first(guid);
    if (it != s_GuidToNonImportClassMap.end())
        return it->second;

    return NULL;
}

void il2cpp::vm::MetadataCache::AddPointerTypeLocked(Il2CppClass* type, Il2CppClass* pointerType, const il2cpp::os::FastAutoLock& lock)
{
    // This method must be called while holding the g_MetadataLock to ensure that we don't insert the same pointer type twice
    // And WalkPointerTypes assumes this

    IL2CPP_ASSERT(lock.IsLock(&g_MetadataLock));
    s_MetadataCache.m_PointerTypes.Add(type, pointerType);
}

const Il2CppGenericInst* il2cpp::vm::MetadataCache::GetGenericInst(const Il2CppType* const* types, uint32_t typeCount)
{
    // temporary inst to lookup a permanent one that may already exist
    Il2CppGenericInst inst;
    inst.type_argc = typeCount;
    inst.type_argv = (const Il2CppType**)types;

    const Il2CppGenericInst* foundInst;
    if (s_GenericInstSet.TryGet(&inst, &foundInst))
        return foundInst;

    il2cpp::os::FastAutoLock lock(&g_MetadataLock);

    // Check if instance was added while we were blocked on g_MetadataLock
    if (s_GenericInstSet.TryGet(&inst, &foundInst))
        return foundInst;

    Il2CppGenericInst* newInst = NULL;
    newInst  = (Il2CppGenericInst*)MetadataMalloc(sizeof(Il2CppGenericInst));
    newInst->type_argc = typeCount;
    newInst->type_argv = (const Il2CppType**)MetadataMalloc(newInst->type_argc * sizeof(Il2CppType*));

    int index = 0;
    const Il2CppType* const* typesEnd = types + typeCount;
    for (const Il2CppType* const* iter = types; iter != typesEnd; ++iter, ++index)
        newInst->type_argv[index] = *iter;

    // Do this while still holding the g_MetadataLock to prevent the same instance from being added twice
    bool added = s_GenericInstSet.Add(newInst);
    IL2CPP_ASSERT(added);
    ++il2cpp_runtime_stats.generic_instance_count;

    return newInst;
}

static baselib::ReentrantLock s_GenericMethodMutex;
const Il2CppGenericMethod* il2cpp::vm::MetadataCache::GetGenericMethod(const MethodInfo* methodDefinition, const Il2CppGenericInst* classInst, const Il2CppGenericInst* methodInst)
{
    Il2CppGenericMethod method = { 0 };
    method.methodDefinition = methodDefinition;
    method.context.class_inst = classInst;
    method.context.method_inst = methodInst;

    il2cpp::os::FastAutoLock lock(&s_GenericMethodMutex);
    Il2CppGenericMethodSet::const_iterator iter = s_GenericMethodSet.find(&method);
    if (iter != s_GenericMethodSet.end())
        return *iter;

    Il2CppGenericMethod* newMethod = MetadataAllocGenericMethod();
    newMethod->methodDefinition = methodDefinition;
    newMethod->context.class_inst = classInst;
    newMethod->context.method_inst = methodInst;

    s_GenericMethodSet.insert(newMethod);

    return newMethod;
}

static bool IsShareableEnum(const Il2CppType* type)
{
    // Base case for recursion - we've found an enum.
    if (il2cpp::vm::Type::IsEnum(type))
        return true;

    if (il2cpp::vm::Type::IsGenericInstance(type))
    {
        // Recursive case - look "inside" the generic instance type to see if this is a nested enum.
        Il2CppClass* definition = il2cpp::vm::GenericClass::GetTypeDefinition(type->data.generic_class);
        return IsShareableEnum(il2cpp::vm::Class::GetType(definition));
    }

    // Base case for recurion - this is not an enum or a generic instance type.
    return false;
}

static il2cpp::vm::GenericParameterRestriction IsReferenceTypeGenericConstraint(const Il2CppType* constraint)
{
    // This must match GenericSharingAnalsyis.GetGenericParameterConstraintRestriction()

    if (constraint->type == IL2CPP_TYPE_VAR || constraint->type == IL2CPP_TYPE_MVAR)
        return il2cpp::vm::GenericParameterRestrictionNone;
    if (il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(constraint, &il2cpp_defaults.enum_class->byval_arg))
        return il2cpp::vm::GenericParameterRestrictionValueType;
    if (il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(constraint, &il2cpp_defaults.value_type_class->byval_arg))
        return il2cpp::vm::GenericParameterRestrictionNone; // Not a valid constraint, so consider it unconstrained
    else if (il2cpp::vm::Class::IsInterface(il2cpp::vm::Class::FromIl2CppType(constraint)))
        return il2cpp::vm::GenericParameterRestrictionNone; // Interfaces constraints can be satisfied by reference or value types

    // Any other type constraint e.g. T : SomeType, SomeType must be a reference type
    return il2cpp::vm::GenericParameterRestrictionReferenceType;
}

il2cpp::vm::GenericParameterRestriction il2cpp::vm::MetadataCache::IsReferenceTypeGenericParameter(Il2CppMetadataGenericParameterHandle genericParameter)
{
    uint16_t flags = il2cpp::vm::GlobalMetadata::GetGenericParameterFlags(genericParameter);
    if ((flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT) != 0)
        return GenericParameterRestrictionReferenceType;
    if ((flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_NOT_NULLABLE_VALUE_TYPE_CONSTRAINT) != 0)
        return GenericParameterRestrictionValueType; // Must be a value type

    uint32_t count = il2cpp::vm::GlobalMetadata::GetGenericConstraintCount(genericParameter);
    for (uint32_t constraintIndex = 0; constraintIndex < count; ++constraintIndex)
    {
        const Il2CppType* constraint = il2cpp::vm::GlobalMetadata::GetGenericParameterConstraintFromIndex(genericParameter, constraintIndex);
        GenericParameterRestriction restriction = IsReferenceTypeGenericConstraint(constraint);
        if (restriction != GenericParameterRestrictionNone)
            return restriction;
    }

    return GenericParameterRestrictionNone;
}

static const Il2CppGenericInst* GetFullySharedInst(Il2CppMetadataGenericContainerHandle genericContainer, const Il2CppGenericInst* inst)
{
    if (inst == NULL || !il2cpp::vm::Runtime::IsFullGenericSharingEnabled())
        return NULL;

    const Il2CppType** types = (const Il2CppType**)alloca(inst->type_argc * sizeof(Il2CppType*));
    for (uint32_t i = 0; i < inst->type_argc; ++i)
    {
        const Il2CppType* type;
        switch (il2cpp::vm::MetadataCache::IsReferenceTypeGenericParameter(il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex(genericContainer, i)))
        {
            case il2cpp::vm::GenericParameterRestrictionValueType:
                type = &il2cpp_defaults.il2cpp_fully_shared_struct_type->byval_arg;
                break;
            case il2cpp::vm::GenericParameterRestrictionReferenceType:
                type = &il2cpp_defaults.object_class->byval_arg;
                break;
            default:
                type = &il2cpp_defaults.il2cpp_fully_shared_type->byval_arg;
                break;
        }

        types[i] = type;
    }

    const Il2CppGenericInst* sharedInst = il2cpp::vm::MetadataCache::GetGenericInst(types, inst->type_argc);

    return sharedInst;
}

// this logic must match the C# logic in GenericSharingAnalysis.GetSharedTypeForGenericParameter
static const Il2CppGenericInst* GetSharedInst(const Il2CppGenericInst* inst)
{
    if (inst == NULL)
        return NULL;

    const Il2CppType** types = (const Il2CppType**)alloca(inst->type_argc * sizeof(Il2CppType*));
    for (uint32_t i = 0; i < inst->type_argc; ++i)
    {
        if (il2cpp::vm::Type::IsReference(inst->type_argv[i]))
            types[i] = &il2cpp_defaults.object_class->byval_arg;
        else
        {
            const Il2CppType* type = inst->type_argv[i];
            if (s_Il2CppCodeGenOptions->enablePrimitiveValueTypeGenericSharing)
            {
                if (IsShareableEnum(type))
                {
                    const Il2CppType* underlyingType = il2cpp::vm::Type::GetUnderlyingType(type);
                    switch (underlyingType->type)
                    {
                        case IL2CPP_TYPE_I1:
                            type = &il2cpp_defaults.sbyte_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_I2:
                            type = &il2cpp_defaults.int16_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_I4:
                            type = &il2cpp_defaults.int32_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_I8:
                            type = &il2cpp_defaults.int64_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_U1:
                            type = &il2cpp_defaults.byte_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_U2:
                        case IL2CPP_TYPE_CHAR:
                            type = &il2cpp_defaults.uint16_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_U4:
                            type = &il2cpp_defaults.uint32_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_U8:
                            type = &il2cpp_defaults.uint64_shared_enum->byval_arg;
                            break;
                        case IL2CPP_TYPE_I:
                        case IL2CPP_TYPE_U:
                            break;
                        default:
                            IL2CPP_ASSERT(0 && "Invalid enum underlying type");
                            break;
                    }
                }
            }

            if (il2cpp::vm::Type::IsGenericInstance(type))
            {
                const Il2CppGenericInst* sharedInst = GetSharedInst(type->data.generic_class->context.class_inst);
                Il2CppGenericClass* gklass = il2cpp::metadata::GenericMetadata::GetGenericClass(type->data.generic_class->type, sharedInst);
                Il2CppClass* klass = il2cpp::vm::GenericClass::GetClass(gklass);
                type = &klass->byval_arg;
            }
            types[i] = type;
        }
    }

    const Il2CppGenericInst* sharedInst = il2cpp::vm::MetadataCache::GetGenericInst(types, inst->type_argc);

    return sharedInst;
}

static il2cpp::vm::Il2CppGenericMethodPointers MakeGenericMethodPointers(const Il2CppGenericMethodIndices* methodIndicies, bool isFullyShared)
{
    IL2CPP_ASSERT(methodIndicies->methodIndex >= 0 && (methodIndicies->invokerIndex >= 0 || methodIndicies->invokerIndex == kMethodIndexInvalid));
    if (static_cast<uint32_t>(methodIndicies->methodIndex) < s_Il2CppCodeRegistration->genericMethodPointersCount && static_cast<uint32_t>(methodIndicies->invokerIndex) < s_Il2CppCodeRegistration->invokerPointersCount)
    {
        Il2CppMethodPointer virtualMethod;
        Il2CppMethodPointer method;
        method = s_Il2CppCodeRegistration->genericMethodPointers[methodIndicies->methodIndex];
        if (methodIndicies->adjustorThunkIndex != -1)
        {
            virtualMethod = s_Il2CppCodeRegistration->genericAdjustorThunks[methodIndicies->adjustorThunkIndex];
        }
        else
        {
            virtualMethod = method;
        }

        InvokerMethod invokerMethod;
        if (methodIndicies->invokerIndex == kMethodIndexInvalid)
            invokerMethod = il2cpp::vm::Runtime::GetMissingMethodInvoker();
        else
            invokerMethod = s_Il2CppCodeRegistration->invokerPointers[methodIndicies->invokerIndex];

        return { method, virtualMethod, invokerMethod, isFullyShared };
    }
    return { NULL, NULL, NULL, false };
}

il2cpp::vm::Il2CppGenericMethodPointers il2cpp::vm::MetadataCache::GetGenericMethodPointers(const MethodInfo* methodDefinition, const Il2CppGenericContext* context)
{
    Il2CppGenericMethod method = { 0 };
    method.methodDefinition = const_cast<MethodInfo*>(methodDefinition);
    method.context.class_inst = context->class_inst;
    method.context.method_inst = context->method_inst;

    Il2CppMethodTableMapIter iter = s_MethodTableMap.find(&method);
    if (iter != s_MethodTableMap.end())
        return MakeGenericMethodPointers(iter->second, false);

    // get the shared version if it exists
    method.context.class_inst = GetSharedInst(context->class_inst);
    method.context.method_inst = GetSharedInst(context->method_inst);

    iter = s_MethodTableMap.find(&method);
    if (iter != s_MethodTableMap.end())
        return MakeGenericMethodPointers(iter->second, false);

    // get the fully shared version if it exists
    method.context.class_inst = GetFullySharedInst(methodDefinition->klass->genericContainerHandle, context->class_inst);
    method.context.method_inst = GetFullySharedInst(methodDefinition->genericContainerHandle, context->method_inst);

    iter = s_MethodTableMap.find(&method);
    if (iter != s_MethodTableMap.end())
        return MakeGenericMethodPointers(iter->second, true);

    return { NULL, NULL, NULL };
}

const Il2CppType* il2cpp::vm::MetadataCache::GetIl2CppTypeFromIndex(const Il2CppImage* image, TypeIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetIl2CppTypeFromIndex(index);
}

const Il2CppType* il2cpp::vm::MetadataCache::GetTypeFromRgctxDefinition(const Il2CppRGCTXDefinition* rgctxDef)
{
    return il2cpp::vm::GlobalMetadata::GetTypeFromRgctxDefinition(rgctxDef);
}

const Il2CppGenericMethod* il2cpp::vm::MetadataCache::GetGenericMethodFromRgctxDefinition(const Il2CppRGCTXDefinition* rgctxDef)
{
    return il2cpp::vm::GlobalMetadata::GetGenericMethodFromRgctxDefinition(rgctxDef);
}

std::pair<const Il2CppType*, const MethodInfo*> il2cpp::vm::MetadataCache::GetConstrainedCallFromRgctxDefinition(const Il2CppRGCTXDefinition* rgctxDef)
{
    return il2cpp::vm::GlobalMetadata::GetConstrainedCallFromRgctxDefinition(rgctxDef);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetMethodInfoFromVTableSlot(const Il2CppClass* klass, int32_t vTableSlot)
{
    return il2cpp::vm::GlobalMetadata::GetMethodInfoFromVTableSlot(klass, vTableSlot);
}

static int CompareIl2CppTokenAdjustorThunkPair(const void* pkey, const void* pelem)
{
    return (int)(((Il2CppTokenAdjustorThunkPair*)pkey)->token - ((Il2CppTokenAdjustorThunkPair*)pelem)->token);
}

Il2CppMethodPointer il2cpp::vm::MetadataCache::GetAdjustorThunk(const Il2CppImage* image, uint32_t token)
{
    if (image->codeGenModule->adjustorThunkCount == 0)
        return NULL;

    Il2CppTokenAdjustorThunkPair key;
    memset(&key, 0, sizeof(Il2CppTokenAdjustorThunkPair));
    key.token = token;

    const Il2CppTokenAdjustorThunkPair* result = (const Il2CppTokenAdjustorThunkPair*)bsearch(&key, image->codeGenModule->adjustorThunks,
        image->codeGenModule->adjustorThunkCount, sizeof(Il2CppTokenAdjustorThunkPair), CompareIl2CppTokenAdjustorThunkPair);

    if (result == NULL)
        return NULL;

    return result->adjustorThunk;
}

Il2CppMethodPointer il2cpp::vm::MetadataCache::GetMethodPointer(const Il2CppImage* image, uint32_t token)
{
    uint32_t rid = GetTokenRowId(token);
    uint32_t table =  GetTokenType(token);
    if (rid == 0)
        return NULL;

    IL2CPP_ASSERT(rid <= image->codeGenModule->methodPointerCount);

    return image->codeGenModule->methodPointers[rid - 1];
}

InvokerMethod il2cpp::vm::MetadataCache::GetMethodInvoker(const Il2CppImage* image, uint32_t token)
{
    uint32_t rid = GetTokenRowId(token);
    uint32_t table = GetTokenType(token);
    if (rid == 0)
        return Runtime::GetMissingMethodInvoker();

    int32_t index = image->codeGenModule->invokerIndices[rid - 1];

    if (index == (uint32_t)kMethodIndexInvalid)
        return Runtime::GetMissingMethodInvoker();

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) < s_Il2CppCodeRegistration->invokerPointersCount);
    return s_Il2CppCodeRegistration->invokerPointers[index];
}

const Il2CppInteropData* il2cpp::vm::MetadataCache::GetInteropDataForType(const Il2CppType* type)
{
    IL2CPP_ASSERT(type != NULL);
    InteropDataMap::iterator interopData = s_InteropData.find_first(type);
    if (interopData == s_InteropData.end())
        return NULL;

    return interopData;
}

static bool MatchTokens(Il2CppTokenIndexMethodTuple key, Il2CppTokenIndexMethodTuple element)
{
    return key.token < element.token;
}

static bool GenericInstancesMatch(const MethodInfo* method, const MethodInfo* matchingMethod)
{
    if (method->genericMethod->context.class_inst != NULL && matchingMethod->genericMethod->context.class_inst != NULL)
    {
        if (!il2cpp::metadata::Il2CppGenericInstCompare::AreEqual(method->genericMethod->context.class_inst, matchingMethod->genericMethod->context.class_inst))
            return false;
    }

    if (method->genericMethod->context.method_inst != NULL && matchingMethod->genericMethod->context.method_inst != NULL)
    {
        if (!il2cpp::metadata::Il2CppGenericInstCompare::AreEqual(method->genericMethod->context.method_inst, matchingMethod->genericMethod->context.method_inst))
            return false;
    }

    return true;
}

Il2CppMethodPointer il2cpp::vm::MetadataCache::GetReversePInvokeWrapper(const Il2CppImage* image, const MethodInfo* method)
{
    if (image->codeGenModule->reversePInvokeWrapperCount == 0)
        return NULL;

    // For each image (i.e. assembly), the reverse pinvoke wrapper indices are in an array sorted by
    // metadata token. Each entry also might have the method metadata pointer, which is used to further
    // find methods that have a matching metadata token.

    Il2CppTokenIndexMethodTuple key;
    memset(&key, 0, sizeof(Il2CppTokenIndexMethodTuple));
    key.token = method->token;

    // Binary search for a range which matches the metadata token.
    auto begin = image->codeGenModule->reversePInvokeWrapperIndices;
    auto end = image->codeGenModule->reversePInvokeWrapperIndices + image->codeGenModule->reversePInvokeWrapperCount;
    auto matchingRange = std::equal_range(begin, end, key, &MatchTokens);

    int32_t index = -1;
    auto numberOfMatches = std::distance(matchingRange.first, matchingRange.second);
    if (numberOfMatches == 1)
    {
        if (method->genericMethod == NULL)
        {
            // We found one non-generic method.
            index = matchingRange.first->index;
        }
        else
        {
            // We found one generic method - let's make sure the class and method generic instances match. This reverse p/invoke
            // wrapper might be for a different inflated generic instance.
            const MethodInfo* possibleMatch = il2cpp::metadata::GenericMethod::GetMethod(il2cpp::vm::GlobalMetadata::GetGenericMethodFromTokenMethodTuple(matchingRange.first));
            if (possibleMatch->genericMethod != NULL && GenericInstancesMatch(method, possibleMatch))
                index = matchingRange.first->index;
        }
    }
    else if (numberOfMatches > 1)
    {
        // Multiple generic instance methods share the same token, since it is from the generic method definition.
        // To find the proper method, look for the one with a matching method metadata pointer.
        const Il2CppTokenIndexMethodTuple* currentMatch = matchingRange.first;
        const Il2CppTokenIndexMethodTuple* lastMatch = matchingRange.second;
        while (currentMatch != lastMatch)
        {
            // First, check the method metadata, and use it if it has been initialized.
            // If not, let's fall back to the generic method.
            const MethodInfo* possibleMatch = (const MethodInfo*)*currentMatch->method;
            if (!il2cpp::vm::GlobalMetadata::IsRuntimeMetadataInitialized(possibleMatch))
                possibleMatch = il2cpp::metadata::GenericMethod::GetMethod(il2cpp::vm::GlobalMetadata::GetGenericMethodFromTokenMethodTuple(currentMatch));
            if (possibleMatch == method)
            {
                index = currentMatch->index;
                break;
            }
            currentMatch++;
        }
    }

    if (index == -1)
        return NULL;

    IL2CPP_ASSERT(index >= 0 && static_cast<uint32_t>(index) < s_Il2CppCodeRegistration->reversePInvokeWrapperCount);
    return s_Il2CppCodeRegistration->reversePInvokeWrappers[index];
}

static const Il2CppType* GetReducedType(const Il2CppType* type)
{
    if (type->byref)
        return &il2cpp_defaults.object_class->byval_arg;

    if (il2cpp::vm::Type::IsEnum(type))
        type = il2cpp::vm::Type::GetUnderlyingType(type);

    switch (type->type)
    {
        case IL2CPP_TYPE_BOOLEAN:
            return &il2cpp_defaults.byte_class->byval_arg;
        case IL2CPP_TYPE_CHAR:
            return &il2cpp_defaults.uint16_class->byval_arg;
        case IL2CPP_TYPE_BYREF:
        case IL2CPP_TYPE_CLASS:
        case IL2CPP_TYPE_OBJECT:
        case IL2CPP_TYPE_STRING:
        case IL2CPP_TYPE_ARRAY:
        case IL2CPP_TYPE_SZARRAY:
            return &il2cpp_defaults.object_class->byval_arg;
        case IL2CPP_TYPE_GENERICINST:
            if (il2cpp::vm::Type::IsValueType(type))
            {
                // We can't inflate a generic instance that contains generic arguments
                if (il2cpp::metadata::GenericMetadata::ContainsGenericParameters(type))
                    return type;

                const Il2CppGenericInst* sharedInst = GetSharedInst(type->data.generic_class->context.class_inst);
                Il2CppGenericClass* gklass = il2cpp::metadata::GenericMetadata::GetGenericClass(type->data.generic_class->type, sharedInst);
                Il2CppClass* klass = il2cpp::vm::GenericClass::GetClass(gklass);
                return &klass->byval_arg;
            }

            return &il2cpp_defaults.object_class->byval_arg;
        default:
            return type;
    }
}

il2cpp::vm::Il2CppUnresolvedCallStubs il2cpp::vm::MetadataCache::GetUnresovledCallStubs(const MethodInfo* method)
{
    il2cpp::vm::Il2CppUnresolvedCallStubs stubs;
    stubs.stubsFound = false;

    il2cpp::metadata::Il2CppSignature signature;
    signature.Count = method->parameters_count + 1;
    signature.Types = (const Il2CppType**)alloca(signature.Count * sizeof(Il2CppType*));

    signature.Types[0] = GetReducedType(method->return_type);
    for (int i = 0; i < method->parameters_count; ++i)
        signature.Types[i + 1] = GetReducedType(method->parameters[i]);

    Il2CppUnresolvedSignatureMapIter it = s_pUnresolvedSignatureMap->find(signature);
    if (it != s_pUnresolvedSignatureMap->end())
    {
        if (il2cpp::vm::Method::IsInstance(method))
        {
            stubs.methodPointer = s_Il2CppCodeRegistration->unresolvedInstanceCallPointers[it->second];
            stubs.virtualMethodPointer = s_Il2CppCodeRegistration->unresolvedVirtualCallPointers[it->second];
            stubs.stubsFound = true;
        }
        else
        {
            stubs.methodPointer = s_Il2CppCodeRegistration->unresolvedStaticCallPointers[it->second];
            stubs.virtualMethodPointer = stubs.methodPointer;
            stubs.stubsFound = true;
        }
    }
    else
    {
        const MethodInfo* entryPointNotFoundMethod = il2cpp::vm::Method::GetEntryPointNotFoundMethodInfo();
        stubs.methodPointer = entryPointNotFoundMethod->methodPointer;
        stubs.virtualMethodPointer = entryPointNotFoundMethod->methodPointer;
    }

    return stubs;
}

const Il2CppAssembly* il2cpp::vm::MetadataCache::GetAssemblyFromIndex(AssemblyIndex index)
{
    if (index == kGenericContainerIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index <= s_AssembliesCount);
    return s_AssembliesTable + index;
}

const Il2CppAssembly* il2cpp::vm::MetadataCache::GetAssemblyByName(const char* nameToFind)
{
    for (int i = 0; i < s_AssembliesCount; i++)
    {
        const Il2CppAssembly* assembly = s_AssembliesTable + i;

        const char* assemblyName = assembly->aname.name;

        if (strcmp(assemblyName, nameToFind) == 0)
            return assembly;
    }

    return NULL;
}

Il2CppImage* il2cpp::vm::MetadataCache::GetImageFromIndex(ImageIndex index)
{
    if (index == kGenericContainerIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index <= s_ImagesCount);
    return s_ImagesTable + index;
}

Il2CppClass* il2cpp::vm::MetadataCache::GetTypeInfoFromType(const Il2CppType* type)
{
    if (type == NULL)
        return NULL;

    return il2cpp::vm::GlobalMetadata::GetTypeInfoFromType(type);
}

Il2CppClass* il2cpp::vm::MetadataCache::GetTypeInfoFromHandle(Il2CppMetadataTypeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetTypeInfoFromHandle(handle);
}

Il2CppMetadataGenericContainerHandle il2cpp::vm::MetadataCache::GetGenericContainerFromGenericClass(const Il2CppImage* image, const Il2CppGenericClass* genericClass)
{
    return il2cpp::vm::GlobalMetadata::GetGenericContainerFromGenericClass(genericClass);
}

Il2CppMetadataGenericContainerHandle il2cpp::vm::MetadataCache::GetGenericContainerFromMethod(Il2CppMetadataMethodDefinitionHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetGenericContainerFromMethod(handle);
}

Il2CppMetadataGenericParameterHandle il2cpp::vm::MetadataCache::GetGenericParameterFromType(const Il2CppType* type)
{
    return il2cpp::vm::GlobalMetadata::GetGenericParameterFromType(type);
}

Il2CppClass* il2cpp::vm::MetadataCache::GetContainerDeclaringType(Il2CppMetadataGenericContainerHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetContainerDeclaringType(handle);
}

Il2CppClass* il2cpp::vm::MetadataCache::GetParameterDeclaringType(Il2CppMetadataGenericParameterHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetParameterDeclaringType(handle);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetParameterDeclaringMethod(Il2CppMetadataGenericParameterHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetParameterDeclaringMethod(handle);
}

Il2CppMetadataGenericParameterHandle il2cpp::vm::MetadataCache::GetGenericParameterFromIndex(Il2CppMetadataGenericContainerHandle handle, GenericContainerParameterIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetGenericParameterFromIndex(handle, index);
}

const Il2CppType* il2cpp::vm::MetadataCache::GetGenericParameterConstraintFromIndex(Il2CppMetadataGenericParameterHandle handle, GenericParameterConstraintIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetGenericParameterConstraintFromIndex(handle, index);
}

Il2CppClass* il2cpp::vm::MetadataCache::GetNestedTypeFromOffset(const Il2CppClass* klass, TypeNestedTypeIndex offset)
{
    return il2cpp::vm::GlobalMetadata::GetNestedTypeFromOffset(klass, offset);
}

const Il2CppType* il2cpp::vm::MetadataCache::GetInterfaceFromOffset(const Il2CppClass* klass, TypeInterfaceIndex offset)
{
    return il2cpp::vm::GlobalMetadata::GetInterfaceFromOffset(klass, offset);
}

Il2CppInterfaceOffsetInfo il2cpp::vm::MetadataCache::GetInterfaceOffsetInfo(const Il2CppClass* klass, TypeInterfaceOffsetIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetInterfaceOffsetInfo(klass, index);
}

static int CompareIl2CppTokenRangePair(const void* pkey, const void* pelem)
{
    return (int)(((Il2CppTokenRangePair*)pkey)->token - ((Il2CppTokenRangePair*)pelem)->token);
}

il2cpp::vm::RGCTXCollection il2cpp::vm::MetadataCache::GetRGCTXs(const Il2CppImage* image, uint32_t token)
{
    RGCTXCollection collection = { 0, NULL };
    if (image->codeGenModule->rgctxRangesCount == 0)
        return collection;

    Il2CppTokenRangePair key;
    memset(&key, 0, sizeof(Il2CppTokenRangePair));
    key.token = token;

    const Il2CppTokenRangePair* res = (const Il2CppTokenRangePair*)bsearch(&key, image->codeGenModule->rgctxRanges, image->codeGenModule->rgctxRangesCount, sizeof(Il2CppTokenRangePair), CompareIl2CppTokenRangePair);

    if (res == NULL)
        return collection;

    collection.count = res->range.length;
    collection.items = image->codeGenModule->rgctxs + res->range.start;

    return collection;
}

const uint8_t* il2cpp::vm::MetadataCache::GetFieldDefaultValue(const FieldInfo* field, const Il2CppType** type)
{
    return il2cpp::vm::GlobalMetadata::GetFieldDefaultValue(field, type);
}

const uint8_t* il2cpp::vm::MetadataCache::GetParameterDefaultValue(const MethodInfo* method, int32_t parameterPosition, const Il2CppType** type, bool* isExplicitySetNullDefaultValue)
{
    return il2cpp::vm::GlobalMetadata::GetParameterDefaultValue(method, parameterPosition, type, isExplicitySetNullDefaultValue);
}

int il2cpp::vm::MetadataCache::GetFieldMarshaledSizeForField(const FieldInfo* field)
{
    return il2cpp::vm::GlobalMetadata::GetFieldMarshaledSizeForField(field);
}

int32_t il2cpp::vm::MetadataCache::GetFieldOffsetFromIndexLocked(const Il2CppClass* klass, int32_t fieldIndexInType, FieldInfo* field, const il2cpp::os::FastAutoLock& lock)
{
    int32_t offset = il2cpp::vm::GlobalMetadata::GetFieldOffset(klass, fieldIndexInType, field);
    if (offset < 0)
    {
        AddThreadLocalStaticOffsetForFieldLocked(field, offset & ~THREAD_LOCAL_STATIC_MASK, lock);
        return THREAD_STATIC_FIELD_OFFSET;
    }
    return offset;
}

void il2cpp::vm::MetadataCache::AddThreadLocalStaticOffsetForFieldLocked(FieldInfo* field, int32_t offset, const il2cpp::os::FastAutoLock& lock)
{
    s_ThreadLocalStaticOffsetMap.add(field, offset);
}

int32_t il2cpp::vm::MetadataCache::GetThreadLocalStaticOffsetForField(FieldInfo* field)
{
    IL2CPP_ASSERT(field->offset == THREAD_STATIC_FIELD_OFFSET);

    il2cpp::os::FastAutoLock lock(&g_MetadataLock);
    Il2CppThreadLocalStaticOffsetHashMapIter iter = s_ThreadLocalStaticOffsetMap.find(field);
    IL2CPP_ASSERT(iter != s_ThreadLocalStaticOffsetMap.end());
    return iter->second;
}

Il2CppMetadataCustomAttributeHandle il2cpp::vm::MetadataCache::GetCustomAttributeTypeToken(const Il2CppImage* image, uint32_t token)
{
    return il2cpp::vm::GlobalMetadata::GetCustomAttributeTypeToken(image, token);
}

il2cpp::metadata::CustomAttributeDataReader  il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(const Il2CppImage* image, uint32_t token)
{
    return il2cpp::vm::GlobalMetadata::GetCustomAttributeDataReader(image, token);
}

il2cpp::metadata::CustomAttributeDataReader  il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(Il2CppMetadataCustomAttributeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetCustomAttributeDataReader(handle);
}

const Il2CppAssembly* il2cpp::vm::MetadataCache::GetReferencedAssembly(const Il2CppAssembly* assembly, int32_t referencedAssemblyTableIndex)
{
    return il2cpp::vm::GlobalMetadata::GetReferencedAssembly(assembly, referencedAssemblyTableIndex, s_AssembliesTable, s_AssembliesCount);
}

void il2cpp::vm::MetadataCache::InitializeAllMethodMetadata()
{
    il2cpp::vm::GlobalMetadata::InitializeAllMethodMetadata();
}

void* il2cpp::vm::MetadataCache::InitializeRuntimeMetadata(uintptr_t* metadataPointer)
{
    return il2cpp::vm::GlobalMetadata::InitializeRuntimeMetadata(metadataPointer, true);
}

void il2cpp::vm::MetadataCache::WalkPointerTypes(WalkTypesCallback callback, void* context)
{
    os::FastAutoLock lock(&g_MetadataLock);

    for (PointerTypeMap::iterator it = s_MetadataCache.m_PointerTypes.UnlockedBegin(); it != s_MetadataCache.m_PointerTypes.UnlockedEnd(); it++)
    {
        callback(it->second, context);
    }
}

Il2CppMetadataTypeHandle il2cpp::vm::MetadataCache::GetTypeHandleFromIndex(const Il2CppImage* image, TypeDefinitionIndex typeIndex)
{
    return il2cpp::vm::GlobalMetadata::GetTypeHandleFromIndex(typeIndex);
}

Il2CppMetadataTypeHandle il2cpp::vm::MetadataCache::GetTypeHandleFromType(const Il2CppType* type)
{
    return il2cpp::vm::GlobalMetadata::GetTypeHandleFromType(type);
}

bool il2cpp::vm::MetadataCache::TypeIsNested(Il2CppMetadataTypeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::TypeIsNested(handle);
}

bool il2cpp::vm::MetadataCache::TypeIsValueType(Il2CppMetadataTypeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::TypeIsValueType(handle);
}

bool il2cpp::vm::MetadataCache::StructLayoutPackIsDefault(Il2CppMetadataTypeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::StructLayoutPackIsDefault(handle);
}

int32_t il2cpp::vm::MetadataCache::StructLayoutPack(Il2CppMetadataTypeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::StructLayoutPack(handle);
}

bool il2cpp::vm::MetadataCache::StructLayoutSizeIsDefault(Il2CppMetadataTypeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::StructLayoutSizeIsDefault(handle);
}

std::pair<const char*, const char*> il2cpp::vm::MetadataCache::GetTypeNamespaceAndName(Il2CppMetadataTypeHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetTypeNamespaceAndName(handle);
}

Il2CppMetadataTypeHandle il2cpp::vm::MetadataCache::GetNestedTypes(Il2CppClass *klass, void* *iter)
{
    return GetNestedTypes(
        klass->typeMetadataHandle,
        iter
    );
}

Il2CppMetadataTypeHandle il2cpp::vm::MetadataCache::GetNestedTypes(Il2CppMetadataTypeHandle handle, void** iter)
{
    return il2cpp::vm::GlobalMetadata::GetNestedTypes(handle, iter);
}

Il2CppMetadataFieldInfo il2cpp::vm::MetadataCache::GetFieldInfo(const Il2CppClass* klass, TypeFieldIndex fieldIndex)
{
    return il2cpp::vm::GlobalMetadata::GetFieldInfo(klass, fieldIndex);
}

Il2CppMetadataMethodInfo il2cpp::vm::MetadataCache::GetMethodInfo(const Il2CppClass* klass, TypeMethodIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetMethodInfo(klass, index);
}

Il2CppMetadataParameterInfo il2cpp::vm::MetadataCache::GetParameterInfo(const Il2CppClass* klass, Il2CppMetadataMethodDefinitionHandle handle, MethodParameterIndex paramIndex)
{
    return il2cpp::vm::GlobalMetadata::GetParameterInfo(klass, handle, paramIndex);
}

Il2CppMetadataPropertyInfo il2cpp::vm::MetadataCache::GetPropertyInfo(const Il2CppClass* klass, TypePropertyIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetPropertyInfo(klass, index);
}

Il2CppMetadataEventInfo il2cpp::vm::MetadataCache::GetEventInfo(const Il2CppClass* klass, TypeEventIndex index)
{
    return il2cpp::vm::GlobalMetadata::GetEventInfo(klass, index);
}

uint32_t il2cpp::vm::MetadataCache::GetReturnParameterToken(Il2CppMetadataMethodDefinitionHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetReturnParameterToken(handle);
}

uint32_t il2cpp::vm::MetadataCache::GetGenericContainerCount(Il2CppMetadataGenericContainerHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetGenericContainerCount(handle);
}

void il2cpp::vm::MetadataCache::MakeGenericArgType(Il2CppMetadataGenericContainerHandle containerHandle, Il2CppMetadataGenericParameterHandle paramHandle, Il2CppType* arg)
{
    return il2cpp::vm::GlobalMetadata::MakeGenericArgType(containerHandle, paramHandle, arg);
}

bool il2cpp::vm::MetadataCache::GetGenericContainerIsMethod(Il2CppMetadataGenericContainerHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetGenericContainerIsMethod(handle);
}

int16_t il2cpp::vm::MetadataCache::GetGenericConstraintCount(Il2CppMetadataGenericParameterHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetGenericConstraintCount(handle);
}

const char* il2cpp::vm::MetadataCache::GetGenericParameterName(Il2CppMetadataGenericParameterHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetGenericParameterName(handle);
}

Il2CppGenericParameterInfo il2cpp::vm::MetadataCache::GetGenericParameterInfo(Il2CppMetadataGenericParameterHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetGenericParameterInfo(handle);
}

uint16_t il2cpp::vm::MetadataCache::GetGenericParameterFlags(Il2CppMetadataGenericParameterHandle handle)
{
    return il2cpp::vm::GlobalMetadata::GetGenericParameterFlags(handle);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetMethodInfoFromCatchPoint(const Il2CppImage* image, const Il2CppCatchPoint* cp)
{
    return il2cpp::vm::GlobalMetadata::GetMethodInfoFromCatchPoint(cp);
}

const MethodInfo* il2cpp::vm::MetadataCache::GetMethodInfoFromSequencePoint(const Il2CppImage* image, const Il2CppSequencePoint* seqPoint)
{
    return il2cpp::vm::GlobalMetadata::GetMethodInfoFromSequencePoint(seqPoint);
}

Il2CppClass* il2cpp::vm::MetadataCache::GetTypeInfoFromTypeSourcePair(const Il2CppImage* image, const Il2CppTypeSourceFilePair* pair)
{
    return il2cpp::vm::GlobalMetadata::GetTypeInfoFromTypeSourcePair(pair);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MetadataCache.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MetadataLoader.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MetadataLoader.h"
#include "os/File.h"
#include "os/Mutex.h"
#include "utils/MemoryMappedFile.h"
#include "utils/PathUtils.h"
#include "utils/Runtime.h"
#include "utils/Logging.h"


void* il2cpp::vm::MetadataLoader::LoadMetadataFile(const char* fileName)
{
    std::string resourcesDirectory = utils::PathUtils::Combine(utils::Runtime::GetDataDir(), utils::StringView<char>("Metadata"));

    std::string resourceFilePath = utils::PathUtils::Combine(resourcesDirectory, utils::StringView<char>(fileName, strlen(fileName)));

    int error = 0;
    os::FileHandle* handle = os::File::Open(resourceFilePath, kFileModeOpen, kFileAccessRead, kFileShareRead, kFileOptionsNone, &error);
    if (error != 0)
    {
        utils::Logging::Write("ERROR: Could not open %s", resourceFilePath.c_str());
        return NULL;
    }

    void* fileBuffer = utils::MemoryMappedFile::Map(handle);

    os::File::Close(handle, &error);
    if (error != 0)
    {
        utils::MemoryMappedFile::Unmap(fileBuffer);
        fileBuffer = NULL;
        return NULL;
    }

    return fileBuffer;
}

void il2cpp::vm::MetadataLoader::UnloadMetadataFile(void* fileBuffer)
{
    bool success = il2cpp::utils::MemoryMappedFile::Unmap(fileBuffer);
    NO_UNUSED_WARNING(success);
    IL2CPP_ASSERT(success);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\MetadataLoader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Method.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/Method.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-class-internals.h"
#include "vm/Class.h"
#include "vm/MetadataCache.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/Type.h"

namespace il2cpp
{
namespace vm
{
    const Il2CppType* Method::GetReturnType(const MethodInfo* method)
    {
        return method->return_type;
    }

    Il2CppClass *Method::GetDeclaringType(const MethodInfo* method)
    {
        return method->klass;
    }

    const char* Method::GetName(const MethodInfo *method)
    {
        return method->name;
    }

    std::string Method::GetNameWithGenericTypes(const MethodInfo* method)
    {
        std::string str;

        str += method->name;

        if (method->is_inflated && method->genericMethod->context.method_inst)
        {
            const Il2CppGenericInst *inst = method->genericMethod->context.method_inst;

            str += '<';

            for (unsigned int i = 0; i < inst->type_argc; ++i)
            {
                str += Type::GetName(inst->type_argv[i], IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
                if (i < inst->type_argc - 1)
                    str += ",";
            }

            str += '>';
        }

        return str;
    }

    bool Method::IsGeneric(const MethodInfo *method)
    {
        return method->is_generic;
    }

    bool Method::IsInflated(const MethodInfo *method)
    {
        return method->is_inflated;
    }

    bool Method::IsGenericInstance(const MethodInfo *method)
    {
        return method->is_inflated && !method->is_generic;
    }

    bool Method::IsGenericInstanceMethod(const MethodInfo *method)
    {
        return method->is_inflated && !method->is_generic && method->genericMethod->context.method_inst;
    }

    bool Method::IsDefaultInterfaceMethodOnGenericInstance(const MethodInfo* method)
    {
        return method->methodPointer && Class::IsInterface(method->klass) && Class::IsInflated(method->klass) && !method->klass->is_import_or_windows_runtime;
    }

    bool Method::IsInstance(const MethodInfo *method)
    {
        return !(method->flags & METHOD_ATTRIBUTE_STATIC);
    }

    uint32_t Method::GetParamCount(const MethodInfo *method)
    {
        return method->parameters_count;
    }

    uint32_t Method::GetGenericParamCount(const MethodInfo *method)
    {
        if (IsGeneric(method) && method->genericContainerHandle != NULL)
            return MetadataCache::GetGenericContainerCount(method->genericContainerHandle);
        return 0;
    }

    const Il2CppType* Method::GetParam(const MethodInfo *method, uint32_t index)
    {
        if (index < method->parameters_count)
            return method->parameters[index];
        else
            return NULL;
    }

    const char* Method::GetParamName(const MethodInfo *method, uint32_t index)
    {
        IL2CPP_ASSERT(method != NULL && "Method::GetParamName cannot be invoked with a NULL MethodInfo.");

        if (index >= method->parameters_count)
            return NULL;

        if (method->is_inflated)
        {
            method = il2cpp::vm::MetadataCache::GetGenericMethodDefinition(method);
        }

        // we construct some 'pseudo' methods for things like arrays
        if (!method->methodMetadataHandle)
            return NULL;

        Il2CppMetadataParameterInfo paramInfo = MetadataCache::GetParameterInfo(method->klass, method->methodMetadataHandle, index);

        return paramInfo.name;
    }

    Il2CppClass* Method::GetClass(const MethodInfo *method)
    {
        return method->klass;
    }

    bool Method::HasAttribute(const MethodInfo *method, Il2CppClass *attr_class)
    {
        return Reflection::HasAttribute(method, attr_class);
    }

    uint32_t Method::GetImplementationFlags(const MethodInfo *method)
    {
        return method->iflags;
    }

    uint32_t Method::GetFlags(const MethodInfo *method)
    {
        return method->flags;
    }

    uint32_t Method::GetToken(const MethodInfo *method)
    {
        return method->token;
    }

// From ECMA-335, I.10.2 Overloading
// Methods and properties can be overloaded by:
//  * Number of parameters
//  * Type of any parameter
//  * Calling convention <------ not stored in our metadata yet
//  * Custom modifiers   <------ not supported by il2cpp
//  * Whether a parameter is passed by value or by reference
    static bool AreParametersSame(const Il2CppType** params1, const Il2CppType** params2, int count)
    {
        for (int i = 0; i < count; i++)
        {
            const Il2CppType* param1 = params1[i];
            const Il2CppType* param2 = params2[i];

            if (param1->byref != param2->byref)
            {
                return false;
            }

            if (Class::FromIl2CppType(param1) != Class::FromIl2CppType(param2))
            {
                return false;
            }
        }

        return true;
    }

    static int CompareParameters(const Il2CppType** params1, const Il2CppType** params2, int count)
    {
        for (int i = 0; i < count; i++)
        {
            const Il2CppType* param1 = params1[i];
            const Il2CppType* param2 = params2[i];

            if (param1->byref == param2->byref)
            {
                return Class::FromIl2CppType(param1) < Class::FromIl2CppType(param2);
            }

            return param1->byref < param2->byref;
        }

        return true;
    }

    bool Method::IsSameOverloadSignature(const MethodInfo* method1, const MethodInfo* method2)
    {
        if (method1->parameters_count != method2->parameters_count)
        {
            return false;
        }

        return AreParametersSame(method1->parameters, method2->parameters, method1->parameters_count);
    }

    bool Method::IsSameOverloadSignature(const PropertyInfo* property1, const PropertyInfo* property2)
    {
        uint8_t parameterCount1, parameterCount2;
        const Il2CppType** parameters1;
        const Il2CppType** parameters2;

        if (property1->get != NULL)
        {
            parameterCount1 = property1->get->parameters_count;
            parameters1 = property1->get->parameters;
        }
        else
        {
            // In set method, value is the last parameter, so we just don't care about it
            parameterCount1 = property1->set->parameters_count - 1;
            parameters1 = property1->set->parameters;
        }

        if (property2->get != NULL)
        {
            parameterCount2 = property2->get->parameters_count;
            parameters2 = property2->get->parameters;
        }
        else
        {
            parameterCount2 = property2->set->parameters_count - 1;
            parameters2 = property2->set->parameters;
        }

        if (parameterCount1 != parameterCount2)
        {
            return false;
        }

        return AreParametersSame(parameters1, parameters2, parameterCount1);
    }

    int Method::CompareOverloadSignature(const PropertyInfo* property1, const PropertyInfo* property2)
    {
        uint8_t parameterCount1, parameterCount2;
        const Il2CppType** parameters1;
        const Il2CppType** parameters2;

        if (property1->get != NULL)
        {
            parameterCount1 = property1->get->parameters_count;
            parameters1 = property1->get->parameters;
        }
        else
        {
            // In set method, value is the last parameter, so we just don't care about it
            parameterCount1 = property1->set->parameters_count - 1;
            parameters1 = property1->set->parameters;
        }

        if (property2->get != NULL)
        {
            parameterCount2 = property2->get->parameters_count;
            parameters2 = property2->get->parameters;
        }
        else
        {
            parameterCount2 = property2->set->parameters_count - 1;
            parameters2 = property2->set->parameters;
        }

        if (parameterCount1 == parameterCount2)
        {
            return CompareParameters(parameters1, parameters2, parameterCount1);
        }

        return parameterCount1 < parameterCount2;
    }

    const char* Method::GetParameterDefaultValue(const MethodInfo* method, int32_t parameterPosition, const Il2CppType** type, bool* isExplicitySetNullDefaultValue)
    {
        return reinterpret_cast<const char*>(MetadataCache::GetParameterDefaultValue(method, parameterPosition, type, isExplicitySetNullDefaultValue));
    }

    uint32_t Method::GetParameterToken(const MethodInfo* method, int32_t index)
    {
        if (index >= method->parameters_count)
            return 0;

        if (method->is_inflated)
        {
            method = il2cpp::vm::MetadataCache::GetGenericMethodDefinition(method);
        }

        // we construct some 'pseudo' methods for things like arrays
        if (!method->methodMetadataHandle)
            return 0;

        // We are looking at the return parameter, which is not stored as a parameter, but the method has its token
        if (index == -1)
        {
            return MetadataCache::GetReturnParameterToken(method->methodMetadataHandle);
        }

        Il2CppMetadataParameterInfo paramInfo = MetadataCache::GetParameterInfo(method->klass, method->methodMetadataHandle, index);

        return paramInfo.token;
    }

    std::string Method::GetFullName(const MethodInfo* method)
    {
        std::string str;
        str += Type::GetName(&method->klass->byval_arg, IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
        str += "::";
        str += Method::GetNameWithGenericTypes(method);

        return str;
    }

    static void AmbiguousImplementationMethod()
    {
        il2cpp::vm::Runtime::RaiseAmbiguousImplementationException(NULL);
    }

    static void AmbiguousImplementationMethodInvoker(Il2CppMethodPointer ptr, const MethodInfo* method, void* obj, void** args, void* ret)
    {
        il2cpp::vm::Runtime::RaiseAmbiguousImplementationException(method);
    }

    static void EntryPointNotFoundImplementationMethod()
    {
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetEntryPointNotFoundException(""));
    }

    static void EntryPointNotFoundMethodInvoker(Il2CppMethodPointer ptr, const MethodInfo* method, void* obj, void** args, void* ret)
    {
        std::string name = "";
        if (method != NULL && method->name != NULL)
            name = Method::GetFullName(method);
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetEntryPointNotFoundException(name.c_str()));
    }

    const static MethodInfo ambiguousMethodInfo =
    {
        AmbiguousImplementationMethod,              // method_ptr
        AmbiguousImplementationMethod,              // virtual_method_ptr
        AmbiguousImplementationMethodInvoker,       // invoker_method
    };

    const static MethodInfo entryPointNoFoundMethodInfo =
    {
        EntryPointNotFoundImplementationMethod,     // method_ptr
        EntryPointNotFoundImplementationMethod,     // virtual_method_ptr
        EntryPointNotFoundMethodInvoker,            // invoker_method
    };

    const MethodInfo* Method::GetAmbiguousMethodInfo()
    {
        IL2CPP_ASSERT(ambiguousMethodInfo.methodPointer == AmbiguousImplementationMethod);
        IL2CPP_ASSERT(ambiguousMethodInfo.virtualMethodPointer == AmbiguousImplementationMethod);
        IL2CPP_ASSERT(ambiguousMethodInfo.invoker_method == AmbiguousImplementationMethodInvoker);

        // GenericMethod::GetMethod relies on ambiguousMethodInfo being a singleton
        return &ambiguousMethodInfo;
    }

    const MethodInfo* Method::GetEntryPointNotFoundMethodInfo()
    {
        IL2CPP_ASSERT(entryPointNoFoundMethodInfo.methodPointer == EntryPointNotFoundImplementationMethod);
        IL2CPP_ASSERT(entryPointNoFoundMethodInfo.virtualMethodPointer == EntryPointNotFoundImplementationMethod);
        IL2CPP_ASSERT(entryPointNoFoundMethodInfo.invoker_method == EntryPointNotFoundMethodInvoker);

        return &entryPointNoFoundMethodInfo;
    }

    bool Method::IsAmbiguousMethodInfo(const MethodInfo* method)
    {
        return method == &ambiguousMethodInfo || metadata::GenericMethod::IsGenericAmbiguousMethodInfo(method);
    }

    bool Method::IsEntryPointNotFoundMethodInfo(const MethodInfo* method)
    {
        return method == &entryPointNoFoundMethodInfo;
    }

    bool Method::HasFullGenericSharingSignature(const MethodInfo* method)
    {
        return method->has_full_generic_sharing_signature;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Method.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Module.cpp---------------
.
.
#include "vm/Module.h"
#include "il2cpp-class-internals.h"

namespace il2cpp
{
namespace vm
{
    uint32_t Module::GetToken(const Il2CppImage *image)
    {
        return image->token;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Module.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Monitor.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "vm/Monitor.h"

#if IL2CPP_SUPPORT_THREADS

#include "os/Atomic.h"
#include "os/Event.h"
#include "os/Semaphore.h"
#include "os/Thread.h"
#include "vm/Exception.h"
#include "vm/Thread.h"

#include "utils/ThreadSafeFreeList.h"

#include <limits>
#include <exception>

#include "Baselib.h"
#include "Cpp/Atomic.h"


// Mostly follows the algorithm outlined in "Implementing Fast Java Monitors with Relaxed-Locks".

/// State of a lock associated with an object.
///
/// Allocated from the normal non-GC heap and kept on a free list. This means that an object that is
/// not unlocked before it is reclaimed will leak its monitor. However, it allows us to not have to
/// synchronize with the GC and to efficiently reuse a small number of monitor instances between an
/// arbitrary number of managed objects.
///
// NOTE: We do *NOT* allow deletion of monitors as threads may be hanging on to monitors even as they
//  are already back on the free list (and maybe even in use somewhere else already).
struct MonitorData : public il2cpp::utils::ThreadSafeFreeListNode
{
    static const il2cpp::os::Thread::ThreadId kCanBeAcquiredByOtherThread = il2cpp::os::Thread::kInvalidThreadId;
    static const il2cpp::os::Thread::ThreadId kHasBeenReturnedToFreeList = (il2cpp::os::Thread::ThreadId)-1;

    /// ID of thread that currently has the object locked or one of the two values above.
    ///
    /// This signals three possible states:
    ///
    /// 1) Contains a valid thread ID. Means the monitor is owned by that thread and only that thread can
    ///    change the value of this field.
    /// 2) Contains kCanBeAcquiredByOtherThread. Means monitor is still live and attached to an object
    ///    but is up for grabs by whichever thread manages to swap the value of this field for its own
    ///    thread ID first.
    /// 3) Contains kHasBeenReturnedToFreeList. Means monitor is not attached to any object and can be
    ///    acquired by any thread *but* only through the free list.
    baselib::atomic<il2cpp::os::Thread::ThreadId> owningThreadId;

    baselib::atomic<bool> threadAborted;

    /// Number of times the object has been locked on the owning thread. Everything above 1 indicates
    /// a recursive lock.
    /// NOTE: This field is never reset to zero.
    uint32_t recursiveLockingCount;

    /// Semaphore used to signal other blocked threads that the monitor has become available.
    /// The "ready queue" is implicit in the list of threads waiting on this semaphore.
    il2cpp::os::Semaphore semaphore;

    /// Number of threads that are already waiting or are about to wait for a lock on the monitor.
    baselib::atomic<uint32_t> numThreadsWaitingForSemaphore;

    /// Event that a waiting thread fires to acknowledge that it has been kicked off a monitor by the thread
    /// already holding a lock on the object being waited for. This happens when the locking thread decides
    /// to deflate the locked object and thus kill the monitor but then some other thread comes along and
    /// decides to wait on the monitor-to-be-killed.
    il2cpp::os::Event flushAcknowledged;

    /// Node in list of waiting threads.
    ///
    /// Memory management is done the same way as for MonitorData itself. The same constraints apply.
    /// Wait nodes are returned to the free list by the threads that have created them except for abandoned
    /// nodes which may be returned by the pulsing thread.
    ///
    /// NOTE: Every wait node must be cleaned up by the wait thread that allocated it.
    struct PulseWaitingListNode : public il2cpp::utils::ThreadSafeFreeListNode
    {
        enum State
        {
            /// Node is waiting to be reused.
            kUnused,
            /// Node is waiting to be signaled.
            kWaiting
        };

        /// Next node in "threadsWaitingForPulse" list.
        /// NOTE: Once on the list, this field may only be modified by the thread holding a lock
        ///       on the respective monitor.
        PulseWaitingListNode* nextNode;

        /// Event to notify waiting thread of pulse.
        il2cpp::os::Event signalWaitingThread;

        /// Current usage state. This is not set atomically. Change this state only if you
        /// are at a known sequence point.
        int32_t state;

        static il2cpp::utils::ThreadSafeFreeList<PulseWaitingListNode>* s_FreeList;

        PulseWaitingListNode()
            : nextNode(NULL)
            , state(kUnused) {}

        void Release()
        {
            state = kUnused;
            signalWaitingThread.Reset();
            s_FreeList->Release(this);
        }

        static PulseWaitingListNode* Allocate()
        {
            PulseWaitingListNode* node = s_FreeList->Allocate();
            IL2CPP_ASSERT(node->state == kUnused);
            return node;
        }
    };

    /// List of threads waiting for a pulse on the monitor.
    /// NOTE: This field may be modified concurrently by several threads (no lock).
    PulseWaitingListNode* threadsWaitingForPulse;

    static il2cpp::utils::ThreadSafeFreeList<MonitorData>* s_FreeList;

    MonitorData()
        : owningThreadId(kHasBeenReturnedToFreeList)
        , threadAborted(false)
        , recursiveLockingCount(1)
        , numThreadsWaitingForSemaphore(0)
        , threadsWaitingForPulse(NULL)
        , semaphore(0, std::numeric_limits<int32_t>::max())
    {
    }

    bool IsAcquired() const
    {
        return (owningThreadId != kCanBeAcquiredByOtherThread && owningThreadId != kHasBeenReturnedToFreeList);
    }

    bool IsOwnedByThread(il2cpp::os::Thread::ThreadId threadId) const
    {
        return owningThreadId == threadId;
    }

    bool TryAcquire(size_t threadId)
    {
        // The compare_exchange_strong method can change its first argument.
        // We don't care about the changed valuem, though, so ignore it.
        il2cpp::os::Thread::ThreadId local = kCanBeAcquiredByOtherThread;
        return owningThreadId.compare_exchange_strong(local, threadId);
    }

    void Unacquire()
    {
        IL2CPP_ASSERT(owningThreadId == il2cpp::os::Thread::CurrentThreadId());
        // Use `exchange` rather than `store` to ensure this is a read-modify-write
        // operation and all threads observe modifications in the same order,
        // i.e. changes within the `lock` block occur before the acquisition
        // of the monitor by another thread.
        // See: https://en.cppreference.com/w/cpp/atomic/memory_order
        owningThreadId.exchange(kCanBeAcquiredByOtherThread);
    }

    /// Mark current thread as being blocked in Monitor.Enter(), i.e. as "ready to acquire monitor
    /// whenever it becomes available."
    void AddCurrentThreadToReadyList()
    {
        numThreadsWaitingForSemaphore++;
        il2cpp::vm::Thread::SetState(il2cpp::vm::Thread::Current(), il2cpp::vm::kThreadStateWaitSleepJoin);
    }

    /// Mark current thread is no longer being blocked on the monitor.
    int RemoveCurrentThreadFromReadyList()
    {
        int numRemainingWaitingThreads = --numThreadsWaitingForSemaphore;
        il2cpp::vm::Thread::ClrState(il2cpp::vm::Thread::Current(), il2cpp::vm::kThreadStateWaitSleepJoin);
        return numRemainingWaitingThreads;
    }

    /// Acknowledge that the owning thread has decided to kill the monitor (a.k.a. deflate the corresponding
    /// object) while we were waiting on it.
    void VacateDyingMonitor()
    {
        RemoveCurrentThreadFromReadyList();
        flushAcknowledged.Set();
    }

    void PushOntoPulseWaitingList(PulseWaitingListNode* node)
    {
        // Change state to waiting. Safe to not do this atomically as at this point,
        // the waiting thread is the only one with access to the node.
        node->state = PulseWaitingListNode::kWaiting;

        // Race other wait threads until we've successfully linked the
        // node into the list.
        while (true)
        {
            PulseWaitingListNode* nextNode = threadsWaitingForPulse;
            node->nextNode = nextNode;
            if (il2cpp::os::Atomic::CompareExchangePointer(&threadsWaitingForPulse, node, nextNode) == nextNode)
                break;
        }
    }

    /// Get the next wait node and remove it from the list.
    /// NOTE: Calling thread *must* have the monitor locked.
    PulseWaitingListNode* PopNextFromPulseWaitingList()
    {
        IL2CPP_ASSERT(owningThreadId == il2cpp::os::Thread::CurrentThreadId());

        PulseWaitingListNode* head = threadsWaitingForPulse;
        if (!head)
            return NULL;

        // Grab the node for ourselves. We take the node even if some other thread
        // changes "threadsWaitingForPulse" in the meantime. If that happens, we don't
        // unlink the node and the node will stay on the list until the waiting thread
        // cleans up the list.
        PulseWaitingListNode* next = head->nextNode;
        if (il2cpp::os::Atomic::CompareExchangePointer(&threadsWaitingForPulse, next, head) == head)
            head->nextNode = NULL;

        return head;
    }

    /// Remove the given waiting node from "threadsWaitingForPulse".
    /// NOTE: Calling thread *must* have the monitor locked.
    bool RemoveFromPulseWaitingList(PulseWaitingListNode* node)
    {
        IL2CPP_ASSERT(owningThreadId == il2cpp::os::Thread::CurrentThreadId());

        // This function works only because threads calling Wait() on the monitor will only
        // ever *prepend* nodes to the list. This means that only the "threadsWaitingForPulse"
        // variable is actually shared between threads whereas the list contents are owned
        // by the thread that has the monitor locked.

    tryAgain:
        PulseWaitingListNode * previous = NULL;
        for (PulseWaitingListNode* current = threadsWaitingForPulse; current != NULL;)
        {
            // Go through list looking for node.
            if (current != node)
            {
                previous = current;
                current = current->nextNode;
                continue;
            }

            // Node found. Remove.
            if (previous)
                previous->nextNode = node->nextNode;
            else
            {
                // We may have to change "threadsWaitingForPulse" and thus have to synchronize
                // with other threads.
                if (il2cpp::os::Atomic::CompareExchangePointer(&threadsWaitingForPulse, node->nextNode, node) != node)
                {
                    // One or more other threads have changed the list.
                    goto tryAgain;
                }
            }
            node->nextNode = NULL;

            return true;
        }

        // Not found in list.
        return false;
    }
};

il2cpp::utils::ThreadSafeFreeList<MonitorData>* MonitorData::s_FreeList;
il2cpp::utils::ThreadSafeFreeList<MonitorData::PulseWaitingListNode>* MonitorData::PulseWaitingListNode::s_FreeList;

static MonitorData* GetMonitorAndThrowIfNotLockedByCurrentThread(Il2CppObject* obj)
{
    // Fetch monitor data.
    MonitorData* monitor = il2cpp::os::Atomic::ReadPointer(&obj->monitor);
    if (!monitor)
    {
        // No one locked this object.
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetSynchronizationLockException("Object is not locked."));
    }

    // Throw SynchronizationLockException if we're not holding a lock.
    // NOTE: Unlike .NET, Mono simply ignores this and does not throw.
    uint64_t currentThreadId = il2cpp::os::Thread::CurrentThreadId();
    if (monitor->owningThreadId != currentThreadId && !monitor->threadAborted)
    {
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetSynchronizationLockException
                ("Object has not been locked by this thread."));
    }

    return monitor;
}

namespace il2cpp
{
namespace vm
{
    void Monitor::AllocateStaticData()
    {
        MonitorData::s_FreeList = new il2cpp::utils::ThreadSafeFreeList<MonitorData>;
        MonitorData::PulseWaitingListNode::s_FreeList = new il2cpp::utils::ThreadSafeFreeList<MonitorData::PulseWaitingListNode>;
    }

    void Monitor::FreeStaticData()
    {
        delete MonitorData::s_FreeList;
        MonitorData::s_FreeList = nullptr;

        delete MonitorData::PulseWaitingListNode::s_FreeList;
        MonitorData::PulseWaitingListNode::s_FreeList = nullptr;
    }

    void Monitor::Enter(Il2CppObject* object)
    {
        TryEnter(object, std::numeric_limits<uint32_t>::max());
    }

    bool Monitor::TryEnter(Il2CppObject* obj, uint32_t timeOutMilliseconds)
    {
        size_t currentThreadId = il2cpp::os::Thread::CurrentThreadId();

        while (true)
        {
            MonitorData* installedMonitor = il2cpp::os::Atomic::ReadPointer(&obj->monitor);
            if (!installedMonitor)
            {
                // Set up a new monitor.
                MonitorData* newlyAllocatedMonitorForThisThread = MonitorData::s_FreeList->Allocate();
                il2cpp::os::Thread::ThreadId previousOwnerThreadId = newlyAllocatedMonitorForThisThread->owningThreadId.exchange(currentThreadId);
                IL2CPP_ASSERT(previousOwnerThreadId == MonitorData::kHasBeenReturnedToFreeList && "Monitor on freelist cannot be owned by thread!");

                // Try to install the monitor on the object (aka "inflate" the object).
                if (il2cpp::os::Atomic::CompareExchangePointer(&obj->monitor, newlyAllocatedMonitorForThisThread, (MonitorData*)NULL) == NULL)
                {
                    // Done. There was no contention on this object. This is
                    // the fast path.
                    IL2CPP_ASSERT(obj->monitor);
                    IL2CPP_ASSERT(obj->monitor->recursiveLockingCount == 1);
                    IL2CPP_ASSERT(obj->monitor->owningThreadId == currentThreadId);
                    return true;
                }
                else
                {
                    // Some other thread raced us and won. Retry.
                    newlyAllocatedMonitorForThisThread->owningThreadId = MonitorData::kHasBeenReturnedToFreeList;
                    MonitorData::s_FreeList->Release(newlyAllocatedMonitorForThisThread);
                    continue;
                }
            }

            // Object was locked previously. See if we already have the lock.
            if (installedMonitor->owningThreadId == currentThreadId)
            {
                // Yes, recursive lock. Just increase count.
                ++installedMonitor->recursiveLockingCount;
                return true;
            }

            // Attempt to acquire lock if it's free
            if (installedMonitor->TryAcquire(currentThreadId))
            {
                // There is no locking around the sections of this logic to speed
                // things up, there is potential for race condition to reset the objects
                // monitor.  If it has been reset prior to successfully coming out of
                // TryAquire, dont return, unaquire the installedMonitor, go back through the logic again to grab a
                // a valid monitor.

                if (il2cpp::os::Atomic::ReadPointer(&obj->monitor) != installedMonitor)
                {
                    installedMonitor->Unacquire();
                    continue;
                }

                // Ownership of monitor passed from previously locking thread to us.
                IL2CPP_ASSERT(installedMonitor->recursiveLockingCount == 1);
                IL2CPP_ASSERT(obj->monitor == installedMonitor);

                return true;
            }

            // Getting an immediate lock failed, so if we have a zero timeout now,
            // entering the monitor failed.
            if (timeOutMilliseconds == 0)
                return false;

            // Object was locked by other thread. Let the monitor know we are waiting for a lock.
            installedMonitor->AddCurrentThreadToReadyList();
            if (il2cpp::os::Atomic::ReadPointer(&obj->monitor) != installedMonitor)
            {
                // Another thread deflated the object while we tried to lock it. Get off
                // the monitor.
                // NOTE: By now we may already be dealing with a monitor that is back on the free list
                //  or even installed on an object again.
                installedMonitor->VacateDyingMonitor();

                // NOTE: The "Implementing Fast Java Monitors with Relaxed-Locks" paper describes a path
                //  that may lead to monitors being leaked if the thread currently holding a lock sees our
                //  temporary increment of numWaitingThreads and ends up not deflating the object. However,
                //  we can only ever end up inside this branch here if the locking thread has already decided to
                //  deflate, so I don't see how we can leak here.

                // Retry.
                continue;
            }

            // NOTE: At this point, we are in the waiting line for the monitor. However, the thread currently
            //  locking the monitor may still have already made the decision to deflate the object so we may
            //  still get kicked off the monitor.

            // Wait for the locking thread to signal us.
            while (il2cpp::os::Atomic::ReadPointer(&obj->monitor) == installedMonitor)
            {
                // Try to grab the object for ourselves.
                if (installedMonitor->TryAcquire(currentThreadId))
                {
                    // Ownership of monitor passed from previously locking thread to us.
                    IL2CPP_ASSERT(installedMonitor->recursiveLockingCount == 1);
                    IL2CPP_ASSERT(obj->monitor == installedMonitor);
                    installedMonitor->RemoveCurrentThreadFromReadyList();
                    return true;
                }

                // Wait for owner to signal us.
                il2cpp::os::WaitStatus waitStatus;
                try
                {
                    if (timeOutMilliseconds != std::numeric_limits<uint32_t>::max())
                    {
                        // Perform a timed wait.
                        waitStatus = installedMonitor->semaphore.Wait(timeOutMilliseconds, true);
                    }
                    else
                    {
                        // Perform an infinite wait. We may still be interrupted, however.
                        waitStatus = installedMonitor->semaphore.Wait(true);
                    }
                }
                catch (Thread::NativeThreadAbortException&)
                {
                    // This signals that the monitor was not entered properly by this thread. Therefore
                    // a later call to Exit on this monitor should not actually try to exit the monitor,
                    // because it is not owned by this thread.
                    installedMonitor->threadAborted = true;
                    throw;
                }
                catch (...)
                {
                    // A user APC could throw an exception from within Wait(). This can commonly happen
                    // during shutdown, when vm::Thread::AbortAllThreads() causes an APC that throws a
                    // NativeThreadAbortException. Just make sure we clean up properly.
                    installedMonitor->RemoveCurrentThreadFromReadyList();
                    throw;
                }

                ////TODO: adjust wait time if we have a Wait() failure and before going another round

                if (waitStatus == kWaitStatusTimeout)
                {
                    // Wait failed. Get us off the list.
                    int newNumWaitingThreads = installedMonitor->RemoveCurrentThreadFromReadyList();

                    // If there are no more waiting threads on this monitor, we need to check for leaking.
                    // This may happen if the locking thread has just been executing a Monitor.Exit(), seen
                    // the positive numWaitingThread count, and decided that it thus cannot deflate the object
                    // and will trigger the semaphore. However, we've just decided to give up waiting, so if
                    // we were the only thread waiting and no one ever attempts to lock the object again, the
                    // monitor will stick around with no one ever deflating the object.
                    //
                    // We solve this by simply trying to acquire ownership of the monitor if we were the last
                    // waiting thread and if that succeeds, we simply change from returning with a time out
                    // failure to returning with a successful lock.
                    if (!newNumWaitingThreads && il2cpp::os::Atomic::ReadPointer(&obj->monitor) == installedMonitor)
                    {
                        if (installedMonitor->TryAcquire(currentThreadId))
                        {
                            // We've successfully acquired a lock on the object.
                            IL2CPP_ASSERT(installedMonitor->recursiveLockingCount == 1);
                            IL2CPP_ASSERT(obj->monitor == installedMonitor);
                            return true;
                        }
                    }

                    // Catch the case where a timeout expired the very moment the owning thread decided to
                    // get us to vacate the monitor by sending an acknowledgement just to make sure.
                    if (il2cpp::os::Atomic::ReadPointer(&obj->monitor) != installedMonitor)
                        installedMonitor->flushAcknowledged.Set();

                    return false;
                }
            }

            // Owner has deflated the object and the monitor is no longer associated with the
            // object we're trying to lock. Signal to the owner that we acknowledge this and
            // move off the monitor.
            installedMonitor->VacateDyingMonitor();
        }

        return false;
    }

    void Monitor::Exit(Il2CppObject* obj)
    {
        // Fetch monitor data.
        MonitorData* monitor = GetMonitorAndThrowIfNotLockedByCurrentThread(obj);

        // We have the object lock. Undo one single invocation of Enter().
        int newLockingCount = monitor->recursiveLockingCount - 1;
        if (newLockingCount > 0)
        {
            // Was recursively locked. Lock still held by us.
            monitor->recursiveLockingCount = newLockingCount;
            return;
        }

        // See if there are already threads ready to take over the lock.
        if (monitor->numThreadsWaitingForSemaphore != 0)
        {
            // Yes, so relinquish ownership of the object and signal the next thread.
            monitor->Unacquire();
            monitor->semaphore.Post();
        }
        else if (monitor->threadsWaitingForPulse)
        {
            // No, but there's threads waiting for a pulse so we can't deflate the object.
            // The wait nodes may already have been abandoned but that is for the pulsing
            // and waiting threads to sort out. Either way, if there ever is going to be a
            // pulse, *some* thread will get around to looking at this monitor again so all
            // we do here is relinquish ownership.
            monitor->Unacquire();

            // there is a race as follows: T1 is our thread and we own monitor lock
            // T1 - checks numThreadsWaitingForSemaphore and sees 0
            // T2 - sees T1 has lock. Increments numThreadsWaitingForSemaphore
            // T2 - tries to acquire monitor, but we hold it
            // T2 - waits on semaphore
            // T1 - we unacquire and wait to be pulsed (if Exit is called from Wait)
            // Result: deadlock as semaphore is never posted
            // Fix: double check 'numThreadsWaitingForSemaphore' after we've unacquired
            // Worst case might be an extra post, which will just incur an additional
            // pass through the loop with an extra attempt to acquire the monitor with a CAS
            if (monitor->numThreadsWaitingForSemaphore != 0)
                monitor->semaphore.Post();
        }
        else
        {
            // Seems like no other thread is interested in the monitor. Deflate the object.
            il2cpp::os::Atomic::ExchangePointer(&obj->monitor, (MonitorData*)NULL);

            // At this point the monitor is no longer associated with the object and we cannot safely
            // "re-attach" it. We need to make sure that all threads still having a reference to the
            // monitor let go of it before we put the monitor back on the free list.
            //
            // IMPORTANT: We still *own* the monitor at this point. No other thread can acquire it and
            //  we must not let go of the monitor until we have kicked all other threads off of it.

            monitor->flushAcknowledged.Reset();
            while (monitor->numThreadsWaitingForSemaphore != 0)
            {
                monitor->semaphore.Post(monitor->numThreadsWaitingForSemaphore);
                // If a thread starts waiting right after we have read numThreadsWaitingForSemaphore,
                // we won't release the semaphore enough times. So don't wait spend a long time waiting
                // for acknowledgement here.
                monitor->flushAcknowledged.Wait(1, false);
            }

            // IMPORTANT: At this point, all other threads must have either already vacated the monitor or
            //   be on a path that makes them vacate the monitor next. The latter may happen if a thread
            //   is stopped right before adding itself to the ready list of our monitor in which case we
            //   will not see the thread on numThreadsWaitingForSemaphore. If we then put the monitor back
            //   on the freelist and then afterwards the other thread is resumed, it will still put itself
            //   on the ready list only to then realize it got the wrong monitor.
            //   So, even for monitors on the free list, we accept that a thread may temporarily add itself
            //   to the wrong monitor's ready list as long as all it does it simply remove itself right after
            //   realizing the mistake.

            // Release monitor back to free list.
            IL2CPP_ASSERT(monitor->owningThreadId == il2cpp::os::Thread::CurrentThreadId());
            monitor->owningThreadId = MonitorData::kHasBeenReturnedToFreeList;
            MonitorData::s_FreeList->Release(monitor);
        }
    }

    static void PulseMonitor(Il2CppObject* obj, bool all = false)
    {
        // Grab monitor.
        MonitorData* monitor = GetMonitorAndThrowIfNotLockedByCurrentThread(obj);

        bool isFirst = true;
        while (true)
        {
            // Grab next waiting thread, if any.
            MonitorData::PulseWaitingListNode* waitNode = monitor->PopNextFromPulseWaitingList();
            if (!waitNode)
                break;

            // Pulse thread.
            waitNode->signalWaitingThread.Set();

            // Stop if we're only supposed to pulse the one thread.
            if (isFirst && !all)
                break;

            isFirst = false;
        }
    }

    void Monitor::Pulse(Il2CppObject* object)
    {
        PulseMonitor(object, false);
    }

    void Monitor::PulseAll(Il2CppObject* object)
    {
        PulseMonitor(object, true);
    }

    void Monitor::Wait(Il2CppObject* object)
    {
        TryWait(object, std::numeric_limits<uint32_t>::max());
    }

    bool Monitor::TryWait(Il2CppObject* object, uint32_t timeoutMilliseconds)
    {
        MonitorData* monitor = GetMonitorAndThrowIfNotLockedByCurrentThread(object);

        // Undo any recursive locking but remember the count so we can restore it
        // after we have re-acquired the lock.
        uint32_t oldLockingCount = monitor->recursiveLockingCount;
        monitor->recursiveLockingCount = 1;

        // Add us to the pulse waiting list for the monitor (except if we won't be
        // waiting for a pulse at all).
        MonitorData::PulseWaitingListNode* waitNode = NULL;
        if (timeoutMilliseconds != 0)
        {
            waitNode = MonitorData::PulseWaitingListNode::Allocate();
            monitor->PushOntoPulseWaitingList(waitNode);
        }

        // Release the monitor.
        Exit(object);
        monitor = NULL;

        // Wait for pulse (if we either have a timeout or are supposed to
        // wait infinitely).
        il2cpp::os::WaitStatus pulseWaitStatus = kWaitStatusTimeout;
        std::exception_ptr exceptionThrownDuringWait = NULL;
        if (timeoutMilliseconds != 0)
        {
            pulseWaitStatus = kWaitStatusFailure;
            try
            {
                il2cpp::vm::ThreadStateSetter state(il2cpp::vm::kThreadStateWaitSleepJoin);
                pulseWaitStatus = waitNode->signalWaitingThread.Wait(timeoutMilliseconds, true);
            }
            catch (...)
            {
                // Exception occurred during wait. Remember exception but continue with reacquisition
                // and cleanup. We re-throw later.
                exceptionThrownDuringWait = std::current_exception();
                pulseWaitStatus = kWaitStatusFailure;
            }
        }

        // Reacquire the monitor.
        Enter(object);

        // Monitor *may* have changed.
        monitor = object->monitor;

        // Restore recursion count.
        monitor->recursiveLockingCount = oldLockingCount;

        // Get rid of wait list node.
        if (waitNode)
        {
            // Make sure the node is gone from the wait list. If the pulsing thread already did
            // that, this won't do anything.
            monitor->RemoveFromPulseWaitingList(waitNode);

            // And hand it back for reuse.
            waitNode->Release();
            waitNode = NULL;
        }

        // If the wait was interrupted by an exception (most likely a ThreadInterruptedException),
        // then re-throw now.
        //
        // NOTE: We delay this to until after we've gone through the reacquisition sequence as we
        //  have to guarantee that when Monitor.Wait() exits -- whether successfully or not --, it
        //  still holds a lock. Otherwise a lock() statement around the Wait() will throw an exception,
        //  for example.
        if (exceptionThrownDuringWait)
            std::rethrow_exception(exceptionThrownDuringWait);

        ////TODO: According to MSDN, the timeout indicates whether we reacquired the lock in time
        ////    and not just whether the pulse came in time. Thus the current code is imprecise.
        return (pulseWaitStatus != kWaitStatusTimeout);
    }

    bool Monitor::IsAcquired(Il2CppObject* object)
    {
        MonitorData* monitor = object->monitor;
        if (!monitor)
            return false;

        return monitor->IsAcquired();
    }

    bool Monitor::IsOwnedByCurrentThread(Il2CppObject* object)
    {
        MonitorData* monitor = object->monitor;
        if (!monitor)
            return false;

        return monitor->IsOwnedByThread(il2cpp::os::Thread::CurrentThreadId());
    }
} /* namespace vm */
} /* namespace il2cpp */


#endif // IL2CPP_SUPPORT_THREADS
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Monitor.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Object.cpp---------------
.
.
#include "il2cpp-config.h"
#include <memory>

#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"
#include "il2cpp-runtime-stats.h"
#include "gc/gc_wrapper.h"
#include "gc/GarbageCollector.h"
#include "metadata/GenericMethod.h"
#include "metadata/Il2CppTypeCompare.h"
#include "utils/StringUtils.h"
#include "vm-utils/VmThreadUtils.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/ClassInlines.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Profiler.h"
#include "vm/RCW.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/String.h"
#include "vm/Thread.h"
#include "vm/Type.h"

#if IL2CPP_GC_BOEHM
#define ALLOC_PTRFREE(obj, vt, size) do { (obj) = (Il2CppObject*)GC_MALLOC_ATOMIC ((size)); (obj)->klass = (vt); (obj)->monitor = NULL;} while (0)
#define ALLOC_OBJECT(obj, vt, size) do { (obj) = (Il2CppObject*)GC_MALLOC ((size)); (obj)->klass = (vt);} while (0)
#ifdef GC_GCJ_SUPPORT
#define ALLOC_TYPED(dest, size, type) do { (dest) = (Il2CppObject*)GC_gcj_malloc ((size),(type)); } while (0)
#else
#define GC_NO_DESCRIPTOR (NULL)
#define ALLOC_TYPED(dest, size, type) do { (dest) = GC_MALLOC ((size)); *(void**)dest = (type);} while (0)
#endif
#else
#ifdef HAVE_SGEN_GC
#define GC_NO_DESCRIPTOR (NULL)
#define ALLOC_PTRFREE(obj, vt, size) do { (obj) = mono_gc_alloc_obj (vt, size);} while (0)
#define ALLOC_OBJECT(obj, vt, size) do { (obj) = mono_gc_alloc_obj (vt, size);} while (0)
#define ALLOC_TYPED(dest, size, type) do { (dest) = mono_gc_alloc_obj (type, size);} while (0)
#else
#define ALLOC_PTRFREE(obj, vt, size) do { (obj) = (Il2CppObject*)malloc ((size)); (obj)->klass = (vt); (obj)->monitor = NULL;} while (0)
#define ALLOC_OBJECT(obj, vt, size) do { (obj) = (Il2CppObject*)calloc (1, (size)); (obj)->klass = (vt);} while (0)
#define ALLOC_TYPED(dest, size, type) do { (dest) = (Il2CppObject*)(calloc (1, (size))); *(void**)dest = (type);} while (0)
#endif
#endif

namespace il2cpp
{
namespace vm
{
    Il2CppObject * Object::Allocate(size_t size, Il2CppClass *typeInfo)
    {
        IL2CPP_ASSERT(typeInfo->initialized);
        Il2CppObject *o;
        ALLOC_OBJECT(o, typeInfo, size);

        ++il2cpp_runtime_stats.new_object_count;

        return o;
    }

    Il2CppObject * Object::AllocatePtrFree(size_t size, Il2CppClass *typeInfo)
    {
        IL2CPP_ASSERT(typeInfo->initialized);
        Il2CppObject *o;
        ALLOC_PTRFREE(o, typeInfo, size);

        ++il2cpp_runtime_stats.new_object_count;

        return o;
    }

    Il2CppObject * Object::AllocateSpec(size_t size, Il2CppClass *typeInfo)
    {
        IL2CPP_ASSERT(typeInfo->initialized);
        Il2CppObject *o;
        ALLOC_TYPED(o, size, typeInfo);

        ++il2cpp_runtime_stats.new_object_count;

        return o;
    }

    Il2CppObject* Object::Box(Il2CppClass *typeInfo, void* val)
    {
        if (!typeInfo->byval_arg.valuetype)
            return *(Il2CppObject**)val;

        bool isNullable = Class::IsNullable(typeInfo);

        if (isNullable)
        {
            /* From ECMA-335, I.8.2.4 Boxing and unboxing of values:

                All value types have an operation called box. Boxing a value of any value type produces its boxed value;
                i.e., a value of the corresponding boxed type containing a bitwise copy of the original value. If the
                value type is a nullable type defined as an instantiation of the value type System.Nullable<T> the result
                is a null reference or bitwise copy of its Value property of type T, depending on its HasValue property
                (false and true, respectively).
            */
            if (!NullableHasValue(typeInfo, val))
                return NULL;
        }

        Il2CppObject* obj = Object::New(typeInfo);

        size_t size = Class::GetInstanceSize(typeInfo);

        // At this point we know we have a value type and we need to adjust the
        // copy size by the size of Il2CppObject
        size = size - sizeof(Il2CppObject);

        uint8_t* valueStart = static_cast<uint8_t*>(val);
        if (isNullable)
        {
            IL2CPP_ASSERT(metadata::Il2CppTypeEqualityComparer::AreEqual(typeInfo->fields[1].type, &Class::GetNullableArgument(typeInfo)->byval_arg));
            // Shift the valueStart right past the bool for nullable
            int32_t nullableShift = typeInfo->fields[1].offset - sizeof(Il2CppObject);
            valueStart += nullableShift;

            // the size needs to be further adjusted to be smaller
            size -= nullableShift;
        }

        memcpy(((char*)obj) + sizeof(Il2CppObject), valueStart, size);
        gc::GarbageCollector::SetWriteBarrier((void**)(((char*)obj) + sizeof(Il2CppObject)), size);
        return obj;
    }

    Il2CppObject* Object::Clone(Il2CppObject *obj)
    {
        Il2CppObject *o;
        int size;
        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Object::Clone, "Finish implementation");

        if (obj->klass->rank)
        {
            return Array::Clone((Il2CppArray*)obj);
        }

        size = obj->klass->instance_size;
        o = Allocate(size, obj->klass);
        /* do not copy the sync state */
        memcpy((char*)o + sizeof(Il2CppObject), (char*)obj + sizeof(Il2CppObject), size - sizeof(Il2CppObject));

        gc::GarbageCollector::SetWriteBarrier((void**)(((char*)o) + sizeof(Il2CppObject)), size);

//#ifdef HAVE_SGEN_GC
//  if (obj->vtable->klass->has_references)
//      mono_gc_wbarrier_object (o);
//#endif

        if (obj->klass->has_finalize)
            il2cpp::gc::GarbageCollector::RegisterFinalizerForNewObject(o);

#if IL2CPP_ENABLE_PROFILER
        if (Profiler::ProfileAllocations())
            Profiler::Allocation(o, obj->klass);
#endif

        return o;
    }

    Il2CppClass* Object::GetClass(Il2CppObject* obj)
    {
        return obj->klass;
    }

#if IL2CPP_SIZEOF_VOID_P == 8
    const int kObjectAlignmentShift = 3;
#elif IL2CPP_SIZEOF_VOID_P == 4
    const int kObjectAlignmentShift = 2;
#else
#error Invalid architecture size
#endif

    int32_t Object::GetHash(Il2CppObject* obj)
    {
        // shift away unused bits due to alignment, then use Knuth's multiplicative hash
        return (((uint32_t)(intptr_t)(obj)) >> kObjectAlignmentShift) * 2654435761u;
    }

    uint32_t Object::GetSize(Il2CppObject* obj)
    {
        Il2CppClass* klass = GetClass(obj);
        if (klass == il2cpp_defaults.string_class)
        {
            return sizeof(Il2CppString) + 2 * utils::StringUtils::GetLength((Il2CppString*)obj) + 2;
        }
        else if (obj->klass->rank)
        {
            Il2CppArray *array = (Il2CppArray*)obj;
            size_t size = kIl2CppSizeOfArray + Array::GetElementSize(klass) * Array::GetLength(array);
            if (array->bounds)
            {
                size += 3;
                size &= ~3;
                size += sizeof(Il2CppArrayBounds) * obj->klass->rank;
            }
            return (uint32_t)size;
        }
        else
        {
            return Class::GetInstanceSize(klass);
        }
    }

    const MethodInfo* Object::GetVirtualMethod(Il2CppObject *obj, const MethodInfo *virtualMethod)
    {
        if ((virtualMethod->flags & METHOD_ATTRIBUTE_FINAL) || !(virtualMethod->flags & METHOD_ATTRIBUTE_VIRTUAL))
            return virtualMethod;

        Il2CppClass* methodDeclaringType = virtualMethod->klass;
        const MethodInfo* vtableSlotMethod;
        if (Class::IsInterface(methodDeclaringType))
        {
            vtableSlotMethod = ClassInlines::GetInterfaceInvokeDataFromVTable(obj, methodDeclaringType, virtualMethod->slot).method;
        }
        else
        {
            IL2CPP_ASSERT(virtualMethod->slot < obj->klass->vtable_count);
            vtableSlotMethod = obj->klass->vtable[virtualMethod->slot].method;
        }

        if (Method::IsGenericInstanceMethod(virtualMethod))
            return il2cpp::metadata::GenericMethod::GetGenericVirtualMethod(vtableSlotMethod, virtualMethod);
        return vtableSlotMethod;
    }

    Il2CppObject* Object::IsInst(Il2CppObject *obj, Il2CppClass *klass)
    {
        if (!obj)
            return NULL;

        Il2CppClass* objClass = Object::GetClass(obj);
        if (Class::IsAssignableFrom(klass, objClass))
            return obj;

        if (!objClass->is_import_or_windows_runtime)
            return NULL;

        // check if klass has an interface id
        if (Class::IsInterface(klass) && klass->interopData != NULL)
        {
            const Il2CppGuid* iid = klass->interopData->guid;
            if (iid != NULL)
            {
                Il2CppIUnknown* unknown = RCW::QueryInterfaceNoAddRef<false>(static_cast<Il2CppComObject*>(obj), *iid);
                if (unknown)
                    return static_cast<Il2CppComObject*>(obj);
            }
        }

        return (klass == il2cpp_defaults.object_class) ? obj : NULL;
    }

    Il2CppObject* Object::New(Il2CppClass *klass)
    {
        // same as NewAllocSpecific as we only support a single domain
        return NewAllocSpecific(klass);
    }

    Il2CppObject* Object::NewPinned(Il2CppClass *klass)
    {
#if (IL2CPP_GC_BOEHM || IL2CPP_GC_NULL)
        return New(klass);
#else
        IL2CPP_NOT_IMPLEMENTED(Object::NewPinned);
#endif
    }

    Il2CppObject * Object::NewAllocSpecific(Il2CppClass *klass)
    {
        Il2CppObject *o = NULL;

        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Object::NewAllocSpecific, "We really shouldn't need this initialization");
        Class::Init(klass);

        if (Class::IsNullable(klass))
            klass = il2cpp::vm::Class::GetNullableArgument(klass);

        if (!klass->has_references)
        {
            o = NewPtrFree(klass);
        }
#if IL2CPP_HAS_GC_DESCRIPTORS
        else if (klass->gc_desc != GC_NO_DESCRIPTOR)
        {
            o = AllocateSpec(klass->instance_size, klass);
        }
#endif
        else
        {
            o = Allocate(klass->instance_size, klass);
        }
        if (klass->has_finalize)
            il2cpp::gc::GarbageCollector::RegisterFinalizerForNewObject(o);

#if IL2CPP_ENABLE_PROFILER
        if (Profiler::ProfileAllocations())
            Profiler::Allocation(o, klass);
#endif

        Runtime::ClassInit(klass);
        return o;
    }

    Il2CppObject* Object::NewPtrFree(Il2CppClass *klass)
    {
        Il2CppObject *obj = {0};

        IL2CPP_ASSERT(klass->initialized);
        IL2CPP_ASSERT(!klass->has_references);

        ALLOC_PTRFREE(obj, klass, klass->instance_size);
#if NEED_TO_ZERO_PTRFREE
        /* an inline memset is much faster for the common vcase of small objects
         * note we assume the allocated size is a multiple of sizeof (void*).
         */
        if (klass->instance_size < 128)
        {
            void* *p, *end;
            end = (void**)((char*)obj + klass->instance_size);
            p = (void**)((char*)obj + sizeof(Il2CppObject));
            while (p < end)
            {
                *p = NULL;
                ++p;
            }
        }
        else
        {
            memset((char*)obj + sizeof(Il2CppObject), 0, klass->instance_size - sizeof(Il2CppObject));
        }
#endif

        ++il2cpp_runtime_stats.new_object_count;

        return obj;
    }

    void* Object::Unbox(Il2CppObject* obj)
    {
        void* val = (void*)(((char*)obj) + sizeof(Il2CppObject));
        return val;
    }

    void Object::UnboxNullable(Il2CppObject* obj, Il2CppClass* nullableClass, void* storage)
    {
        // We assume storage is on the stack, if not we'll need a write barrier
        IL2CPP_ASSERT_STACK_PTR(storage);

        // After the assert above, we can safely call this method, because the GC will find storage as a root,
        // since it is on the stack.
        UnboxNullableGCUnsafe(obj, nullableClass, storage);
    }

    void Object::UnboxNullableWithWriteBarrier(Il2CppObject* obj, Il2CppClass* nullableClass, void* storage)
    {
        uint32_t valueSize = UnboxNullableGCUnsafe(obj, nullableClass, storage);
        il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)storage, valueSize);
    }

    // Hey! You probably don't want to call this method. Call Object::UnboxNullable  or
    // Object::UnboxNullableWithWriteBarrier instead.
    //
    //
    // Ok - still here? If you call this method and storage is not on the stack, you need to set a
    // GC write barrier for the pointer at storage with a length that is the number of bytes, which
    // this method returns. That's what UnboxNullableWithWriteBarrier. Use it!
    uint32_t Object::UnboxNullableGCUnsafe(Il2CppObject* obj, Il2CppClass* nullableClass, void* storage)
    {
        IL2CPP_ASSERT(Class::IsNullable(nullableClass));
        IL2CPP_ASSERT(nullableClass->field_count == 2);
        IL2CPP_ASSERT(metadata::Il2CppTypeEqualityComparer::AreEqual(nullableClass->fields[0].type, &il2cpp_defaults.boolean_class->byval_arg));
        IL2CPP_ASSERT(obj == NULL || metadata::Il2CppTypeEqualityComparer::AreEqual(nullableClass->fields[1].type, &obj->klass->byval_arg));

        void* valueField = Field::GetInstanceFieldDataPointer(storage, &nullableClass->fields[1]);
        uint32_t valueSize = Class::GetNullableArgument(nullableClass)->instance_size - sizeof(Il2CppObject);

        if (obj == NULL)
        {
            memset(valueField, 0, valueSize);
            *(static_cast<uint8_t*>(storage)) = false;
        }
        else
        {
            memcpy(valueField, Unbox(obj), valueSize);
            *(static_cast<uint8_t*>(storage)) = true;
        }

        return valueSize;
    }

    void Object::NullableInit(uint8_t* buf, Il2CppObject* value, Il2CppClass* klass)
    {
        Il2CppClass *parameterClass = klass->castClass;

        IL2CPP_ASSERT(Class::FromIl2CppType(klass->fields[0].type) == il2cpp_defaults.boolean_class);
        IL2CPP_ASSERT(Class::FromIl2CppType(klass->fields[1].type) == parameterClass);

        *(uint8_t*)(buf + klass->fields[0].offset - sizeof(Il2CppObject)) = value ? 1 : 0;
        if (value)
            memcpy(buf + klass->fields[1].offset - sizeof(Il2CppObject), Object::Unbox(value), Class::GetValueSize(parameterClass, NULL));
        else
            memset(buf + klass->fields[1].offset - sizeof(Il2CppObject), 0, Class::GetValueSize(parameterClass, NULL));
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Object.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Parameter.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-runtime-metadata.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "Parameter.h"
#include "vm-utils/BlobReader.h"
#include "vm/Class.h"
#include "vm/Object.h"
#include "vm/Method.h"

namespace il2cpp
{
namespace vm
{
    Il2CppObject* Parameter::GetDefaultParameterValueObject(const MethodInfo* method, int32_t parameterPosition, bool* isExplicitySetNullDefaultValue)
    {
        const Il2CppType* typeOfDefaultValue;
        const char* data = Method::GetParameterDefaultValue(method, parameterPosition, &typeOfDefaultValue, isExplicitySetNullDefaultValue);
        if (data == NULL)
            return NULL;

        Il2CppClass* parameterType = Class::FromIl2CppType(method->parameters[parameterPosition]);
        if (il2cpp::vm::Class::IsValuetype(parameterType))
        {
            if (il2cpp::vm::Class::IsNullable(parameterType))
            {
                parameterType = il2cpp::vm::Class::GetNullableArgument(parameterType);
                typeOfDefaultValue = &parameterType->byval_arg;
            }

            Class::SetupFields(parameterType);
            IL2CPP_ASSERT(parameterType->size_inited);
            void* value = alloca(parameterType->instance_size - sizeof(Il2CppObject));
            utils::BlobReader::GetConstantValueFromBlob(method->klass->image, typeOfDefaultValue->type, data, value);
            return Object::Box(parameterType, value);
        }

        Il2CppObject* value = NULL;
        utils::BlobReader::GetConstantValueFromBlob(method->klass->image, typeOfDefaultValue->type, data, &value);
        return value;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Parameter.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Path.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/Path.h"
#include "os/Path.h"

namespace il2cpp
{
namespace vm
{
    static std::string s_TempPath;

    void Path::SetTempPath(const char* path)
    {
        s_TempPath = path;
    }

    std::string Path::GetTempPath()
    {
        if (!s_TempPath.empty())
            return s_TempPath;
        return os::Path::GetTempPath();
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Path.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\PlatformInvoke.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"

#include "PlatformInvoke.h"
#include "Exception.h"
#include "MetadataCache.h"
#include "Method.h"
#include "Object.h"
#include "Runtime.h"
#include "Type.h"

#include "gc/WriteBarrier.h"
#include "os/LibraryLoader.h"
#include "os/MarshalStringAlloc.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "vm-utils/VmStringUtils.h"

#include <stdint.h>
#include <algorithm>

namespace il2cpp
{
namespace vm
{
    void PlatformInvoke::SetFindPluginCallback(Il2CppSetFindPlugInCallback method)
    {
        os::LibraryLoader::SetFindPluginCallback(method);
    }

    Il2CppMethodPointer PlatformInvoke::Resolve(const PInvokeArguments& pinvokeArgs)
    {
        // Before resolving a P/Invoke, check against a hardcoded list of "known P/Invokes" that is different for every platform.
        // This bit solves several different problems we have when P/Invoking into native system libraries from mscorlib.dll.
        // Some platforms, like UWP, just don't allow you to load to load system libraries at runtime dynamically.
        // On other platforms (THEY SHALL NOT BE NAMED :O), while the functions that mscorlib.dll wants to P/Invoke into exist,
        // They exist in different system libraries than it is said in the DllImport attribute.
        Il2CppMethodPointer function = os::LibraryLoader::GetHardcodedPInvokeDependencyFunctionPointer(pinvokeArgs.moduleName, pinvokeArgs.entryPoint, pinvokeArgs.charSet);
        if (function != NULL)
            return function;

        Baselib_DynamicLibrary_Handle dynamicLibrary = Baselib_DynamicLibrary_Handle_Invalid;
        std::string detailedLoadError;
        if (utils::VmStringUtils::CaseSensitiveEquals(il2cpp::utils::StringUtils::NativeStringToUtf8(pinvokeArgs.moduleName.Str()).c_str(), "__InternalDynamic"))
            dynamicLibrary = os::LibraryLoader::LoadDynamicLibrary(il2cpp::utils::StringView<Il2CppNativeChar>::Empty(), detailedLoadError);
        else
            dynamicLibrary = os::LibraryLoader::LoadDynamicLibrary(pinvokeArgs.moduleName, detailedLoadError);

        if (dynamicLibrary == Baselib_DynamicLibrary_Handle_Invalid)
        {
            std::string message;
            message += "Unable to load DLL '";
            message += il2cpp::utils::StringUtils::NativeStringToUtf8(pinvokeArgs.moduleName.Str());
            message += "'. Tried the load the following dynamic libraries: ";
            message += detailedLoadError;
            Exception::Raise(Exception::GetDllNotFoundException(message.c_str()));
        }

        std::string detailedGetFunctionError;
        function = os::LibraryLoader::GetFunctionPointer(dynamicLibrary, pinvokeArgs, detailedGetFunctionError);
        if (function == NULL)
        {
            std::string message;
            message += "Unable to find an entry point named '";
            message += pinvokeArgs.entryPoint.Str();
            message += "' in '";
            message += il2cpp::utils::StringUtils::NativeStringToUtf8(pinvokeArgs.moduleName.Str());
            message += "'. Tried the following entry points: ";
            message += detailedGetFunctionError;
            Exception::Raise(Exception::GetEntryPointNotFoundException(message.c_str()));
        }

        return function;
    }

    void PlatformInvoke::MarshalFree(void* ptr)
    {
        if (ptr != NULL)
            MarshalAlloc::Free(ptr);
    }

    char* PlatformInvoke::MarshalCSharpStringToCppString(Il2CppString* managedString)
    {
        if (managedString == NULL)
            return NULL;

        std::string utf8String = utils::StringUtils::Utf16ToUtf8(managedString->chars);

        char* nativeString = MarshalAllocateStringBuffer<char>(utf8String.size() + 1);
        strcpy(nativeString, utf8String.c_str());

        return nativeString;
    }

    void PlatformInvoke::MarshalCSharpStringToCppStringFixed(Il2CppString* managedString, char* buffer, int numberOfCharacters)
    {
        if (managedString == NULL)
        {
            *buffer = '\0';
        }
        else
        {
            std::string utf8String = utils::StringUtils::Utf16ToUtf8(managedString->chars, numberOfCharacters - 1);
            strcpy(buffer, utf8String.c_str());
        }
    }

    Il2CppChar* PlatformInvoke::MarshalCSharpStringToCppWString(Il2CppString* managedString)
    {
        if (managedString == NULL)
            return NULL;

        int32_t stringLength = utils::StringUtils::GetLength(managedString);
        Il2CppChar* nativeString = MarshalAllocateStringBuffer<Il2CppChar>(stringLength + 1);
        for (int32_t i = 0; i < managedString->length; ++i)
            nativeString[i] = managedString->chars[i];

        nativeString[managedString->length] = '\0';

        return nativeString;
    }

    void PlatformInvoke::MarshalCSharpStringToCppWStringFixed(Il2CppString* managedString, Il2CppChar* buffer, int numberOfCharacters)
    {
        if (managedString == NULL)
        {
            *buffer = '\0';
        }
        else
        {
            int32_t stringLength = std::min(utils::StringUtils::GetLength(managedString), numberOfCharacters - 1);
            for (int32_t i = 0; i < stringLength; ++i)
                buffer[i] = managedString->chars[i];

            buffer[stringLength] = '\0';
        }
    }

    il2cpp_hresult_t PlatformInvoke::MarshalCSharpStringToCppBStringNoThrow(Il2CppString* managedString, Il2CppChar** bstr)
    {
        IL2CPP_ASSERT(bstr);

        if (managedString == NULL)
        {
            *bstr = NULL;
            return IL2CPP_S_OK;
        }

        int32_t stringLength = utils::StringUtils::GetLength(managedString);
        Il2CppChar* stringChars = utils::StringUtils::GetChars(managedString);
        return os::MarshalStringAlloc::AllocateBStringLength(stringChars, stringLength, bstr);
    }

    Il2CppChar* PlatformInvoke::MarshalCSharpStringToCppBString(Il2CppString* managedString)
    {
        Il2CppChar* bstr;
        const il2cpp_hresult_t hr = MarshalCSharpStringToCppBStringNoThrow(managedString, &bstr);
        vm::Exception::RaiseIfFailed(hr, true);
        return bstr;
    }

    Il2CppString* PlatformInvoke::MarshalCppStringToCSharpStringResult(const char* value)
    {
        if (value == NULL)
            return NULL;

        return String::New(value);
    }

    Il2CppString* PlatformInvoke::MarshalCppWStringToCSharpStringResult(const Il2CppChar* value)
    {
        if (value == NULL)
            return NULL;

        return String::NewUtf16(value, (int32_t)utils::StringUtils::StrLen(value));
    }

    Il2CppString* PlatformInvoke::MarshalCppBStringToCSharpStringResult(const Il2CppChar* value)
    {
        if (value == NULL)
            return NULL;

        int32_t length;
        const il2cpp_hresult_t hr = os::MarshalStringAlloc::GetBStringLength(value, &length);
        vm::Exception::RaiseIfFailed(hr, true);

        return String::NewUtf16(value, length);
    }

    void PlatformInvoke::MarshalFreeBString(Il2CppChar* value)
    {
        const il2cpp_hresult_t hr = os::MarshalStringAlloc::FreeBString(value);
        vm::Exception::RaiseIfFailed(hr, true);
    }

    char* PlatformInvoke::MarshalEmptyStringBuilder(Il2CppStringBuilder* stringBuilder, size_t& stringLength, std::vector<std::string>& utf8Chunks, std::vector<Il2CppStringBuilder*>& builders)
    {
        if (stringBuilder == NULL)
            return NULL;

        stringLength = 0;
        Il2CppStringBuilder* currentBuilder = stringBuilder;

        while (true)
        {
            if (currentBuilder == NULL)
                break;

            const Il2CppChar *str = (Il2CppChar*)il2cpp::vm::Array::GetFirstElementAddress(currentBuilder->chunkChars);
            std::string utf8String = utils::StringUtils::Utf16ToUtf8(str, (int)currentBuilder->chunkChars->max_length);

            utf8Chunks.push_back(utf8String);
            builders.push_back(currentBuilder);

            size_t lenToCount = std::max((size_t)currentBuilder->chunkChars->max_length, utf8String.size());

            stringLength += lenToCount;

            currentBuilder = currentBuilder->chunkPrevious;
        }

        char* nativeString = MarshalAllocateStringBuffer<char>(stringLength + 1);

        // We need to zero out the memory because the chunkChar array lengh may have been larger than the chunkLength
        // and when this happens we'll have a utf8String that is smaller than the the nativeString we allocated.  When we go to copy the
        // chunk utf8String into the nativeString it won't fill everything and we can end up with w/e junk value was in that memory before
        memset(nativeString, 0, sizeof(char) * (stringLength + 1));

        return nativeString;
    }

    char* PlatformInvoke::MarshalEmptyStringBuilder(Il2CppStringBuilder* stringBuilder)
    {
        size_t sizeLength;
        std::vector<std::string> utf8Chunks;
        std::vector<Il2CppStringBuilder*> builders;
        return MarshalEmptyStringBuilder(stringBuilder, sizeLength, utf8Chunks, builders);
    }

    char* PlatformInvoke::MarshalStringBuilder(Il2CppStringBuilder* stringBuilder)
    {
        if (stringBuilder == NULL)
            return NULL;

        size_t stringLength;
        std::vector<std::string> utf8Chunks;
        std::vector<Il2CppStringBuilder*> builders;
        char* nativeString = MarshalEmptyStringBuilder(stringBuilder, stringLength, utf8Chunks, builders);

        if (stringLength > 0)
        {
            int offsetAdjustment = 0;
            for (int i = (int)utf8Chunks.size() - 1; i >= 0; i--)
            {
                std::string utf8String = utf8Chunks[i];

                const char* utf8CString = utf8String.c_str();

                memcpy(nativeString + builders[i]->chunkOffset + offsetAdjustment, utf8CString, (int)utf8String.size());

                offsetAdjustment += (int)utf8String.size() - builders[i]->chunkLength;
            }
        }

        return nativeString;
    }

    Il2CppChar* PlatformInvoke::MarshalEmptyWStringBuilder(Il2CppStringBuilder* stringBuilder, size_t& stringLength)
    {
        if (stringBuilder == NULL)
            return NULL;

        stringLength = 0;
        Il2CppStringBuilder* currentBuilder = stringBuilder;
        while (true)
        {
            if (currentBuilder == NULL)
                break;

            stringLength += (size_t)currentBuilder->chunkChars->max_length;

            currentBuilder = currentBuilder->chunkPrevious;
        }

        return MarshalAllocateStringBuffer<Il2CppChar>(stringLength + 1);
    }

    Il2CppChar* PlatformInvoke::MarshalEmptyWStringBuilder(Il2CppStringBuilder* stringBuilder)
    {
        size_t stringLength;
        return MarshalEmptyWStringBuilder(stringBuilder, stringLength);
    }

    Il2CppChar* PlatformInvoke::MarshalWStringBuilder(Il2CppStringBuilder* stringBuilder)
    {
        if (stringBuilder == NULL)
            return NULL;

        size_t stringLength;
        Il2CppChar* nativeString = MarshalEmptyWStringBuilder(stringBuilder, stringLength);

        if (stringLength > 0)
        {
            Il2CppStringBuilder* currentBuilder = stringBuilder;
            while (true)
            {
                if (currentBuilder == NULL)
                    break;

                const Il2CppChar *str = (Il2CppChar*)il2cpp::vm::Array::GetFirstElementAddress(currentBuilder->chunkChars);

                memcpy(nativeString + currentBuilder->chunkOffset, str, (int)currentBuilder->chunkChars->max_length * sizeof(Il2CppChar));

                currentBuilder = currentBuilder->chunkPrevious;
            }
        }

        nativeString[stringLength] = '\0';

        return nativeString;
    }

    void PlatformInvoke::MarshalStringBuilderResult(Il2CppStringBuilder* stringBuilder, char* buffer)
    {
        if (stringBuilder == NULL || buffer == NULL)
            return;

        UTF16String utf16String = utils::StringUtils::Utf8ToUtf16(buffer);

        IL2CPP_OBJECT_SETREF(stringBuilder, chunkChars, il2cpp::vm::Array::New(il2cpp_defaults.char_class, (int)utf16String.size() + 1));

        for (int i = 0; i < (int)utf16String.size(); i++)
            il2cpp_array_set(stringBuilder->chunkChars, Il2CppChar, i, utf16String[i]);

        il2cpp_array_set(stringBuilder->chunkChars, Il2CppChar, (int)utf16String.size(), '\0');

        stringBuilder->chunkLength = (int)utf16String.size();
        stringBuilder->chunkOffset = 0;
        IL2CPP_OBJECT_SETREF_NULL(stringBuilder, chunkPrevious);
    }

    void PlatformInvoke::MarshalWStringBuilderResult(Il2CppStringBuilder* stringBuilder, Il2CppChar* buffer)
    {
        if (stringBuilder == NULL || buffer == NULL)
            return;

        int len = (int)utils::StringUtils::StrLen(buffer);

        IL2CPP_OBJECT_SETREF(stringBuilder, chunkChars, il2cpp::vm::Array::New(il2cpp_defaults.char_class, len + 1));

        for (int i = 0; i < len; i++)
            il2cpp_array_set(stringBuilder->chunkChars, Il2CppChar, i, buffer[i]);

        il2cpp_array_set(stringBuilder->chunkChars, Il2CppChar, len, '\0');

        stringBuilder->chunkLength = len;
        stringBuilder->chunkOffset = 0;
        IL2CPP_OBJECT_SETREF_NULL(stringBuilder, chunkPrevious);
    }

    static bool IsGenericInstance(const Il2CppType* type)
    {
        if (type->type == IL2CPP_TYPE_GENERICINST)
            return true;

        while (type->type == IL2CPP_TYPE_SZARRAY)
        {
            if (type->data.type->type == IL2CPP_TYPE_GENERICINST)
                return true;

            type = type->data.type;
        }

        return false;
    }

    static std::string TypeNameListFor(const Il2CppGenericInst* genericInst)
    {
        std::string typeNameList;
        if (genericInst != NULL)
        {
            int numberOfTypeArguments = genericInst->type_argc;
            for (int i = 0; i < numberOfTypeArguments; i++)
            {
                typeNameList += Type::GetName(genericInst->type_argv[i], IL2CPP_TYPE_NAME_FORMAT_FULL_NAME);
                if (i != numberOfTypeArguments - 1)
                    typeNameList += ", ";
            }
        }

        return typeNameList;
    }

    intptr_t PlatformInvoke::MarshalDelegate(Il2CppDelegate* d)
    {
        if (d == NULL)
            return 0;

        if (IsFakeDelegateMethodMarshaledFromNativeCode(d))
            return reinterpret_cast<intptr_t>(d->delegate_trampoline);

        Il2CppMethodPointer reversePInvokeWrapper = MetadataCache::GetReversePInvokeWrapper(d->method->klass->image, d->method);
        if (reversePInvokeWrapper == NULL)
        {
            std::string methodName = il2cpp::vm::Method::GetFullName(d->method);
            // Okay, we cannot marshal it for some reason. Figure out why.
            if (Method::IsInstance(d->method))
            {
                std::string errorMessage = "IL2CPP does not support marshaling delegates that point to instance methods to native code. The method we're attempting to marshal is: " + methodName;
                vm::Exception::Raise(vm::Exception::GetNotSupportedException(errorMessage.c_str()));
            }

            if (il2cpp::vm::Method::HasFullGenericSharingSignature(d->method))
            {
                std::string errorMessage = "IL2CPP does not support marshaling generic delegates when full generic sharing is enabled. The method we're attempting to marshal is: " + methodName;
                errorMessage += "\nTo marshal this delegate, please add an attribute named 'MonoPInvokeCallback' to the method definition.";
                errorMessage += "\nThis attribute should have a type argument which is a generic delegate with all of the types required for this generic instantiation:";

                std::string genericTypeArguments = TypeNameListFor(d->method->genericMethod->context.class_inst);
                if (!genericTypeArguments.empty())
                    errorMessage += "\nGeneric type arguments: " + genericTypeArguments;

                std::string genericMethodArguments = TypeNameListFor(d->method->genericMethod->context.method_inst);
                if (!genericMethodArguments.empty())
                    errorMessage += "\nGeneric method arguments: " + genericMethodArguments;

                errorMessage += "\nThis C# code should work, for example:";
                std::string maybeComma = !genericTypeArguments.empty() ? ", " : "";
                errorMessage += "\n[MonoPInvokeCallback(typeof(System.Action<" + genericTypeArguments + maybeComma + genericMethodArguments + ">))]";

                vm::Exception::Raise(vm::Exception::GetNotSupportedException(errorMessage.c_str()));
            }

            if (d->method->parameters != NULL)
            {
                for (int i = 0; i < d->method->parameters_count; ++i)
                {
                    if (IsGenericInstance(d->method->parameters[i]))
                    {
                        std::string errorMessage = "Cannot marshal method '" + methodName + "' parameter '" + Method::GetParamName(d->method, i) + "': Generic types cannot be marshaled.";
                        vm::Exception::Raise(vm::Exception::GetMarshalDirectiveException(errorMessage.c_str()));
                    }
                }
            }

            std::string errorMessage = "To marshal a managed method, please add an attribute named 'MonoPInvokeCallback' to the method definition. The method we're attempting to marshal is: " + methodName;
            vm::Exception::Raise(vm::Exception::GetNotSupportedException(errorMessage.c_str()));
        }

        return reinterpret_cast<intptr_t>(reversePInvokeWrapper);
    }

    Il2CppDelegate* PlatformInvoke::MarshalFunctionPointerToDelegate(void* functionPtr, Il2CppClass* delegateType)
    {
        if (functionPtr == NULL)
            return NULL;

        if (!Class::HasParent(delegateType, il2cpp_defaults.delegate_class))
            Exception::Raise(Exception::GetArgumentException("t", "Type must derive from Delegate."));

        const Il2CppInteropData* interopData = delegateType->interopData;
        Il2CppMethodPointer managedToNativeWrapperMethodPointer = interopData != NULL ? interopData->delegatePInvokeWrapperFunction : NULL;

        if (managedToNativeWrapperMethodPointer == NULL)
            Exception::Raise(Exception::GetMarshalDirectiveException(utils::StringUtils::Printf("Cannot marshal P/Invoke call through delegate of type '%s.%s'", Class::GetNamespace(delegateType), Class::GetName(delegateType)).c_str()));

        const MethodInfo* invokeMethod = il2cpp::vm::Runtime::GetDelegateInvoke(delegateType);
        Il2CppDelegate* delegate = (Il2CppDelegate*)il2cpp::vm::Object::New(delegateType);
        Type::ConstructClosedDelegate(delegate, (Il2CppObject*)delegate, managedToNativeWrapperMethodPointer, invokeMethod);
        delegate->delegate_trampoline = functionPtr;

        return delegate;
    }

    // When a delegate is marshalled from native code via Marshal.GetDelegateForFunctionPointer
    // It will store the native function pointer in delegate_trampoline
    bool PlatformInvoke::IsFakeDelegateMethodMarshaledFromNativeCode(const Il2CppDelegate* d)
    {
        return d->delegate_trampoline != NULL;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\PlatformInvoke.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Profiler.cpp---------------
.
.
#include "il2cpp-config.h"
#include "utils/dynamic_array.h"
#include "vm/Profiler.h"

#if IL2CPP_ENABLE_PROFILER

namespace il2cpp
{
namespace vm
{
    struct ProfilerDesc
    {
        Il2CppProfiler* profiler;
        Il2CppProfileFlags events;
        Il2CppProfileFunc shutdownCallback;

        Il2CppProfileMethodFunc methodEnterCallback;
        Il2CppProfileMethodFunc methodLeaveCallback;

        Il2CppProfileAllocFunc allocationCallback;

        Il2CppProfileGCFunc gcEventCallback;
        Il2CppProfileGCResizeFunc gcHeapResizeCallback;

        Il2CppProfileFileIOFunc fileioCallback;

        Il2CppProfileThreadFunc threadStartCallback;
        Il2CppProfileThreadFunc threadEndCallback;
    };

    typedef il2cpp::utils::dynamic_array<ProfilerDesc*> ProfilersVec;
    struct ProfilerContext
    {
        ProfilersVec m_profilers;
    };
    ProfilerContext* s_ProfilerContext = nullptr;

    Il2CppProfileFlags Profiler::s_profilerEvents;

    void Profiler::Install(Il2CppProfiler *prof, Il2CppProfileFunc shutdownCallback)
    {
        AllocateStaticData();

        ProfilerDesc* desc = (ProfilerDesc*)IL2CPP_CALLOC(1, sizeof(ProfilerDesc));
        desc->profiler = prof;
        desc->shutdownCallback = shutdownCallback;
        s_ProfilerContext->m_profilers.push_back(desc);
    }

    void Profiler::Shutdown()
    {
        for (ProfilersVec::iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if ((*iter)->shutdownCallback)
                (*iter)->shutdownCallback((*iter)->profiler);
            IL2CPP_FREE((void*)(*iter));
        }
        s_ProfilerContext->m_profilers.clear();
    }

    void Profiler::SetEvents(Il2CppProfileFlags events)
    {
        Il2CppProfileFlags value = IL2CPP_PROFILE_NONE;
        if (s_ProfilerContext->m_profilers.size())
            s_ProfilerContext->m_profilers.back()->events = events;
        for (ProfilersVec::iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
            value = (Il2CppProfileFlags)(value | (*iter)->events);
        s_profilerEvents = value;
    }

    void Profiler::InstallEnterLeave(Il2CppProfileMethodFunc enter, Il2CppProfileMethodFunc fleave)
    {
        if (!s_ProfilerContext->m_profilers.size())
            return;
        s_ProfilerContext->m_profilers.back()->methodEnterCallback = enter;
        s_ProfilerContext->m_profilers.back()->methodLeaveCallback = fleave;
    }

    void Profiler::InstallAllocation(Il2CppProfileAllocFunc callback)
    {
        if (!s_ProfilerContext->m_profilers.size())
            return;
        s_ProfilerContext->m_profilers.back()->allocationCallback = callback;
    }

    void Profiler::InstallGC(Il2CppProfileGCFunc callback, Il2CppProfileGCResizeFunc heap_resize_callback)
    {
        if (!s_ProfilerContext->m_profilers.size())
            return;
        s_ProfilerContext->m_profilers.back()->gcEventCallback = callback;
        s_ProfilerContext->m_profilers.back()->gcHeapResizeCallback = heap_resize_callback;
    }

    void Profiler::InstallFileIO(Il2CppProfileFileIOFunc callback)
    {
        if (!s_ProfilerContext->m_profilers.size())
            return;
        s_ProfilerContext->m_profilers.back()->fileioCallback = callback;
    }

    void Profiler::InstallThread(Il2CppProfileThreadFunc start, Il2CppProfileThreadFunc end)
    {
        if (!s_ProfilerContext->m_profilers.size())
            return;
        s_ProfilerContext->m_profilers.back()->threadStartCallback = start;
        s_ProfilerContext->m_profilers.back()->threadEndCallback = end;
    }

    void Profiler::Allocation(Il2CppObject *obj, Il2CppClass *klass)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_ALLOCATIONS) && (*iter)->allocationCallback)
                (*iter)->allocationCallback((*iter)->profiler, obj, klass);
        }
    }

    void Profiler::MethodEnter(const MethodInfo *method)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_ENTER_LEAVE) && (*iter)->methodEnterCallback)
                (*iter)->methodEnterCallback((*iter)->profiler, method);
        }
    }

    void Profiler::MethodExit(const MethodInfo *method)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_ENTER_LEAVE) && (*iter)->methodLeaveCallback)
                (*iter)->methodLeaveCallback((*iter)->profiler, method);
        }
    }

    void Profiler::GCEvent(Il2CppGCEvent eventType)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_GC) && (*iter)->gcEventCallback)
                (*iter)->gcEventCallback((*iter)->profiler, eventType, 0);
        }
    }

    void Profiler::GCHeapResize(int64_t newSize)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_GC) && (*iter)->gcEventCallback)
                (*iter)->gcHeapResizeCallback((*iter)->profiler, newSize);
        }
    }

    void Profiler::FileIO(Il2CppProfileFileIOKind kind, int count)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_FILEIO) && (*iter)->fileioCallback)
                (*iter)->fileioCallback((*iter)->profiler, kind, count);
        }
    }

    void Profiler::ThreadStart(unsigned long tid)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_THREADS) && (*iter)->threadStartCallback)
                (*iter)->threadStartCallback((*iter)->profiler, tid);
        }
    }

    void Profiler::ThreadEnd(unsigned long tid)
    {
        for (ProfilersVec::const_iterator iter = s_ProfilerContext->m_profilers.begin(); iter != s_ProfilerContext->m_profilers.end(); iter++)
        {
            if (((*iter)->events & IL2CPP_PROFILE_THREADS) && (*iter)->threadEndCallback)
                (*iter)->threadEndCallback((*iter)->profiler, tid);
        }
    }

    void Profiler::AllocateStaticData()
    {
        if (s_ProfilerContext == nullptr)
            s_ProfilerContext = new ProfilerContext();
    }

    void Profiler::FreeStaticData()
    {
        delete s_ProfilerContext;
        s_ProfilerContext = nullptr;
    }
} /* namespace vm */
} /* namespace il2cpp */

#endif // IL2CPP_ENABLE_PROFILER
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Profiler.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Property.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/Property.h"
#include "il2cpp-class-internals.h"

namespace il2cpp
{
namespace vm
{
    uint32_t Property::GetFlags(const PropertyInfo* prop)
    {
        return prop->attrs;
    }

    const MethodInfo* Property::GetGetMethod(const PropertyInfo* prop)
    {
        return prop->get;
    }

    const MethodInfo* Property::GetSetMethod(const PropertyInfo* prop)
    {
        return prop->set;
    }

    const char* Property::GetName(const PropertyInfo* prop)
    {
        return prop->name;
    }

    Il2CppClass* Property::GetParent(const PropertyInfo* prop)
    {
        return prop->parent;
    }

    uint32_t Property::GetToken(const PropertyInfo* prop)
    {
        return prop->token;
    }

    const Il2CppType* Property::GetType(const PropertyInfo* prop)
    {
        if (prop->get)
            return prop->get->return_type;

        return prop->set->parameters[prop->set->parameters_count - 1];
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Property.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Random.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/Random.h"

#include "os/Cryptography.h"

namespace il2cpp
{
namespace vm
{
    bool Random::Open()
    {
        return il2cpp::os::Cryptography::OpenCryptographyProvider();
    }

    void* Random::Create()
    {
        il2cpp::os::Cryptography::OpenCryptographyProvider();
        return il2cpp::os::Cryptography::GetCryptographyProvider();
    }

    void Random::Free(void* handle)
    {
        il2cpp::os::Cryptography::ReleaseCryptographyProvider(handle);
    }

/**
* mono_rand_try_get_bytes:
* @handle: A pointer to an RNG handle. Handle is set to NULL on failure.
* @buffer: A buffer into which to write random data.
* @buffer_size: Number of bytes to write into buffer.
* @error: Set on error.
*
* Returns: FALSE on failure and sets @error, TRUE on success.
*
* Extracts bytes from an RNG handle.
*/
    bool Random::TryGetBytes(void* *handle, unsigned char *buffer, int buffer_size)
    {
        IL2CPP_ASSERT(handle);
        void* provider = *handle;

        if (!il2cpp::os::Cryptography::FillBufferWithRandomBytes(provider, buffer_size, buffer))
        {
            il2cpp::os::Cryptography::ReleaseCryptographyProvider(provider);
            /* we may have lost our context with CryptoAPI, but all hope isn't lost yet! */
            provider = il2cpp::os::Cryptography::GetCryptographyProvider();
            if (!il2cpp::os::Cryptography::FillBufferWithRandomBytes(provider, buffer_size, buffer))
            {
                il2cpp::os::Cryptography::ReleaseCryptographyProvider(provider);
                *handle = 0;
                //mono_error_set_execution_engine(error, "Failed to gen random bytes (%d)", GetLastError());
                return false;
            }
        }

        return true;
    }

/**
* mono_rand_try_get_uint32:
* @handle: A pointer to an RNG handle. Handle is set to NULL on failure.
* @val: A pointer to a 32-bit unsigned int, to which the result will be written.
* @min: Result will be greater than or equal to this value.
* @max: Result will be less than or equal to this value.
*
* Returns: FALSE on failure, TRUE on success.
*
* Extracts one 32-bit unsigned int from an RNG handle.
*/
    bool Random::TryGetUnsignedInt32(void* *handle, uint32_t *val, uint32_t min, uint32_t max)
    {
        IL2CPP_ASSERT(val);
        if (!TryGetBytes(handle, (unsigned char*)val, sizeof(uint32_t)))
            return false;

        double randomDouble = ((double)*val) / (((double)UINT32_MAX) + 1); // Range is [0,1)
        *val = (uint32_t)(randomDouble * (max - min + 1) + min);

        IL2CPP_ASSERT(*val >= min);
        IL2CPP_ASSERT(*val <= max);

        return true;
    }

    uint32_t Random::Next(void** handle, uint32_t min, uint32_t max)
    {
        uint32_t val;
        bool ok = TryGetUnsignedInt32(handle, &val, min, max);

        IL2CPP_ASSERT(ok);

        return val;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Random.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\RCW.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-tabledefs.h"
#include "gc/GCHandle.h"
#include "metadata/GenericMetadata.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/MetadataCache.h"
#include "vm/Object.h"
#include "vm/PlatformInvoke.h"
#include "vm/RCW.h"
#include "vm/Runtime.h"
#include "os/Atomic.h"
#include "os/COM.h"
#include "vm/Monitor.h"
#include "os/Mutex.h"
#include "os/WindowsRuntime.h"
#include "utils/Il2CppError.h"
#include "utils/Il2CppHashMap.h"
#include "utils/HashUtils.h"
#include "utils/StringUtils.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

const Il2CppGuid Il2CppIUnknown::IID = { 0x00000000, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
const Il2CppGuid Il2CppISequentialStream::IID = { 0x0c733a30, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d };
const Il2CppGuid Il2CppIStream::IID = { 0x0000000c, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
const Il2CppGuid Il2CppIMarshal::IID = { 0x00000003, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
const Il2CppGuid Il2CppIManagedObject::IID = { 0xc3fcc19e, 0xa970, 0x11d2, 0x8b, 0x5a, 0x00, 0xa0, 0xc9, 0xb7, 0xc9, 0xc4 };
const Il2CppGuid Il2CppIManagedObjectHolder::IID = { 0xd4bbc1c8, 0xf5bf, 0x4647, 0x94, 0x95, 0x2e, 0x5c, 0xf, 0x20, 0xf7, 0x5d };
const Il2CppGuid Il2CppIInspectable::IID = { 0xaf86e2e0, 0xb12d, 0x4c6a, 0x9c, 0x5a, 0xd7, 0xaa, 0x65, 0x10, 0x1E, 0x90 };
const Il2CppGuid Il2CppIActivationFactory::IID = { 0x00000035, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
const Il2CppGuid Il2CppIRestrictedErrorInfo::IID = { 0x82ba7092, 0x4c88, 0x427d, 0xa7, 0xbc, 0x16, 0xdd, 0x93, 0xfe, 0xb6, 0x7e };
const Il2CppGuid Il2CppILanguageExceptionErrorInfo::IID = { 0x04a2dbf3, 0xdf83, 0x116c, 0x09, 0x46, 0x08, 0x12, 0xab, 0xf6, 0xe0, 0x7d };
const Il2CppGuid Il2CppIAgileObject::IID = { 0x94ea2b94, 0xe9cc, 0x49e0, 0xc0, 0xff, 0xee, 0x64, 0xca, 0x8f, 0x5b, 0x90 };
const Il2CppGuid Il2CppIWeakReference::IID = { 0x00000037, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
const Il2CppGuid Il2CppIWeakReferenceSource::IID = { 0x00000038, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

namespace il2cpp
{
namespace vm
{
    typedef Il2CppHashMap<Il2CppIUnknown*, /* Weak GC Handle */ Il2CppGCHandle, il2cpp::utils::PointerHash<Il2CppIUnknown> > RCWCache;

    static baselib::ReentrantLock s_RCWCacheMutex;
    static RCWCache s_RCWCache;

    void RCW::Register(Il2CppComObject* rcw)
    {
        os::FastAutoLock lock(&s_RCWCacheMutex);
        rcw->refCount = 1;
        auto weakRef = gc::GCHandle::NewWeakref(rcw, false);
        vm::Exception::RaiseIfError(weakRef.GetError());
        const bool inserted = s_RCWCache.insert(std::make_pair(rcw->identity, weakRef.Get())).second;
        Assert(inserted);
    }

    static inline Il2CppIUnknown* GetIdentity(Il2CppIUnknown* unknown)
    {
        Il2CppIUnknown* identity;
        il2cpp_hresult_t hr = unknown->QueryInterface(Il2CppIUnknown::IID, reinterpret_cast<void**>(&identity));
        vm::Exception::RaiseIfFailed(hr, true);
        IL2CPP_ASSERT(identity);

        return identity;
    }

// Shameless comment copycat from .NET Native (https://github.com/dotnet/corert/blob/374c3d47992a7c444ec7d1dfe94b1780de942a55/src/System.Private.Interop/src/Shared/McgComHelpers.cs#L557):
// 1. Prefer using the class returned from GetRuntimeClassName
// 2. Otherwise use the class (if there) in the signature
// 3. Out of options - create Il2CppComObject
    static inline Il2CppClass* GetClassForRCW(Il2CppIInspectable* inspectable, Il2CppClass* fallbackClass)
    {
        Il2CppHString className;
        il2cpp_hresult_t hr = inspectable->GetRuntimeClassName(&className);
        if (IL2CPP_HR_FAILED(hr) || className == NULL)
            return fallbackClass;

        uint32_t classNameLength;
        auto classNamePtr = os::WindowsRuntime::GetHStringBuffer(className, &classNameLength);
        vm::Exception::RaiseIfError(classNamePtr.GetError());
        std::string classNameUtf8 = utils::StringUtils::Utf16ToUtf8(classNamePtr.Get(), classNameLength);
        os::WindowsRuntime::DeleteHString(className);

        Il2CppClass* rcwClass = MetadataCache::GetWindowsRuntimeClass(classNameUtf8.c_str());
        return rcwClass != NULL ? rcwClass : fallbackClass;
    }

    static inline Il2CppClass* GetClassForRCW(Il2CppIUnknown* unknown, Il2CppClass* fallbackClass)
    {
        Il2CppIInspectable* inspectable;
        il2cpp_hresult_t hr = unknown->QueryInterface(Il2CppIInspectable::IID, reinterpret_cast<void**>(&inspectable));

        if (IL2CPP_HR_FAILED(hr))
            return fallbackClass;

        Il2CppClass* result = GetClassForRCW(inspectable, fallbackClass);
        inspectable->Release();
        return result;
    }

    Il2CppObject* ReboxIReference(Il2CppIUnknown* comObject, Il2CppClass* objectClass);
    Il2CppObject* ReboxKeyValuePair(Il2CppIUnknown* comObject, Il2CppClass* keyValuePairGenericInstance);
    Il2CppObject* ReboxUri(Il2CppIUnknown* comObject);

    Il2CppObject* ReboxIfBoxed(Il2CppIUnknown* comObject, Il2CppClass* objectClass)
    {
        if (strcmp(objectClass->namespaze, "Windows.Foundation") == 0)
        {
            if (strcmp(objectClass->name, "IReference`1") == 0 || strcmp(objectClass->name, "IReferenceArray`1") == 0)
                return ReboxIReference(comObject, objectClass);
        }
        else if (strcmp(objectClass->namespaze, "System.Collections.Generic") == 0 && strcmp(objectClass->name, "KeyValuePair`2") == 0)
        {
            return ReboxKeyValuePair(comObject, objectClass);
        }
        else if (objectClass == il2cpp_defaults.system_uri_class)
        {
            return ReboxUri(comObject);
        }

        return NULL;
    }

    Il2CppObject* ReboxIReference(Il2CppIUnknown* comObject, Il2CppClass* objectClass)
    {
        Class::Init(objectClass);

        // Sanity checks
        IL2CPP_ASSERT(Class::IsInflated(objectClass));
        IL2CPP_ASSERT(objectClass->vtable_count == 1); // IReference`1<T> only has get_Value method

        const MethodInfo* getValueMethod = objectClass->vtable[0].method;
        IL2CPP_ASSERT(strcmp(getValueMethod->name, "get_Value") == 0);

        // We don't really want to allocate it on the GC heap for this little invocation
        Il2CppComObject fakeRcw;
        memset(&fakeRcw, 0, sizeof(fakeRcw));
        fakeRcw.klass = objectClass;
        fakeRcw.identity = comObject;

        Il2CppException* exception = NULL;
        Il2CppObject* reboxed = Runtime::Invoke(getValueMethod, &fakeRcw, NULL, &exception);

        if (exception != NULL)
            Exception::Raise(exception);

        return reboxed;
    }

    Il2CppObject* ReboxKeyValuePair(Il2CppIUnknown* comObject, Il2CppClass* keyValuePairGenericInstance)
    {
        Class::Init(keyValuePairGenericInstance);

        // Sanity checks
        IL2CPP_ASSERT(Class::IsInflated(keyValuePairGenericInstance));
        IL2CPP_ASSERT(il2cpp_defaults.ikey_value_pair_class != NULL);

        // Retrieve Windows.Foundation.Collections.IKeyValuePair`1<K, V> generic instance
        Il2CppGenericClass* iKeyValuePairGenericClass = metadata::GenericMetadata::GetGenericClass(il2cpp_defaults.ikey_value_pair_class, keyValuePairGenericInstance->generic_class->context.class_inst);
        Il2CppClass* iKeyValuePairGenericInstance = GenericClass::GetClass(iKeyValuePairGenericClass);
        Class::Init(iKeyValuePairGenericInstance);

        IL2CPP_ASSERT(iKeyValuePairGenericInstance->vtable_count == 2);

        const MethodInfo* getKeyMethod = iKeyValuePairGenericInstance->vtable[0].method;
        IL2CPP_ASSERT(strcmp(getKeyMethod->name, "get_Key") == 0);

        const MethodInfo* getValueMethod = iKeyValuePairGenericInstance->vtable[1].method;
        IL2CPP_ASSERT(strcmp(getValueMethod->name, "get_Value") == 0);

        Il2CppComObject fakeRcw;
        memset(&fakeRcw, 0, sizeof(fakeRcw));
        fakeRcw.klass = il2cpp_defaults.il2cpp_com_object_class;
        fakeRcw.identity = comObject;

        // Create new boxed key value pair
        Il2CppObject* reboxed = Object::New(keyValuePairGenericInstance);

        for (uint16_t i = 0; i < 2; i++)
        {
            const MethodInfo* methodToInvoke = NULL;
            const FieldInfo& field = keyValuePairGenericInstance->fields[i];

            // Figure out which getter to call
            if (strcmp(field.name, "key") == 0)
            {
                methodToInvoke = getKeyMethod;
            }
            else if (strcmp(field.name, "value") == 0)
            {
                methodToInvoke = getValueMethod;
            }

            // Call the getter
            Il2CppException* exception = NULL;
            Il2CppObject* fieldValue = Runtime::Invoke(methodToInvoke, &fakeRcw, NULL, &exception);

            if (exception != NULL)
                Exception::Raise(exception);

            // Set the field in our reboxed key value pair instance
            if (Class::FromIl2CppType(field.type)->byval_arg.valuetype)
            {
                Field::SetValue(reboxed, &field, Object::Unbox(fieldValue));
            }
            else
            {
                Field::SetValue(reboxed, &field, fieldValue);
            }
        }

        return reboxed;
    }

    Il2CppObject* ReboxUri(Il2CppIUnknown* comObject)
    {
        Il2CppClass* systemUriClass = il2cpp_defaults.system_uri_class;
        Il2CppClass* iUriRuntimeClassClass = il2cpp_defaults.windows_foundation_iuri_runtime_class_class;

        Class::Init(systemUriClass);
        Class::Init(iUriRuntimeClassClass);

        const int kGetRawUriMethodIndex = 10; // IUriRuntimeClass::get_RawUri
        IL2CPP_ASSERT(iUriRuntimeClassClass->vtable_count > kGetRawUriMethodIndex);

        VirtualInvokeData getRawUriInvokeData = iUriRuntimeClassClass->vtable[kGetRawUriMethodIndex];
        IL2CPP_ASSERT(strcmp(getRawUriInvokeData.method->name, "get_RawUri") == 0);

        Il2CppComObject fakeRcw;
        memset(&fakeRcw, 0, sizeof(fakeRcw));
        fakeRcw.klass = il2cpp_defaults.il2cpp_com_object_class;
        fakeRcw.identity = comObject;

        Il2CppObject* rawUri = Runtime::InvokeWithThrow(getRawUriInvokeData.method, &fakeRcw, NULL);

        const MethodInfo* uriConstructor = NULL;
        uint16_t uriMethodCount = systemUriClass->method_count;

        for (uint16_t i = 0; i < uriMethodCount; i++)
        {
            const MethodInfo* method = systemUriClass->methods[i];
            if (strcmp(method->name, ".ctor") == 0 && method->parameters_count == 1 && method->parameters[0]->type == IL2CPP_TYPE_STRING)
            {
                uriConstructor = method;
                break;
            }
        }

        IL2CPP_ASSERT(uriConstructor);
        Il2CppObject* reboxedUri = Object::New(systemUriClass);
        void* constructorArgs[1] = { rawUri };

        Runtime::InvokeWithThrow(uriConstructor, reboxedUri, constructorArgs);
        return reboxedUri;
    }

    template<typename T, bool isSealedClassInstance>
    static inline Il2CppObject* GetOrCreateRCW(T* comObject, Il2CppClass* objectClass)
    {
        IL2CPP_ASSERT(comObject != NULL);

        if (!isSealedClassInstance)
        {
            // 1. Check if comObject is actually our COM Callable Wrapper
            Il2CppIManagedObjectHolder* managedHolder;
            il2cpp_hresult_t hr = comObject->QueryInterface(Il2CppIManagedObjectHolder::IID, reinterpret_cast<void**>(&managedHolder));
            if (IL2CPP_HR_SUCCEEDED(hr))
            {
                Il2CppObject* instance = managedHolder->GetManagedObject();
                managedHolder->Release();

                IL2CPP_ASSERT(instance);
                return instance;
            }
        }

        Il2CppIUnknown* identity = GetIdentity(comObject);

        // 2. Try to find it in RCW cache
        os::FastAutoLock lock(&s_RCWCacheMutex);
        RCWCache::iterator iter = s_RCWCache.find(identity);
        if (iter != s_RCWCache.end())
        {
            Il2CppComObject* obj = static_cast<Il2CppComObject*>(gc::GCHandle::GetTarget(iter->second));
            if (obj != NULL)
            {
                // Make sure the RCW isn't dead. If increment returns 1, it means
                // that the ref count had previous reached 0 and was released
                if (os::Atomic::Increment(&obj->refCount) > 1)
                {
                    identity->Release();
                    identity = NULL;
                    return obj;
                }
            }

            // The RCW was already queued for finalization or destroyed by ref count reaching 0.
            // Erase it from the cache and let us create a new one.
            s_RCWCache.erase(iter);
        }

        // 3. Figure out the concrete RCW class
        if (!isSealedClassInstance)
        {
            Il2CppClass* fallbackClass = objectClass;
            objectClass = GetClassForRCW(comObject, fallbackClass);

            // If object class is one of the blessed unboxable classes,
            // unbox the object from its windows runtime representation,
            // unmarshal it, box it to Il2CppObject and return it
            //
            // Current list of unboxable classes:
            //     Windows.Foundation.IReference`1<T>
            //     Windows.Foundation.IReferenceArray`1<T>
            //     System.Collections.Generic.KeyValuePair`2<K, V>
            //     System.Uri
            Il2CppObject* reboxed = ReboxIfBoxed(comObject, objectClass);
            if (reboxed != NULL)
                return reboxed;

            if (objectClass->byval_arg.type != IL2CPP_TYPE_CLASS ||
                objectClass->flags & TYPE_ATTRIBUTE_INTERFACE ||
                objectClass->is_generic)
            {
                // We must be able to instantiate the type. If we can't, fallback to a caller passed in type
                objectClass = fallbackClass;
            }
        }

        IL2CPP_ASSERT(Class::HasParent(objectClass, il2cpp_defaults.il2cpp_com_object_class));

        // 4. Create RCW object
        Il2CppComObject* rcw = static_cast<Il2CppComObject*>(Object::New(objectClass));
        rcw->identity = identity;
        rcw->refCount = 1;

        // 5. Insert it into the cache
        auto weakRef = gc::GCHandle::NewWeakref(rcw, false);
        vm::Exception::RaiseIfError(weakRef.GetError());
        const bool inserted = s_RCWCache.insert(std::make_pair(identity, weakRef.Get())).second;
        Assert(inserted);

        return rcw;
    }

    Il2CppObject* RCW::GetOrCreateFromIUnknown(Il2CppIUnknown* unknown, Il2CppClass* fallbackClass)
    {
        return GetOrCreateRCW<Il2CppIUnknown, false>(unknown, fallbackClass);
    }

    Il2CppObject* RCW::GetOrCreateFromIInspectable(Il2CppIInspectable* inspectable, Il2CppClass* fallbackClass)
    {
        return GetOrCreateRCW<Il2CppIInspectable, false>(inspectable, fallbackClass);
    }

    Il2CppObject* RCW::GetOrCreateForSealedClass(Il2CppIUnknown* unknown, Il2CppClass* objectClass)
    {
        return GetOrCreateRCW<Il2CppIUnknown, true>(unknown, objectClass);
    }

    void RCW::Cleanup(Il2CppComObject* rcw)
    {
        if (rcw->klass->is_import_or_windows_runtime)
        {
            os::FastAutoLock lock(&s_RCWCacheMutex);

            RCWCache::iterator iter = s_RCWCache.find(rcw->identity);

            // It is possible for us to not find object in the cache if two RCWs for the same IUnknown get
            // finalized in a row: then, the first finalizer will remove the NULL object, and the second one
            // will not find it.
            if (iter != s_RCWCache.end())
            {
                Il2CppObject* obj = gc::GCHandle::GetTarget(iter->second);

                // If it's null, it means that the cache contains our object
                // but the weak GC handle has been invalidated by the GC already
                // If it's equal to our object, it means that RCW::Cleanup was
                // called manually, and we should also delete it from the cache
                // Otherwise, it's a different object. It means that we have already
                // created a new RCW in place of this one during the time
                // it had been queued for finalization
                if (obj == NULL || obj == rcw)
                    s_RCWCache.erase(iter);
            }
        }

        int32_t shortCacheSize = rcw->qiShortCacheSize;
        for (int32_t i = 0; i < shortCacheSize; i++)
            rcw->qiShortCache[i].qiResult->Release();

        int32_t longCacheSize = rcw->qiLongCacheSize;
        if (longCacheSize > 0)
        {
            for (int32_t i = 0; i < longCacheSize; i++)
                rcw->qiLongCache[i].qiResult->Release();

            IL2CPP_FREE(rcw->qiLongCache);
        }
    }

    Il2CppIUnknown* RCW::QueryInterfaceCached(Il2CppComObject* rcw, const Il2CppGuid& iid)
    {
        MonitorHolder monitorHolder(rcw);

        int32_t shortCacheSize = rcw->qiShortCacheSize;
        for (int32_t i = 0; i < shortCacheSize; i++)
        {
            const Il2CppGuid* queriedInterface = rcw->qiShortCache[i].iid;
            if (queriedInterface == &iid)
                return rcw->qiShortCache[i].qiResult;
        }

        int32_t longCacheSize = rcw->qiLongCacheSize;
        for (int32_t i = 0; i < longCacheSize; i++)
        {
            const Il2CppGuid* queriedInterface = rcw->qiLongCache[i].iid;
            if (queriedInterface == &iid)
                return rcw->qiLongCache[i].qiResult;
        }

        return NULL;
    }

    bool RCW::CacheQueriedInterface(Il2CppComObject* rcw, const Il2CppGuid& iid, Il2CppIUnknown* queriedInterface)
    {
        MonitorHolder monitorHolder(rcw);

        QICache cache = { &iid, queriedInterface };

        // We need to rescan caches in case another thread got to cache it first
        int32_t shortCacheSize = rcw->qiShortCacheSize;
        IL2CPP_ASSERT(shortCacheSize <= IL2CPP_ARRAY_SIZE(rcw->qiShortCache));

        for (int32_t i = 0; i < shortCacheSize; i++)
        {
            const Il2CppGuid* queriedInterface = rcw->qiShortCache[i].iid;
            if (queriedInterface == &iid)
                return false;
        }

        if (shortCacheSize == IL2CPP_ARRAY_SIZE(rcw->qiShortCache))
        {
            // We only need to check long cache if short cache is full
            int32_t longCacheSize = rcw->qiLongCacheSize;
            for (int32_t i = 0; i < longCacheSize; i++)
            {
                const Il2CppGuid* queriedInterface = rcw->qiLongCache[i].iid;
                if (queriedInterface == &iid)
                    return false;
            }
        }
        else
        {
            rcw->qiShortCache[shortCacheSize] = cache;
            rcw->qiShortCacheSize = shortCacheSize + 1;
            return true;
        }

        int32_t longCacheSize = rcw->qiLongCacheSize;
        int32_t longCacheCapacity = rcw->qiLongCacheCapacity;
        IL2CPP_ASSERT(longCacheSize <= longCacheCapacity);

        if (longCacheSize == longCacheCapacity)
        {
            longCacheCapacity *= 2;
            rcw->qiLongCache = static_cast<QICache*>(IL2CPP_REALLOC(rcw->qiLongCache, sizeof(QICache) * longCacheCapacity));
            rcw->qiLongCacheCapacity = longCacheCapacity;
        }

        rcw->qiLongCache[longCacheSize] = cache;
        rcw->qiLongCacheSize = longCacheSize + 1;
        return true;
    }

    const VirtualInvokeData* RCW::GetComInterfaceInvokeData(Il2CppClass* queriedInterface, const Il2CppClass* targetInterface, Il2CppMethodSlot slot)
    {
        Class::Init(queriedInterface);
        uint16_t vtableCount = queriedInterface->vtable_count;

        if (targetInterface->generic_class != NULL)
        {
            if (Class::IsGenericClassAssignableFrom(targetInterface, queriedInterface))
                return NULL;

            const Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets = queriedInterface->interfaceOffsets;
            uint16_t interfaceOffsetsCount = queriedInterface->interface_offsets_count;
            for (uint16_t i = 0; i < interfaceOffsetsCount; i++)
            {
                if (Class::IsGenericClassAssignableFrom(targetInterface, interfaceOffsets[i].interfaceType))
                {
                    Il2CppMethodSlot slotWithOffset = interfaceOffsets[i].offset + slot;
                    if (slotWithOffset < vtableCount)
                        return &queriedInterface->vtable[slotWithOffset];
                }
            }
        }
        else
        {
            const Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets = queriedInterface->interfaceOffsets;
            uint16_t interfaceOffsetsCount = queriedInterface->interface_offsets_count;
            for (uint16_t i = 0; i < interfaceOffsetsCount; ++i)
            {
                if (interfaceOffsets[i].interfaceType == targetInterface)
                {
                    Il2CppMethodSlot slotWithOffset = interfaceOffsets[i].offset + slot;
                    if (slotWithOffset < vtableCount)
                        return &queriedInterface->vtable[slotWithOffset];
                }
            }
        }

        Il2CppClass* const* implementedInterfaces = queriedInterface->implementedInterfaces;
        uint16_t implementedInterfacesCount = queriedInterface->interfaces_count;

        for (uint16_t i = 0; i < implementedInterfacesCount; i++)
        {
            Il2CppClass* implementedInterface = implementedInterfaces[i];
            const VirtualInvokeData* invokeData = GetComInterfaceInvokeData(implementedInterface, targetInterface, slot);
            if (invokeData != NULL)
                return invokeData;
        }

        return NULL;
    }

    const VirtualInvokeData* RCW::GetComInterfaceInvokeData(Il2CppComObject* rcw, const Il2CppClass* targetInterface, Il2CppMethodSlot slot)
    {
        uint16_t vtableCount = targetInterface->vtable_count;
        if (slot < vtableCount)
        {
            const Il2CppInteropData* itfInteropData = targetInterface->interopData;
            if (itfInteropData != NULL)
            {
                const Il2CppGuid* itfGuid = itfInteropData->guid;
                if (itfGuid != NULL)
                {
                    // Try querying for the interface we were asked
                    if (RCW::QueryInterfaceNoAddRef<false>(rcw, *itfGuid) != NULL)
                        return &targetInterface->vtable[slot];
                }
            }
        }

        if (targetInterface->is_import_or_windows_runtime)
            return NULL;

        // For projected interfaces, we look in the cache for compatible interface in order to handle these scenarios:
        // * Covariable/Contravariance. For instance, we should be able to invoke IReadOnlyList<object> methods on IReadOnlyList<string>, even though if QI fails for IVectorView<object>
        // * Inherited interfaces on CLR but not Windows Runtime side. For instance, IEnumerable<T> implements IEnumerable but IIterable<T> does not implement IBindableIterable
        MonitorHolder monitorHolder(rcw);

        int32_t shortCacheSize = rcw->qiShortCacheSize;
        for (int32_t i = 0; i < shortCacheSize; i++)
        {
            Il2CppClass* queriedInterface = vm::MetadataCache::GetClassForGuid(rcw->qiShortCache[i].iid);
            if (queriedInterface != NULL)
            {
                const VirtualInvokeData* invokeData = GetComInterfaceInvokeData(queriedInterface, targetInterface, slot);
                if (invokeData != NULL)
                    return invokeData;
            }
        }

        int32_t longCacheSize = rcw->qiLongCacheSize;
        for (int32_t i = 0; i < longCacheSize; i++)
        {
            Il2CppClass* queriedInterface = vm::MetadataCache::GetClassForGuid(rcw->qiLongCache[i].iid);
            if (queriedInterface != NULL)
            {
                const VirtualInvokeData* invokeData = GetComInterfaceInvokeData(queriedInterface, targetInterface, slot);
                if (invokeData != NULL)
                    return invokeData;
            }
        }

        if (slot < vtableCount)
            return &targetInterface->vtable[slot];

        return NULL;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\RCW.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Reflection.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"
#include "mono-structs.h"
#include "gc/GCHandle.h"
#include "gc/WriteBarrier.h"
#include "metadata/CustomAttributeDataReader.h"
#include "metadata/CustomAttributeCreator.h"
#include "metadata/Il2CppTypeCompare.h"
#include "metadata/Il2CppTypeHash.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Event.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "vm/Image.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Parameter.h"
#include "vm/Property.h"
#include "vm/Reflection.h"
#include "vm/String.h"
#include "vm/AssemblyName.h"
#include "utils/Il2CppHashMap.h"
#include "utils/StringUtils.h"
#include "utils/HashUtils.h"
#include "gc/AppendOnlyGCHashMap.h"


#include "gc/Allocator.h"

template<typename T>
struct ReflectionMapHash
{
    size_t operator()(const T& ea) const
    {
        return ((size_t)(intptr_t)(ea.first)) >> 3;
    }
};

template<typename T>
struct ReflectionMapLess
{
    bool operator()(const T& ea, const T& eb) const
    {
        if (ea.first < eb.first)
            return true;
        if (ea.second < eb.second)
            return true;
        return false;
    }
};


template<typename Key, typename Value>
struct ReflectionMap : public il2cpp::gc::AppendOnlyGCHashMap<Key, Value, ReflectionMapHash<Key> >
{
};

typedef ReflectionMap<std::pair<const Il2CppAssembly*, Il2CppClass*>, Il2CppReflectionAssembly*> AssemblyMap;
typedef ReflectionMap<std::pair<const FieldInfo*, Il2CppClass*>, Il2CppReflectionField*> FieldMap;
typedef ReflectionMap<std::pair<const PropertyInfo*, Il2CppClass*>, Il2CppReflectionProperty*> PropertyMap;
typedef ReflectionMap<std::pair<const EventInfo*, Il2CppClass*>, Il2CppReflectionEvent*> EventMap;
typedef ReflectionMap<std::pair<const MethodInfo*, Il2CppClass*>, Il2CppReflectionMethod*> MethodMap;
typedef ReflectionMap<std::pair<const Il2CppImage*, Il2CppClass*>, Il2CppReflectionModule*> ModuleMap;
typedef ReflectionMap<std::pair<const MethodInfo*, Il2CppClass*>, Il2CppArray*> ParametersMap;

typedef il2cpp::gc::AppendOnlyGCHashMap<const Il2CppType*, Il2CppReflectionType*, il2cpp::metadata::Il2CppTypeHash, il2cpp::metadata::Il2CppTypeEqualityComparer> TypeMap;

typedef Il2CppHashMap<Il2CppMetadataGenericParameterHandle, const MonoGenericParameterInfo*, il2cpp::utils::PassThroughHash<Il2CppMetadataGenericParameterHandle> > MonoGenericParameterMap;
typedef Il2CppHashMap<const  Il2CppAssembly*, const Il2CppMonoAssemblyName*, il2cpp::utils::PointerHash<const Il2CppAssembly> > MonoAssemblyNameMap;

// these needs to be pointers and allocated after GC is initialized since it uses GC Allocator
static AssemblyMap* s_AssemblyMap;
static FieldMap* s_FieldMap;
static PropertyMap* s_PropertyMap;
static EventMap* s_EventMap;
static MethodMap* s_MethodMap;
static ModuleMap* s_ModuleMap;
static ParametersMap* s_ParametersMap;
static TypeMap* s_TypeMap;
static MonoGenericParameterMap* s_MonoGenericParamterMap;
static MonoAssemblyNameMap* s_MonoAssemblyNameMap;

namespace il2cpp
{
namespace vm
{
    static Il2CppClass *s_System_Reflection_Assembly;
    static Il2CppClass * s_System_Reflection_RuntimeFieldInfoKlass;
    static Il2CppClass *s_System_Reflection_Module;
    static Il2CppClass * s_System_Reflection_RuntimePropertyInfoKlass;
    static Il2CppClass * s_System_Reflection_RuntimeEventInfoKlass;
    static FieldInfo *s_DbNullValueField;
    static FieldInfo *s_ReflectionMissingField;
    static Il2CppClass *s_System_Reflection_ParameterInfo;
    static Il2CppClass *s_System_Reflection_ParameterInfo_array;
/*
 * We use the same C representation for methods and constructors, but the type
 * name in C# is different.
 */
    static Il2CppClass *s_System_Reflection_MethodInfo;
    static Il2CppClass *s_System_Reflection_ConstructorInfo;

    static il2cpp::metadata::CustomAttributeFilter GetFilter(Il2CppClass*& attributeClass)
    {
        if (attributeClass == NULL)
            return [](const MethodInfo*) { return true; };

        return [attributeClass](const MethodInfo* ctor) {
                Il2CppClass* klass = ctor->klass;
                return il2cpp::vm::Class::HasParent(klass, attributeClass) || (il2cpp::vm::Class::IsInterface(attributeClass) && il2cpp::vm::Class::IsAssignableFrom(attributeClass, klass));
        };
    }

    Il2CppReflectionAssembly* Reflection::GetAssemblyObject(const Il2CppAssembly *assembly)
    {
        Il2CppReflectionAssembly *res;

        AssemblyMap::key_type::wrapped_type key(assembly, (Il2CppClass*)NULL);
        AssemblyMap::data_type value = NULL;

        if (s_AssemblyMap->TryGetValue(key, &value))
            return value;

        res = (Il2CppReflectionAssembly*)Object::New(s_System_Reflection_Assembly);
        res->assembly = assembly;

        return s_AssemblyMap->GetOrAdd(key, res);
    }

    Il2CppReflectionAssemblyName* Reflection::GetAssemblyNameObject(const Il2CppAssemblyName *assemblyName)
    {
        IL2CPP_ASSERT(il2cpp_defaults.assembly_name_class != NULL);

        std::string fullAssemblyName = vm::AssemblyName::AssemblyNameToString(*assemblyName);
        Il2CppReflectionAssemblyName* reflectionAssemblyName = (Il2CppReflectionAssemblyName*)Object::New(il2cpp_defaults.assembly_name_class);
        vm::AssemblyName::ParseName(reflectionAssemblyName, fullAssemblyName);
        return reflectionAssemblyName;
    }

    Il2CppReflectionField* Reflection::GetFieldObject(Il2CppClass *klass, FieldInfo *field)
    {
        Il2CppReflectionField *res;

        FieldMap::key_type::wrapped_type key(field, klass);
        FieldMap::data_type value = NULL;

        if (s_FieldMap->TryGetValue(key, &value))
            return value;

        res = (Il2CppReflectionField*)Object::New(s_System_Reflection_RuntimeFieldInfoKlass);
        res->klass = klass;
        res->field = field;
        IL2CPP_OBJECT_SETREF(res, name, String::New(Field::GetName(field)));
        res->attrs = field->type->attrs;
        IL2CPP_OBJECT_SETREF(res, type, GetTypeObject(field->type));

        return s_FieldMap->GetOrAdd(key, res);
    }

    const FieldInfo* Reflection::GetField(const Il2CppReflectionField* field)
    {
        return field->field;
    }

    const MethodInfo* Reflection::GetMethod(const Il2CppReflectionMethod* method)
    {
        return method->method;
    }

    Il2CppReflectionMethod* Reflection::GetMethodObject(const MethodInfo *method, Il2CppClass *refclass)
    {
        Il2CppClass *klass;
        Il2CppReflectionMethod *ret;

        if (!refclass)
            refclass = method->klass;

        MethodMap::key_type::wrapped_type key(method, refclass);
        MethodMap::data_type value = NULL;

        if (s_MethodMap->TryGetValue(key, &value))
            return value;

        if (*method->name == '.' && (strcmp(method->name, ".ctor") == 0 || strcmp(method->name, ".cctor") == 0))
        {
            klass = s_System_Reflection_ConstructorInfo;
        }
        else
        {
            klass = s_System_Reflection_MethodInfo;
        }
        ret = (Il2CppReflectionMethod*)Object::New(klass);
        ret->method = method;
        IL2CPP_OBJECT_SETREF(ret, reftype, GetTypeObject(&refclass->byval_arg));

        return s_MethodMap->GetOrAdd(key, ret);
    }

    Il2CppReflectionModule* Reflection::GetModuleObject(const Il2CppImage *image)
    {
        Il2CppReflectionModule *res;
        //char* basename;

        ModuleMap::key_type::wrapped_type key(image, (Il2CppClass*)NULL);
        ModuleMap::data_type value = NULL;

        if (s_ModuleMap->TryGetValue(key, &value))
            return value;

        res = (Il2CppReflectionModule*)Object::New(s_System_Reflection_Module);

        res->image = image;
        IL2CPP_OBJECT_SETREF(res, assembly, Reflection::GetAssemblyObject(image->assembly));

        IL2CPP_OBJECT_SETREF(res, fqname, String::New(image->name));
        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(Reflection::GetModuleObject, "Missing Module fields need set");
        //basename = g_path_get_basename (image->name);
        //IL2CPP_OBJECT_SETREF (res, name, String::New (basename));
        IL2CPP_OBJECT_SETREF(res, name, String::New(image->name));
        IL2CPP_OBJECT_SETREF(res, scopename, String::New(image->nameNoExt));

        //g_free (basename);

        /*if (image->assembly->image == image) {
            res->token = mono_metadata_make_token (MONO_TABLE_MODULE, 1);
        } else {
            int i;
            res->token = 0;
            if (image->assembly->image->modules) {
                for (i = 0; i < image->assembly->image->module_count; i++) {
                    if (image->assembly->image->modules [i] == image)
                        res->token = mono_metadata_make_token (MONO_TABLE_MODULEREF, i + 1);
                }
                IL2CPP_ASSERT(res->token);
            }
        }*/

        return s_ModuleMap->GetOrAdd(key, res);
    }

    Il2CppReflectionProperty* Reflection::GetPropertyObject(Il2CppClass *klass, const PropertyInfo *property)
    {
        Il2CppReflectionProperty *res;

        PropertyMap::key_type::wrapped_type key(property, klass);
        PropertyMap::data_type value = NULL;

        if (s_PropertyMap->TryGetValue(key, &value))
            return value;

        res = (Il2CppReflectionProperty*)Object::New(s_System_Reflection_RuntimePropertyInfoKlass);
        res->klass = klass;
        res->property = property;

        return s_PropertyMap->GetOrAdd(key, res);
    }

    Il2CppReflectionEvent* Reflection::GetEventObject(Il2CppClass* klass, const EventInfo* event)
    {
        Il2CppReflectionEvent* result;

        EventMap::key_type::wrapped_type key(event, klass);
        EventMap::data_type value = NULL;

        if (s_EventMap->TryGetValue(key, &value))
            return value;

        Il2CppReflectionMonoEvent* monoEvent = reinterpret_cast<Il2CppReflectionMonoEvent*>(Object::New(s_System_Reflection_RuntimeEventInfoKlass));
        monoEvent->eventInfo = event;
        monoEvent->reflectedType = Reflection::GetTypeObject(&klass->byval_arg);
        result = reinterpret_cast<Il2CppReflectionEvent*>(monoEvent);

        return s_EventMap->GetOrAdd(key, result);
    }

    Il2CppReflectionType* Reflection::GetTypeObject(const Il2CppType *type)
    {
        Il2CppReflectionType* object = NULL;

        if (s_TypeMap->TryGetValue(type, &object))
            return object;

        Il2CppReflectionType* typeObject = (Il2CppReflectionType*)Object::New(il2cpp_defaults.runtimetype_class);

        typeObject->type = type;

        return s_TypeMap->GetOrAdd(type, typeObject);
    }

    Il2CppObject* Reflection::GetDBNullObject()
    {
        Il2CppObject* valueFieldValue;

        if (!s_DbNullValueField)
        {
            s_DbNullValueField = Class::GetFieldFromName(il2cpp_defaults.dbnull_class, "Value");
            IL2CPP_ASSERT(s_DbNullValueField);
        }

        valueFieldValue = Field::GetValueObject(s_DbNullValueField, NULL);
        IL2CPP_ASSERT(valueFieldValue);
        return valueFieldValue;
    }

    static Il2CppObject* GetReflectionMissingObject()
    {
        Il2CppObject* valueFieldValue;

        if (!s_ReflectionMissingField)
        {
            Il2CppClass* klass = Image::ClassFromName(il2cpp_defaults.corlib, "System.Reflection", "Missing");
            Class::Init(klass);
            s_ReflectionMissingField = Class::GetFieldFromName(klass, "Value");
            IL2CPP_ASSERT(s_ReflectionMissingField);
        }

        valueFieldValue = Field::GetValueObject(s_ReflectionMissingField, NULL);
        IL2CPP_ASSERT(valueFieldValue);
        return valueFieldValue;
    }

    static Il2CppObject* GetObjectForMissingDefaultValue(uint32_t parameterAttributes)
    {
        if (parameterAttributes & PARAM_ATTRIBUTE_OPTIONAL)
            return GetReflectionMissingObject();
        else
            return Reflection::GetDBNullObject();
    }

    Il2CppArray* Reflection::GetParamObjects(const MethodInfo *method, Il2CppClass *refclass)
    {
        Il2CppArray *res = NULL;
        Il2CppReflectionMethod *member = NULL;

        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Reflection::GetParamObjects, "Work in progress!");

        if (!method->parameters_count)
            return Array::NewSpecific(s_System_Reflection_ParameterInfo_array, 0);

        // Mono caches based on the address of the method pointer in the MethodInfo
        // since they put everything in one cache and the MethodInfo is already used as key for GetMethodObject caching
        // However, since we have distinct maps for the different types we can use MethodInfo as the key again

        ParametersMap::key_type::wrapped_type key(method, refclass);
        ParametersMap::data_type value;

        if (s_ParametersMap->TryGetValue(key, &value))
            return value;

        member = GetMethodObject(method, refclass);
        res = Array::NewSpecific(s_System_Reflection_ParameterInfo_array, method->parameters_count);
        for (int i = 0; i < method->parameters_count; ++i)
        {
            Il2CppReflectionParameter* param = (Il2CppReflectionParameter*)Object::New(s_System_Reflection_ParameterInfo);
            IL2CPP_OBJECT_SETREF(param, ClassImpl, GetTypeObject(method->parameters[i]));
            IL2CPP_OBJECT_SETREF(param, MemberImpl, (Il2CppObject*)member);
            const char* parameter_name = Method::GetParamName(method, i);
            IL2CPP_OBJECT_SETREF(param, NameImpl, parameter_name ? String::New(parameter_name) : NULL);
            param->PositionImpl = i;
            param->AttrsImpl = method->parameters[i]->attrs;

            Il2CppObject* defaultValue = NULL;
            if (param->AttrsImpl & PARAM_ATTRIBUTE_HAS_DEFAULT)
            {
                bool isExplicitySetNullDefaultValue = false;
                defaultValue = Parameter::GetDefaultParameterValueObject(method, i, &isExplicitySetNullDefaultValue);
                if (defaultValue == NULL && !isExplicitySetNullDefaultValue)
                    defaultValue = GetObjectForMissingDefaultValue(param->AttrsImpl);
            }
            else
            {
                defaultValue = GetObjectForMissingDefaultValue(param->AttrsImpl);
            }

            IL2CPP_OBJECT_SETREF(param, DefaultValueImpl, defaultValue);

            il2cpp_array_setref(res, i, param);
        }

        return s_ParametersMap->GetOrAdd(key, res);
    }

// TODO: move this somewhere else
    bool Reflection::IsType(Il2CppObject *obj)
    {
        return (obj->klass == il2cpp_defaults.runtimetype_class);
    }

    static bool IsMethod(Il2CppObject *obj)
    {
        return obj->klass == s_System_Reflection_MethodInfo;
    }

    static bool IsCMethod(Il2CppObject *obj)
    {
        return obj->klass == s_System_Reflection_ConstructorInfo;
    }

    bool Reflection::IsAnyMethod(Il2CppObject *obj)
    {
        return IsMethod(obj) || IsCMethod(obj);
    }

    bool Reflection::IsField(Il2CppObject *obj)
    {
        return obj->klass == s_System_Reflection_RuntimeFieldInfoKlass;
    }

    bool Reflection::IsProperty(Il2CppObject *obj)
    {
        return obj->klass == s_System_Reflection_RuntimePropertyInfoKlass;
    }

    bool Reflection::IsEvent(Il2CppObject *obj)
    {
        return obj->klass == s_System_Reflection_RuntimeEventInfoKlass;
    }

    static bool IsParameter(Il2CppObject *obj)
    {
        return obj->klass == il2cpp_defaults.parameter_info_class;
    }

    static bool IsAssembly(Il2CppObject *obj)
    {
        return obj->klass == s_System_Reflection_Assembly->klass;
    }

    static std::tuple<uint32_t, const Il2CppImage*> GetMetadataTokenFromReflectionType(Il2CppObject* obj, bool throwOnError = true)
    {
        if (vm::Reflection::IsField(obj))
        {
            Il2CppReflectionField* field = (Il2CppReflectionField*)obj;
            return std::make_tuple(vm::Field::GetToken(field->field), field->field->parent->image);
        }
        if (vm::Reflection::IsAnyMethod(obj))
        {
            Il2CppReflectionMethod* method = (Il2CppReflectionMethod*)obj;
            return std::make_tuple(vm::Method::GetToken(method->method), method->method->klass->image);
        }
        if (vm::Reflection::IsProperty(obj))
        {
            Il2CppReflectionProperty* prop = (Il2CppReflectionProperty*)obj;
            return std::make_tuple(vm::Property::GetToken(prop->property), prop->property->parent->image);
        }
        if (vm::Reflection::IsEvent(obj))
        {
            Il2CppReflectionMonoEvent* eventInfo = (Il2CppReflectionMonoEvent*)obj;
            return std::make_tuple(vm::Event::GetToken(eventInfo->eventInfo), eventInfo->eventInfo->parent->image);
        }
        if (vm::Reflection::IsType(obj))
        {
            Il2CppReflectionType* type = (Il2CppReflectionType*)obj;
            Il2CppClass* klass = vm::Class::FromIl2CppType(type->type);
            return std::make_tuple(klass->token, klass->image);
        }
        if (IsParameter(obj))
        {
            Il2CppReflectionParameter* parameter = (Il2CppReflectionParameter*)obj;
            Il2CppReflectionMethod* method = (Il2CppReflectionMethod*)parameter->MemberImpl;
            const Il2CppImage* image = method->method->klass->image;

            return std::make_tuple(vm::Method::GetParameterToken(method->method, parameter->PositionImpl), method->method->klass->image);
        }
        if (IsAssembly(obj))
        {
            Il2CppReflectionAssembly* assembly = (Il2CppReflectionAssembly*)obj;
            return std::make_tuple(assembly->assembly->token, assembly->assembly->image);
        }

        if (throwOnError)
            NOT_SUPPORTED_IL2CPP(MemberInfo::get_MetadataToken, "This icall is not supported by il2cpp.");
        return std::make_tuple(0, (const Il2CppImage*)nullptr);
    }

    int Reflection::GetMetadataToken(Il2CppObject* obj)
    {
        uint32_t token;
        const Il2CppImage* image;
        std::tie(token, image) = GetMetadataTokenFromReflectionType(obj);
        return (int)token;
    }

    bool Reflection::HasAttribute(Il2CppReflectionParameter *parameter, Il2CppClass* attributeClass)
    {
        Il2CppReflectionMethod* method = (Il2CppReflectionMethod*)parameter->MemberImpl;

        if (method->method->parameters == NULL)
            return false;

        IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Reflection::GetCustomAttributeTypeCacheFor, "-1 represents the return value. Need to emit custom attribute information for that.")
        if (parameter->PositionImpl == -1)
            return false;

        const MethodInfo* methodWithParameterAttributeInformation = method->method;
        if (method->method->is_inflated)
            methodWithParameterAttributeInformation = method->method->genericMethod->methodDefinition;

        auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(methodWithParameterAttributeInformation->klass->image, Method::GetParameterToken(method->method, parameter->PositionImpl));
        return HasAttribute(reader, attributeClass);
    }

    Il2CppArray* Reflection::GetCustomAttrsInfo(Il2CppObject* obj, Il2CppClass* attributeClass)
    {
        il2cpp::metadata::CustomAttributeDataReader reader = GetCustomAttrsDataReader(obj);
        return GetCustomAttrsInfo(reader, attributeClass);
    }

    Il2CppArray* Reflection::GetCustomAttrsInfo(const il2cpp::metadata::CustomAttributeDataReader& reader, Il2CppClass* attributeClass)
    {
        if (reader.GetCount() == 0)
            return NULL;

        auto filter = GetFilter(attributeClass);

        uint32_t attributeCount = reader.GetCount(filter);

        if (attributeCount == 0)
            return NULL;

        Il2CppArray* attrArray = il2cpp::vm::Array::New(il2cpp_defaults.attribute_class, attributeCount);

        il2cpp::metadata::CustomAttributeDataIterator iter = reader.GetDataIterator(filter);
        for (uint32_t i = 0; i < attributeCount; i++)
        {
            Il2CppException* exc = NULL;
            il2cpp::metadata::CustomAttributeCreator creator;
            if (reader.VisitCustomAttributeData(&iter, &creator, &exc))
            {
                il2cpp_array_setref(attrArray, i, creator.GetAttribute(&exc));
                if (exc != NULL)
                    il2cpp::vm::Exception::Raise(exc);
            }

            if (exc != NULL)
                il2cpp::vm::Exception::Raise(exc);
        }

        return attrArray;
    }

    il2cpp::metadata::CustomAttributeDataReader Reflection::GetCustomAttrsDataReader(Il2CppObject* obj)
    {
        uint32_t token;
        const Il2CppImage* image;
        std::tie(token, image) = GetMetadataTokenFromReflectionType(obj, false);
        if (token == 0)
        {
            // obj is not a reflection type, reflect on obj's class
            token = obj->klass->token;
            image = obj->klass->image;
        }

        if ((token & IL2CPP_TOKEN_PARAM_DEF) == IL2CPP_TOKEN_PARAM_DEF)
        {
            Il2CppReflectionParameter* parameter = (Il2CppReflectionParameter*)obj;
            Il2CppReflectionMethod* method = (Il2CppReflectionMethod*)parameter->MemberImpl;

            if (method->method->parameters == NULL)
                return il2cpp::metadata::CustomAttributeDataReader::Empty();
        }

        return il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(image, token);
    }

    bool Reflection::HasAttribute(Il2CppObject *obj, Il2CppClass* attributeClass)
    {
        il2cpp::metadata::CustomAttributeDataReader reader = GetCustomAttrsDataReader(obj);
        return HasAttribute(reader, attributeClass);
    }

    bool Reflection::HasAttribute(const il2cpp::metadata::CustomAttributeDataReader& reader, Il2CppClass* attributeClass)
    {
        if (reader.GetCount() == 0)
            return false;

        auto filter = GetFilter(attributeClass);
        auto ctorIter = reader.GetCtorIterator(filter);
        const MethodInfo* ctor;
        return reader.IterateAttributeCtors(&ctor, &ctorIter);
    }

    Il2CppObject* Reflection::GetCustomAttribute(Il2CppMetadataCustomAttributeHandle token, Il2CppClass* attributeClass)
    {
        auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(token);

        if (reader.GetCount() == 0)
            return NULL;

        auto filter = GetFilter(attributeClass);

        if (reader.GetCount(filter) == 0)
            return NULL;

        Il2CppObject* attr = NULL;
        il2cpp::metadata::CustomAttributeDataIterator iter = reader.GetDataIterator(filter);
        Il2CppException* exc = NULL;
        il2cpp::metadata::CustomAttributeCreator creator;
        if (reader.VisitCustomAttributeData(&iter, &creator, &exc))
        {
            if (exc == NULL)
                attr = creator.GetAttribute(&exc);
        }

        if (exc != NULL)
            il2cpp::vm::Exception::Raise(exc);

        return attr;
    }

    Il2CppArray* Reflection::ConstructCustomAttributes(Il2CppMetadataCustomAttributeHandle token)
    {
        auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(token);
        return GetCustomAttrsInfo(reader, NULL);
    }

    void Reflection::Initialize()
    {
        s_AssemblyMap = new AssemblyMap();
        s_FieldMap = new FieldMap();
        s_PropertyMap = new PropertyMap();
        s_EventMap = new EventMap();
        s_MethodMap = new MethodMap();
        s_ModuleMap = new ModuleMap();
        s_ParametersMap = new ParametersMap();
        s_TypeMap = new TypeMap();
        s_MonoGenericParamterMap = new MonoGenericParameterMap();
        s_MonoAssemblyNameMap = new MonoAssemblyNameMap();

        s_System_Reflection_Assembly = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimeAssembly");
        IL2CPP_ASSERT(s_System_Reflection_Assembly != NULL);
        s_System_Reflection_Module = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimeModule");
        IL2CPP_ASSERT(s_System_Reflection_Module != NULL);

        s_System_Reflection_ConstructorInfo = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimeConstructorInfo");
        IL2CPP_ASSERT(s_System_Reflection_ConstructorInfo != NULL);
        s_System_Reflection_MethodInfo = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimeMethodInfo");
        IL2CPP_ASSERT(s_System_Reflection_MethodInfo != NULL);
        s_System_Reflection_ParameterInfo = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimeParameterInfo");
        IL2CPP_ASSERT(s_System_Reflection_ParameterInfo != NULL);
        s_System_Reflection_ParameterInfo_array = Class::GetArrayClass(s_System_Reflection_ParameterInfo, 1);
        IL2CPP_ASSERT(s_System_Reflection_ParameterInfo_array != NULL);

        s_System_Reflection_RuntimeFieldInfoKlass = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimeFieldInfo");
        IL2CPP_ASSERT(s_System_Reflection_RuntimeFieldInfoKlass != NULL);
        s_System_Reflection_RuntimeEventInfoKlass = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimeEventInfo");
        IL2CPP_ASSERT(s_System_Reflection_RuntimeEventInfoKlass != NULL);
        s_System_Reflection_RuntimePropertyInfoKlass = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "RuntimePropertyInfo");
        IL2CPP_ASSERT(s_System_Reflection_RuntimePropertyInfoKlass != NULL);
    }

    bool Reflection::HasAttribute(FieldInfo *field, Il2CppClass *attributeClass)
    {
        auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(field->parent->image, Field::GetToken(field));
        return HasAttribute(reader, attributeClass);
    }

    bool Reflection::HasAttribute(const MethodInfo *method, Il2CppClass *attributeClass)
    {
        auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(method->klass->image, Method::GetToken(method));
        return HasAttribute(reader, attributeClass);
    }

    bool Reflection::HasAttribute(Il2CppClass *klass, Il2CppClass *attributeClass)
    {
        auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(klass->image, klass->token);
        return HasAttribute(reader, attributeClass);
    }

    bool Reflection::HasAttribute(Il2CppMetadataCustomAttributeHandle handle, Il2CppClass *attributeClass)
    {
        auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(handle);
        return HasAttribute(reader, attributeClass);
    }

    Il2CppClass* Reflection::TypeGetHandle(Il2CppReflectionType* ref)
    {
        if (!ref)
            return NULL;

        return Class::FromSystemType(ref);
    }

    const MonoGenericParameterInfo* Reflection::GetMonoGenericParameterInfo(Il2CppMetadataGenericParameterHandle param)
    {
        MonoGenericParameterMap::const_iterator it = s_MonoGenericParamterMap->find(param);
        if (it == s_MonoGenericParamterMap->end())
            return NULL;

        return it->second;
    }

    void Reflection::SetMonoGenericParameterInfo(Il2CppMetadataGenericParameterHandle param, const MonoGenericParameterInfo *monoParam)
    {
        s_MonoGenericParamterMap->insert(std::make_pair(param, monoParam));
    }

    const Il2CppMonoAssemblyName* Reflection::GetMonoAssemblyName(const Il2CppAssembly *assembly)
    {
        MonoAssemblyNameMap::const_iterator it = s_MonoAssemblyNameMap->find(assembly);
        if (it == s_MonoAssemblyNameMap->end())
            return NULL;

        return it->second;
    }

    void Reflection::SetMonoAssemblyName(const Il2CppAssembly *assembly, const Il2CppMonoAssemblyName *aname)
    {
        s_MonoAssemblyNameMap->insert(std::make_pair(assembly, aname));
    }

    void Reflection::ClearStatics()
    {
        delete s_AssemblyMap;
        s_AssemblyMap = NULL;
        delete s_FieldMap;
        s_FieldMap = NULL;
        delete s_PropertyMap;
        s_PropertyMap = NULL;
        delete s_EventMap;
        s_EventMap = NULL;
        delete s_MethodMap;
        s_MethodMap = NULL;
        delete s_ModuleMap;
        s_ModuleMap = NULL;
        delete s_ParametersMap;
        s_ParametersMap = NULL;
        delete s_TypeMap;
        s_TypeMap = NULL;
        delete s_MonoGenericParamterMap;
        s_MonoGenericParamterMap = NULL;
        delete s_MonoAssemblyNameMap;
        s_MonoAssemblyNameMap = NULL;

        s_System_Reflection_Assembly = NULL;
        s_System_Reflection_RuntimeFieldInfoKlass = NULL;
        s_System_Reflection_Module = NULL;
        s_System_Reflection_RuntimePropertyInfoKlass = NULL;
        s_System_Reflection_RuntimeEventInfoKlass = NULL;
        s_DbNullValueField = NULL;
        s_ReflectionMissingField = NULL;
        s_System_Reflection_ParameterInfo = NULL;
        s_System_Reflection_ParameterInfo_array = NULL;

        s_System_Reflection_MethodInfo = NULL;
        s_System_Reflection_ConstructorInfo = NULL;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Reflection.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Runtime.cpp---------------
.
.
#include "il2cpp-config.h"
#include "metadata/GenericMethod.h"
#include "os/CrashHelpers.h"
#include "os/Environment.h"
#include "os/File.h"
#include "os/Image.h"
#include "os/Initialize.h"
#include "os/LibraryLoader.h"
#include "os/Locale.h"
#include "os/MemoryMappedFile.h"
#include "os/Mutex.h"
#include "os/Path.h"
#include "os/SynchronizationContext.h"
#include "os/Thread.h"
#include "os/Socket.h"
#include "os/c-api/Allocator.h"
#include "metadata/GenericMetadata.h"
#include "vm/Array.h"
#include "vm/Assembly.h"
#include "vm/ClassLibraryPAL.h"
#include "vm/COMEntryPoints.h"
#include "vm/Class.h"
#include "vm/Domain.h"
#include "vm/Exception.h"
#include "vm/Field.h"
#include "gc/GCHandle.h"
#include "vm/Image.h"
#include "vm/LastError.h"
#include "vm/MetadataAlloc.h"
#include "vm/MetadataCache.h"
#include "vm/MetadataLock.h"
#include "vm/Method.h"
#include "vm/Reflection.h"
#include "vm/Runtime.h"
#include "vm/Thread.h"
#include "vm/Type.h"
#include "vm/StackTrace.h"
#include "vm/String.h"
#include "vm/Object.h"
#include "vm-utils/Debugger.h"
#include "vm-utils/DebugSymbolReader.h"
#include "vm/Profiler.h"
#include "utils/Logging.h"
#include <string>
#include <map>
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"
#include "gc/GarbageCollector.h"
#include "gc/WriteBarrier.h"
#include "vm/InternalCalls.h"
#include "utils/Collections.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "utils/PathUtils.h"
#include "utils/Runtime.h"
#include "utils/Environment.h"
#include "mono/ThreadPool/threadpool-ms.h"
#include "mono/ThreadPool/threadpool-ms-io.h"
#include "icalls/mscorlib/System.Reflection/RuntimeAssembly.h"
#include "icalls/mscorlib/System.IO/MonoIO.h"
#include "vm/Monitor.h"
#include "vm-utils/Debugger.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

Il2CppDefaults il2cpp_defaults;
bool g_il2cpp_is_fully_initialized = false;
static bool shutting_down = false;

MetadataInitializerCleanupFunc g_ClearMethodMetadataInitializedFlags = NULL;

static baselib::ReentrantLock s_InitLock;
static int32_t s_RuntimeInitCount;

typedef void (*CodegenRegistrationFunction) ();
extern CodegenRegistrationFunction g_CodegenRegistration;

namespace il2cpp
{
namespace vm
{
    baselib::ReentrantLock g_MetadataLock;

    static int32_t exitcode = 0;
    static std::string s_ConfigDir;
    static const char *s_FrameworkVersion = 0;
    static const char *s_BundledMachineConfig = 0;
    static Il2CppRuntimeUnhandledExceptionPolicy s_UnhandledExceptionPolicy = IL2CPP_UNHANDLED_POLICY_CURRENT;
    static const void* s_UnitytlsInterface = NULL;

#define DEFAULTS_INIT(field, ns, n) do { il2cpp_defaults.field = Class::FromName (il2cpp_defaults.corlib, ns, n);\
    IL2CPP_ASSERT(il2cpp_defaults.field); } while (0)

#define DEFAULTS_INIT_TYPE(field, ns, n, nativetype) do { DEFAULTS_INIT(field, ns, n); \
    IL2CPP_ASSERT(il2cpp_defaults.field->instance_size == sizeof(nativetype) + (il2cpp_defaults.field->byval_arg.valuetype ? sizeof(Il2CppObject) : 0)); } while (0)

#define DEFAULTS_INIT_OPTIONAL(field, ns, n) do { il2cpp_defaults.field = Class::FromName (il2cpp_defaults.corlib, ns, n); } while (0)

#define DEFAULTS_INIT_TYPE_OPTIONAL(field, ns, n, nativetype) do { DEFAULTS_INIT_OPTIONAL(field, ns, n); \
    if (il2cpp_defaults.field != NULL) \
        IL2CPP_ASSERT(il2cpp_defaults.field->instance_size == sizeof(nativetype) + (il2cpp_defaults.field->byval_arg.valuetype ? sizeof(Il2CppObject) : 0)); } while (0)

#define DEFAULTS_GEN_INIT(field, ns, n) do { il2cpp_defaults.field = Class::FromName (il2cpp_defaults.corlib_gen, ns, n);\
    IL2CPP_ASSERT(il2cpp_defaults.field); } while (0)

#define DEFAULTS_GEN_INIT_TYPE(field, ns, n, nativetype) do { DEFAULTS_GEN_INIT(field, ns, n); \
    IL2CPP_ASSERT(il2cpp_defaults.field->instance_size == sizeof(nativetype) + (il2cpp_defaults.field->byval_arg.valuetype ? sizeof(Il2CppObject) : 0)); } while (0)

#define DEFAULTS_GEN_INIT_OPTIONAL(field, ns, n) do { il2cpp_defaults.field = Class::FromName (il2cpp_defaults.corlib_gen, ns, n); } while (0)

    char* basepath(const char* path)
    {
        std::string original_path(path);
        size_t position_of_last_separator = original_path.find_last_of(IL2CPP_DIR_SEPARATOR);

        return il2cpp::utils::StringUtils::StringDuplicate(original_path.substr(position_of_last_separator + 1).c_str());
    }

    static const char *framework_version_for(const char *runtime_version)
    {
        IL2CPP_ASSERT(runtime_version && "Invalid runtime version");

        IL2CPP_ASSERT((strstr(runtime_version, "v4.0") == runtime_version) && "Invalid runtime version");
        return "4.0";
    }

    static void SanityChecks()
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        IL2CPP_ASSERT(ALIGN_OF(int64_t) == 8);
#endif
    }

    static inline void InitializeStringEmpty()
    {
        Class::Init(il2cpp_defaults.string_class);
        FieldInfo* stringEmptyField = Class::GetFieldFromName(il2cpp_defaults.string_class, "Empty");
        Field::StaticSetValue(stringEmptyField, String::Empty());
    }

    static void SetConfigStr(const std::string& executablePath);

    bool Runtime::Init(const char* domainName)
    {
        os::FastAutoLock lock(&s_InitLock);

        IL2CPP_ASSERT(s_RuntimeInitCount >= 0);
        if (s_RuntimeInitCount++ > 0)
            return true;

        SanityChecks();

#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::AllocateStaticData();
#endif
        il2cpp::vm::Monitor::AllocateStaticData();
        il2cpp::os::MemoryMappedFile::AllocateStaticData();
        il2cpp::icalls::mscorlib::System::IO::MonoIO::AllocateStaticData();
        il2cpp::vm::Class::AllocateStaticData();

#if IL2CPP_ENABLE_PROFILER
        // Static data for profiler is initialised here and also when profiler is installed (Profiler::Install()) since il2cpp test setup differs from Unity
        il2cpp::vm::Profiler::AllocateStaticData();
#endif

        il2cpp::icalls::mscorlib::System::Reflection::RuntimeAssembly::AllocateStaticData();

        os::Initialize();
        os::Locale::Initialize();
        MetadataAllocInitialize();

        // NOTE(gab): the runtime_version needs to change once we
        // will support multiple runtimes.
        // For now we default to the one used by unity and don't
        // allow the callers to change it.
        s_FrameworkVersion = framework_version_for("v4.0.30319");

        os::Image::Initialize();
        os::Thread::Init();

#if IL2CPP_HAS_OS_SYNCHRONIZATION_CONTEXT
        // Has to happen after Thread::Init() due to it needing a COM apartment on Windows
        il2cpp::os::SynchronizationContext::Initialize();
#endif

        // This should be filled in by generated code.
        IL2CPP_ASSERT(g_CodegenRegistration != NULL);
        g_CodegenRegistration();

        if (!MetadataCache::Initialize())
        {
            s_RuntimeInitCount--;
            return false;
        }

        Assembly::Initialize();
        gc::GarbageCollector::Initialize();

        // Thread needs GC initialized
        Thread::Initialize();

        register_allocator(il2cpp::utils::Memory::Malloc, il2cpp::utils::Memory::Free);

        memset(&il2cpp_defaults, 0, sizeof(Il2CppDefaults));

        const Il2CppAssembly* assembly = Assembly::Load("mscorlib.dll");
        const Il2CppAssembly* assembly2 = Assembly::Load("__Generated");

        // It is not possible to use DEFAULTS_INIT_TYPE for managed types for which we have a native struct, if the
        // native struct does not map the complete managed type.
        // Which is the case for: Il2CppThread, Il2CppAppDomain, Il2CppCultureInfo, Il2CppReflectionProperty,
        // Il2CppDateTimeFormatInfo, Il2CppNumberFormatInfo

        il2cpp_defaults.corlib = Assembly::GetImage(assembly);
        il2cpp_defaults.corlib_gen = Assembly::GetImage(assembly2);
        DEFAULTS_INIT(object_class, "System", "Object");
        DEFAULTS_INIT(void_class, "System", "Void");
        DEFAULTS_INIT_TYPE(boolean_class, "System", "Boolean", bool);
        DEFAULTS_INIT_TYPE(byte_class, "System", "Byte", uint8_t);
        DEFAULTS_INIT_TYPE(sbyte_class, "System", "SByte", int8_t);
        DEFAULTS_INIT_TYPE(int16_class, "System", "Int16", int16_t);
        DEFAULTS_INIT_TYPE(uint16_class, "System", "UInt16", uint16_t);
        DEFAULTS_INIT_TYPE(int32_class, "System", "Int32", int32_t);
        DEFAULTS_INIT_TYPE(uint32_class, "System", "UInt32", uint32_t);
        DEFAULTS_INIT(uint_class, "System", "UIntPtr");
        DEFAULTS_INIT_TYPE(int_class, "System", "IntPtr", intptr_t);
        DEFAULTS_INIT_TYPE(int64_class, "System", "Int64", int64_t);
        DEFAULTS_INIT_TYPE(uint64_class, "System", "UInt64", uint64_t);
        DEFAULTS_INIT_TYPE(single_class, "System", "Single", float);
        DEFAULTS_INIT_TYPE(double_class, "System", "Double", double);
        DEFAULTS_INIT_TYPE(char_class, "System", "Char", Il2CppChar);
        DEFAULTS_INIT(string_class, "System", "String");
        DEFAULTS_INIT(enum_class, "System", "Enum");
        DEFAULTS_INIT(array_class, "System", "Array");
        DEFAULTS_INIT(value_type_class, "System", "ValueType");
        DEFAULTS_INIT_TYPE(delegate_class, "System", "Delegate", Il2CppDelegate);
        DEFAULTS_INIT_TYPE(multicastdelegate_class, "System", "MulticastDelegate", Il2CppMulticastDelegate);
        DEFAULTS_INIT(asyncresult_class, "System.Runtime.Remoting.Messaging", "AsyncResult");
        DEFAULTS_INIT_TYPE(async_call_class, "System", "MonoAsyncCall", Il2CppAsyncCall);
        DEFAULTS_INIT(manualresetevent_class, "System.Threading", "ManualResetEvent");
        //DEFAULTS_INIT(typehandle_class, "System", "RuntimeTypeHandle");
        //DEFAULTS_INIT(methodhandle_class, "System", "RuntimeMethodHandle");
        //DEFAULTS_INIT(fieldhandle_class, "System", "RuntimeFieldHandle");
        DEFAULTS_INIT(systemtype_class, "System", "Type");
        DEFAULTS_INIT_TYPE(monotype_class, "System", "MonoType", Il2CppReflectionMonoType);
        //DEFAULTS_INIT(exception_class, "System", "Exception");
        //DEFAULTS_INIT(threadabortexcepXtion_class, "System.Threading", "ThreadAbortException");
        DEFAULTS_INIT_TYPE(thread_class, "System.Threading", "Thread", Il2CppThread);
        DEFAULTS_INIT_TYPE(internal_thread_class, "System.Threading", "InternalThread", Il2CppInternalThread);
        DEFAULTS_INIT_TYPE(runtimetype_class, "System", "RuntimeType", Il2CppReflectionRuntimeType);
        DEFAULTS_INIT(appdomain_class, "System", "AppDomain");
        DEFAULTS_INIT(appdomain_setup_class, "System", "AppDomainSetup");
        DEFAULTS_INIT(member_info_class, "System.Reflection", "MemberInfo");
        DEFAULTS_INIT(field_info_class, "System.Reflection", "FieldInfo");
        DEFAULTS_INIT(method_info_class, "System.Reflection", "MethodInfo");
        DEFAULTS_INIT(property_info_class, "System.Reflection", "PropertyInfo");
        DEFAULTS_INIT_TYPE(event_info_class, "System.Reflection", "EventInfo", Il2CppReflectionEvent);
        DEFAULTS_INIT_TYPE(stringbuilder_class, "System.Text", "StringBuilder", Il2CppStringBuilder);
        DEFAULTS_INIT_TYPE(stack_frame_class, "System.Diagnostics", "StackFrame", Il2CppStackFrame);
        DEFAULTS_INIT(stack_trace_class, "System.Diagnostics", "StackTrace");
        DEFAULTS_INIT_TYPE(typed_reference_class, "System", "TypedReference", Il2CppTypedRef);
        DEFAULTS_INIT(generic_ilist_class, "System.Collections.Generic", "IList`1");
        DEFAULTS_INIT(generic_icollection_class, "System.Collections.Generic", "ICollection`1");
        DEFAULTS_INIT(generic_ienumerable_class, "System.Collections.Generic", "IEnumerable`1");
        DEFAULTS_INIT(generic_ireadonlylist_class, "System.Collections.Generic", "IReadOnlyList`1");
        DEFAULTS_INIT(generic_ireadonlycollection_class, "System.Collections.Generic", "IReadOnlyCollection`1");
        DEFAULTS_INIT(generic_nullable_class, "System", "Nullable`1");
        DEFAULTS_INIT(version, "System", "Version");
        DEFAULTS_INIT(culture_info, "System.Globalization", "CultureInfo");
        DEFAULTS_INIT_TYPE(assembly_class, "System.Reflection", "RuntimeAssembly", Il2CppReflectionAssembly);
        DEFAULTS_INIT_TYPE_OPTIONAL(assembly_name_class, "System.Reflection", "AssemblyName", Il2CppReflectionAssemblyName);
        DEFAULTS_INIT_TYPE(parameter_info_class, "System.Reflection", "RuntimeParameterInfo", Il2CppReflectionParameter);
        DEFAULTS_INIT_TYPE(module_class, "System.Reflection", "RuntimeModule", Il2CppReflectionModule);
        DEFAULTS_INIT_TYPE(exception_class, "System", "Exception", Il2CppException);
        DEFAULTS_INIT_TYPE(system_exception_class, "System", "SystemException", Il2CppSystemException);
        DEFAULTS_INIT_TYPE(argument_exception_class, "System", "ArgumentException", Il2CppArgumentException);
        DEFAULTS_INIT_TYPE(marshalbyrefobject_class, "System", "MarshalByRefObject", Il2CppMarshalByRefObject);
        DEFAULTS_GEN_INIT_TYPE(il2cpp_com_object_class, "System", "__Il2CppComObject", Il2CppComObject);
        DEFAULTS_INIT_TYPE(safe_handle_class, "System.Runtime.InteropServices", "SafeHandle", Il2CppSafeHandle);
        DEFAULTS_INIT_TYPE(sort_key_class, "System.Globalization", "SortKey", Il2CppSortKey);
        DEFAULTS_INIT(dbnull_class, "System", "DBNull");
        DEFAULTS_INIT_TYPE_OPTIONAL(error_wrapper_class, "System.Runtime.InteropServices", "ErrorWrapper", Il2CppErrorWrapper);
        DEFAULTS_INIT(missing_class, "System.Reflection", "Missing");
        DEFAULTS_INIT(attribute_class, "System", "Attribute");
        DEFAULTS_INIT_OPTIONAL(customattribute_data_class, "System.Reflection", "CustomAttributeData");
        DEFAULTS_INIT_OPTIONAL(customattribute_typed_argument_class, "System.Reflection", "CustomAttributeTypedArgument");
        DEFAULTS_INIT_OPTIONAL(customattribute_named_argument_class, "System.Reflection", "CustomAttributeNamedArgument");
        DEFAULTS_INIT(key_value_pair_class, "System.Collections.Generic", "KeyValuePair`2");
        DEFAULTS_INIT(system_guid_class, "System", "Guid");

        DEFAULTS_INIT(threadpool_wait_callback_class, "System.Threading", "_ThreadPoolWaitCallback");
        DEFAULTS_INIT(mono_method_message_class, "System.Runtime.Remoting.Messaging", "MonoMethodMessage");

        il2cpp_defaults.threadpool_perform_wait_callback_method = (MethodInfo*)vm::Class::GetMethodFromName(
            il2cpp_defaults.threadpool_wait_callback_class, "PerformWaitCallback", 0);

        DEFAULTS_INIT_OPTIONAL(sbyte_shared_enum, "System", "SByteEnum");
        DEFAULTS_INIT_OPTIONAL(int16_shared_enum, "System", "Int16Enum");
        DEFAULTS_INIT_OPTIONAL(int32_shared_enum, "System", "Int32Enum");
        DEFAULTS_INIT_OPTIONAL(int64_shared_enum, "System", "Int64Enum");

        DEFAULTS_INIT_OPTIONAL(byte_shared_enum, "System", "ByteEnum");
        DEFAULTS_INIT_OPTIONAL(uint16_shared_enum, "System", "UInt16Enum");
        DEFAULTS_INIT_OPTIONAL(uint32_shared_enum, "System", "UInt32Enum");
        DEFAULTS_INIT_OPTIONAL(uint64_shared_enum, "System", "UInt64Enum");

        DEFAULTS_GEN_INIT_OPTIONAL(il2cpp_fully_shared_type, "Unity.IL2CPP.Metadata", "__Il2CppFullySharedGenericType");
        DEFAULTS_GEN_INIT_OPTIONAL(il2cpp_fully_shared_struct_type, "Unity.IL2CPP.Metadata", "__Il2CppFullySharedGenericStructType");

        ClassLibraryPAL::Initialize();

        // Reflection needs GC initialized
        Reflection::Initialize();

        Image::InitNestedTypes(il2cpp_defaults.corlib);

        const Il2CppAssembly* systemDll = Assembly::Load("System");
        if (systemDll != NULL)
            il2cpp_defaults.system_uri_class = Class::FromName(Assembly::GetImage(systemDll), "System", "Uri");

        // This will only exist if there was at least 1 winmd file present during conversion
        const Il2CppAssembly* windowsRuntimeMetadataAssembly = Assembly::Load("WindowsRuntimeMetadata");
        if (windowsRuntimeMetadataAssembly != NULL)
        {
            const Il2CppImage* windowsRuntimeMetadataImage = Assembly::GetImage(windowsRuntimeMetadataAssembly);
            il2cpp_defaults.ireference_class = Class::FromName(windowsRuntimeMetadataImage, "Windows.Foundation", "IReference`1");
            il2cpp_defaults.ireferencearray_class = Class::FromName(windowsRuntimeMetadataImage, "Windows.Foundation", "IReferenceArray`1");
            il2cpp_defaults.ikey_value_pair_class = Class::FromName(windowsRuntimeMetadataImage, "Windows.Foundation.Collections", "IKeyValuePair`2");
            il2cpp_defaults.ikey_value_pair_class = Class::FromName(windowsRuntimeMetadataImage, "Windows.Foundation.Collections", "IKeyValuePair`2");
            il2cpp_defaults.windows_foundation_uri_class = Class::FromName(windowsRuntimeMetadataImage, "Windows.Foundation", "Uri");
            il2cpp_defaults.windows_foundation_iuri_runtime_class_class = Class::FromName(windowsRuntimeMetadataImage, "Windows.Foundation", "IUriRuntimeClass");
        }

        Class::Init(il2cpp_defaults.string_class);

        os::Socket::Startup();

#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::Init();
#endif

        Il2CppDomain* domain = Domain::GetCurrent();

        Il2CppThread* mainThread = Thread::Attach(domain);
        Thread::SetMain(mainThread);

        Il2CppAppDomainSetup* setup = (Il2CppAppDomainSetup*)Object::NewPinned(il2cpp_defaults.appdomain_setup_class);

        Il2CppAppDomain* ad = (Il2CppAppDomain*)Object::NewPinned(il2cpp_defaults.appdomain_class);
        gc::WriteBarrier::GenericStore(&ad->data, domain);
        gc::WriteBarrier::GenericStore(&domain->domain, ad);
        gc::WriteBarrier::GenericStore(&domain->setup, setup);

        domain->domain_id = 1; // Only have a single domain ATM.

        domain->friendly_name = basepath(domainName);

        LastError::InitializeLastErrorThreadStatic();

        gc::GarbageCollector::InitializeFinalizer();

        MetadataCache::InitializeGCSafe();

        String::InitializeEmptyString(il2cpp_defaults.string_class);
        InitializeStringEmpty();

        g_il2cpp_is_fully_initialized = true;

        // Force binary serialization in Mono to use reflection instead of code generation.
    #undef SetEnvironmentVariable // Get rid of windows.h #define.
        os::Environment::SetEnvironmentVariable("MONO_REFLECTION_SERIALIZER", "yes");
        os::Environment::SetEnvironmentVariable("MONO_XMLSERIALIZER_THS", "no");

        Domain::ContextInit(domain);
        Domain::ContextSet(domain->default_context);

        VerifyApiVersion();

#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::Start();
#endif

        std::string executablePath = os::Path::GetExecutablePath();
        SetConfigStr(executablePath);

        if (utils::Environment::GetNumMainArgs() == 0)
        {
            // If main args were never set, we default to 1 arg that is the executable path
            const char* mainArgs[] = { executablePath.c_str() };
            utils::Environment::SetMainArgs(mainArgs, 1);
        }

        vm::MetadataCache::ExecuteEagerStaticClassConstructors();
        vm::MetadataCache::ExecuteModuleInitializers();

#if !IL2CPP_MONO_DEBUGGER
        il2cpp::utils::DebugSymbolReader::LoadDebugSymbols();
#endif

        return true;
    }

    static Il2CppObject* GetEventArgsEmptyField()
    {
        Il2CppClass* eventArgsKlass = Class::FromName(il2cpp_defaults.corlib, "System", "EventArgs");
        if (eventArgsKlass != NULL)
        {
            Class::Init(eventArgsKlass);
            FieldInfo* emptyField = vm::Class::GetFieldFromName(eventArgsKlass, "Empty");
            if (emptyField != NULL)
            {
                Il2CppObject* emptyValue;
                vm::Field::StaticGetValue(emptyField, &emptyValue);

                return emptyValue;
            }
        }

        return NULL;
    }

    static void FireProcessExitEvent()
    {
        FieldInfo* processExitField = vm::Class::GetFieldFromName(il2cpp_defaults.appdomain_class, "ProcessExit");
        if (processExitField != NULL) // The field might have been stripped, just ignore it.
        {
            Il2CppAppDomain* appDomain = vm::Domain::GetCurrent()->domain;
            Il2CppDelegate* processExitDelegate;
            vm::Field::GetValue((Il2CppObject*)appDomain, processExitField, &processExitDelegate);
            if (processExitDelegate == NULL) // Don't call the delegate if no one is listening to it.
                return;

            void* args[2];
            args[0] = appDomain;
            args[1] = GetEventArgsEmptyField();
            Il2CppException* unusedException;
            Runtime::DelegateInvoke(processExitDelegate, args, &unusedException);
        }
    }

    void Runtime::Shutdown()
    {
        os::FastAutoLock lock(&s_InitLock);

        IL2CPP_ASSERT(s_RuntimeInitCount > 0);
        if (--s_RuntimeInitCount > 0)
            return;

        FireProcessExitEvent();

        shutting_down = true;

#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::RuntimeShutdownEnd();
#endif

        il2cpp::icalls::mscorlib::System::Reflection::RuntimeAssembly::FreeStaticData();

#if IL2CPP_SUPPORT_THREADS
        threadpool_ms_cleanup();
#endif
        // Tries to abort all threads
        // Threads at alertable waits may not have existing when this return
        Thread::AbortAllThreads();

#if IL2CPP_ENABLE_PROFILER
        il2cpp::vm::Profiler::Shutdown();
#endif

        os::Socket::Cleanup();
        String::CleanupEmptyString();

        il2cpp::gc::GarbageCollector::UninitializeFinalizers();

        // after the gc cleanup so the finalizer thread can unregister itself
        Thread::Uninitialize();

#if IL2CPP_HAS_OS_SYNCHRONIZATION_CONTEXT
        // Has to happen before os::Thread::Shutdown() due to it needing a COM apartment on Windows
        il2cpp::os::SynchronizationContext::Shutdown();
#endif

        os::Thread::Shutdown();

#if IL2CPP_ENABLE_RELOAD
        MetadataCache::Clear();
#endif

        // We need to do this before UninitializeGC because it uses (fixed) GC memory
        Reflection::ClearStatics();

        // We need to do this after thread shut down because it is freeing GC fixed memory
        il2cpp::gc::GarbageCollector::UninitializeGC();

        // This needs to happen after no managed code can run anymore, including GC finalizers
        os::LibraryLoader::CleanupLoadedLibraries();

        vm::Image::ClearCachedResourceData();
        MetadataAllocCleanup();

        vm::COMEntryPoints::FreeCachedData();

        os::Locale::UnInitialize();
        os::Uninitialize();


#if IL2CPP_ENABLE_PROFILER
        il2cpp::vm::Profiler::FreeStaticData();
#endif

        il2cpp::vm::Monitor::FreeStaticData();
        il2cpp::os::MemoryMappedFile::FreeStaticData();
        il2cpp::icalls::mscorlib::System::IO::MonoIO::FreeStaticData();
        il2cpp::vm::Class::FreeStaticData();
#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::FreeStaticData();
#endif

#if IL2CPP_ENABLE_RELOAD
        if (g_ClearMethodMetadataInitializedFlags != NULL)
            g_ClearMethodMetadataInitializedFlags();
#endif
    }

    bool Runtime::IsShuttingDown()
    {
        return shutting_down;
    }

    void Runtime::SetConfigDir(const char *path)
    {
        s_ConfigDir = path;
    }

    static void SetConfigStr(const std::string& executablePath)
    {
        Il2CppDomain* domain = vm::Domain::GetCurrent();
        std::string configFileName = utils::PathUtils::Basename(executablePath);
        configFileName.append(".config");
        std::string appBase = utils::PathUtils::DirectoryName(executablePath);
        IL2CPP_OBJECT_SETREF(domain->setup, application_base, vm::String::New(appBase.c_str()));
        IL2CPP_OBJECT_SETREF(domain->setup, configuration_file, vm::String::New(configFileName.c_str()));
    }

    void Runtime::SetConfigUtf16(const Il2CppChar* executablePath)
    {
        IL2CPP_ASSERT(executablePath);

        std::string exePathUtf8 = il2cpp::utils::StringUtils::Utf16ToUtf8(executablePath);
        SetConfigStr(exePathUtf8);
    }

    void Runtime::SetConfig(const char* executablePath)
    {
        IL2CPP_ASSERT(executablePath);
        std::string executablePathStr(executablePath);
        SetConfigStr(executablePathStr);
    }

    void Runtime::SetUnityTlsInterface(const void* unitytlsInterface)
    {
        s_UnitytlsInterface = unitytlsInterface;
    }

    const char *Runtime::GetFrameworkVersion()
    {
        return s_FrameworkVersion;
    }

    std::string Runtime::GetConfigDir()
    {
        if (s_ConfigDir.size() > 0)
            return s_ConfigDir;

        return utils::PathUtils::Combine(utils::Runtime::GetDataDir(), utils::StringView<char>("etc"));
    }

    const void* Runtime::GetUnityTlsInterface()
    {
        return s_UnitytlsInterface;
    }

    const MethodInfo* Runtime::GetDelegateInvoke(Il2CppClass* klass)
    {
        const MethodInfo* invoke = Class::GetMethodFromName(klass, "Invoke", -1);
        IL2CPP_ASSERT(invoke);
        return invoke;
    }

    Il2CppObject* Runtime::DelegateInvoke(Il2CppDelegate *delegate, void **params, Il2CppException **exc)
    {
        const MethodInfo* invoke = GetDelegateInvoke(delegate->object.klass);
        return Invoke(invoke, delegate, params, exc);
    }

    Il2CppObject* Runtime::Invoke(const MethodInfo *method, void *obj, void **params, Il2CppException **exc)
    {
        if (exc)
            il2cpp::gc::WriteBarrier::GenericStoreNull(exc);

        // we wrap invoker call in try/catch here, rather than emitting a try/catch
        // in every invoke call as that blows up the code size.
        try
        {
            if ((method->flags & METHOD_ATTRIBUTE_STATIC) && method->klass && !method->klass->cctor_finished_or_no_cctor)
                ClassInit(method->klass);

            return InvokeWithThrow(method, obj, params);
        }
        catch (Il2CppExceptionWrapper& ex)
        {
            if (exc)
                il2cpp::gc::WriteBarrier::GenericStore(exc, ex.ex);
            return NULL;
        }
    }

    Il2CppObject* Runtime::InvokeWithThrow(const MethodInfo *method, void *obj, void **params)
    {
        if (method->return_type->type == IL2CPP_TYPE_VOID)
        {
            method->invoker_method(method->methodPointer, method, obj, params, NULL);
            return NULL;
        }
        else
        {
            if (method->return_type->valuetype)
            {
                Il2CppClass* returnType = Class::FromIl2CppType(method->return_type);
                Class::Init(returnType);
                void* returnValue = alloca(returnType->instance_size - sizeof(Il2CppObject));
                method->invoker_method(method->methodPointer, method, obj, params, returnValue);
                return Object::Box(returnType, returnValue);
            }
            else
            {
                // Note that here method->return_type might be a reference type or it might be
                // a value type returned by reference.
                void* returnValue = NULL;
                method->invoker_method(method->methodPointer, method, obj, params, &returnValue);
                if (method->return_type->byref)
                {
                    // We cannot use method->return_type->valuetype here, because that will be
                    // false for methods that return by reference. Instead, get the class for the
                    // type, which discards the byref flag.
                    Il2CppClass* returnType = Class::FromIl2CppType(method->return_type);
                    if (vm::Class::IsValuetype(returnType))
                        return Object::Box(returnType, returnValue);
                    return *(Il2CppObject**)returnValue;
                }

                return (Il2CppObject*)returnValue;
            }
        }
    }

    Il2CppObject* Runtime::InvokeArray(const MethodInfo *method, void *obj, Il2CppArray *params, Il2CppException **exc)
    {
        if (params == NULL)
            return InvokeConvertArgs(method, obj, NULL, 0, exc);

        // TO DO: when changing GC to one that moves managed objects around, mark params array local variable as pinned!
        return InvokeConvertArgs(method, obj, reinterpret_cast<Il2CppObject**>(Array::GetFirstElementAddress(params)), Array::GetLength(params), exc);
    }

    void Runtime::ObjectInit(Il2CppObject *object)
    {
        ObjectInitException(object, NULL);
    }

    void Runtime::ObjectInitException(Il2CppObject *object, Il2CppException **exc)
    {
        const MethodInfo *method = NULL;
        Il2CppClass *klass = object->klass;

        method = Class::GetMethodFromName(klass, ".ctor", 0);
        IL2CPP_ASSERT(method != NULL && "ObjectInit; no default constructor for object is found");

        if (method->klass->byval_arg.valuetype)
            object = (Il2CppObject*)Object::Unbox(object);
        Invoke(method, object, NULL, exc);
    }

    void Runtime::SetUnhandledExceptionPolicy(Il2CppRuntimeUnhandledExceptionPolicy value)
    {
        s_UnhandledExceptionPolicy = value;
    }

    Il2CppRuntimeUnhandledExceptionPolicy Runtime::GetUnhandledExceptionPolicy()
    {
        return s_UnhandledExceptionPolicy;
    }

    void Runtime::UnhandledException(Il2CppException* exc)
    {
        Il2CppDomain *currentDomain = Domain::GetCurrent();
        Il2CppDomain *rootDomain = Domain::GetRoot();
        FieldInfo *field;
        Il2CppObject *current_appdomain_delegate = NULL;
        Il2CppObject *root_appdomain_delegate = NULL;

        field = Class::GetFieldFromName(il2cpp_defaults.appdomain_class, "UnhandledException");
        IL2CPP_ASSERT(field);

        Il2CppObject* excObject = (Il2CppObject*)exc;

        if (excObject->klass != il2cpp_defaults.threadabortexception_class)
        {
            //bool abort_process = (Thread::Current () == Thread::Main ()) ||
            //  (Runtime::GetUnhandledExceptionPolicy () == IL2CPP_UNHANDLED_POLICY_CURRENT);

            Field::GetValue((Il2CppObject*)rootDomain->domain, field, &root_appdomain_delegate);

            IL2CPP_NOT_IMPLEMENTED_NO_ASSERT(Runtime::UnhandledException, "We don't have runtime version info yet");
            //if (currentDomain != rootDomain && (mono_framework_version () >= 2)) {
            //  Field::GetValue ((Il2CppObject*)currentDomain->domain, field, &current_appdomain_delegate);
            //}
            //else
            //{
            //  current_appdomain_delegate = NULL;
            //}

            ///* set exitcode only if we will abort the process */
            //if (abort_process)
            //  mono_environment_exitcode_set (1);
            //if ((current_appdomain_delegate == NULL) && (root_appdomain_delegate == NULL)
            //{
            //  mono_print_unhandled_exception (exc);
            //}
            //else
            {
                if (root_appdomain_delegate)
                {
                    CallUnhandledExceptionDelegate(rootDomain, (Il2CppDelegate*)root_appdomain_delegate, exc);
                }
                if (current_appdomain_delegate)
                {
                    CallUnhandledExceptionDelegate(currentDomain, (Il2CppDelegate*)current_appdomain_delegate, exc);
                }
            }
        }
    }

    static inline Il2CppObject* InvokeConvertThis(const MethodInfo* method, void* thisArg, void** convertedParameters, Il2CppException** exception)
    {
        Il2CppClass* thisType = method->klass;

        // If it's not a constructor, just invoke directly
        if (strcmp(method->name, ".ctor") != 0 || method->klass == il2cpp_defaults.string_class)
        {
            void* obj = thisArg;
            if (Class::IsNullable(method->klass))
            {
                Il2CppObject* nullable;

                /* Convert the unboxed vtype into a Nullable structure */
                nullable = Object::New(method->klass);

                Il2CppObject* boxed = Object::Box(method->klass->castClass, obj);
                Object::NullableInit((uint8_t*)Object::Unbox(nullable), boxed, method->klass);
                obj = Object::Unbox(nullable);
            }

            return Runtime::Invoke(method, obj, convertedParameters, exception);
        }

        // If it is a construction, we need to construct a return value and allocate object if needed
        Il2CppObject* instance;

        if (thisArg == NULL)
        {
            if (Class::IsNullable(thisType))
            {
                // in the case of a Nullable constructor we can just return a boxed value type
                IL2CPP_ASSERT(convertedParameters);
                instance = Object::Box(thisType->castClass, convertedParameters[0]);
            }
            else
            {
                thisArg = instance = Object::New(thisType);
                Runtime::Invoke(method, thisType->byval_arg.valuetype ? Object::Unbox((Il2CppObject*)thisArg) : thisArg, convertedParameters, exception);
            }
        }
        else
        {
            // thisArg is pointer to data in case of a value type
            // We need to invoke the constructor first, passing point to the value
            // Since the constructor may modify the value, we need to box the result
            // AFTER the constructor was invoked
            Runtime::Invoke(method, thisArg, convertedParameters, exception);
            instance = Object::Box(thisType, thisArg);
        }

        return instance;
    }

    Il2CppObject* Runtime::InvokeConvertArgs(const MethodInfo *method, void* thisArg, Il2CppObject** parameters, int paramCount, Il2CppException** exception)
    {
        void** convertedParameters = NULL;
        bool hasByRefNullables = false;

        // Convert parameters if they are not null
        if (parameters != NULL)
        {
            convertedParameters = (void**)alloca(sizeof(void*) * paramCount);

            for (int i = 0; i < paramCount; i++)
            {
                bool passedByReference = method->parameters[i]->byref;
                Il2CppClass* parameterType = Class::FromIl2CppType(method->parameters[i]);
                Class::Init(parameterType);

                if (Class::IsValuetype(parameterType))
                {
                    if (Class::IsNullable(parameterType))
                    {
                        // Since we don't really store boxed nullables, we need to create a new one.
                        void* nullableStorage = alloca(parameterType->instance_size - sizeof(Il2CppObject));
                        Object::UnboxNullable(parameters[i], parameterType, nullableStorage);
                        convertedParameters[i] = nullableStorage;
                        hasByRefNullables |= passedByReference;
                    }
                    else if (passedByReference)
                    {
                        // If value type is passed by reference, just pass pointer to value directly
                        // If null was passed in, create a new boxed value type in its place
                        if (parameters[i] == NULL)
                            gc::WriteBarrier::GenericStore(parameters + i, Object::New(parameterType));

                        convertedParameters[i] = Object::Unbox(parameters[i]);
                    }
                    else if (parameters[i] == NULL) // If value type is passed by value, we need to pass pointer to its value
                    {
                        // If null was passed in, allocate a new value with default value
                        uint32_t valueSize = parameterType->instance_size - sizeof(Il2CppObject);
                        convertedParameters[i] = alloca(valueSize);
                        memset(convertedParameters[i], 0, valueSize);
                    }
                    else
                    {
                        // Otherwise, pass the original
                        convertedParameters[i] = Object::Unbox(parameters[i]);
                    }
                }
                else if (passedByReference)
                {
                    convertedParameters[i] = &parameters[i]; // Reference type passed by reference
                }
                else if (parameterType->byval_arg.type == IL2CPP_TYPE_PTR)
                {
                    if (parameters[i] != NULL)
                    {
                        IL2CPP_ASSERT(parameters[i]->klass == il2cpp_defaults.int_class);
                        convertedParameters[i] = reinterpret_cast<void*>(*static_cast<intptr_t*>(Object::Unbox(parameters[i])));
                    }
                    else
                    {
                        convertedParameters[i] = NULL;
                    }
                }
                else
                {
                    convertedParameters[i] = parameters[i]; // Reference type passed by value
                }
            }
        }

        Il2CppObject* result = InvokeConvertThis(method, thisArg, convertedParameters, exception);

        if (hasByRefNullables)
        {
            // We need to copy by reference nullables back to original argument array
            for (int i = 0; i < paramCount; i++)
            {
                if (!method->parameters[i]->byref)
                    continue;

                Il2CppClass* parameterType = Class::FromIl2CppType(method->parameters[i]);

                if (Class::IsNullable(parameterType))
                    gc::WriteBarrier::GenericStore(parameters + i, Object::Box(parameterType, convertedParameters[i]));
            }
        }

        if (method->return_type->type == IL2CPP_TYPE_PTR)
        {
            static Il2CppClass* pointerClass = Class::FromName(il2cpp_defaults.corlib, "System.Reflection", "Pointer");
            Il2CppReflectionPointer* pointer = reinterpret_cast<Il2CppReflectionPointer*>(Object::New(pointerClass));
            pointer->data = result;
            IL2CPP_OBJECT_SETREF(pointer, type, Reflection::GetTypeObject(method->return_type));
            result = reinterpret_cast<Il2CppObject*>(pointer);
        }

        return result;
    }

    void Runtime::CallUnhandledExceptionDelegate(Il2CppDomain* domain, Il2CppDelegate* delegate, Il2CppException* exc)
    {
        Il2CppException *e = NULL;
        void* pa[2];

        pa[0] = domain->domain;
        pa[1] = CreateUnhandledExceptionEventArgs(exc);
        DelegateInvoke(delegate, pa, &e);

        // A managed exception occurred during the unhandled exception handler.
        // We can't do much else here other than try to abort the process.
        if (e != NULL)
            utils::Runtime::Abort();
    }

    static baselib::ReentrantLock s_TypeInitializationLock;

// We currently call Runtime::ClassInit in 4 places:
// 1. Just after we allocate storage for a new object (Object::NewAllocSpecific)
// 2. Just before reading any static field
// 3. Just before calling any static method
// 4. Just before calling class instance constructor from a derived class instance constructor
    void Runtime::ClassInit(Il2CppClass *klass)
    {
        // Nothing to do if class has no static constructor or already ran.
        if (klass->cctor_finished_or_no_cctor)
            return;

        s_TypeInitializationLock.Acquire();

        // See if some thread ran it while we acquired the lock.
        if (os::Atomic::CompareExchange(&klass->cctor_finished_or_no_cctor, 1, 1) == 1)
        {
            s_TypeInitializationLock.Release();
            return;
        }

        // See if some other thread got there first and already started running the constructor.
        if (os::Atomic::CompareExchange(&klass->cctor_started, 1, 1) == 1)
        {
            s_TypeInitializationLock.Release();

            // May have been us and we got here through recursion.
            os::Thread::ThreadId currentThread = os::Thread::CurrentThreadId();
            if (os::Atomic::CompareExchangePointer((size_t**)&klass->cctor_thread, (size_t*)currentThread, (size_t*)currentThread) == (size_t*)currentThread)
                return;

            // Wait for other thread to finish executing the constructor.
            while (os::Atomic::CompareExchange(&klass->cctor_finished_or_no_cctor, 1, 1) != 1 && os::Atomic::CompareExchangePointer((void**)&klass->initializationExceptionGCHandle, (void*)0, (void*)0) == 0)
            {
                os::Thread::Sleep(1);
            }
        }
        else
        {
            // Let others know we have started executing the constructor.
            os::Atomic::ExchangePointer((size_t**)&klass->cctor_thread, (size_t*)os::Thread::CurrentThreadId());
            os::Atomic::Exchange(&klass->cctor_started, 1);

            s_TypeInitializationLock.Release();

            // Run it.
            Il2CppException* exception = NULL;
            const MethodInfo* cctor = Class::GetCCtor(klass);
            if (cctor != NULL)
            {
                vm::Runtime::Invoke(cctor, NULL, NULL, &exception);
            }

            os::Atomic::ExchangePointer((size_t**)&klass->cctor_thread, (size_t*)0);

            // Deal with exceptions.
            if (exception == NULL)
            {
                // Let other threads know we finished.
                os::Atomic::Exchange(&klass->cctor_finished_or_no_cctor, 1);
            }
            else
            {
                const Il2CppType *type = Class::GetType(klass);
                std::string n = il2cpp::utils::StringUtils::Printf("The type initializer for '%s' threw an exception.", Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_IL).c_str());
                Class::SetClassInitializationError(klass, Exception::GetTypeInitializationException(n.c_str(), exception));
            }
        }

        if (klass->initializationExceptionGCHandle)
        {
            il2cpp::vm::Exception::Raise((Il2CppException*)gc::GCHandle::GetTarget(klass->initializationExceptionGCHandle));
        }
    }

    struct ConstCharCompare
    {
        bool operator()(char const *a, char const *b) const
        {
            return strcmp(a, b) < 0;
        }
    };

    Il2CppObject* Runtime::CreateUnhandledExceptionEventArgs(Il2CppException *exc)
    {
        Il2CppClass *klass;
        void* args[2];
        const MethodInfo *method = NULL;
        bool is_terminating = true;
        Il2CppObject *obj;

        klass = Class::FromName(il2cpp_defaults.corlib, "System", "UnhandledExceptionEventArgs");
        IL2CPP_ASSERT(klass);

        Class::Init(klass);

        /* UnhandledExceptionEventArgs only has 1 public ctor with 2 args */
        method = Class::GetMethodFromNameFlags(klass, ".ctor", 2, METHOD_ATTRIBUTE_PUBLIC);
        IL2CPP_ASSERT(method);

        args[0] = exc;
        args[1] = &is_terminating;

        obj = Object::New(klass);
        Runtime::Invoke(method, obj, args, NULL);

        return obj;
    }

    const char *Runtime::GetBundledMachineConfig()
    {
        return s_BundledMachineConfig;
    }

    void Runtime::RegisterBundledMachineConfig(const char *config_xml)
    {
        s_BundledMachineConfig = config_xml;
    }

    void Runtime::VerifyApiVersion()
    {
#if IL2CPP_DEBUG
        Il2CppClass *klass = Class::FromName(il2cpp_defaults.corlib, "System", "Environment");
        Class::Init(klass);
        FieldInfo *field = Class::GetFieldFromName(klass, "mono_corlib_version");
        Il2CppString* value;
        Field::StaticGetValue(field, &value);

        std::string version = il2cpp::utils::StringUtils::Utf16ToUtf8(value->chars);
        IL2CPP_ASSERT(version == "1A5E0066-58DC-428A-B21C-0AD6CDAE2789");
#endif
    }

    int32_t Runtime::GetExitCode()
    {
        return exitcode;
    }

    void Runtime::SetExitCode(int32_t value)
    {
        exitcode = value;
    }

    static void MissingMethodInvoker(Il2CppMethodPointer ptr, const MethodInfo* method, void* obj, void** args, void* ret)
    {
        Runtime::RaiseExecutionEngineException(method, false);
    }

    InvokerMethod Runtime::GetMissingMethodInvoker()
    {
        return MissingMethodInvoker;
    }

    static int32_t IndexFromIndicesArgs(Il2CppArray* array, void** args)
    {
        int32_t rank = array->klass->rank;
        int32_t* indices = (int32_t*)alloca(sizeof(int32_t) * rank);
        for (auto i = 0; i < rank; ++i)
            indices[i] = *(int32_t*)args[i];
        return ARRAY_LENGTH_AS_INT32(vm::Array::IndexFromIndices(array, indices));
    }

    static void SetInvokerMethod(Il2CppMethodPointer methodPtr, const MethodInfo* method, void* obj, void** args, void* returnAddress)
    {
        int32_t rank = method->klass->rank;
        // Arrays are limited to 32 dimensions. Given this limit, we can use a stack allocated array to store the indices.
        // https://learn.microsoft.com/en-us/dotnet/api/system.array
        IL2CPP_ASSERT(rank <= 32);
        IL2CPP_ASSERT(method->parameters_count == (rank + 1));

        int32_t index = IndexFromIndicesArgs((Il2CppArray*)obj, args);
        Il2CppClass* elementClass = method->klass->element_class;
        void* value = args[rank];
        if (Class::IsValuetype(elementClass))
        {
            // In the case of Nullable<T>, the 'value' is the Nullable<T> instance not T.
            // This allows us to treat Nullable<T> as a normal value type for the purposes
            // of array element setting.
            int elementSize = vm::Class::GetArrayElementSize(elementClass);
            il2cpp_array_setrefwithsize((Il2CppArray*)obj, elementSize, index, value);
        }
        else
        {
            il2cpp_array_setref((Il2CppArray*)obj, index, value);
        }
    }

    InvokerMethod Runtime::GetArraySetInvoker()
    {
        return &SetInvokerMethod;
    }

    static void ArrayGetInvoker(Il2CppMethodPointer methodPtr, const MethodInfo* method, void* obj, void** args, void* returnAddress)
    {
        int32_t rank = method->klass->rank;
        // Arrays are limited to 32 dimensions. Given this limit, we can use a stack allocated array to store the indices.
        // https://learn.microsoft.com/en-us/dotnet/api/system.array
        IL2CPP_ASSERT(rank <= 32);
        IL2CPP_ASSERT(method->parameters_count == rank);


        int32_t index = IndexFromIndicesArgs((Il2CppArray*)obj, args);
        Il2CppClass* elementClass = method->klass->element_class;
        void* addr = il2cpp_array_addr_with_size((Il2CppArray*)obj, vm::Class::GetArrayElementSize(elementClass), index);
        if (Class::IsValuetype(elementClass))
        {
            // In the case of Nullable<T>, the 'value' is the Nullable<T> instance not T.
            // This allows us to treat Nullable<T> as a normal value type for the purposes
            // of array element setting.
            int elementSize = vm::Class::GetArrayElementSize(elementClass);
            memcpy(returnAddress, addr, elementSize);
            gc::GarbageCollector::SetWriteBarrier((void**)returnAddress, elementSize);
        }
        else
        {
            gc::WriteBarrier::GenericStore((void**)returnAddress, *(void**)addr);
        }
    }

    InvokerMethod Runtime::GetArrayGetInvoker()
    {
        return &ArrayGetInvoker;
    }

    void Runtime::AlwaysRaiseExecutionEngineException(const MethodInfo* method)
    {
        RaiseExecutionEngineException(method, false);
    }

    void Runtime::AlwaysRaiseExecutionEngineExceptionOnVirtualCall(const MethodInfo* method)
    {
        RaiseExecutionEngineException(method, true);
    }

    void Runtime::RaiseExecutionEngineException(const MethodInfo* method, bool virtualCall)
    {
        if (Method::GetClass(method))
            RaiseExecutionEngineException(method, Method::GetFullName(method).c_str(), virtualCall);
        else
            RaiseExecutionEngineException(method, Method::GetNameWithGenericTypes(method).c_str(), virtualCall);
    }

    void Runtime::RaiseAmbiguousImplementationException(const MethodInfo* method)
    {
        if (method != NULL && !Method::IsAmbiguousMethodInfo(method))
            Exception::Raise(Exception::GetAmbiguousImplementationException(utils::StringUtils::Printf("Attempting to call default interface method for '%s' with ambiguous implementations", Method::GetFullName(method).c_str()).c_str()));
        else
            Exception::Raise(Exception::GetAmbiguousImplementationException("Attempting to call default interface method with ambiguous implementations"));
    }

    void Runtime::RaiseExecutionEngineException(const MethodInfo* method, const char* methodFullName, bool virtualCall)
    {
        if (method->flags & METHOD_ATTRIBUTE_ABSTRACT)
        {
            // Default Interface Method support will throw EntryPointNotFoundExceptions if an abstract interface method is accessed
            Exception::Raise(Exception::GetEntryPointNotFoundException(utils::StringUtils::Printf("Attempting to call abstract method '%s'", methodFullName).c_str()));
        }
        else if (method->methodPointer)
        {
            if (method->is_unmanaged_callers_only)
                Exception::Raise(Exception::GetExecutionEngineException(utils::StringUtils::Printf("Cannot call a method marked with [UnmangedCallersOnly] from managed code: '%s'", methodFullName).c_str()));
            else
                Exception::Raise(Exception::GetExecutionEngineException(utils::StringUtils::Printf("Invalid call to method '%s'", methodFullName).c_str()));
        }
        else
        {
            std::string help = "";
            if (virtualCall && (method->flags & METHOD_ATTRIBUTE_VIRTUAL) && method->is_inflated)
                help = utils::StringUtils::Printf("  Consider increasing the --generic-virtual-method-iterations=%d argument", metadata::GenericMetadata::GetGenericVirtualIterations());
            Exception::Raise(Exception::GetExecutionEngineException(utils::StringUtils::Printf("Attempting to call method '%s' for which no ahead of time (AOT) code was generated.%s", methodFullName, help.c_str()).c_str()));
        }
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Runtime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ScopedThreadAttacher.cpp---------------
.
.
#include "il2cpp-config.h"
#include "vm/Thread.h"
#include "vm/Domain.h"
#include "vm/Runtime.h"
#include "ScopedThreadAttacher.h"

il2cpp::vm::ScopedThreadAttacher::ScopedThreadAttacher()
    : m_AttachedThread(NULL)
{
    if (il2cpp::vm::Thread::Current() == NULL)
        m_AttachedThread = il2cpp::vm::Thread::Attach(il2cpp::vm::Domain::GetRoot());
}

il2cpp::vm::ScopedThreadAttacher::~ScopedThreadAttacher()
{
    if (m_AttachedThread != NULL)
        il2cpp::vm::Thread::Detach(m_AttachedThread);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ScopedThreadAttacher.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\StackTrace.cpp---------------
.
.
#include "il2cpp-config.h"
#include "StackTrace.h"
#include "il2cpp-object-internals.h"
#include "os/Event.h"
#include "os/StackTrace.h"
#include "os/Thread.h"
#include "os/ThreadLocalValue.h"
#include "os/Image.h"
#include "vm/Method.h"
#include "vm/Thread.h"
#include "vm/Type.h"
#include "vm-utils/Debugger.h"
#include "vm-utils/NativeSymbol.h"
#include "vm-utils/DebugSymbolReader.h"
#include "vm-utils/Debugger.h"

#include <map>
#include <cstdio>

namespace il2cpp
{
namespace vm
{
#if IL2CPP_ENABLE_STACKTRACES

    class CachedInfo
    {
        int32_t m_depth;
        const void* m_stackPointer;
    public:
        CachedInfo() : m_depth(INT_MAX), m_stackPointer(NULL) {}
        void Update(int32_t depth, const void *stackPointer)
        {
            m_depth = depth;
            m_stackPointer = stackPointer;
        }

        bool CheckCondition(int32_t depth, const void *stackPointer) const
        {
            // We can use cached value if stack pointer is the same and not NULL, and 'depth' has been incremented since previous call
            return m_stackPointer != NULL && stackPointer == m_stackPointer && depth - 1 == m_depth;
        }
    };

    class MethodStack
    {
    protected:
        os::ThreadLocalValue s_StackFrames;
        os::ThreadLocalValue s_StoredCachedInfo;

        inline StackFrames* GetStackFramesRaw()
        {
            StackFrames* stackFrames = NULL;

            os::ErrorCode result = s_StackFrames.GetValue(reinterpret_cast<void**>(&stackFrames));
            Assert(result == os::kErrorCodeSuccess);

            return stackFrames;
        }

        inline CachedInfo* GetStoredCachedInfoRaw()
        {
            CachedInfo* storedCachedInfo = NULL;

            os::ErrorCode result = s_StoredCachedInfo.GetValue(reinterpret_cast<void**>(&storedCachedInfo));
            Assert(result == os::kErrorCodeSuccess);

            return storedCachedInfo;
        }

    public:
        inline void InitializeForCurrentThread()
        {
            if (GetStackFramesRaw() != NULL)
                return;

            StackFrames* stackFrames = new StackFrames();
            stackFrames->reserve(64);

            os::ErrorCode result = s_StackFrames.SetValue(stackFrames);
            Assert(result == os::kErrorCodeSuccess);

            CachedInfo* cachedInfo = new CachedInfo();
            result = s_StoredCachedInfo.SetValue(cachedInfo);
            Assert(result == os::kErrorCodeSuccess);
        }

        inline void CleanupForCurrentThread()
        {
            StackFrames* frames = GetStackFramesRaw();

            if (frames == NULL)
                return;

            delete frames;

            CachedInfo* cachedInfo = GetStoredCachedInfoRaw();

            if (cachedInfo == NULL)
                return;

            delete cachedInfo;

            os::ErrorCode result = s_StackFrames.SetValue(NULL);
            Assert(result == os::kErrorCodeSuccess);
            result = s_StoredCachedInfo.SetValue(NULL);
            Assert(result == os::kErrorCodeSuccess);
        }
    };

#if IL2CPP_ENABLE_STACKTRACE_SENTRIES

    class StacktraceSentryMethodStack : public MethodStack
    {
    public:
        inline const StackFrames* GetStackFrames()
        {
            return GetStackFramesRaw();
        }

        inline const StackFrames* GetCachedStackFrames(int32_t depth, const void* stackPointer)
        {
            return GetStackFrames();
        }

        inline bool GetStackFrameAt(int32_t depth, Il2CppStackFrameInfo& frame)
        {
            const StackFrames& frames = *GetStackFramesRaw();

            if (static_cast<int>(frames.size()) + depth < 1)
                return false;

            frame = frames[frames.size() - 1 + depth];
            return true;
        }

        inline void PushFrame(Il2CppStackFrameInfo& frame)
        {
            GetStackFramesRaw()->push_back(frame);
        }

        inline void PopFrame()
        {
            StackFrames* stackFrames = GetStackFramesRaw();
            stackFrames->pop_back();
        }

        inline const void* GetStackPointer()
        {
            return nullptr;
        }
    };

#endif // IL2CPP_ENABLE_STACKTRACE_SENTRIES

#if IL2CPP_ENABLE_NATIVE_STACKTRACES

#if IL2CPP_MONO_DEBUGGER
    class DebuggerMethodStack : public MethodStack
    {
    public:
        inline const StackFrames* GetStackFrames()
        {
            StackFrames* stackFrames = GetStackFramesRaw();
            if (stackFrames == NULL)
                return stackFrames;
            stackFrames->clear();

            utils::Debugger::GetStackFrames(stackFrames);

            return stackFrames;
        }

        inline const StackFrames* GetCachedStackFrames(int32_t depth, const void* stackPointer)
        {
            CachedInfo* cachedInfo = GetStoredCachedInfoRaw();
            const StackFrames* stackFrames = cachedInfo->CheckCondition(depth, stackPointer) ? GetStackFramesRaw() : GetStackFrames();
            cachedInfo->Update(depth, stackPointer);
            return stackFrames;
        }

        inline bool GetStackFrameAt(int32_t depth, Il2CppStackFrameInfo& frame)
        {
            const StackFrames& frames = *GetStackFrames();

            if (static_cast<int>(frames.size()) + depth < 1)
                return false;

            frame = frames[frames.size() - 1 + depth];
            return true;
        }

        inline void PushFrame(Il2CppStackFrameInfo& frame)
        {
        }

        inline void PopFrame()
        {
        }

        inline const void* GetStackPointer()
        {
            return nullptr;
        }
    };
#else
    class NativeMethodStack : public MethodStack
    {
        static bool GetStackFramesCallback(Il2CppMethodPointer frame, void* context)
        {
            const MethodInfo* method = il2cpp::utils::NativeSymbol::GetMethodFromNativeSymbol(frame);
            StackFrames* stackFrames = static_cast<StackFrames*>(context);

            if (method != NULL)
            {
                bool frames_added = il2cpp::utils::DebugSymbolReader::AddStackFrames(reinterpret_cast<void*>(frame), stackFrames);

                if (!frames_added)
                {
                    Il2CppStackFrameInfo frameInfo = { 0 };
                    frameInfo.method = method;
                    frameInfo.raw_ip = reinterpret_cast<uintptr_t>(frame) - reinterpret_cast<uintptr_t>(os::Image::GetImageBase());
                    stackFrames->push_back(frameInfo);
                }
            }

            return true;
        }

        struct GetStackFrameAtContext
        {
            int32_t currentDepth;
            const MethodInfo* method;
        };

        static bool GetStackFrameAtCallback(Il2CppMethodPointer frame, void* context)
        {
            const MethodInfo* method = il2cpp::utils::NativeSymbol::GetMethodFromNativeSymbol(frame);
            GetStackFrameAtContext* ctx = static_cast<GetStackFrameAtContext*>(context);

            if (method != NULL)
            {
                if (ctx->currentDepth == 0)
                {
                    ctx->method = method;
                    return false;
                }

                ctx->currentDepth++;
            }

            return true;
        }

    public:
        inline const StackFrames* GetStackFrames()
        {
            StackFrames* stackFrames = GetStackFramesRaw();
            if (stackFrames == NULL)
                return stackFrames;
            stackFrames->clear();

            os::StackTrace::WalkStack(&NativeMethodStack::GetStackFramesCallback, stackFrames, os::StackTrace::kFirstCalledToLastCalled);

            return stackFrames;
        }

        // Avoiding calling GetStackFrames() method for the same stack trace with incremented 'depth' value
        inline const StackFrames* GetCachedStackFrames(int32_t depth, const void* stackPointer)
        {
            CachedInfo* cachedInfo = GetStoredCachedInfoRaw();
            const StackFrames* stackFrames = cachedInfo->CheckCondition(depth, stackPointer) ? GetStackFramesRaw() : GetStackFrames();
            cachedInfo->Update(depth, stackPointer);
            return stackFrames;
        }

        inline bool GetStackFrameAt(int32_t depth, Il2CppStackFrameInfo& frame)
        {
            GetStackFrameAtContext context = { depth, NULL };

            os::StackTrace::WalkStack(&NativeMethodStack::GetStackFrameAtCallback, &context, os::StackTrace::kLastCalledToFirstCalled);

            if (context.method != NULL)
            {
                frame.method = context.method;
                return true;
            }

            return false;
        }

        inline void PushFrame(Il2CppStackFrameInfo& frame)
        {
        }

        inline void PopFrame()
        {
        }

        // Returns SP value or nullptr if not implemented
        inline const void* GetStackPointer()
        {
            return os::StackTrace::GetStackPointer();
        }
    };
#endif // IL2CPP_MONO_DEBUGGER

#endif // IL2CPP_ENABLE_NATIVE_STACKTRACES

#else

    static StackFrames s_EmptyStack;

    class NoOpMethodStack
    {
    public:
        inline void InitializeForCurrentThread()
        {
        }

        inline void CleanupForCurrentThread()
        {
        }

        inline const StackFrames* GetStackFrames()
        {
            return &s_EmptyStack;
        }

        inline const StackFrames* GetCachedStackFrames(int32_t depth, const void* stackPointer)
        {
            return GetStackFrames();
        }

        inline bool GetStackFrameAt(int32_t depth, Il2CppStackFrameInfo& frame)
        {
            return false;
        }

        inline void PushFrame(Il2CppStackFrameInfo& frame)
        {
        }

        inline void PopFrame()
        {
        }

        inline const void* GetStackPointer()
        {
            return nullptr;
        }
    };

#endif // IL2CPP_ENABLE_STACKTRACES

#if IL2CPP_ENABLE_STACKTRACES

#if IL2CPP_ENABLE_STACKTRACE_SENTRIES

    StacktraceSentryMethodStack s_MethodStack;

#elif IL2CPP_ENABLE_NATIVE_STACKTRACES

#if IL2CPP_MONO_DEBUGGER
    DebuggerMethodStack s_MethodStack;
#else
    NativeMethodStack s_MethodStack;
#endif

#endif

#else

    NoOpMethodStack s_MethodStack;

#endif // IL2CPP_ENABLE_STACKTRACES

// Current thread functions

    void StackTrace::InitializeStackTracesForCurrentThread()
    {
        s_MethodStack.InitializeForCurrentThread();
    }

    void StackTrace::CleanupStackTracesForCurrentThread()
    {
        s_MethodStack.CleanupForCurrentThread();
    }

    const StackFrames* StackTrace::GetStackFrames()
    {
        return s_MethodStack.GetStackFrames();
    }

    const StackFrames* StackTrace::GetCachedStackFrames(int32_t depth)
    {
        return s_MethodStack.GetCachedStackFrames(depth, GetStackPointer());
    }

    bool StackTrace::GetStackFrameAt(int32_t depth, Il2CppStackFrameInfo& frame)
    {
        Assert(depth <= 0 && "Frame depth must be 0 or less");
        return s_MethodStack.GetStackFrameAt(depth, frame);
    }

    void StackTrace::WalkFrameStack(Il2CppFrameWalkFunc callback, void* context)
    {
        const StackFrames& frames = *GetStackFrames();

        for (StackFrames::const_iterator it = frames.begin(); it != frames.end(); it++)
            callback(&*it, context);
    }

    void StackTrace::PushFrame(Il2CppStackFrameInfo& frame)
    {
        s_MethodStack.PushFrame(frame);
    }

    void StackTrace::PopFrame()
    {
        s_MethodStack.PopFrame();
    }

    const void* StackTrace::GetStackPointer()
    {
        return s_MethodStack.GetStackPointer();
    }

// Remote thread functions

    struct GetThreadFrameAtContext
    {
        il2cpp::os::Event apcDoneEvent;
        int32_t depth;
        Il2CppStackFrameInfo* frame;
        bool hasResult;
    };

    struct WalkThreadFrameStackContext
    {
        il2cpp::os::Event apcDoneEvent;
        Il2CppFrameWalkFunc callback;
        void* userContext;
    };

    struct GetThreadStackDepthContext
    {
        il2cpp::os::Event apcDoneEvent;
        int32_t stackDepth;
    };

    struct GetThreadTopFrameContext
    {
        il2cpp::os::Event apcDoneEvent;
        Il2CppStackFrameInfo* frame;
        bool hasResult;
    };

    static void STDCALL GetThreadFrameAtCallback(void* context)
    {
        GetThreadFrameAtContext* ctx = static_cast<GetThreadFrameAtContext*>(context);

        ctx->hasResult = StackTrace::GetStackFrameAt(ctx->depth, *ctx->frame);
        ctx->apcDoneEvent.Set();
    }

    bool StackTrace::GetThreadStackFrameAt(Il2CppThread* thread, int32_t depth, Il2CppStackFrameInfo& frame)
    {
#if IL2CPP_ENABLE_STACKTRACES
        GetThreadFrameAtContext apcContext;

        apcContext.depth = depth;
        apcContext.frame = &frame;

        thread->GetInternalThread()->handle->QueueUserAPC(GetThreadFrameAtCallback, &apcContext);
        apcContext.apcDoneEvent.Wait();

        return apcContext.hasResult;
#else
        return false;
#endif
    }

    static void STDCALL WalkThreadFrameStackCallback(void* context)
    {
        WalkThreadFrameStackContext* ctx = static_cast<WalkThreadFrameStackContext*>(context);

        StackTrace::WalkFrameStack(ctx->callback, ctx->userContext);
        ctx->apcDoneEvent.Set();
    }

    void StackTrace::WalkThreadFrameStack(Il2CppThread* thread, Il2CppFrameWalkFunc callback, void* context)
    {
#if IL2CPP_ENABLE_STACKTRACES
        WalkThreadFrameStackContext apcContext;

        apcContext.callback = callback;
        apcContext.userContext = context;

        thread->GetInternalThread()->handle->QueueUserAPC(WalkThreadFrameStackCallback, &apcContext);
        apcContext.apcDoneEvent.Wait();
#endif
    }

    static void STDCALL GetThreadStackDepthCallback(void* context)
    {
        GetThreadStackDepthContext* ctx = static_cast<GetThreadStackDepthContext*>(context);

        ctx->stackDepth = static_cast<int32_t>(StackTrace::GetStackDepth());
        ctx->apcDoneEvent.Set();
    }

    int32_t StackTrace::GetThreadStackDepth(Il2CppThread* thread)
    {
#if IL2CPP_ENABLE_STACKTRACES
        GetThreadStackDepthContext apcContext;

        thread->GetInternalThread()->handle->QueueUserAPC(GetThreadStackDepthCallback, &apcContext);
        apcContext.apcDoneEvent.Wait();

        return apcContext.stackDepth;
#else
        return 0;
#endif
    }

    static void STDCALL GetThreadTopFrameCallback(void* context)
    {
        GetThreadTopFrameContext* ctx = static_cast<GetThreadTopFrameContext*>(context);

        ctx->hasResult = StackTrace::GetTopStackFrame(*ctx->frame);
        ctx->apcDoneEvent.Set();
    }

    bool StackTrace::GetThreadTopStackFrame(Il2CppThread* thread, Il2CppStackFrameInfo& frame)
    {
#if IL2CPP_ENABLE_STACKTRACES
        GetThreadTopFrameContext apcContext;
        apcContext.frame = &frame;

        thread->GetInternalThread()->handle->QueueUserAPC(GetThreadTopFrameCallback, &apcContext);
        apcContext.apcDoneEvent.Wait();

        return apcContext.hasResult;
#else
        return false;
#endif
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\StackTrace.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\String.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/Allocator.h"
#include "gc/GarbageCollector.h"
#include "gc/GCHandle.h"
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "vm/Exception.h"
#include "vm/String.h"
#include "vm/Object.h"
#include "vm/Profiler.h"
#include "gc/AppendOnlyGCHashMap.h"
#include "utils/StringUtils.h"
#include <string>
#include <memory.h>
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"

#include "Baselib.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace vm
{
    static Il2CppString* s_EmptyString;

    void String::InitializeEmptyString(Il2CppClass* stringClass)
    {
        IL2CPP_ASSERT(s_EmptyString == NULL && "Empty string was already initialized");

        // size for string and null terminator
        s_EmptyString = static_cast<Il2CppString*>(gc::GarbageCollector::AllocateFixed(sizeof(Il2CppString) + 2, 0));
        s_EmptyString->object.klass = stringClass;
        s_EmptyString->length = 0;
        s_EmptyString->chars[0] = 0;
    }

    void String::CleanupEmptyString()
    {
        IL2CPP_ASSERT(s_EmptyString && "Empty string was not yet initialized");
        gc::GarbageCollector::FreeFixed(s_EmptyString);
        s_EmptyString = NULL;
    }

    Il2CppString* String::Empty()
    {
        IL2CPP_ASSERT(s_EmptyString && "Empty string was not yet initialized");
        return s_EmptyString;
    }

    int32_t String::GetHash(Il2CppString* str)
    {
        const Il2CppChar* p = utils::StringUtils::GetChars(str);
        int i, len = utils::StringUtils::GetLength(str);
        uint32_t h = 0;

        for (i = 0; i < len; i++)
        {
            h = (h << 5) - h + *p;
            p++;
        }

        return h;
    }

    Il2CppString* String::New(const char* str)
    {
        return NewLen(str, (uint32_t)strlen(str));
    }

    Il2CppString* String::NewWrapper(const char* str)
    {
        return New(str);
    }

    Il2CppString* String::NewLen(const char* str, uint32_t length)
    {
        UTF16String utf16Chars = il2cpp::utils::StringUtils::Utf8ToUtf16(str, length);

        return NewUtf16(utf16Chars.c_str(), (uint32_t)utf16Chars.length());
    }

    Il2CppString* String::NewUtf16(const Il2CppChar* text, int32_t len)
    {
        Il2CppString *s;

        s = NewSize(len);
        IL2CPP_ASSERT(s != NULL);

        memcpy(utils::StringUtils::GetChars(s), text, (size_t)len * 2);

        return s;
    }

    Il2CppString* String::NewUtf16(const utils::StringView<Il2CppChar>& text)
    {
        IL2CPP_ASSERT(text.Length() < static_cast<uint32_t>(std::numeric_limits<int32_t>::max()));
        return NewUtf16(text.Str(), static_cast<int32_t>(text.Length()));
    }

    Il2CppString* String::NewSize(int32_t len)
    {
        if (len == 0)
            return Empty();

        Il2CppString *s;
        IL2CPP_ASSERT(len >= 0);
        size_t size = (sizeof(Il2CppString) + (((size_t)len + 1) * 2));

        /* overflow ? can't fit it, can't allocate it! */
        if (static_cast<uint32_t>(len) > size)
            Exception::RaiseOutOfMemoryException();

        s = reinterpret_cast<Il2CppString*>(Object::AllocatePtrFree(size, il2cpp_defaults.string_class));

        s->length = len;
#if NEED_TO_ZERO_PTRFREE
        s->chars[len] = 0;
#endif

#if IL2CPP_ENABLE_PROFILER
        if (Profiler::ProfileAllocations())
            Profiler::Allocation((Il2CppObject*)s, il2cpp_defaults.string_class);
#endif

        return s;
    }

    struct InternedString
    {
        int32_t length;
        const Il2CppChar* chars;
    };

    class InternedStringHash
    {
    public:
        size_t operator()(const InternedString& ea) const
        {
            return utils::StringUtils::Hash(ea.chars, ea.length);
        }
    };

    class InternedStringCompare
    {
    public:
        bool operator()(const InternedString& ea, const InternedString& eb) const
        {
            return (ea.length == eb.length) && (0 == memcmp(ea.chars, eb.chars, sizeof(Il2CppChar) * ea.length));
        }
    };


    typedef il2cpp::gc::AppendOnlyGCHashMap<InternedString, Il2CppString*, InternedStringHash, InternedStringCompare> InternedStringMap;

    static InternedStringMap* s_InternedStringMap;

    Il2CppString* String::Intern(Il2CppString* str)
    {
        // allocate this at runtime since it uses GC allocator to keep managed strings alive and needs GC initialized
        if (s_InternedStringMap == NULL)
        {
            InternedStringMap* newMap = new InternedStringMap();
            if (os::Atomic::CompareExchangePointer<InternedStringMap>(&s_InternedStringMap, newMap, NULL) != NULL)
                delete newMap;
        }

        InternedString internedString = { str->length, str->chars };
        Il2CppString* value = NULL;
        if (s_InternedStringMap->TryGetValue(internedString, &value))
            return value;

        internedString.chars = utils::StringUtils::GetChars(str);
        return s_InternedStringMap->GetOrAdd(internedString, str);
    }

    Il2CppString* String::IsInterned(Il2CppString* str)
    {
        // if this is NULL, it means we have no interned strings
        if (s_InternedStringMap == NULL)
            return NULL;

        InternedString internedString = { str->length, str->chars };
        Il2CppString* value = NULL;
        if (s_InternedStringMap->TryGetValue(internedString, &value))
            return value;

        return NULL;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\String.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Thread.cpp---------------
.
.
#include "il2cpp-config.h"
#include "os/Mutex.h"
#include "os/Thread.h"
#include "os/ThreadLocalValue.h"
#include "os/Time.h"
#include "os/Semaphore.h"
#include "vm/Domain.h"
#include "vm/Exception.h"
#include "vm/Object.h"
#include "vm/Profiler.h"
#include "vm/Runtime.h"
#include "vm/StackTrace.h"
#include "vm/Thread.h"
#include "vm/String.h"
#include "gc/Allocator.h"
#include "gc/GarbageCollector.h"
#include "gc/GCHandle.h"
#include "gc/WriteBarrier.h"
#include "utils/Memory.h"
#include "utils/StringUtils.h"
#include "vm-utils/Debugger.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include <algorithm>

#include "Baselib.h"
#include "Cpp/Atomic.h"
#include "Cpp/ReentrantLock.h"

namespace il2cpp
{
namespace vm
{
    Il2CppThread* Thread::s_MainThread = NULL;

    typedef std::vector<Il2CppThread*, il2cpp::gc::Allocator<Il2CppThread*> > GCTrackedThreadVector;

    // we need to allocate this ourselves so the CRT does not initialize it and try to allocate GC memory on startup before the GC is initialized
    static GCTrackedThreadVector* s_AttachedThreads;

    static bool s_BlockNewThreads = false;

#define AUTO_LOCK_THREADS() il2cpp::os::FastAutoLock lock(&s_ThreadMutex)

    static baselib::ReentrantLock s_ThreadMutex;

    static std::vector<int32_t> s_ThreadStaticSizes;

    static il2cpp::os::ThreadLocalValue s_CurrentThread;
    static il2cpp::os::ThreadLocalValue s_StaticData; // Cache the static thread data in a local TLS slot for faster lookup

    static baselib::atomic<int32_t> s_NextManagedThreadId = {0};

    /*
        Thread static data is stored in a two level lookup so we can grow the size at runtime
        without requiring a lock on looking up static data

        We pre-allocate a fixed number of slot pointers - kMaxThreadStaticSlots at startup.
        Each of these slots can hold kMaxThreadStaticDataPointers data pointer.  These slots
        are allocated as needed.
    */

    const int32_t kMaxThreadStaticSlots = 1024;
    const int32_t kMaxThreadStaticDataPointers = 1024;

    struct ThreadStaticOffset
    {
        uint32_t slot;
        uint32_t index;
    };

    static ThreadStaticOffset IndexToStaticFieldOffset(int32_t index)
    {
        static_assert(kMaxThreadStaticSlots <= 0xFFFF, "Only 65535 base thread static slots are supported");
        static_assert(kMaxThreadStaticDataPointers <= 0xFFFF, "Only 65535 thread static slots are supported");

        uint32_t value = (uint32_t)index;
        ThreadStaticOffset offset;
        offset.slot = value >> 16;
        offset.index = value & 0xFFFF;
        return offset;
    }

    struct ThreadStaticDataSlot
    {
        void* data[kMaxThreadStaticSlots];
    };

    struct ThreadStaticData
    {
        ThreadStaticDataSlot* slots[kMaxThreadStaticSlots];
    };

    static void
    set_wbarrier_for_attached_threads()
    {
        gc::GarbageCollector::SetWriteBarrier((void**)s_AttachedThreads->data(), sizeof(Il2CppThread*) * s_AttachedThreads->size());
    }

    static void
    thread_cleanup_on_cancel(void* arg)
    {
        Thread::Detach((Il2CppThread*)arg, true);

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP
        il2cpp::os::Thread* osThread = ((Il2CppThread*)arg)->GetInternalThread()->handle;
        osThread->SignalExited();
#endif
    }

    void Thread::Initialize()
    {
#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP
        os::Thread::SetNativeThreadCleanup(&thread_cleanup_on_cancel);
#endif
#if IL2CPP_ENABLE_RELOAD
        s_BlockNewThreads = false;
#endif
        s_AttachedThreads = new GCTrackedThreadVector();
    }

    void Thread::Uninitialize()
    {
        IL2CPP_ASSERT(Current() == Main());

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP
        os::Thread::SetNativeThreadCleanup(NULL);
#endif

        delete s_AttachedThreads;
        s_AttachedThreads = NULL;

        s_MainThread = NULL;
    }

    Il2CppThread* Thread::Attach(Il2CppDomain *domain)
    {
        Il2CppThread* managedThread = Current();

        if (managedThread != NULL)
            return managedThread;

        gc::GarbageCollector::RegisterThread();

        StackTrace::InitializeStackTracesForCurrentThread();

        // Get/create OS thread representing the current thread. For pre-existing threads such as
        // the main thread, this will create an OS thread instance on demand. For threads that have
        // been started through our OS layer, there will already be an instance.
        os::Thread* osThread = os::Thread::GetOrCreateCurrentThread();

        // Create managed object representing the current thread.
        managedThread = (Il2CppThread*)Object::New(il2cpp_defaults.thread_class);
        SetupInternalManagedThread(managedThread, osThread);

        managedThread->GetInternalThread()->state = kThreadStateRunning;

        InitializeManagedThread(managedThread, domain);

        return managedThread;
    }

    void Thread::SetupInternalManagedThread(Il2CppThread* thread, os::Thread* osThread)
    {
        Il2CppInternalThread* internalManagedThread = (Il2CppInternalThread*)Object::New(il2cpp_defaults.internal_thread_class);
        internalManagedThread->handle = osThread;
        internalManagedThread->tid = osThread->Id();
        internalManagedThread->managed_id = GetNewManagedId();

        // The synch_cs object is deallocated in the InternalThread::Thread_free_internal icall, which
        // is called from the managed thread finalizer.
        internalManagedThread->longlived = (Il2CppLongLivedThreadData*)IL2CPP_MALLOC(sizeof(Il2CppLongLivedThreadData));
        internalManagedThread->longlived->synch_cs = new baselib::ReentrantLock;

        internalManagedThread->apartment_state = il2cpp::os::kApartmentStateUnknown;
        gc::WriteBarrier::GenericStore(&thread->internal_thread, internalManagedThread);
    }

    void Thread::InitializeManagedThread(Il2CppThread* thread, Il2CppDomain* domain)
    {
#if IL2CPP_SUPPORT_THREADS
        IL2CPP_ASSERT(thread->GetInternalThread()->handle != NULL);
        IL2CPP_ASSERT(thread->GetInternalThread()->longlived->synch_cs != NULL);
#endif

#if IL2CPP_MONO_DEBUGGER
        utils::Debugger::AllocateThreadLocalData();
#endif

        s_CurrentThread.SetValue(thread);

        Domain::ContextSet(domain->default_context);

        Register(thread);
        AllocateStaticDataForCurrentThread();

#if IL2CPP_MONO_DEBUGGER
        utils::Debugger::ThreadStarted((uintptr_t)thread->GetInternalThread()->tid);
#endif

#if IL2CPP_ENABLE_PROFILER
        vm::Profiler::ThreadStart(((unsigned long)thread->GetInternalThread()->tid));
#endif

        // Sync thread name.
        if (thread->GetInternalThread()->name.chars)
        {
            std::string utf8Name = il2cpp::utils::StringUtils::Utf16ToUtf8(thread->GetInternalThread()->name.chars);
            thread->GetInternalThread()->handle->SetName(utf8Name.c_str());
        }

        // Sync thread apartment state.
        thread->GetInternalThread()->apartment_state = thread->GetInternalThread()->handle->GetApartment();

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP
        // register us for platform specific cleanup attempt in case thread is not exited cleanly
        os::Thread::RegisterCurrentThreadForCleanup(thread);
#endif

        // If an interrupt has been requested before the thread was started, re-request
        // the interrupt now.
        if (thread->GetInternalThread()->interruption_requested)
            RequestInterrupt(thread);
    }

    void Thread::UninitializeManagedThread(Il2CppThread* thread)
    {
        Thread::UninitializeManagedThread(thread, false);
    }

    void Thread::UninitializeManagedThread(Il2CppThread *thread, bool inNativeThreadCleanup)
    {
        // This method is only valid to call from the current thread
        // But we can't safely check the Current() in native thread shutdown
        // because we can't rely on TLS values being valid
        IL2CPP_ASSERT(inNativeThreadCleanup || thread == Current());

#if IL2CPP_HAS_NATIVE_THREAD_CLEANUP
        // unregister from special cleanup since we are doing it now
        os::Thread::UnregisterCurrentThreadForCleanup();
#endif

        if (!gc::GarbageCollector::UnregisterThread())
            IL2CPP_ASSERT(0 && "gc::GarbageCollector::UnregisterThread failed");

#if IL2CPP_ENABLE_PROFILER
        vm::Profiler::ThreadEnd(((unsigned long)thread->GetInternalThread()->tid));
#endif

#if IL2CPP_MONO_DEBUGGER
        // Only raise the event for the debugger if there is a current thread at the OS thread level.
        // The debugger code will try to take a lock, which requires a current thread. If this
        // thread is being detached by a call from thread_cleanup_on_cancel, then there might
        // not be a current thread, as pthreads does not privide TLS entries in thread destructors.
        if (os::Thread::HasCurrentThread())
            utils::Debugger::ThreadStopped((uintptr_t)thread->GetInternalThread()->tid);
#endif

        FreeCurrentThreadStaticData(thread, inNativeThreadCleanup);

        // Call Unregister after all access to managed objects (Il2CppThread and Il2CppInternalThread)
        // is complete. Unregister will remove the managed thread object from the GC tracked vector of
        // attached threads, and allow it to be finalized and re-used. If runtime code accesses it
        // after a call to Unregister, there will be a race condition between the GC and the runtime
        // code for access to that object.
        Unregister(thread);

#if IL2CPP_MONO_DEBUGGER
        utils::Debugger::FreeThreadLocalData();
#endif

        os::Thread::DetachCurrentThread();
        s_CurrentThread.SetValue(NULL);
    }

    Il2CppThread* Thread::Current()
    {
        void* value = NULL;
        s_CurrentThread.GetValue(&value);
        return (Il2CppThread*)value;
    }

    static void STDCALL TerminateThread(void* context)
    {
        // We throw a dummy exception to make sure things clean up properly
        // and we don't leave any locks behind (such as global locks in the allocator which
        // would then deadlock other threads). This could work off ThreadAbortException
        // but we don't want to deal with a managed exception here. So we use a C++ exception.
        throw Thread::NativeThreadAbortException();
    }

    static bool IsDebuggerThread(os::Thread* thread)
    {
#if IL2CPP_MONO_DEBUGGER
        return utils::Debugger::IsDebuggerThread(thread);
#else
        return false;
#endif
    }

    // This function requests that all threads exit
    // If a thread is in a non-alertable wait it may not have exited when this method exits
    void Thread::AbortAllThreads()
    {
#if IL2CPP_SUPPORT_THREADS
        Il2CppThread* gcFinalizerThread = NULL;
        Il2CppThread* currentThread = Current();
        IL2CPP_ASSERT(currentThread != NULL && "No current thread!");

        s_ThreadMutex.Acquire();
        s_BlockNewThreads = true;
        GCTrackedThreadVector attachedThreadsCopy = *s_AttachedThreads;

        // In theory, we don't need a write barrier here for Boehm, because we keep a
        // reference to the object on the stack during it's lifetime. But for validation
        // tests, we turn off GC, and thus we need it to pass.
        gc::GarbageCollector::SetWriteBarrier((void**)attachedThreadsCopy.data(), sizeof(Il2CppThread*) * attachedThreadsCopy.size());
        s_ThreadMutex.Release();

        std::vector<os::Thread*> activeThreads;

        // Kill all threads but the finalizer and current one. We temporarily flush out
        // the entire list and then just put the two threads back.
        while (attachedThreadsCopy.size())
        {
            Il2CppThread* thread = attachedThreadsCopy.back();
            os::Thread* osThread = thread->GetInternalThread()->handle;

            if (gc::GarbageCollector::IsFinalizerThread(thread))
            {
                IL2CPP_ASSERT(gcFinalizerThread == NULL && "There seems to be more than one finalizer thread!");
                gcFinalizerThread = thread;
            }
            else if (thread != currentThread && !IsDebuggerThread(osThread))
            {
                ////TODO: use Thread.Abort() instead
                osThread->QueueUserAPC(TerminateThread, NULL);
                activeThreads.push_back(osThread);
            }

            attachedThreadsCopy.pop_back();
        }
        // In theory, we don't need a write barrier here for Boehm, because we keep a
        // reference to the object on the stack during it's lifetime. But for validation
        // tests, we turn off GC, and thus we need it to pass.
        gc::GarbageCollector::SetWriteBarrier((void**)attachedThreadsCopy.data(), sizeof(Il2CppThread*) * attachedThreadsCopy.size());

        ////FIXME: While we don't have stable thread abortion in place yet, work around problems in
        ////    the current implementation by repeatedly requesting threads to terminate. This works around
        ////    race condition to some extent.
        while (activeThreads.size())
        {
            os::Thread* osThread = activeThreads.back();

            // Wait for the thread.
            if (osThread->Join(10) == kWaitStatusSuccess)
                activeThreads.pop_back();
            else
            {
                ////TODO: use Thread.Abort() instead
                osThread->QueueUserAPC(TerminateThread, NULL);
            }
        }


        AUTO_LOCK_THREADS();
        s_AttachedThreads->clear();

        // Put finalizer and current thread back in list.
        IL2CPP_ASSERT(gcFinalizerThread != NULL && "GC finalizer thread was not found in list of attached threads!");
        if (gcFinalizerThread)
            s_AttachedThreads->push_back(gcFinalizerThread);
        if (currentThread)
            s_AttachedThreads->push_back(currentThread);
        set_wbarrier_for_attached_threads();
#endif
    }

    void Thread::Detach(Il2CppThread* thread)
    {
        Thread::Detach(thread, false);
    }

    void Thread::Detach(Il2CppThread *thread, bool inNativeThreadCleanup)
    {
        IL2CPP_ASSERT(thread != NULL && "Cannot detach a NULL thread");

        UninitializeManagedThread(thread, inNativeThreadCleanup);
        il2cpp::vm::StackTrace::CleanupStackTracesForCurrentThread();
    }

    Il2CppThread* Thread::Main()
    {
        return s_MainThread;
    }

    void Thread::SetMain(Il2CppThread* thread)
    {
        IL2CPP_ASSERT(s_MainThread == NULL);
        s_MainThread = thread;
    }

    void Thread::SetState(Il2CppThread *thread, ThreadState value)
    {
        il2cpp::os::FastAutoLock lock(thread->GetInternalThread()->longlived->synch_cs);
        thread->GetInternalThread()->state |= value;
    }

    void Thread::ClrState(Il2CppInternalThread* thread, ThreadState clr)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);
        thread->state &= ~clr;
    }

    void Thread::SetState(Il2CppInternalThread *thread, ThreadState value)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);
        thread->state |= value;
    }

    ThreadState Thread::GetState(Il2CppInternalThread *thread)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);
        return (ThreadState)thread->state;
    }

    bool Thread::TestState(Il2CppInternalThread* thread, ThreadState value)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);
        return (thread->state & value) != 0;
    }

    Il2CppInternalThread* Thread::CurrentInternal()
    {
        return Current()->GetInternalThread();
    }

    ThreadState Thread::GetState(Il2CppThread *thread)
    {
        il2cpp::os::FastAutoLock lock(thread->GetInternalThread()->longlived->synch_cs);
        return (ThreadState)thread->GetInternalThread()->state;
    }

    void Thread::ClrState(Il2CppThread* thread, ThreadState state)
    {
        il2cpp::os::FastAutoLock lock(thread->GetInternalThread()->longlived->synch_cs);
        thread->GetInternalThread()->state &= ~state;
    }

    static void AllocThreadDataSlot(ThreadStaticData* staticData, ThreadStaticOffset offset, int32_t size)
    {
        if (staticData->slots[offset.slot] == NULL)
            staticData->slots[offset.slot] = (ThreadStaticDataSlot*)IL2CPP_CALLOC(1, sizeof(ThreadStaticDataSlot));

        if (staticData->slots[offset.slot]->data[offset.index] == NULL)
            staticData->slots[offset.slot]->data[offset.index] = gc::GarbageCollector::AllocateFixed(size, NULL);
    }

    void Thread::AllocateStaticDataForCurrentThread()
    {
        AUTO_LOCK_THREADS();
        int32_t index = 0;

        // Alloc the slotData along with the first slots at once
        ThreadStaticData* staticData = (ThreadStaticData*)IL2CPP_CALLOC(1, sizeof(ThreadStaticData) + sizeof(ThreadStaticDataSlot));
        staticData->slots[0] = (ThreadStaticDataSlot*)(staticData + 1);

        Il2CppThread* thread = Current();
        IL2CPP_ASSERT(!thread->GetInternalThread()->static_data);
        thread->GetInternalThread()->static_data = staticData;
        s_StaticData.SetValue(staticData);

        for (std::vector<int32_t>::const_iterator iter = s_ThreadStaticSizes.begin(); iter != s_ThreadStaticSizes.end(); ++iter)
        {
            AllocThreadDataSlot(staticData, IndexToStaticFieldOffset(index), *iter);
            index++;
        }
    }

    int32_t Thread::AllocThreadStaticData(int32_t size)
    {
        AUTO_LOCK_THREADS();
        int32_t index = (int32_t)s_ThreadStaticSizes.size();

        IL2CPP_ASSERT(index < kMaxThreadStaticSlots * kMaxThreadStaticDataPointers);
        if (index >= kMaxThreadStaticSlots * kMaxThreadStaticDataPointers)
            il2cpp::vm::Exception::Raise(Exception::GetExecutionEngineException("Out of thread static storage slots"));

        s_ThreadStaticSizes.push_back(size);

        ThreadStaticOffset offset = IndexToStaticFieldOffset(index);

        for (GCTrackedThreadVector::const_iterator iter = s_AttachedThreads->begin(); iter != s_AttachedThreads->end(); ++iter)
        {
            Il2CppThread* thread = *iter;
            ThreadStaticData* staticData = reinterpret_cast<ThreadStaticData*>(thread->GetInternalThread()->static_data);

            if (staticData == NULL)
            {
                // There is a race on staticData for a thread could be NULL here in two cases
                // 1. The thread hasn't entered AllocateStaticDataForCurrentThread yet
                // 2. The thread has exited FreeCurrentThreadStaticData but hasn't been remove from the s_AttachedThreads yet
                // In both cases we can just continue and in 1. the data will be allocated in AllocateStaticDataForCurrentThread
                // and in 2. we don't want to allocate anything
                continue;
            }

            AllocThreadDataSlot(staticData, offset, size);
        }

        return index;
    }

    void Thread::FreeCurrentThreadStaticData(Il2CppThread *thread, bool inNativeThreadCleanup)
    {
        // This method is only valid to call from the current thread
        // But we can't safely check the Current() in native thread shutdown
        // because we can't rely on TLS values being valid
        IL2CPP_ASSERT(inNativeThreadCleanup || thread == Current());

        AUTO_LOCK_THREADS();

        ThreadStaticData* staticData = reinterpret_cast<ThreadStaticData*>(thread->GetInternalThread()->static_data);

        thread->GetInternalThread()->static_data = NULL;
        s_StaticData.SetValue(NULL);

        // This shouldn't happen unless we call this twice, but there's no reason to crash here
        IL2CPP_ASSERT(staticData);
        if (staticData == NULL)
            return;

        for (int slot = 0; slot < kMaxThreadStaticSlots; slot++)
        {
            if (!staticData->slots[slot])
                break;

            for (int i = 0; i < kMaxThreadStaticDataPointers; i++)
            {
                if (!staticData->slots[slot]->data[i])
                    break;
                gc::GarbageCollector::FreeFixed(staticData->slots[slot]->data[i]);
            }

            // Don't free the first slot because we allocate the first slot along with the root slots
            if (slot > 0)
                IL2CPP_FREE(staticData->slots[slot]);
        }

        IL2CPP_FREE(staticData);
    }

    void* Thread::GetThreadStaticData(int32_t offset)
    {
        // No lock. We allocate static_data once with a fixed size so we can read it
        // safely without a lock here.
        IL2CPP_ASSERT(offset >= 0 && static_cast<uint32_t>(offset) < s_ThreadStaticSizes.size());

        ThreadStaticOffset staticOffset = IndexToStaticFieldOffset(offset);

        ThreadStaticData* staticData;
        s_StaticData.GetValue((void**)&staticData);
        IL2CPP_ASSERT(staticData != NULL);

        return staticData->slots[staticOffset.slot]->data[staticOffset.index];
    }

    void* Thread::GetThreadStaticDataForThread(int32_t offset, Il2CppInternalThread* thread)
    {
        // No lock. We allocate static_data once with a fixed size so we can read it
        // safely without a lock here.
        IL2CPP_ASSERT(offset >= 0 && static_cast<uint32_t>(offset) < s_ThreadStaticSizes.size());
        IL2CPP_ASSERT(thread->static_data != NULL);

        ThreadStaticOffset staticOffset = IndexToStaticFieldOffset(offset);
        return reinterpret_cast<ThreadStaticData*>(thread->static_data)->slots[staticOffset.slot]->data[staticOffset.index];
    }

    void Thread::Register(Il2CppThread *thread)
    {
        AUTO_LOCK_THREADS();
        if (s_BlockNewThreads)
            TerminateThread(NULL);
        else
        {
            s_AttachedThreads->push_back(thread);
            set_wbarrier_for_attached_threads();
        }
    }

    void Thread::Unregister(Il2CppThread *thread)
    {
        AUTO_LOCK_THREADS();
        GCTrackedThreadVector::iterator it = std::find(s_AttachedThreads->begin(), s_AttachedThreads->end(), thread);

#if IL2CPP_MONO_DEBUGGER
        if (it == s_AttachedThreads->end() && thread->internal_thread && il2cpp::utils::Debugger::IsDebuggerThread(thread->internal_thread->handle))
            return;
#endif

        IL2CPP_ASSERT(it != s_AttachedThreads->end() && "Vm thread not found in list of attached threads.");
        s_AttachedThreads->erase(it);
        set_wbarrier_for_attached_threads();
    }

    bool Thread::IsVmThread(Il2CppThread *thread)
    {
        return !gc::GarbageCollector::IsFinalizerThread(thread);
    }

    std::string Thread::GetName(Il2CppInternalThread* thread)
    {
        if (thread->name.chars == NULL)
            return std::string();

        return utils::StringUtils::Utf16ToUtf8(thread->name.chars);
    }

    void Thread::SetName(Il2CppThread* thread, Il2CppString* name)
    {
        il2cpp::os::FastAutoLock lock(thread->GetInternalThread()->longlived->synch_cs);

        // Throw if already set.
        if (thread->GetInternalThread()->name.length != 0)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetInvalidOperationException("Thread name can only be set once."));

        // Store name.
        thread->GetInternalThread()->name.length = utils::StringUtils::GetLength(name);
        thread->GetInternalThread()->name.chars = il2cpp::utils::StringUtils::StringDuplicate(utils::StringUtils::GetChars(name), thread->GetInternalThread()->name.length);

        // Hand over to OS layer, if thread has been started already.
        if (thread->GetInternalThread()->handle)
        {
            std::string utf8Name = il2cpp::utils::StringUtils::Utf16ToUtf8(thread->GetInternalThread()->name.chars);
            thread->GetInternalThread()->handle->SetName(utf8Name.c_str());
        }
    }

    void Thread::SetName(Il2CppInternalThread* thread, Il2CppString* name)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);

        // Throw if already set.
        if (thread->name.length != 0)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetInvalidOperationException("Thread name can only be set once."));

        // Store name.
        thread->name.length = utils::StringUtils::GetLength(name);
        thread->name.chars = il2cpp::utils::StringUtils::StringDuplicate(utils::StringUtils::GetChars(name), thread->name.length);

        // Hand over to OS layer, if thread has been started already.
        if (thread->handle)
        {
            std::string utf8Name = il2cpp::utils::StringUtils::Utf16ToUtf8(thread->name.chars);
            thread->handle->SetName(utf8Name.c_str());
        }
    }

    static void STDCALL CheckCurrentThreadForInterruptCallback(void* context)
    {
        Thread::CheckCurrentThreadForInterruptAndThrowIfNecessary();
    }

    void Thread::RequestInterrupt(Il2CppThread* thread)
    {
        il2cpp::os::FastAutoLock lock(thread->GetInternalThread()->longlived->synch_cs);

        thread->GetInternalThread()->interruption_requested = true;

        // If thread has already been started, queue an interrupt now.
        il2cpp::os::Thread* osThread = thread->GetInternalThread()->handle;
        if (osThread)
            osThread->QueueUserAPC(CheckCurrentThreadForInterruptCallback, NULL);
    }

    void Thread::CheckCurrentThreadForInterruptAndThrowIfNecessary()
    {
        Il2CppThread* currentThread = il2cpp::vm::Thread::Current();
        if (!currentThread)
            return;

        il2cpp::os::FastAutoLock lock(currentThread->GetInternalThread()->longlived->synch_cs);

        // Don't throw if thread is not currently in waiting state or if there's
        // no pending interrupt.
        if (!currentThread->GetInternalThread()->interruption_requested
            || !(il2cpp::vm::Thread::GetState(currentThread) & il2cpp::vm::kThreadStateWaitSleepJoin))
            return;

        // Mark the current thread as being unblocked.
        currentThread->GetInternalThread()->interruption_requested = false;
        il2cpp::vm::Thread::ClrState(currentThread, il2cpp::vm::kThreadStateWaitSleepJoin);

        // Throw interrupt exception.
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetThreadInterruptedException());
    }

    static void STDCALL CheckCurrentThreadForAbortCallback(void* context)
    {
        Thread::CheckCurrentThreadForAbortAndThrowIfNecessary();
    }

    bool Thread::RequestAbort(Il2CppThread* thread)
    {
        il2cpp::os::FastAutoLock lock(thread->GetInternalThread()->longlived->synch_cs);

        ThreadState state = il2cpp::vm::Thread::GetState(thread);
        if (state & kThreadStateAbortRequested || state & kThreadStateStopped || state & kThreadStateStopRequested)
            return false;

        il2cpp::os::Thread* osThread = thread->GetInternalThread()->handle;
        if (osThread)
        {
            // If thread has already been started, queue an abort now.
            Thread::SetState(thread, kThreadStateAbortRequested);
            osThread->QueueUserAPC(CheckCurrentThreadForAbortCallback, NULL);
        }
        else
        {
            // If thread has not started, put it in the aborted state.
            Thread::SetState(thread, kThreadStateAborted);
        }

        return true;
    }

    bool Thread::RequestAbort(Il2CppInternalThread* thread)
    {
        il2cpp::os::FastAutoLock lock(thread->longlived->synch_cs);

        ThreadState state = il2cpp::vm::Thread::GetState(thread);
        if (state & kThreadStateAbortRequested || state & kThreadStateStopped || state & kThreadStateStopRequested)
            return false;

        il2cpp::os::Thread* osThread = thread->handle;
        if (osThread)
        {
            // If thread has already been started, queue an abort now.
            Thread::SetState(thread, kThreadStateAbortRequested);
            osThread->QueueUserAPC(CheckCurrentThreadForAbortCallback, NULL);
        }
        else
        {
            // If thread has not started, put it in the aborted state.
            Thread::SetState(thread, kThreadStateAborted);
        }

        return true;
    }

    void Thread::SetPriority(Il2CppThread* thread, int32_t priority)
    {
        Il2CppInternalThread* internalThread = thread->GetInternalThread();
        il2cpp::os::FastAutoLock lock(internalThread->longlived->synch_cs);
        internalThread->handle->SetPriority((il2cpp::os::ThreadPriority)priority);
    }

    int32_t Thread::GetPriority(Il2CppThread* thread)
    {
        Il2CppInternalThread* internalThread = thread->GetInternalThread();
        il2cpp::os::FastAutoLock lock(internalThread->longlived->synch_cs);
        return internalThread->handle->GetPriority();
    }

    struct StartDataInternal
    {
        Il2CppThread* m_Thread;
        Il2CppDomain* m_Domain;
        void* m_Delegate;
        void* m_StartArg;
        il2cpp::os::Semaphore* m_Semaphore;
    };

    static void ThreadStart(void* arg)
    {
        StartDataInternal* startData = (StartDataInternal*)arg;

        startData->m_Semaphore->Wait();

        {
            gc::GarbageCollector::RegisterThread();

            il2cpp::vm::StackTrace::InitializeStackTracesForCurrentThread();

            bool attachSuccessful = false;
            try
            {
                il2cpp::vm::Thread::InitializeManagedThread(startData->m_Thread, startData->m_Domain);
                il2cpp::vm::Thread::SetState(startData->m_Thread, kThreadStateRunning);

                attachSuccessful = true;

                try
                {
                    ((void(*)(void*))startData->m_Delegate)(startData->m_StartArg);
                }
                catch (Il2CppExceptionWrapper& ex)
                {
                    // Only deal with the unhandled exception if the runtime is not
                    // shutting down. Otherwise, the code to process the unhandled
                    // exception might fail in unexpected ways, because it needs
                    // the full runtime available. We've seen this cause crashes
                    // that are difficult to reproduce locally.
                    if (!il2cpp::vm::Runtime::IsShuttingDown())
                        Runtime::UnhandledException(ex.ex);
                }
            }
            catch (il2cpp::vm::Thread::NativeThreadAbortException)
            {
                // Nothing to do. We've successfully aborted the thread.
                il2cpp::vm::Thread::SetState(startData->m_Thread, kThreadStateAborted);
            }

            il2cpp::vm::Thread::ClrState(startData->m_Thread, kThreadStateRunning);
            il2cpp::vm::Thread::SetState(startData->m_Thread, kThreadStateStopped);
            if (attachSuccessful)
                il2cpp::vm::Thread::UninitializeManagedThread(startData->m_Thread, false);

            il2cpp::vm::StackTrace::CleanupStackTracesForCurrentThread();
        }

        delete startData->m_Semaphore;
        gc::GarbageCollector::FreeFixed(startData);
    }

    Il2CppInternalThread* Thread::CreateInternal(void(*func)(void*), void* arg, bool threadpool_thread, uint32_t stack_size)
    {
        // The os::Thread object is deallocated in the InternalThread::Thread_free_internal icall, which
        // is called from the managed thread finalizer.
        os::Thread* osThread = new os::Thread();
        Il2CppThread* managedThread = (Il2CppThread*)Object::New(il2cpp_defaults.thread_class);

        SetupInternalManagedThread(managedThread, osThread);
        Il2CppInternalThread* internalManagedThread = managedThread->GetInternalThread();

        internalManagedThread->state = kThreadStateUnstarted;
        internalManagedThread->threadpool_thread = threadpool_thread;

        // use fixed GC memory since we are storing managed object pointers
        StartDataInternal* startData = (StartDataInternal*)gc::GarbageCollector::AllocateFixed(sizeof(StartDataInternal), NULL);
        gc::WriteBarrier::GenericStore(&startData->m_Thread, managedThread);
        gc::WriteBarrier::GenericStore(&startData->m_Domain, Domain::GetCurrent());
        startData->m_Delegate = (void*)func;
        startData->m_StartArg = arg;
        startData->m_Semaphore = new il2cpp::os::Semaphore(0);

        osThread->SetStackSize(stack_size);
        osThread->SetExplicitApartment(static_cast<il2cpp::os::ApartmentState>(managedThread->GetInternalThread()->apartment_state));
        il2cpp::os::ErrorCode status = osThread->Run(&ThreadStart, startData);
        if (status != il2cpp::os::kErrorCodeSuccess)
        {
            delete osThread;
            return NULL;
        }

        internalManagedThread->state &= ~kThreadStateUnstarted;

        startData->m_Semaphore->Post(1, NULL);

        return internalManagedThread;
    }

    void Thread::Stop(Il2CppInternalThread* thread)
    {
        IL2CPP_ASSERT(thread != CurrentInternal());
        if (!RequestAbort(thread))
            return;

        os::Thread* osThread = thread->handle;

        ////FIXME: While we don't have stable thread abortion in place yet, work around problems in
        ////    the current implementation by repeatedly requesting threads to terminate. This works around
        ////    race condition to some extent.
        while (true)
        {
            // If it's a background thread, request it to kill itself.
            if (GetState(thread) & kThreadStateBackground)
            {
                ////TODO: use Thread.Abort() instead
                osThread->QueueUserAPC(TerminateThread, NULL);
            }

            // Wait for the thread.
            if (osThread->Join(10) == kWaitStatusSuccess)
                break;
        }
    }

    void Thread::Sleep(uint32_t ms)
    {
        CurrentInternal()->handle->Sleep(ms);
    }

    bool Thread::YieldInternal()
    {
        return os::Thread::YieldInternal();
    }

    void Thread::SetDefaultAffinityMask(int64_t affinityMask)
    {
#if defined(IL2CPP_ENABLE_PLATFORM_THREAD_AFFINTY)
        os::Thread::SetDefaultAffinityMask(affinityMask);
#endif
    }

    void Thread::CheckCurrentThreadForAbortAndThrowIfNecessary()
    {
        Il2CppThread* currentThread = il2cpp::vm::Thread::Current();
        if (!currentThread)
            return;

        il2cpp::os::FastAutoLock lock(currentThread->GetInternalThread()->longlived->synch_cs);

        ThreadState state = il2cpp::vm::Thread::GetState(currentThread);
        if (!(state & kThreadStateAbortRequested))
            return;

        // Throw interrupt exception.
        Il2CppException* abortException = il2cpp::vm::Exception::GetThreadAbortException();
        IL2CPP_OBJECT_SETREF(currentThread->GetInternalThread(), abort_exc, abortException);
        il2cpp::vm::Exception::Raise(abortException);
    }

    void Thread::ResetAbort(Il2CppThread* thread)
    {
        il2cpp::vm::Thread::ClrState(thread, kThreadStateAbortRequested);
        if (thread->GetInternalThread()->abort_exc == NULL)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetThreadStateException("Unable to reset abort because no abort was requested."));
    }

    void Thread::ResetAbort(Il2CppInternalThread* thread)
    {
        il2cpp::vm::Thread::ClrState(thread, kThreadStateAbortRequested);
        if (thread->abort_exc == NULL)
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetThreadStateException("Unable to reset abort because no abort was requested."));
    }

    void Thread::FullMemoryBarrier()
    {
        os::Atomic::FullMemoryBarrier();
    }

    int32_t Thread::GetNewManagedId()
    {
        return ++s_NextManagedThreadId;
    }

    uint64_t Thread::GetId(Il2CppThread* thread)
    {
        return thread->GetInternalThread()->tid;
    }

    uint64_t Thread::GetId(Il2CppInternalThread* thread)
    {
        return thread->tid;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Thread.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ThreadPoolMs.cpp---------------
.
.
#include "il2cpp-api.h"
#include "il2cpp-config.h"
#include "utils/dynamic_array.h"
#include "vm/ThreadPoolMs.h"
#include "vm/Domain.h"
#include "vm/Array.h"
#include "vm/Object.h"
#include "vm/Runtime.h"
#include "os/Atomic.h"
#include "gc/WriteBarrier.h"
#include "mono/ThreadPool/threadpool-ms.h"

namespace il2cpp
{
namespace vm
{
    Il2CppAsyncResult* ThreadPoolMs::DelegateBeginInvoke(Il2CppDelegate* delegate, void** params, Il2CppDelegate* asyncCallback, Il2CppObject* state)
    {
        int numParams = delegate->method->parameters_count;
        il2cpp::utils::dynamic_array<void*> newParams(numParams + 2);
        for (int i = 0; i < numParams; ++i)
            newParams[i] = params[i];

        newParams[numParams] = asyncCallback;
        newParams[numParams + 1] = state;

        return threadpool_ms_begin_invoke(il2cpp::vm::Domain::GetCurrent(), (Il2CppObject*)delegate, const_cast<MethodInfo*>(delegate->method), newParams.data());
    }

    Il2CppObject* ThreadPoolMs::DelegateEndInvoke(Il2CppAsyncResult* asyncResult, void **out_args)
    {
        Il2CppArray *arrayOutArgs;
        Il2CppObject *exc, *retVal;

        retVal = threadpool_ms_end_invoke(asyncResult, &arrayOutArgs, &exc);

        if (exc)
            il2cpp_raise_exception((Il2CppException*)exc);

        if (out_args)
        {
            const MethodInfo *method = asyncResult->async_delegate->method;
            void** outArgsPtr = (void**)il2cpp_array_addr(arrayOutArgs, Il2CppObject*, 0);

            il2cpp_array_size_t arrayOutArgsIndex = 0;
            for (size_t methodParameterIndex = 0; methodParameterIndex < method->parameters_count; methodParameterIndex++)
            {
                const Il2CppType* paramType = method->parameters[methodParameterIndex];

                // Assume that arrayOutArgs only contains parameters that are passed by reference.
                if (!paramType->byref)
                    continue;
                IL2CPP_ASSERT(arrayOutArgsIndex < arrayOutArgs->max_length);
                Il2CppClass *paramClass = il2cpp_class_from_type(paramType);

                if (paramClass->byval_arg.valuetype)
                {
                    IL2CPP_ASSERT(paramClass->native_size > 0 && "EndInvoke: Invalid native_size found when trying to copy a value type in the out_args.");

                    // NOTE(gab): in case of value types, we need to copy the data over.
                    memcpy(out_args[arrayOutArgsIndex], il2cpp::vm::Object::Unbox((Il2CppObject*)outArgsPtr[arrayOutArgsIndex]), paramClass->native_size);
                }
                else
                {
                    *((void**)out_args[arrayOutArgsIndex]) = outArgsPtr[arrayOutArgsIndex];
                }
                arrayOutArgsIndex++;
            }
        }

        return retVal;
    }

    Il2CppObject* ThreadPoolMs::MessageInvoke(Il2CppObject *target, Il2CppMethodMessage *msg, Il2CppObject **exc, Il2CppArray **out_args)
    {
        static Il2CppClass *object_array_klass = NULL;
        MethodInfo *method;
        Il2CppObject *ret;
        Il2CppArray *arr;
        int i, j, outarg_count = 0;

        method = (MethodInfo*)msg->method->method;

        for (i = 0; i < method->parameters_count; i++)
        {
            if (method->parameters[i]->byref)
                outarg_count++;
        }

        if (!object_array_klass)
        {
            Il2CppClass *klass;

            klass = il2cpp_array_class_get(il2cpp_defaults.object_class, 1);
            IL2CPP_ASSERT(klass);

            os::Atomic::FullMemoryBarrier();
            object_array_klass = klass;
        }

        arr = il2cpp_array_new_specific(object_array_klass, outarg_count);

        il2cpp::gc::WriteBarrier::GenericStore(out_args, arr);
        il2cpp::gc::WriteBarrier::GenericStoreNull(exc);

        ret = vm::Runtime::InvokeArray(method, method->klass->byval_arg.valuetype ? il2cpp_object_unbox(target) : target, method->parameters_count > 0 ? msg->args : NULL, (Il2CppException**)exc);

        for (i = 0, j = 0; i < method->parameters_count; i++)
        {
            if (method->parameters[i]->byref)
            {
                Il2CppObject* arg;
                arg = (Il2CppObject*)il2cpp_array_get(msg->args, void*, i);
                il2cpp_array_setref(*out_args, j, arg);
                j++;
            }
        }

        return ret;
    }

    void ThreadPoolMs::Suspend()
    {
        threadpool_ms_suspend();
    }

    void ThreadPoolMs::Resume()
    {
        threadpool_ms_resume();
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\ThreadPoolMs.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Type.cpp---------------
.
.
#include "il2cpp-config.h"

#include <string>
#include <cstring>
#include <algorithm>
#include <ctype.h>

#include "gc/WriteBarrier.h"
#include "metadata/Il2CppTypeCompare.h"
#include "utils/StringUtils.h"
#include "vm/Assembly.h"
#include "vm/AssemblyName.h"
#include "vm/Class.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/GenericContainer.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/Object.h"
#include "vm/Reflection.h"
#include "vm/String.h"
#include "vm/Type.h"
#include "vm-utils/VmStringUtils.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-tabledefs.h"
#include "vm/Array.h"

static char* copy_name(const char* name)
{
    const size_t len = strlen(name);
    char* cname = new char[len + 1];

    strncpy(cname, name, len);

    cname[len] = '\0';

    return cname;
}

namespace il2cpp
{
namespace vm
{
    TypeNameParser::TypeNameParser(const std::string &name, TypeNameParseInfo &info, bool is_nested) :
        _info(info),
        _is_nested(is_nested),
        _accept_assembly_name(true),
        _p(name.begin()),
        _end(name.end())
    {
    }

    TypeNameParser::TypeNameParser(std::string::const_iterator &begin, std::string::const_iterator &end, TypeNameParseInfo &info, bool is_nested) :
        _info(info),
        _is_nested(is_nested),
        _accept_assembly_name(true),
        _p(begin),
        _end(end)
    {
    }

    bool TypeNameParser::Parse(bool acceptAssemblyName)
    {
        _accept_assembly_name = acceptAssemblyName;

        int32_t arity = 0;

        InitializeParser();

        if (IsEOL())
            return false;
        if (!ParseTypeName(arity))
            return false;
        if (!ParseNestedTypeOptional(arity))
            return false;
        if (!ParseTypeArgumentsOptional(arity))
            return false;
        if (!ParsePointerModifiersOptional())
            return false;
        if (!ParseArrayModifierOptional())
            return false;
        if (!ParseByRefModifiersOptional())
            return false;
        if (!ParseAssemblyNameOptional())
            return false;

        return (_p == _end) || _is_nested;
    }

    bool TypeNameParser::ParseAssembly()
    {
        InitializeParser();

        if (IsEOL())
            return false;
        if (!ParseAssemblyName())
            return false;

        return true;
    }

    bool TypeNameParser::ParseTypeName(int32_t &arity)
    {
        std::string::const_iterator begin = _p;
        std::string::const_iterator last_dot = _end;

        while (true)
        {
            ConsumeIdentifier();

            if (!CurrentIs('.'))
                break;

            last_dot = _p;

            if (!Next())
                return false; // Invalid format
        }

        if (CurrentIs('`'))
        {
            if (!Next())
                return false; // Invalid format

            if (!ConsumeNumber(arity))
                return false; // Invalid format
        }

        if (last_dot == _end)
        {
            _info._name.assign(begin, _p);
        }
        else
        {
            _info._namespace.assign(begin, last_dot);
            _info._name.assign(last_dot + 1, _p);
        }

        return true;
    }

    bool TypeNameParser::ParseNestedTypeOptional(int32_t &arity)
    {
        while (CurrentIs('+'))
        {
            if (!Next())
                return false; // Invalid format

            std::string::const_iterator begin = _p;

            ConsumeIdentifier();

            if (CurrentIs('`'))
            {
                if (!Next())
                    return false; // Invalid format

                int32_t nested_arity = 0;

                if (!ConsumeNumber(nested_arity))
                    return false; // Invalid format

                arity += nested_arity;
            }

            _info._nested.push_back(std::string(begin, _p));
        }

        return true;
    }

    bool TypeNameParser::ParsePointerModifiersOptional()
    {
        if (IsEOL())
            return true;

        while (CurrentIs('*'))
        {
            _info._modifiers.push_back(-1);
            if (!Next(true))
                break;
        }

        return true;
    }

    bool TypeNameParser::ParseByRefModifiersOptional()
    {
        if (IsEOL())
            return true;

        if (CurrentIs('&'))
        {
            if (std::find(_info._modifiers.begin(), _info._modifiers.end(), 0) != _info._modifiers.end())
                return false; // Invalid format, already marked as reference

            _info._modifiers.push_back(0);

            Next(true);
        }

        return true;
    }

    bool TypeNameParser::ParseTypeArgumentsOptional(int32_t &arity)
    {
        SkipWhites();

        if (IsEOL())
            return true;

        if (!CurrentIs('['))
            return true;

        if (NextWillBe(']', true) || NextWillBe(',', true) || NextWillBe('*', true))
            return true;

        if (!Next(true))
            return false; // Invalid format

        _info._type_arguments.reserve(arity);

        while (true)
        {
            bool acceptAssemblyName = false;

            if (CurrentIs('['))
            {
                acceptAssemblyName = true;

                if (!Next(true))
                    return false; // Invalid format
            }

            TypeNameParseInfo info;
            TypeNameParser parser(_p, _end, info, true);

            if (!parser.Parse(acceptAssemblyName))
                return false; // Invalid format

            _p = parser._p;

            _info._type_arguments.push_back(info);

            SkipWhites();

            if (IsEOL())
                return false; // Invalid format

            if (acceptAssemblyName)
            {
                if (!CurrentIs(']'))
                    return false; // Invalid format

                if (!Next(true))
                    return false; // Invalid format
            }

            if (CurrentIs(']'))
                break;

            if (CurrentIs(','))
            {
                if (!Next(true))
                    return false; // Invalid format
            }
            else
            {
                return false; // Invalid format
            }
        }

        if (_info._type_arguments.size() != arity)
            return false; // Invalid format

        Next(true);

        return true;
    }

    bool TypeNameParser::ParseArrayModifierOptional()
    {
        SkipWhites();

        if (IsEOL())
            return true;

        if (!CurrentIs('['))
            return true;

        if (!NextWillBe(']', true) && !NextWillBe(',', true) && !NextWillBe('*', true))
            return true;

        if (!Next(true))
            return false; // Invalid format

        int32_t rank = 1;

        while (true)
        {
            if (CurrentIs(']'))
            {
                Next(true);
                break;
            }
            else if (CurrentIs(','))
            {
                ++rank;
                if (!Next(true))
                    return false; // invalid format
            }
            else if (CurrentIs('*'))
            {
                _info._modifiers.push_back(-2);

                if (!Next(true))
                    return false; // invalid format
            }
            else
            {
                return false; // invalid format
            }
        }

        _info._modifiers.push_back(rank);

        // This is to support arrays of array
        return ParseArrayModifierOptional();
    }

    bool TypeNameParser::ParseAssemblyNameOptional()
    {
        if (!_accept_assembly_name)
            return true;

        if (!CurrentIs(','))
            return true;

        if (!Next())
            return false; // Invalid format

        SkipWhites();

        return ParseAssemblyName();
    }

    bool TypeNameParser::ParseAssemblyName()
    {
        std::string::const_iterator begin = _p;

        ConsumeAssemblyIdentifier();

        _info._assembly_name.name.assign(begin, _p);

        SkipWhites();

        ParsePropertiesOptional();

        return true;
    }

    bool TypeNameParser::ParsePropertiesOptional()
    {
        while (CurrentIs(','))
        {
            if (!Next(true))
                return false; // Invalid format

            std::string::const_iterator begin = _p;
            ConsumePropertyIdentifier();
            std::string propertyName(begin, _p);
            utils::VmStringUtils::CaseInsensitiveComparer propertyNameComparer;

            if (!CurrentIs('='))
                return false;

            if (!Next())
                return false; // Invalid format

            begin = _p;
            ConsumePropertyValue();
            std::string propertyValue(begin, _p);

            if (propertyNameComparer(propertyName, "version"))
            {
                if (!ParseVersion(propertyValue, _info._assembly_name.major, _info._assembly_name.minor, _info._assembly_name.build, _info._assembly_name.revision))
                    return false;
            }
            else if (propertyNameComparer(propertyName.c_str(), "publickey"))
            {
                if (!propertyNameComparer(propertyValue, "null"))
                    _info._assembly_name.public_key = propertyValue;
            }
            else if (propertyNameComparer(propertyName.c_str(), "publickeytoken"))
            {
                if (!propertyNameComparer(propertyValue, "null"))
                {
                    if ((kPublicKeyTokenLength - 1) != propertyValue.size())
                        return false;
                    strncpy(_info._assembly_name.public_key_token, propertyValue.c_str(), kPublicKeyTokenLength);
                }
            }
            else if (propertyNameComparer(propertyName.c_str(), "culture"))
            {
                _info._assembly_name.culture = propertyValue;
            }
            else if (propertyNameComparer(propertyName.c_str(), "contenttype"))
            {
                // If content type is WindowsRuntime, coerse assembly name into WindowsRuntimeMetadata if it's not that (otherwise preserve its casing)
                if (propertyNameComparer(propertyValue, "windowsruntime") && !propertyNameComparer(_info._assembly_name.name.c_str(), "windowsruntimemetadata"))
                    _info._assembly_name.name = "WindowsRuntimeMetadata";
            }
            else
            {
                return false;
            }
        }

        return true;
    }

    bool TypeNameParser::ParseVersion(const std::string& version, uint16_t& major, uint16_t& minor, uint16_t& build, uint16_t& revision)
    {
        size_t start = 0;
        size_t index = version.find('.');
        if (-1 == index)
            return false;
        std::string component = version.substr(start, index - start);
        major = atoi(component.c_str());

        start = index + 1;
        index = version.find('.', start);
        if (-1 == index)
            return false;
        component = version.substr(start, index - start);
        minor = atoi(component.c_str());

        start = index + 1;
        index = version.find('.', start);
        if (-1 == index)
            return false;
        component = version.substr(start, index - start);
        build = atoi(component.c_str());

        start = index + 1;
        component = version.substr(start, version.size() - start);
        revision = atoi(component.c_str());

        return true;
    }

    bool TypeNameParser::NextWillBe(char v, bool skipWhites) const
    {
        if (IsEOL())
            return false;

        int32_t i = 1;
        if (skipWhites)
        {
            if ((*(_p + i) == ' ') || (*(_p + i) == '\t'))
                ++i;

            if ((_p + i) >= _end)
                return false;
        }

        return *(_p + i) == v;
    }

    bool TypeNameParser::ConsumeNumber(int32_t &value)
    {
        if (!isdigit(*_p))
            return false;

        std::string::const_iterator begin = _p;

        while (isdigit(*_p))
        {
            if (!Next())
                break;
        }

        value = (int32_t)strtol(&(*begin), NULL, 10);

        return true;
    }

    void TypeNameParser::ConsumeAssemblyIdentifier()
    {
        do
        {
            switch (*_p)
            {
                case ',':
                case '+':
                case '&':
                case '*':
                case '[':
                case ']':
                case '=':
                case '"':
                case '`':
                    return;

                case '\\':
                    Next();
                    break;
            }
        }
        while (Next());
    }

    void TypeNameParser::ConsumePropertyIdentifier()
    {
        do
        {
            switch (*_p)
            {
                case '=':
                    return;
            }
        }
        while (Next());
    }

    void TypeNameParser::ConsumePropertyValue()
    {
        do
        {
            switch (*_p)
            {
                case ',':
                case ']':
                    return;
            }
        }
        while (Next());
    }

    void TypeNameParser::ConsumeIdentifier()
    {
        do
        {
            switch (*_p)
            {
                case ',':
                case '+':
                case '&':
                case '*':
                case '[':
                case ']':
                case '.':
                case '=':
                case '"':
                case '`':
                    return;

                case '\\':
                    Next();
                    break;
            }
        }
        while (Next());
    }

    void TypeNameParser::InitializeParser()
    {
        SkipWhites();
    }

    void TypeNameParser::SkipWhites()
    {
        while ((CurrentIs(' ') || CurrentIs('\t')) && !IsEOL())
            ++_p;
    }

    TypeNameParseInfo::TypeNameParseInfo()
    {
    }

    TypeNameParseInfo::~TypeNameParseInfo()
    {
        _type_arguments.clear();
        _modifiers.clear();
        _nested.clear();
    }

    int Type::GetType(const Il2CppType *type)
    {
        return type->type;
    }

    void Type::GetNameInternal(std::string &str, const Il2CppType *type, Il2CppTypeNameFormat format, bool is_nested)
    {
        switch (type->type)
        {
            case IL2CPP_TYPE_ARRAY:
            {
                Il2CppClass* arrayClass = Class::FromIl2CppType(type);
                Il2CppClass* elementClass = Class::GetElementClass(arrayClass);
                Type::GetNameInternal(
                    str,
                    &elementClass->byval_arg,
                    format >= IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED ? IL2CPP_TYPE_NAME_FORMAT_FULL_NAME : format,
                    false);

                str += '[';

                if (arrayClass->rank == 1)
                    str += '*';

                for (int32_t i = 1; i < arrayClass->rank; i++)
                    str += ',';

                str += ']';

                if (type->byref)
                    str += '&';

                if (format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED)
                {
                    const Il2CppAssembly* ta = elementClass->image->assembly;
                    str += ", " + vm::AssemblyName::AssemblyNameToString(ta->aname);
                }
                else if (format == IL2CPP_TYPE_NAME_FORMAT_REFLECTION_QUALIFIED)
                {
                    str += ", ";
                    str.append(elementClass->image->nameNoExt);
                }


                break;
            }

            case IL2CPP_TYPE_SZARRAY:
            {
                Il2CppClass* elementClass = Class::FromIl2CppType(type->data.type);
                Type::GetNameInternal(
                    str,
                    &elementClass->byval_arg,
                    format >= IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED ? IL2CPP_TYPE_NAME_FORMAT_FULL_NAME : format,
                    false);

                str += "[]";

                if (type->byref)
                    str += '&';

                if (format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED)
                {
                    const Il2CppAssembly *ta = elementClass->image->assembly;
                    str += ", " + vm::AssemblyName::AssemblyNameToString(ta->aname);
                }
                else if (format == IL2CPP_TYPE_NAME_FORMAT_REFLECTION_QUALIFIED)
                {
                    str += ", ";
                    str.append(elementClass->image->nameNoExt);
                }
                break;
            }

            case IL2CPP_TYPE_PTR:
            {
                Type::GetNameInternal(
                    str,
                    type->data.type,
                    format >= IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED ? IL2CPP_TYPE_NAME_FORMAT_FULL_NAME : format,
                    false);

                str += '*';

                if (type->byref)
                    str += '&';

                if (format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED)
                {
                    const Il2CppAssembly *ta = Class::FromIl2CppType(type->data.type)->image->assembly;
                    str += ", " + vm::AssemblyName::AssemblyNameToString(ta->aname);
                }
                else if (format == IL2CPP_TYPE_NAME_FORMAT_REFLECTION_QUALIFIED)
                {
                    str += ", ";
                    str.append(Class::FromIl2CppType(type->data.type)->image->nameNoExt);
                }
                break;
            }

            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:

                str += MetadataCache::GetGenericParameterName(Type::GetGenericParameterHandle(type));
                if (type->byref)
                    str += '&';
                break;

            default:
            {
                Il2CppClass *klass = Class::FromIl2CppType(type);
                Class::Init(klass);

                Il2CppClass* declaringType = Class::GetDeclaringType(klass);
                if (declaringType)
                {
                    Type::GetNameInternal(str, &declaringType->byval_arg, format, true);
                    str += (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '.' : '+');
                }
                else if (*klass->namespaze)
                {
                    str += klass->namespaze;
                    str += '.';
                }

                if (format == IL2CPP_TYPE_NAME_FORMAT_IL)
                {
                    const char *s = strchr(klass->name, '`');
                    str += (s ? std::string(klass->name, s) : klass->name);
                }
                else
                    str += klass->name;

                if (is_nested)
                    break;

                if (klass->generic_class)
                {
                    Il2CppGenericClass *gclass = klass->generic_class;
                    const Il2CppGenericInst *inst = gclass->context.class_inst;
                    Il2CppTypeNameFormat nested_format;

                    nested_format = format == IL2CPP_TYPE_NAME_FORMAT_FULL_NAME ? IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED : format;

                    str += (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '<' : '[');

                    for (uint32_t i = 0; i < inst->type_argc; i++)
                    {
                        const Il2CppType *t = inst->type_argv[i];

                        if (i)
                            str += ',';

                        if ((format >= IL2CPP_TYPE_NAME_FORMAT_FULL_NAME) && (t->type != IL2CPP_TYPE_VAR) && (type->type != IL2CPP_TYPE_MVAR))
                            str += '[';

                        Type::GetNameInternal(str, inst->type_argv[i], nested_format, false);

                        if ((format >= IL2CPP_TYPE_NAME_FORMAT_FULL_NAME) && (t->type != IL2CPP_TYPE_VAR) && (type->type != IL2CPP_TYPE_MVAR))
                            str += ']';
                    }

                    str += (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '>' : ']');
                }
                else if (Class::IsGeneric(klass) && format < IL2CPP_TYPE_NAME_FORMAT_FULL_NAME)
                {
                    Il2CppMetadataGenericContainerHandle containerHandle = Class::GetGenericContainer(klass);

                    str += (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '<' : '[');

                    uint32_t type_argc = MetadataCache::GetGenericContainerCount(containerHandle);
                    for (uint32_t i = 0; i < type_argc; i++)
                    {
                        if (i)
                            str += ',';

                        Il2CppMetadataGenericParameterHandle handle = MetadataCache::GetGenericParameterFromIndex(containerHandle, i);
                        const char* name = MetadataCache::GetGenericParameterName(handle);
                        str += name;
                    }

                    str += (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '>' : ']');
                }

                if (type->byref)
                    str += '&';

                if ((format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED) && (type->type != IL2CPP_TYPE_VAR) && (type->type != IL2CPP_TYPE_MVAR))
                {
                    const Il2CppAssembly *ta = klass->image->assembly;
                    str += ", " + vm::AssemblyName::AssemblyNameToString(ta->aname);
                }
                else if (format == IL2CPP_TYPE_NAME_FORMAT_REFLECTION_QUALIFIED)
                {
                    str += ", ";
                    str.append(klass->image->nameNoExt);
                }

                break;
            }
        }
    }

    std::string Type::GetName(const Il2CppType *type, Il2CppTypeNameFormat format)
    {
        std::string str;
        Type::GetNameInternal(str, type, format, false);
        return str;
    }

    enum
    {
        //max digits on uint16 is 5(used to convert the number of generic args) + max 3 other slots taken;
        kNameChunkBufferSize = 8
    };

    static inline char* flushChunkBuffer(char* buffer, void(*chunkReportFunc)(void*data, void* userData), void* userData)
    {
        chunkReportFunc(buffer, userData);
        memset(buffer, 0x00, kNameChunkBufferSize);

        return buffer;
    }

    void Type::GetNameChunkedRecurseInternal(const Il2CppType *type, Il2CppTypeNameFormat format, bool is_nested, void(*chunkReportFunc)(void*data, void* userData), void* userData)
    {
        char buffer[kNameChunkBufferSize + 1]; //null terminate the buffer
        memset(buffer, 0x00, kNameChunkBufferSize + 1);
        char* bufferPtr = buffer;
        char* bufferIter = bufferPtr;

        switch (type->type)
        {
            case IL2CPP_TYPE_ARRAY:
            {
                Il2CppClass* arrayClass = Class::FromIl2CppType(type);
                Il2CppClass* elementClass = Class::GetElementClass(arrayClass);
                Type::GetNameChunkedRecurseInternal(
                    &elementClass->byval_arg,
                    format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED ? IL2CPP_TYPE_NAME_FORMAT_FULL_NAME : format,
                    false, chunkReportFunc, userData);

                *bufferIter++ = '[';

                if (arrayClass->rank == 1)
                    *bufferIter++ = '*';

                for (int32_t i = 1; i < arrayClass->rank; i++)
                {
                    *bufferIter++ = ',';
                    if (kNameChunkBufferSize - (bufferIter - bufferPtr) < 2)
                    {
                        bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                    }
                }

                *bufferIter++ = ']';

                if (type->byref)
                    *bufferIter++ = '&';

                bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                if (format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED)
                {
                    const Il2CppAssembly *ta = elementClass->image->assembly;
                    *bufferIter++ = ',';
                    chunkReportFunc(bufferPtr, userData);

                    //change this to call the callback
                    vm::AssemblyName::AssemblyNameReportChunked(ta->aname, chunkReportFunc, userData);
                }

                break;
            }

            case IL2CPP_TYPE_SZARRAY:
            {
                Il2CppClass* elementClass = Class::FromIl2CppType(type->data.type);
                Type::GetNameChunkedRecurseInternal(
                    &elementClass->byval_arg,
                    format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED ? IL2CPP_TYPE_NAME_FORMAT_FULL_NAME : format,
                    false, chunkReportFunc, userData);

                *bufferIter++ = '[';
                *bufferIter++ = ']';

                if (type->byref)
                    *bufferIter++ = '&';

                bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                if (format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED)
                {
                    const Il2CppAssembly *ta = elementClass->image->assembly;
                    *bufferIter++ = ',';
                    chunkReportFunc(bufferPtr, userData);
                    //change this to call the callback
                    vm::AssemblyName::AssemblyNameReportChunked(ta->aname, chunkReportFunc, userData);
                }
                break;
            }

            case IL2CPP_TYPE_PTR:
            {
                Type::GetNameChunkedRecurseInternal(
                    type->data.type,
                    format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED ? IL2CPP_TYPE_NAME_FORMAT_FULL_NAME : format,
                    false, chunkReportFunc, userData);

                *bufferIter++ = '*';

                if (type->byref)
                    *bufferIter++ = '&';

                bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                if (format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED)
                {
                    const Il2CppAssembly *ta = Class::FromIl2CppType(type->data.type)->image->assembly;
                    *bufferIter++ = ',';
                    chunkReportFunc(bufferPtr, userData);
                    //change this to call the callback
                    vm::AssemblyName::AssemblyNameReportChunked(ta->aname, chunkReportFunc, userData);
                }
                break;
            }

            case IL2CPP_TYPE_VAR:
            case IL2CPP_TYPE_MVAR:
                chunkReportFunc(const_cast<char*>(MetadataCache::GetGenericParameterName(Type::GetGenericParameterHandle(type))), userData);

                if (type->byref)
                {
                    *bufferIter++ = '&';
                    chunkReportFunc(bufferPtr, userData);
                }
                break;

            default:
            {
                Il2CppClass *klass = Class::FromIl2CppType(type);
                Class::Init(klass);

                Il2CppClass* declaringType = Class::GetDeclaringType(klass);
                if (declaringType)
                {
                    Type::GetNameChunkedRecurseInternal(&declaringType->byval_arg, format, true, chunkReportFunc, userData);
                    *bufferIter++ = (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '.' : '+');
                }
                else if (*klass->namespaze)
                {
                    chunkReportFunc(const_cast<char*>(klass->namespaze), userData);
                    *bufferIter++ = '.';
                }

                if (format == IL2CPP_TYPE_NAME_FORMAT_IL)
                {
                    const char *s = strchr(klass->name, '`');
                    size_t len = s ? s - klass->name : strlen(klass->name);

                    for (size_t i = 0; i < len; ++i)
                    {
                        *bufferIter++ = *(klass->name + i);
                        if (kNameChunkBufferSize - (bufferIter - bufferPtr) == 0)
                        {
                            bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                        }
                    }
                }
                else
                    chunkReportFunc(const_cast<char*>(klass->name), userData);

                if (bufferPtr != bufferIter)
                {
                    bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                }

                if (is_nested)
                    break;

                if (klass->generic_class)
                {
                    Il2CppGenericClass *gclass = klass->generic_class;
                    const Il2CppGenericInst *inst = gclass->context.class_inst;
                    Il2CppTypeNameFormat nested_format;

                    nested_format = format == IL2CPP_TYPE_NAME_FORMAT_FULL_NAME ? IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED : format;

                    *bufferIter++ = (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '<' : '[');

                    for (uint32_t i = 0; i < inst->type_argc; i++)
                    {
                        const Il2CppType *t = inst->type_argv[i];

                        if (i)
                            *bufferIter++ = ',';

                        if ((nested_format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED) && (t->type != IL2CPP_TYPE_VAR) && (type->type != IL2CPP_TYPE_MVAR))
                            *bufferIter++ = '[';
                        bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                        Type::GetNameChunkedRecurseInternal(inst->type_argv[i], nested_format, false, chunkReportFunc, userData);

                        if ((nested_format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED) && (t->type != IL2CPP_TYPE_VAR) && (type->type != IL2CPP_TYPE_MVAR))
                            *bufferIter++ = ']';
                    }

                    *bufferIter++ = (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '>' : ']');
                }
                else if (Class::IsGeneric(klass) && (format != IL2CPP_TYPE_NAME_FORMAT_FULL_NAME) && (format != IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED))
                {
                    Il2CppMetadataGenericContainerHandle containerHandle = Class::GetGenericContainer(klass);

                    *bufferIter++ = (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '<' : '[');

                    uint32_t type_argc = MetadataCache::GetGenericContainerCount(containerHandle);
                    for (uint32_t i = 0; i < type_argc; ++i)
                    {
                        if (i)
                            *bufferIter++ = ',';
                        Il2CppMetadataGenericParameterHandle handle = GenericContainer::GetGenericParameter(containerHandle, i);
                        const char* idxStr = MetadataCache::GetGenericParameterName(handle);
                        size_t len = strlen(idxStr);
                        for (size_t l = 0; l < len; ++l)
                        {
                            *bufferIter++ = *(idxStr + l);
                            if (kNameChunkBufferSize - (bufferIter - bufferPtr) < 2)
                            //make sure there's at least 2 slots empty to
                            //accommodate the worst case scenario until we flush
                            {
                                bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                            }
                        }
                    }

                    *bufferIter++ = (format == IL2CPP_TYPE_NAME_FORMAT_IL ? '>' : ']');
                }

                if (type->byref)
                    *bufferIter++ = '&';

                bufferIter = flushChunkBuffer(bufferPtr, chunkReportFunc, userData);
                if ((format == IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED) && (type->type != IL2CPP_TYPE_VAR) && (type->type != IL2CPP_TYPE_MVAR))
                {
                    const Il2CppAssembly *ta = klass->image->assembly;
                    *bufferIter++ = ',';
                    chunkReportFunc(bufferPtr, userData);
                    //change this to call the callback
                    vm::AssemblyName::AssemblyNameReportChunked(ta->aname, chunkReportFunc, userData);
                }
                break;
            }
        }
    }

    void Type::GetNameChunkedRecurse(const Il2CppType *type, Il2CppTypeNameFormat format, void(*reportFunc)(void*data, void* userData), void* userData)
    {
        GetNameChunkedRecurseInternal(type, format, false, reportFunc, userData);
    }

    Il2CppClass* Type::GetClassOrElementClass(const Il2CppType *type)
    {
        // This is a weird function to mimic old mono behaviour.
        // We incorrectly used the analogous mono function in Unity.
        // Expectations: Return class if type is not an array. Return element type if it is an array.
        if (type->type == IL2CPP_TYPE_ARRAY)
            return Class::FromIl2CppType(type->data.array->etype);

        if (type->type == IL2CPP_TYPE_SZARRAY)
            return Class::FromIl2CppType(type->data.type);

        // IL2CPP_TYPE_SZARRAY stores element class in klass
        return Class::FromIl2CppType(type);
    }

    const Il2CppType* Type::GetUnderlyingType(const Il2CppType *type)
    {
        if (type->type == IL2CPP_TYPE_VALUETYPE && !type->byref && MetadataCache::GetTypeInfoFromType(type)->enumtype)
            return Class::GetEnumBaseType(MetadataCache::GetTypeInfoFromType(type));
        if (IsGenericInstance(type))
        {
            Il2CppClass* definition = GenericClass::GetTypeDefinition(type->data.generic_class);
            if (definition != NULL && definition->enumtype && !type->byref)
                return Class::GetEnumBaseType(definition);
        }
        return type;
    }

    bool Type::IsGenericInstance(const Il2CppType* type)
    {
        return type->type == IL2CPP_TYPE_GENERICINST;
    }

    bool Type::IsGenericParameter(const Il2CppType* type)
    {
        return type->type == IL2CPP_TYPE_VAR || type->type == IL2CPP_TYPE_MVAR;
    }

    Il2CppClass* Type::GetDeclaringType(const Il2CppType* type)
    {
        Il2CppClass *typeInfo = NULL;

        if (type->byref)
            return NULL;
        if (type->type == IL2CPP_TYPE_VAR || type->type == IL2CPP_TYPE_MVAR)
            return MetadataCache::GetParameterDeclaringType(GetGenericParameterHandle(type));
        return Class::GetDeclaringType(Class::FromIl2CppType(type));
    }

    const MethodInfo* Type::GetDeclaringMethod(const Il2CppType* type)
    {
        if (type->byref)
            return NULL;

        if (type->type == IL2CPP_TYPE_MVAR)
        {
            const MethodInfo* methodInfo = MetadataCache::GetParameterDeclaringMethod(GetGenericParameterHandle(type));
            return methodInfo;
        }

        return NULL;
    }

    Il2CppArray* Type::GetGenericArgumentsInternal(Il2CppReflectionType* type, bool runtimeArray)
    {
        Il2CppArray *res;
        Il2CppClass *klass, *pklass;

        klass = Class::FromIl2CppType(type->type);

        Il2CppClass *arrType = runtimeArray ? il2cpp_defaults.runtimetype_class : il2cpp_defaults.systemtype_class;

        if (Class::IsGeneric(klass))
        {
            uint32_t type_argc = MetadataCache::GetGenericContainerCount(klass->genericContainerHandle);
            res = Array::New(arrType, type_argc);
            for (uint32_t i = 0; i < type_argc; ++i)
            {
                pklass = Class::FromGenericParameter(GenericContainer::GetGenericParameter(klass->genericContainerHandle, i));
                il2cpp_array_setref(res, i, Reflection::GetTypeObject(&pklass->byval_arg));
            }
        }
        else if (klass->generic_class)
        {
            const Il2CppGenericInst *inst = klass->generic_class->context.class_inst;
            res = Array::New(arrType, inst->type_argc);
            for (uint32_t i = 0; i < inst->type_argc; ++i)
                il2cpp_array_setref(res, i, Reflection::GetTypeObject(inst->type_argv[i]));
        }
        else
        {
            res = Array::New(arrType, 0);
        }
        return res;
    }

    bool Type::IsEqualToType(const Il2CppType *type, const Il2CppType *otherType)
    {
        return ::il2cpp::metadata::Il2CppTypeEqualityComparer::AreEqual(type, otherType);
    }

    Il2CppReflectionType* Type::GetTypeFromHandle(intptr_t handle)
    {
        const Il2CppType* type = (const Il2CppType*)handle;
        Il2CppClass *klass = vm::Class::FromIl2CppType(type);

        return il2cpp::vm::Reflection::GetTypeObject(&klass->byval_arg);
    }

    uint32_t Type::GetToken(const Il2CppType *type)
    {
        if (IsGenericInstance(type))
            return GenericClass::GetTypeDefinition(type->data.generic_class)->token;
        return GetClass(type)->token;
    }

    bool Type::IsReference(const Il2CppType* type)
    {
        if (type->type == IL2CPP_TYPE_STRING ||
            type->type == IL2CPP_TYPE_SZARRAY ||
            type->type == IL2CPP_TYPE_CLASS ||
            type->type == IL2CPP_TYPE_OBJECT ||
            type->type == IL2CPP_TYPE_ARRAY)
            return true;

        if (IsGenericInstance(type) && !GenericClass::IsValueType(type->data.generic_class))
            return true;

        return false;
    }

    bool Type::IsStruct(const Il2CppType* type)
    {
        if (type->byref)
            return false;

        if (type->type == IL2CPP_TYPE_VALUETYPE && !MetadataCache::GetTypeInfoFromType(type)->enumtype)
            return true;

        if (type->type == IL2CPP_TYPE_TYPEDBYREF)
            return true;

        if (IsGenericInstance(type) &&
            GenericClass::IsValueType(type->data.generic_class) &&
            !GenericClass::IsEnum(type->data.generic_class))
            return true;

        return false;
    }

    bool Type::HasVariableRuntimeSizeWhenFullyShared(const Il2CppType* type)
    {
        // This needs to align with TypeRuntimeStoage::RuntimeFieldLayout

        // Anything passed by ref is pointer sized
        if (type->byref)
            return false;

        // Any generic parameter that is not constrained to be a reference type would be fully shared
        if (IsGenericParameter(type))
            return MetadataCache::IsReferenceTypeGenericParameter(MetadataCache::GetGenericParameterFromType(type)) != GenericParameterRestrictionReferenceType;

        // If a reference type or pointer then we aren't variable sized
        if (!IsValueType(type))
            return false;

        Il2CppClass* klass = Class::FromIl2CppType(type);

        // If we're not a generic instance or generic type definition then we'll be a concrete type
        if (!vm::Class::IsInflated(klass) && !vm::Class::IsGeneric(klass))
            return false;

        FieldInfo* field;
        void* iter = NULL;
        while ((field = Class::GetFields(klass, &iter)))
        {
            if (Field::IsInstance(field) && HasVariableRuntimeSizeWhenFullyShared(Field::GetType(field)))
                return true;
        }

        return false;
    }

    bool Type::IsArray(const Il2CppType *type)
    {
        return type->type == IL2CPP_TYPE_SZARRAY || type->type == IL2CPP_TYPE_ARRAY;
    }

    bool Type::IsEnum(const Il2CppType *type)
    {
        if (type->type != IL2CPP_TYPE_VALUETYPE)
            return false;

        Il2CppClass* klass = GetClass(type);
        return klass->enumtype;
    }

    bool Type::IsPointerType(const Il2CppType *type)
    {
        return type->type == IL2CPP_TYPE_PTR;
    }

    bool Type::IsSystemDBNull(const Il2CppType *type)
    {
        Il2CppClass* klass = GetClass(type);
        return (klass->image == il2cpp_defaults.corlib && strcmp(klass->namespaze, "System") == 0 && strcmp(klass->name, "DBNull") == 0);
    }

    bool Type::IsSystemDateTime(const Il2CppType *type)
    {
        Il2CppClass* klass = GetClass(type);
        return (klass->image == il2cpp_defaults.corlib && strcmp(klass->namespaze, "System") == 0 && strcmp(klass->name, "DateTime") == 0);
    }

    bool Type::IsSystemDecimal(const Il2CppType *type)
    {
        Il2CppClass* klass = GetClass(type);
        return (klass->image == il2cpp_defaults.corlib && strcmp(klass->namespaze, "System") == 0 && strcmp(klass->name, "Decimal") == 0);
    }

    Il2CppClass* Type::GetClass(const Il2CppType *type)
    {
        IL2CPP_ASSERT(type->type == IL2CPP_TYPE_CLASS || type->type == IL2CPP_TYPE_VALUETYPE);
        return MetadataCache::GetTypeInfoFromType(type);
    }

    Il2CppMetadataGenericParameterHandle Type::GetGenericParameterHandle(const Il2CppType *type)
    {
        return MetadataCache::GetGenericParameterFromType(type);
    }

    Il2CppGenericParameterInfo Type::GetGenericParameterInfo(const Il2CppType *type)
    {
        return MetadataCache::GetGenericParameterInfo(MetadataCache::GetGenericParameterFromType(type));
    }

    const Il2CppType* Type::GetGenericTypeDefintion(const Il2CppType* type)
    {
        if (IsGenericInstance(type))
            return type->data.generic_class->type;
        return type;
    }

    static void InvokeDelegateConstructor(Il2CppDelegate* delegate, Il2CppObject* target, const MethodInfo* method)
    {
        typedef void (*DelegateCtor)(Il2CppDelegate* delegate, Il2CppObject* target, intptr_t method, MethodInfo* hiddenMethodInfo);
        const MethodInfo* ctor = Class::GetMethodFromName(delegate->object.klass, ".ctor", 2);
        void* ctorArgs[2] = {target, (void*)&method};
        ctor->invoker_method(ctor->methodPointer, ctor, delegate, ctorArgs, NULL);
    }

/**
* Type::ConstructClosedDelegate:
* @delegate: pointer to an uninitialized delegate object
* @target: target object
* @addr: pointer to native code
* @method: method
*
* Initialize a closed delegate and set a specific function, not the one
* associated with method.  This is useful for pinvoke/marshaling cases
* where addr is pointer to a marshaling helper, not the actual method
*/
    void Type::ConstructClosedDelegate(Il2CppDelegate* delegate, Il2CppObject* target, Il2CppMethodPointer addr, const MethodInfo* method)
    {
        InvokeDelegateConstructor(delegate, target, method);
        SetClosedDelegateInvokeMethod(delegate, target, addr);
    }

    void Type::SetClosedDelegateInvokeMethod(Il2CppDelegate* delegate, Il2CppObject* target, Il2CppMethodPointer addr)
    {
        // For a closed delegate we set our invoke_impl to the method we want to invoke and the "this" we'll pass to the invoke_impl to the target
        // This reduces the cost of a closed delegate call to normal virtual call
        delegate->method_ptr = addr;
        delegate->invoke_impl = addr;
        delegate->invoke_impl_this = target;
    }

/**
* Type::ConstructDelegate:
* @delegate: pointer to an uninitialized delegate object
* @target: target object
* @method: method
*
* Construct a delegate to a method at runtime
*/
    void Type::ConstructDelegate(Il2CppDelegate* delegate, Il2CppObject* target, const MethodInfo* method)
    {
        IL2CPP_ASSERT(delegate);

        if (method)
        {
            bool isVirtualMethod = method->slot != kInvalidIl2CppMethodSlot && !(method->flags & METHOD_ATTRIBUTE_FINAL);
            if (isVirtualMethod && target != NULL)
                method = il2cpp::vm::Object::GetVirtualMethod(target, method);
            else
                delegate->method_is_virtual = isVirtualMethod;
        }

        InvokeDelegateConstructor(delegate, target, method);

        // If we are creating an open delegate on a value type instance method we do not want the adjuster thunk
        // that the ctor will choose, so override it with the direct method
        if (target == NULL && method != NULL && Class::IsValuetype(method->klass))
            delegate->method_ptr = method->methodPointer;
    }

    Il2CppString* Type::AppendAssemblyNameIfNecessary(Il2CppString* typeName, const MethodInfo* callingMethod)
    {
        if (typeName != NULL)
        {
            std::string name = utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(typeName));

            il2cpp::vm::TypeNameParseInfo info;
            il2cpp::vm::TypeNameParser parser(name, info, false);

            if (parser.Parse())
            {
                if (info.assembly_name().name.empty())
                {
                    std::string assemblyQualifiedName;
                    assemblyQualifiedName = name + ", " + callingMethod->klass->image->name;
                    return vm::String::New(assemblyQualifiedName.c_str());
                }
            }
        }

        return typeName;
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\Type.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\VisualizerHelpers.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"

#include "vm/GlobalMetadataFileInternals.h"

#if _MSC_VER

// These structs aren't actually used anywhere, but they are used by the VS debugger visualizer to help visualize various types
namespace VisualizerHelpers
{
    struct Il2CppRawTypeName
    {
        Il2CppClass t;
    };

    struct Il2CppRawTypeNameWithoutDeclaringType
    {
        Il2CppClass t;
    };

    struct Il2CppGenericParameters_DeclaringTypeHas0Parameters
    {
        Il2CppGenericContainer c;
    };

    struct Il2CppGenericParameters_DeclaringTypeHas1Parameters
    {
        Il2CppGenericContainer c;
    };

    struct Il2CppGenericParameters_DeclaringTypeHas2Parameters
    {
        Il2CppGenericContainer c;
    };

    struct Il2CppGenericParameters_DeclaringTypeHas3Parameters
    {
        Il2CppGenericContainer c;
    };

    struct Il2CppGenericParameters_DeclaringTypeHas4Parameters
    {
        Il2CppGenericContainer c;
    };

    struct Il2CppGenericParameters_DeclaringTypeHas5Parameters
    {
        Il2CppGenericContainer c;
    };

    struct Il2CppGenericParameters
    {
        Il2CppGenericContainer c;
    };

    struct Il2CppGenericArguments_DeclaringTypeHas0Arguments
    {
        Il2CppGenericInst gi;
    };

    struct Il2CppGenericArguments_DeclaringTypeHas1Arguments
    {
        Il2CppGenericInst gi;
    };

    struct Il2CppGenericArguments_DeclaringTypeHas2Arguments
    {
        Il2CppGenericInst gi;
    };

    struct Il2CppGenericArguments_DeclaringTypeHas3Arguments
    {
        Il2CppGenericInst gi;
    };

    struct Il2CppGenericArguments_DeclaringTypeHas4Arguments
    {
        Il2CppGenericInst gi;
    };

    struct Il2CppGenericArguments_DeclaringTypeHas5Arguments
    {
        Il2CppGenericInst gi;
    };

    struct Il2CppGenericArguments
    {
        Il2CppGenericClass gi;
    };

    struct Il2CppMethodParameters
    {
        MethodInfo m;
    };

    struct Il2CppMethodGenericParameters
    {
        MethodInfo m;
    };

    struct PreventLinkerFromStrippingTypesFromDebugInfo
    {
        Il2CppRawTypeName* ___rawTypeName;
        Il2CppRawTypeNameWithoutDeclaringType* ___rawTypeNameWithoutDeclaringType;
        Il2CppGenericParameters_DeclaringTypeHas0Parameters* ___genericParameters0;
        Il2CppGenericParameters_DeclaringTypeHas1Parameters* ___genericParameters1;
        Il2CppGenericParameters_DeclaringTypeHas2Parameters* ___genericParameters2;
        Il2CppGenericParameters_DeclaringTypeHas3Parameters* ___genericParameters3;
        Il2CppGenericParameters_DeclaringTypeHas4Parameters* ___genericParameters4;
        Il2CppGenericParameters_DeclaringTypeHas5Parameters* ___genericParameters5;
        Il2CppGenericParameters* ___genericParameters;
        Il2CppGenericArguments_DeclaringTypeHas0Arguments* ___genericArguments0;
        Il2CppGenericArguments_DeclaringTypeHas1Arguments* ___genericArguments1;
        Il2CppGenericArguments_DeclaringTypeHas2Arguments* ___genericArguments2;
        Il2CppGenericArguments_DeclaringTypeHas3Arguments* ___genericArguments3;
        Il2CppGenericArguments_DeclaringTypeHas4Arguments* ___genericArguments4;
        Il2CppGenericArguments_DeclaringTypeHas5Arguments* ___genericArguments5;
        Il2CppGenericArguments* ___genericArguments;
        Il2CppMethodParameters* ___methodParameters;
        Il2CppMethodGenericParameters* ___methodGenericParameters;
    };
}

// We need to declare a global variable, otherwise compiler strips all type information from PDBs, and in result debugger can't visualize them
extern "C" VisualizerHelpers::PreventLinkerFromStrippingTypesFromDebugInfo * ____visualizerHelpersPreventLinkerStripping = NULL;

#endif
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\VisualizerHelpers.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\WaitHandle.cpp---------------
.
.
#include "il2cpp-config.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/WaitHandle.h"

#include "vm/Class.h"
#include "vm/Field.h"
#include "vm/Object.h"
#include "vm/Runtime.h"

namespace il2cpp
{
namespace vm
{
    Il2CppWaitHandle* WaitHandle::NewManualResetEvent(bool initialState)
    {
        static const MethodInfo* constructor = NULL;
        if (!constructor)
            constructor = Class::GetMethodFromName(il2cpp_defaults.manualresetevent_class, ".ctor", 1);

        Il2CppObject* instance = Object::New(il2cpp_defaults.manualresetevent_class);
        void* args[1] = { &initialState };
        // NOTE: passing NULL here as Mono does, as long as the WaitHandle ctor will never throw an exception.
        Runtime::Invoke(constructor, instance, args, NULL);

        return reinterpret_cast<Il2CppWaitHandle*>(instance);
    }

    os::Handle* WaitHandle::GetPlatformHandle(Il2CppWaitHandle* waitHandle)
    {
        static FieldInfo *s_osHandle;
        static FieldInfo *s_safeHandle;

        if (!s_osHandle && !s_safeHandle)
        {
            s_osHandle = vm::Class::GetFieldFromName(il2cpp_defaults.manualresetevent_class, "Handle");
            s_safeHandle = vm::Class::GetFieldFromName(il2cpp_defaults.manualresetevent_class, "safeWaitHandle");
        }

        os::Handle* retval;
        if (s_osHandle)
        {
            intptr_t osHandle;
            vm::Field::GetValue((Il2CppObject*)waitHandle, s_osHandle, &osHandle);
            retval = reinterpret_cast<os::Handle*>(osHandle);
        }
        else
        {
            Il2CppSafeHandle *sh;
            vm::Field::GetValue((Il2CppObject*)waitHandle, s_safeHandle, &sh);
            retval = static_cast<os::Handle*>(sh->handle);
        }

        return static_cast<os::Handle*>(retval);
    }
} /* namespace vm */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\WaitHandle.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\WeakReference.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/GCHandle.h"
#include "utils/Memory.h"
#include "vm/CCW.h"
#include "vm/Exception.h"
#include "vm/ScopedThreadAttacher.h"
#include "WeakReference.h"
#include "utils/New.h"

il2cpp_hresult_t il2cpp::vm::WeakReference::Create(Il2CppObject* managedObject, Il2CppIWeakReference** result)
{
    void* memory = utils::Memory::Malloc(sizeof(WeakReference));
    if (memory == NULL)
        return IL2CPP_E_OUTOFMEMORY;

    *result = new(memory) WeakReference(managedObject);
    return IL2CPP_S_OK;
}

il2cpp::vm::WeakReference::WeakReference(Il2CppObject* managedObject)
{
    auto weakRef = gc::GCHandle::NewWeakref(managedObject, false);
    vm::Exception::RaiseIfError(weakRef.GetError());
    m_GCHandle = weakRef.Get();
    m_RefCount = 1;
}

il2cpp_hresult_t STDCALL il2cpp::vm::WeakReference::QueryInterface(const Il2CppGuid& iid, void** object)
{
    if (memcmp(&iid, &Il2CppIUnknown::IID, sizeof(Il2CppGuid)) == 0 ||
        memcmp(&iid, &Il2CppIWeakReference::IID, sizeof(Il2CppGuid)) == 0)
    {
        AddRef();
        *object = static_cast<Il2CppIWeakReference*>(this);
        return IL2CPP_S_OK;
    }

    return IL2CPP_E_NOINTERFACE;
}

uint32_t STDCALL il2cpp::vm::WeakReference::AddRef()
{
    return ++m_RefCount;
}

uint32_t STDCALL il2cpp::vm::WeakReference::Release()
{
    const uint32_t refCount = --m_RefCount;
    if (refCount == 0)
    {
        this->~WeakReference();
        utils::Memory::Free(this);
    }

    return refCount;
}

il2cpp_hresult_t STDCALL il2cpp::vm::WeakReference::Resolve(const Il2CppGuid& iid, Il2CppIInspectable** object)
{
    ScopedThreadAttacher managedThreadAttached;

    Il2CppObject* managedObject = gc::GCHandle::GetTarget(m_GCHandle);
    if (managedObject == NULL)
    {
        *object = NULL;
        return IL2CPP_S_OK;
    }

    try
    {
        *object = static_cast<Il2CppIInspectable*>(CCW::GetOrCreate(managedObject, iid));
    }
    catch (Il2CppExceptionWrapper& ex)
    {
        return ex.ex->hresult;
    }

    return IL2CPP_S_OK;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\WeakReference.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\WindowsRuntime.cpp---------------
.
.
#include "il2cpp-config.h"
#include "metadata/GenericMetadata.h"
#include "os/LibraryLoader.h"
#include "os/WindowsRuntime.h"
#include "utils/StringUtils.h"
#include "utils/StringViewUtils.h"
#include "vm/AssemblyName.h"
#include "vm/Class.h"
#include "vm/Exception.h"
#include "vm/GenericClass.h"
#include "vm/Il2CppHStringReference.h"
#include "vm/Image.h"
#include "vm/MetadataCache.h"
#include "vm/Type.h"
#include "vm/WindowsRuntime.h"

namespace il2cpp
{
namespace vm
{
    const char kArrayTypePrefixUtf8[] = "Windows.Foundation.IReferenceArray`1<";
    const Il2CppNativeChar kArrayTypePrefix[] = IL2CPP_NATIVE_STRING("Windows.Foundation.IReferenceArray`1<");
    const Il2CppNativeChar kIReferencePrefix[] = IL2CPP_NATIVE_STRING("Windows.Foundation.IReference`1<");
    const Il2CppNativeChar kArrayTypeOrIReferencePrefix[] = IL2CPP_NATIVE_STRING("Windows.Foundation.IReference");
    const Il2CppNativeChar kArrayTypePostprefix[] = IL2CPP_NATIVE_STRING("Array`1<");
    const Il2CppNativeChar kIReferencePostprefix[] = IL2CPP_NATIVE_STRING("`1<");

    Il2CppIActivationFactory* WindowsRuntime::GetActivationFactory(const utils::StringView<Il2CppNativeChar>& runtimeClassName)
    {
        Il2CppHStringReference className(runtimeClassName);
        Il2CppIActivationFactory* factory = NULL;
        il2cpp_hresult_t hr = os::WindowsRuntime::GetActivationFactory(className, &factory);

        if (IL2CPP_HR_SUCCEEDED(hr))
            return factory;

        if (hr != IL2CPP_REGDB_E_CLASSNOTREG)
            Exception::Raise(hr, false);

        // If GetActivationFactory doesn't find the class, we can still try to find it manually
        // All Windows runtime classes must be in namespaces, and that class has to be in a DLL
        // that is named after the namespace of a part of it.
        // For example, MyNamespace.MySubNamespace.MyClass can be in either
        // MyNamespace.MySubNamespace.dll or MyNamespace.dll
        IL2CPP_ASSERT(runtimeClassName.Length() > 1);
        size_t namespaceEnd = runtimeClassName.Length() - 1;

        do
        {
            namespaceEnd--;
        }
        while (namespaceEnd > 0 && runtimeClassName[namespaceEnd] != '.');

        Il2CppNativeChar* nativeDll = static_cast<Il2CppNativeChar*>(alloca((namespaceEnd + 5) * sizeof(Il2CppNativeChar)));
        memcpy(nativeDll, runtimeClassName.Str(), namespaceEnd * sizeof(Il2CppNativeChar));

        std::string detailedError;
        while (namespaceEnd > 0)
        {
            memcpy(nativeDll + namespaceEnd, IL2CPP_NATIVE_STRING(".dll"), 4 * sizeof(Il2CppNativeChar));
            nativeDll[namespaceEnd + 4] = 0;

            Baselib_DynamicLibrary_Handle dynamicLibrary = os::LibraryLoader::LoadDynamicLibrary(utils::StringView<Il2CppNativeChar>(nativeDll, namespaceEnd + 4), detailedError);
            if (dynamicLibrary != Baselib_DynamicLibrary_Handle_Invalid)
            {
                typedef il2cpp_hresult_t(STDCALL * DllGetActivationFactory)(Il2CppHString activatableClassId, Il2CppIActivationFactory** factory);
                DllGetActivationFactory dllGetActivationFactory = reinterpret_cast<DllGetActivationFactory>(os::LibraryLoader::GetFunctionPointer(dynamicLibrary, "DllGetActivationFactory", detailedError));

                if (dllGetActivationFactory != NULL)
                {
                    hr = dllGetActivationFactory(className, &factory);

                    if (IL2CPP_HR_SUCCEEDED(hr))
                        return factory;

                    if (hr != IL2CPP_REGDB_E_CLASSNOTREG)
                        Exception::Raise(hr, false);
                }
            }

            do
            {
                namespaceEnd--;
            }
            while (namespaceEnd > 0 && runtimeClassName[namespaceEnd] != '.');
        }

        Exception::Raise(IL2CPP_REGDB_E_CLASSNOTREG, false);

        return NULL;
    }

    static bool IsWindowsRuntimePrimitiveType(const Il2CppType* type, Il2CppClass*& outCachedNonPrimitiveClass)
    {
        if (type == NULL)
            return false;

        switch (type->type)
        {
            case IL2CPP_TYPE_BOOLEAN:
            case IL2CPP_TYPE_CHAR:
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_R8:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_STRING:
                return true;

            default:
                break;
        }

        Il2CppClass* klass = Class::FromIl2CppType(type);
        if (klass == il2cpp_defaults.system_guid_class)
            return true;

        outCachedNonPrimitiveClass = klass;
        return false;
    }

    static Il2CppWindowsRuntimeTypeKind GetWindowsRuntimeTypeKind(const Il2CppType* type, Il2CppClass*& outCachedNonPrimitiveClass)
    {
        if (type == NULL)
            return kTypeKindCustom;

        switch (type->type)
        {
            case IL2CPP_TYPE_BOOLEAN:
            case IL2CPP_TYPE_CHAR:
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_I2:
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_I4:
            case IL2CPP_TYPE_U4:
            case IL2CPP_TYPE_I8:
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_R4:
            case IL2CPP_TYPE_R8:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_STRING:
                return kTypeKindPrimitive;

            default:
                break;
        }

        Il2CppClass* klass = Class::FromIl2CppType(type);
        if (klass == il2cpp_defaults.system_guid_class)
            return kTypeKindPrimitive;

        outCachedNonPrimitiveClass = klass;
        if (klass->rank > 0)
        {
            Il2CppClass* cachedElementClass;
            if (GetWindowsRuntimeTypeKind(&klass->element_class->byval_arg, cachedElementClass) != kTypeKindCustom)
                return kTypeKindMetadata;
        }
        else
        {
            const char* windowsRuntimeTypeName = MetadataCache::GetWindowsRuntimeClassName(klass);
            if (windowsRuntimeTypeName != NULL)
                return kTypeKindMetadata;

            if (strcmp(klass->image->name, "WindowsRuntimeMetadata") == 0)
            {
                Il2CppGenericClass* genericClass = klass->generic_class;
                if (genericClass == NULL)
                    return kTypeKindMetadata;

                const Il2CppGenericInst* classInst = genericClass->context.class_inst;
                IL2CPP_ASSERT(classInst != NULL);

                uint32_t genericArgumentCount = classInst->type_argc;
                for (uint32_t i = 0; i < genericArgumentCount; i++)
                {
                    Il2CppClass* cachedGenericArgumentClass;
                    if (GetWindowsRuntimeTypeKind(classInst->type_argv[i], cachedGenericArgumentClass) == kTypeKindCustom)
                        return kTypeKindCustom;
                }

                return kTypeKindMetadata;
            }
        }

        return kTypeKindCustom;
    }

    static utils::StringView<Il2CppNativeChar> GetWindowsRuntimePrimitiveTypeName(const Il2CppType* type)
    {
        switch (type->type)
        {
            case IL2CPP_TYPE_BOOLEAN:
                return IL2CPP_NATIVE_STRING("Boolean");

            case IL2CPP_TYPE_CHAR:
                return IL2CPP_NATIVE_STRING("Char16");

            case IL2CPP_TYPE_U1:
                return IL2CPP_NATIVE_STRING("UInt8");

            case IL2CPP_TYPE_I2:
                return IL2CPP_NATIVE_STRING("Int16");

            case IL2CPP_TYPE_U2:
                return IL2CPP_NATIVE_STRING("UInt16");

            case IL2CPP_TYPE_I4:
                return IL2CPP_NATIVE_STRING("Int32");

            case IL2CPP_TYPE_U4:
                return IL2CPP_NATIVE_STRING("UInt32");

            case IL2CPP_TYPE_I8:
                return IL2CPP_NATIVE_STRING("Int64");

            case IL2CPP_TYPE_U8:
                return IL2CPP_NATIVE_STRING("UInt64");

            case IL2CPP_TYPE_R4:
                return IL2CPP_NATIVE_STRING("Single");

            case IL2CPP_TYPE_R8:
                return IL2CPP_NATIVE_STRING("Double");

            case IL2CPP_TYPE_OBJECT:
                return IL2CPP_NATIVE_STRING("Object");

            case IL2CPP_TYPE_STRING:
                return IL2CPP_NATIVE_STRING("String");

            case IL2CPP_TYPE_VALUETYPE:
                return IL2CPP_NATIVE_STRING("Guid");

            default:
                IL2CPP_UNREACHABLE;
                return IL2CPP_NATIVE_STRING("");
        }
    }

    // This is code duplication... but there isn't a better name to achieve good performance for both primitive and metadata types otherwise
    static utils::StringView<char> GetWindowsRuntimePrimitiveTypeNameUtf8(const Il2CppType* type)
    {
        switch (type->type)
        {
            case IL2CPP_TYPE_BOOLEAN:
                return "Boolean";

            case IL2CPP_TYPE_CHAR:
                return "Char16";

            case IL2CPP_TYPE_U1:
                return "UInt8";

            case IL2CPP_TYPE_I2:
                return "Int16";

            case IL2CPP_TYPE_U2:
                return "UInt16";

            case IL2CPP_TYPE_I4:
                return "Int32";

            case IL2CPP_TYPE_U4:
                return "UInt32";

            case IL2CPP_TYPE_I8:
                return "Int64";

            case IL2CPP_TYPE_U8:
                return "UInt64";

            case IL2CPP_TYPE_R4:
                return "Single";

            case IL2CPP_TYPE_R8:
                return "Double";

            case IL2CPP_TYPE_OBJECT:
                return "Object";

            case IL2CPP_TYPE_STRING:
                return "String";

            case IL2CPP_TYPE_VALUETYPE:
                return "Guid";

            default:
                IL2CPP_UNREACHABLE;
                return "";
        }
    }

    static std::string GetWindowsRuntimeTypeNameFromWinmdReference(Il2CppClass* klass);

    static std::string GetWindowsRuntimeMetadataTypeNameUtf8(Il2CppClass* klass)
    {
        if (klass->rank > 0)
        {
            std::string typeName, elementMetadataTypeName;
            const Il2CppType* elementType = &klass->element_class->byval_arg;
            Il2CppClass* elementClass = NULL;
            bool elementIsPrimitive = IsWindowsRuntimePrimitiveType(elementType, elementClass);
            utils::StringView<char> elementTypeName(utils::StringView<char>::Empty());

            // Optimization: time spent in GetWindowsRuntimeMetadataTypeName is dominated by string allocations,
            // so try to reserve needed space on a string in advance.
            if (elementIsPrimitive)
            {
                elementTypeName = GetWindowsRuntimePrimitiveTypeNameUtf8(elementType);
            }
            else
            {
                elementMetadataTypeName = GetWindowsRuntimeMetadataTypeNameUtf8(elementClass);
                elementTypeName = STRING_TO_STRINGVIEW(elementMetadataTypeName);
            }

            size_t spaceRequired = IL2CPP_ARRAY_SIZE(kArrayTypePrefixUtf8) + elementTypeName.Length() + 1 /* '>' */ - 1 /* minus null terminator from IL2CPP_ARRAY_SIZE */;
            typeName.reserve(spaceRequired);

            typeName.append(kArrayTypePrefixUtf8);
            typeName.append(elementTypeName.Str(), elementTypeName.Length());
            typeName.push_back('>');

            return typeName;
        }

        const char* windowsRuntimeTypeName = MetadataCache::GetWindowsRuntimeClassName(klass);
        if (windowsRuntimeTypeName != NULL)
            return windowsRuntimeTypeName;

        return GetWindowsRuntimeTypeNameFromWinmdReference(klass);
    }

    static std::string GetWindowsRuntimeTypeNameFromWinmdReference(Il2CppClass* klass)
    {
        IL2CPP_ASSERT(strcmp(klass->image->name, "WindowsRuntimeMetadata") == 0 && "Windows Runtime type kind was Metadata but it did not come from a Windows Runtime component.");

        std::string typeName;
        size_t namespaceLength = strlen(klass->namespaze);
        size_t nameLength = strlen(klass->name);

        typeName.reserve(namespaceLength + 1 + nameLength);

        typeName.append(klass->namespaze, namespaceLength);
        typeName.push_back('.');
        typeName.append(klass->name, nameLength);

        Il2CppGenericClass* genericClass = klass->generic_class;
        if (genericClass == NULL)
            return typeName;

        const Il2CppGenericInst* classInst = genericClass->context.class_inst;
        IL2CPP_ASSERT(classInst != NULL);

        typeName += '<';

        uint32_t genericArgumentCount = classInst->type_argc;
        for (uint32_t i = 0; i < genericArgumentCount; i++)
        {
            if (i != 0)
                typeName += ',';

            const Il2CppType* genericArgumentType = classInst->type_argv[i];
            Il2CppClass* genericArgumentClass = NULL;

            if (IsWindowsRuntimePrimitiveType(genericArgumentType, genericArgumentClass))
            {
                utils::StringView<char> primitiveTypeName = GetWindowsRuntimePrimitiveTypeNameUtf8(genericArgumentType);
                typeName.append(primitiveTypeName.Str(), primitiveTypeName.Length());
            }
            else
            {
                // Windows Runtime metadata types can't have generic arguments of Custom type, thus the argument is metadata type too
                typeName += GetWindowsRuntimeMetadataTypeNameUtf8(genericArgumentClass);
            }
        }

        typeName += '>';
        return typeName;
    }

    static Il2CppHString GetWindowsRuntimeMetadataTypeName(Il2CppClass* klass)
    {
        // Optimization: for type arrays we can construct native string in place and avoid extra UTF8 -> UTF16 conversion
        // This makes type name retrieval 4 times faster!
        if (klass->rank > 0)
        {
            const Il2CppType* elementType = &klass->element_class->byval_arg;
            Il2CppClass* elementClass = NULL;

            utils::StringView<Il2CppNativeChar> elementTypeName(utils::StringView<Il2CppNativeChar>::Empty());
            Il2CppHString elementMetadataTypeName = NULL;

            bool isElementTypePrimitive = IsWindowsRuntimePrimitiveType(elementType, elementClass);
            if (isElementTypePrimitive)
            {
                elementTypeName = GetWindowsRuntimePrimitiveTypeName(elementType);
            }
            else
            {
                elementMetadataTypeName = GetWindowsRuntimeMetadataTypeName(elementClass);

                uint32_t elementTypeNameLength;
                auto elementMetadataTypeNamePtr = os::WindowsRuntime::GetNativeHStringBuffer(elementMetadataTypeName, &elementTypeNameLength);
                vm::Exception::RaiseIfError(elementMetadataTypeNamePtr.GetError());
                elementTypeName = utils::StringView<Il2CppNativeChar>(elementMetadataTypeNamePtr.Get(), elementTypeNameLength);
            }

            size_t offsetInChars = 0;
            size_t spaceRequired = IL2CPP_ARRAY_SIZE(kArrayTypePrefix) + elementTypeName.Length() + 1 /* '>' */ - 1 /* minus null terminator from IL2CPP_ARRAY_SIZE */;

            Il2CppNativeChar* buffer;
            void* hstringBufferHandle = WindowsRuntime::PreallocateHStringBuffer(static_cast<uint32_t>(spaceRequired), &buffer);

            memcpy(buffer, kArrayTypePrefix, sizeof(kArrayTypePrefix) - sizeof(Il2CppNativeChar));
            offsetInChars += IL2CPP_ARRAY_SIZE(kArrayTypePrefix) - 1;

            memcpy(buffer + offsetInChars, elementTypeName.Str(), elementTypeName.Length() * sizeof(Il2CppNativeChar));
            offsetInChars += elementTypeName.Length();

            buffer[offsetInChars] = static_cast<Il2CppNativeChar>('>');

            if (!isElementTypePrimitive)
                WindowsRuntime::DeleteHString(elementMetadataTypeName);

            return WindowsRuntime::PromoteHStringBuffer(hstringBufferHandle);
        }

        // Note: don't put 'windowsRuntimeTypeName' into an std::string to save an allocation
        const char* windowsRuntimeTypeName = MetadataCache::GetWindowsRuntimeClassName(klass);
        if (windowsRuntimeTypeName != NULL)
        {
            Il2CppNativeString typeName = utils::StringUtils::Utf8ToNativeString(windowsRuntimeTypeName);
            return WindowsRuntime::CreateHString(STRING_TO_STRINGVIEW(typeName));
        }

        std::string typeNameUtf8 = GetWindowsRuntimeTypeNameFromWinmdReference(klass);
        Il2CppNativeString typeName = utils::StringUtils::Utf8ToNativeString(typeNameUtf8);
        return WindowsRuntime::CreateHString(STRING_TO_STRINGVIEW(typeName));
    }

    static Il2CppHString GetWindowsRuntimeCustomTypeName(const Il2CppType* type)
    {
        std::string typeNameUtf8 = Type::GetName(type, IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);
        Il2CppNativeString typeName = utils::StringUtils::Utf8ToNativeString(typeNameUtf8);
        return WindowsRuntime::CreateHString(STRING_TO_STRINGVIEW(typeName));
    }

    void WindowsRuntime::MarshalTypeToNative(const Il2CppType* type, Il2CppWindowsRuntimeTypeName& nativeType)
    {
        if (type == NULL)
        {
            nativeType.typeKind = kTypeKindCustom;
            nativeType.typeName = NULL;
            return;
        }

        Il2CppClass* cachedClass = NULL;
        nativeType.typeKind = GetWindowsRuntimeTypeKind(type, cachedClass);

        switch (nativeType.typeKind)
        {
            case kTypeKindPrimitive:
                nativeType.typeName = CreateHString(GetWindowsRuntimePrimitiveTypeName(type));
                break;

            case kTypeKindMetadata:
                nativeType.typeName = GetWindowsRuntimeMetadataTypeName(cachedClass);
                break;

            case kTypeKindCustom:
                nativeType.typeName = GetWindowsRuntimeCustomTypeName(type);
                break;

            default:
                IL2CPP_UNREACHABLE;
        }
    }

    static REAL_NORETURN IL2CPP_NO_INLINE void ThrowUnexpectedTypeKindException()
    {
        const char kMessage[] = "Unexpected TypeKind when marshaling Windows.Foundation.TypeName. ";
        Il2CppException* exception = Exception::GetArgumentException("", kMessage);
        Exception::Raise(exception);
        IL2CPP_UNREACHABLE;
    }

    static REAL_NORETURN IL2CPP_NO_INLINE void ThrowWindowsRuntimeTypeNotFoundException(utils::StringView<Il2CppNativeChar> typeName)
    {
        std::string typeNameUtf8 = utils::StringUtils::NativeStringToUtf8(typeName.Str(), static_cast<uint32_t>(typeName.Length()));
        Il2CppException* typeLoadException = Exception::GetTypeLoadExceptionForWindowsRuntimeType(utils::StringView<char>::Empty(), STRING_TO_STRINGVIEW(typeNameUtf8));
        Exception::Raise(typeLoadException);
        IL2CPP_UNREACHABLE;
    }

    static Il2CppClass* GetClassFromPrimitiveTypeName(utils::StringView<Il2CppNativeChar> typeName, bool throwOnFailure);
    static Il2CppClass* GetClassFromMetadataTypeName(utils::StringView<Il2CppNativeChar> typeName, bool throwOnFailure);

    static inline Il2CppClass* GetClassFromPrimitiveOrMetadataTypeName(utils::StringView<Il2CppNativeChar> typeName, bool throwOnFailure)
    {
        // Try finding type as primitive type first
        // If that fails, try finding it as metadata type
        Il2CppClass* klass = GetClassFromPrimitiveTypeName(typeName, throwOnFailure);
        if (klass != NULL)
            return klass;

        return GetClassFromMetadataTypeName(typeName, throwOnFailure);
    }

    static Il2CppClass* GetClassFromPrimitiveTypeName(utils::StringView<Il2CppNativeChar> typeName, bool throwOnFailure)
    {
        uint32_t characterSum = 0;
        for (uint32_t i = 0; i < typeName.Length(); i++)
            characterSum += typeName[i];

        // Nothing like an (almost) perfect hash function. Thanks for the idea, @andrei!
        switch (characterSum)
        {
            case 393:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Guid")))
                    return il2cpp_defaults.system_guid_class;

                break;

            case 400:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Int32")))
                    return il2cpp_defaults.int32_class;

                break;

            case 402:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Int16")))
                    return il2cpp_defaults.int16_class;

                break;

            case 405:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Int64")))
                    return il2cpp_defaults.int64_class;

                break;

            case 440:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("UInt8")))
                    return il2cpp_defaults.byte_class;

                break;

            case 485:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Char16")))
                    return il2cpp_defaults.char_class;

                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("UInt32")))
                    return il2cpp_defaults.uint32_class;

                break;

            case 487:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("UInt16")))
                    return il2cpp_defaults.uint16_class;

                break;

            case 490:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("UInt64")))
                    return il2cpp_defaults.uint64_class;

                break;

            case 599:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Object")))
                    return il2cpp_defaults.object_class;

                break;

            case 603:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Double")))
                    return il2cpp_defaults.double_class;

                break;

            case 610:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Single")))
                    return il2cpp_defaults.single_class;

                break;

            case 631:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("String")))
                    return il2cpp_defaults.string_class;

                break;

            case 704:
                if (utils::StringUtils::Equals(typeName, IL2CPP_NATIVE_STRING("Boolean")))
                    return il2cpp_defaults.boolean_class;

                break;
        }

        if (throwOnFailure)
        {
            // Is this actually a metadata type? If so, throw unexpected type kind exception
            if (GetClassFromMetadataTypeName(typeName, false) != NULL)
                ThrowUnexpectedTypeKindException();

            ThrowWindowsRuntimeTypeNotFoundException(typeName);
        }

        return NULL;
    }

    static Il2CppClass* GetGenericInstanceClassFromMetadataTypeName(utils::StringView<Il2CppNativeChar> typeName)
    {
        IL2CPP_ASSERT(typeName[typeName.Length() - 1] == '>');

        size_t backtickIndex = typeName.Find('`');
        if (backtickIndex == utils::StringView<Il2CppNativeChar>::NPos())
            return NULL;

        size_t genericArgumentStartIndex = typeName.Find('<', backtickIndex + 1);
        if (genericArgumentStartIndex == utils::StringView<Il2CppNativeChar>::NPos())
            return NULL;

        int genericArgumentCount;
        utils::StringView<Il2CppNativeChar> genericArgumentCountStr = typeName.SubStr(backtickIndex + 1, genericArgumentStartIndex - backtickIndex - 1);
        if (!genericArgumentCountStr.TryParseAsInt(genericArgumentCount) || genericArgumentCount < 1)
            return NULL;

        utils::StringView<Il2CppNativeChar> typeDefinitionName = typeName.SubStr(0, genericArgumentStartIndex);
        Il2CppClass* classDefinition = GetClassFromMetadataTypeName(typeDefinitionName, false);
        if (classDefinition == NULL || !classDefinition->is_generic)
            return NULL;

        const Il2CppType** genericArguments = (const Il2CppType**)alloca(genericArgumentCount * sizeof(const Il2CppType*));

        int genericDepth = 0;
        int genericArgumentsAdded = 0;
        const Il2CppNativeChar* genericArgumentsPtr = typeName.Str() + genericArgumentStartIndex + 1;
        const Il2CppNativeChar* currentGenericArgumentStart = genericArgumentsPtr;
        const Il2CppNativeChar* genericArgumentsEnd = typeName.Str() + typeName.Length() - 1;

        for (; genericArgumentsPtr <= genericArgumentsEnd; genericArgumentsPtr++)
        {
            Il2CppNativeChar currentChar = *genericArgumentsPtr;

            switch (currentChar)
            {
                case '<':
                    genericDepth++;
                    break;

                case '>':
                    if (genericArgumentsPtr < genericArgumentsEnd)
                    {
                        genericDepth--;
                        break;
                    }
                // fallthrough

                case ',':
                {
                    if (genericDepth == 0)
                    {
                        il2cpp::utils::StringView<Il2CppNativeChar> genericArgumentTypeName(currentGenericArgumentStart, genericArgumentsPtr - currentGenericArgumentStart);
                        Il2CppClass* genericArgumentClass = GetClassFromPrimitiveOrMetadataTypeName(genericArgumentTypeName, false);
                        if (genericArgumentClass == NULL)
                            return NULL;

                        genericArguments[genericArgumentsAdded] = &genericArgumentClass->byval_arg;
                        currentGenericArgumentStart = genericArgumentsPtr + 1;
                        genericArgumentsAdded++;
                    }
                }
            }
        }

        if (genericArgumentsAdded != genericArgumentCount)
            return NULL;

        const Il2CppGenericInst* genericInst = MetadataCache::GetGenericInst(genericArguments, genericArgumentCount);
        Il2CppGenericClass* genericClass = metadata::GenericMetadata::GetGenericClass(classDefinition, genericInst);
        return GenericClass::GetClass(genericClass);
    }

    static Il2CppClass* GetClassFromMetadataTypeName(utils::StringView<Il2CppNativeChar> typeName, bool throwOnFailure)
    {
        // Does this type involve generics?
        if (typeName[typeName.Length() - 1] == '>')
        {
            // Is it an array/boxed value?
            if (utils::StringUtils::StartsWith(typeName, kArrayTypeOrIReferencePrefix))
            {
                if (utils::StringUtils::StartsWith(typeName.SubStr(IL2CPP_ARRAY_SIZE(kArrayTypeOrIReferencePrefix) - 1), kArrayTypePostprefix))
                {
                    // We have an array
                    utils::StringView<Il2CppNativeChar> elementTypeName = typeName.SubStr(IL2CPP_ARRAY_SIZE(kArrayTypePrefix) - 1, typeName.Length() - IL2CPP_ARRAY_SIZE(kArrayTypePrefix));
                    Il2CppClass* elementClass = GetClassFromPrimitiveOrMetadataTypeName(elementTypeName, false);
                    if (elementClass != NULL)
                        return Class::GetArrayClass(elementClass, 1);
                }
                else if (utils::StringUtils::StartsWith(typeName.SubStr(IL2CPP_ARRAY_SIZE(kArrayTypeOrIReferencePrefix) - 1), kIReferencePostprefix))
                {
                    // We have a boxed value
                    utils::StringView<Il2CppNativeChar> boxedTypeName = typeName.SubStr(IL2CPP_ARRAY_SIZE(kIReferencePrefix) - 1, typeName.Length() - IL2CPP_ARRAY_SIZE(kIReferencePrefix));
                    Il2CppClass* boxedClass = GetClassFromPrimitiveOrMetadataTypeName(boxedTypeName, false);
                    if (boxedClass != NULL)
                    {
                        const Il2CppType* boxedType = &boxedClass->byval_arg;
                        const Il2CppGenericInst* genericInst = MetadataCache::GetGenericInst(&boxedType, 1);
                        Il2CppGenericClass* genericClass = metadata::GenericMetadata::GetGenericClass(il2cpp_defaults.generic_nullable_class, genericInst);
                        return GenericClass::GetClass(genericClass);
                    }
                }
            }

            // This could be a generic type
            Il2CppClass* klass = GetGenericInstanceClassFromMetadataTypeName(typeName);
            if (klass != NULL)
                return klass;
        }

        // It's not an generic array, or boxed type. Look in Windows Runtime class type map
        const std::string typeNameUtf8 = utils::StringUtils::NativeStringToUtf8(typeName.Str(), static_cast<uint32_t>(typeName.Length()));
        Il2CppClass* windowsRuntimeClass = MetadataCache::GetWindowsRuntimeClass(typeNameUtf8.c_str());
        if (windowsRuntimeClass != NULL)
            return windowsRuntimeClass;

        // We don't have it in Windows Runtime class type map. Look in WindowsRuntimeMetadata assembly
        size_t lastDotIndex = typeNameUtf8.rfind('.');
        if (lastDotIndex != std::string::npos)
        {
            const std::string namespaze = typeNameUtf8.substr(0, lastDotIndex);
            const char* name = typeNameUtf8.c_str() + lastDotIndex + 1;

            const Il2CppAssembly* windowsRuntimeMetadataAssembly = Assembly::Load("WindowsRuntimeMetadata");
            if (windowsRuntimeMetadataAssembly != NULL)
            {
                Il2CppClass* windowsRuntimeClass = Image::ClassFromName(windowsRuntimeMetadataAssembly->image, namespaze.c_str(), name);
                if (windowsRuntimeClass != NULL)
                    return windowsRuntimeClass;
            }
        }

        if (throwOnFailure)
        {
            // We couldn't find metadata type with given name, so we must now throw an exception.
            // Here's the catch: if a type name is actually a primitive type name, we need to
            // throw a special saying that the type kind was unexpected. Otherwise, we need to
            // throw the same exception as when we cannot find a primitive type.
            if (GetClassFromPrimitiveTypeName(typeName, false) != NULL)
                ThrowUnexpectedTypeKindException();

            // We want to start the generic part of the name from the exception message
            if (typeName[typeName.Length() - 1] == '>')
            {
                size_t genericArgumentStart = typeName.Find('<');
                if (genericArgumentStart != utils::StringView<Il2CppNativeChar>::NPos())
                    typeName = typeName.SubStr(0, genericArgumentStart);
            }

            ThrowWindowsRuntimeTypeNotFoundException(typeName);
        }

        return NULL;
    }

    static const Il2CppType* GetTypeFromCustomTypeName(utils::StringView<Il2CppNativeChar> typeName)
    {
        const std::string str = utils::StringUtils::NativeStringToUtf8(typeName.Str(), static_cast<uint32_t>(typeName.Length()));

        TypeNameParseInfo info;
        TypeNameParser parser(str, info, false);

        if (!parser.Parse())
        {
            utils::StringView<char>
            name(utils::StringView<char>::Empty()),
            assemblyName(utils::StringView<char>::Empty());

            size_t commaIndex = str.find_last_of(',');
            if (commaIndex != std::string::npos)
            {
                name = utils::StringView<char>(str.c_str(), commaIndex);
                while (commaIndex < str.length() && (str[commaIndex] == ' ' || str[commaIndex] == '\t'))
                    commaIndex++;

                if (commaIndex < str.length())
                    assemblyName = utils::StringView<char>(str.c_str() + commaIndex + 1, str.length() - commaIndex - 1);
            }
            else
            {
                name = STRING_TO_STRINGVIEW(str);
            }

            // Splitting name and namespace is pretty complicated, and they're going to be mashed up together in
            // the type load exception message anyway. Let's not bother.
            Exception::Raise(Exception::GetTypeLoadException(utils::StringView<char>::Empty(), name, assemblyName));
        }

        return Class::il2cpp_type_from_type_info(info, static_cast<TypeSearchFlags>(kTypeSearchFlagThrowOnError | kTypeSearchFlagDontUseExecutingImage));
    }

    const Il2CppType* WindowsRuntime::MarshalTypeFromNative(Il2CppWindowsRuntimeTypeName& nativeType)
    {
        if (nativeType.typeName == NULL)
            return NULL;

        uint32_t typeNameLength;
        auto typeNamePtr = os::WindowsRuntime::GetNativeHStringBuffer(nativeType.typeName, &typeNameLength);
        vm::Exception::RaiseIfError(typeNamePtr.GetError());
        utils::StringView<Il2CppNativeChar> typeNameView(typeNamePtr.Get(), typeNameLength);

        switch (nativeType.typeKind)
        {
            case kTypeKindPrimitive:
                return &GetClassFromPrimitiveTypeName(typeNameView, true)->byval_arg;

            case kTypeKindMetadata:
                return &GetClassFromMetadataTypeName(typeNameView, true)->byval_arg;

            case kTypeKindCustom:
                return GetTypeFromCustomTypeName(typeNameView);

            default:
                ThrowUnexpectedTypeKindException();
        }
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm\WindowsRuntime.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\BlobReader.cpp---------------
.
.
#include "il2cpp-config.h"

#include <stdint.h>
#include "BlobReader.h"
#include "gc/GarbageCollector.h"
#include "metadata/CustomAttributeDataReader.h"
#include "vm/Array.h"
#include "vm/Class.h"
#include "vm/Object.h"
#include "vm/MetadataCache.h"
#include "vm/Reflection.h"
#include "vm/String.h"
#include "utils/MemoryRead.h"
#include "il2cpp-object-internals.h"

const uint8_t kArrayTypeWithSameElements = 0;
const uint8_t kArrayTypeWithDifferentElements = 1;

namespace il2cpp
{
namespace utils
{
    bool BlobReader::GetConstantValueFromBlob(const Il2CppImage* image, Il2CppTypeEnum type, const char* blob, void* value)
    {
        return GetConstantValueFromBlob(image, type, &blob, value, true);
    }

    bool BlobReader::GetConstantValueFromBlob(const Il2CppImage* image, Il2CppTypeEnum type, const char **blob, void *value, bool deserializeManagedObjects)
    {
        switch (type)
        {
            case IL2CPP_TYPE_BOOLEAN:
            case IL2CPP_TYPE_U1:
            case IL2CPP_TYPE_I1:
                *(uint8_t*)value = Read8(blob);
                break;
            case IL2CPP_TYPE_CHAR:
                *(Il2CppChar*)value = ReadChar(blob);
                break;
            case IL2CPP_TYPE_U2:
            case IL2CPP_TYPE_I2:
                *(uint16_t*)value = Read16(blob);
                break;
            case IL2CPP_TYPE_U4:
                *(uint32_t*)value = ReadCompressedUInt32(blob);
                break;
            case IL2CPP_TYPE_I4:
                *(int32_t*)value = ReadCompressedInt32(blob);
                break;
            case IL2CPP_TYPE_U8:
            case IL2CPP_TYPE_I8:
                *(uint64_t*)value = Read64(blob);
                break;
            case IL2CPP_TYPE_R4:
                *(float*)value = ReadFloat(blob);
                break;
            case IL2CPP_TYPE_R8:
                *(double*)value = ReadDouble(blob);
                break;
            case IL2CPP_TYPE_STRING:
            {
                *(void**)value = NULL;
                if (*blob != NULL)
                {
                    // int32_t length followed by non-null terminated utf-8 byte stream
                    int32_t length = ReadCompressedInt32(blob);

                    // A length of -1 is a null string
                    if (length != -1)
                    {
                        if (deserializeManagedObjects)
                        {
                            *(Il2CppString**)value = il2cpp::vm::String::NewLen(*blob, length);
                            il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)value);
                        }
                        *blob += length;
                    }
                }
                break;
            }
            case IL2CPP_TYPE_SZARRAY:
            {
                if (*blob == NULL)
                {
                    *(void**)value = NULL;
                    return true;
                }

                int32_t arrayLen = ReadCompressedInt32(blob);
                if (arrayLen == -1)
                {
                    // A length of -1 is a null array
                    *(void**)value = NULL;
                    return true;
                }

                Il2CppClass* arrayElementClass;
                Il2CppTypeEnum arrayElementType = ReadEncodedTypeEnum(image, blob, &arrayElementClass);
                uint8_t arrayElementsAreDifferent = Read8(blob);

                IL2CPP_ASSERT(arrayElementClass);
                IL2CPP_ASSERT(arrayElementsAreDifferent != kArrayTypeWithDifferentElements || arrayElementType == IL2CPP_TYPE_OBJECT);

                Il2CppArray* arr = NULL;
                if (deserializeManagedObjects)
                    arr = il2cpp::vm::Array::New(arrayElementClass, arrayLen);

                for (int32_t i = 0; i < arrayLen; i++)
                {
                    Il2CppClass* elementClass = NULL;
                    Il2CppTypeEnum elementType = arrayElementType;
                    if (arrayElementsAreDifferent == kArrayTypeWithDifferentElements)
                        elementType = ReadEncodedTypeEnum(image, blob, &elementClass);

                    // Assumption: The array code is only called for custom attribute data
                    il2cpp::metadata::CustomAttributeDataStorage dataBuffer;
                    IL2CPP_ASSERT(arrayElementClass->element_size <= sizeof(il2cpp::metadata::CustomAttributeDataStorage));
                    if (!GetConstantValueFromBlob(image, elementType, blob, &dataBuffer, deserializeManagedObjects))
                        return false;

                    if (deserializeManagedObjects)
                    {
                        if (elementType != arrayElementType)
                        {
                            IL2CPP_ASSERT(arrayElementType == IL2CPP_TYPE_OBJECT);
                            IL2CPP_ASSERT(elementClass);
                            il2cpp_array_setref(arr, i, il2cpp::vm::Object::Box(elementClass, &dataBuffer));
                        }
                        else
                        {
                            il2cpp_array_setrefwithsize(arr, arr->klass->element_size, i, &dataBuffer);
                        }
                    }
                }

                *(Il2CppArray**)value = arr;
                il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)value);

                break;
            }
            case IL2CPP_TYPE_CLASS:
            case IL2CPP_TYPE_OBJECT:
            case IL2CPP_TYPE_GENERICINST:
                IL2CPP_ASSERT(*blob == NULL);
                *(void**)value = NULL;
                break;
            case IL2CPP_TYPE_IL2CPP_TYPE_INDEX:
            {
                TypeIndex typeIndex = ReadCompressedInt32(blob);
                if (typeIndex == -1)
                {
                    *(void**)value = NULL;
                }
                else if (deserializeManagedObjects)
                {
                    Il2CppClass* klass = il2cpp::vm::MetadataCache::GetTypeInfoFromTypeIndex(image, typeIndex);
                    *(Il2CppReflectionType**)value = il2cpp::vm::Reflection::GetTypeObject(&klass->byval_arg);
                    il2cpp::gc::GarbageCollector::SetWriteBarrier((void**)value);
                }
                break;
            }
            default:
                IL2CPP_ASSERT(0);
                return false;
        }

        return true;
    }

    Il2CppTypeEnum BlobReader::ReadEncodedTypeEnum(const Il2CppImage* image, const char** blob, Il2CppClass** klass)
    {
        Il2CppTypeEnum type = (Il2CppTypeEnum)Read8(blob);
        if (type == IL2CPP_TYPE_ENUM)
        {
            TypeIndex enumTypeIndex = ReadCompressedInt32(blob);
            *klass = il2cpp::vm::MetadataCache::GetTypeInfoFromTypeIndex(image, enumTypeIndex);
            type = il2cpp::vm::Class::GetEnumBaseType(*klass)->type;
        }
        else if (type == IL2CPP_TYPE_SZARRAY)
        {
            // Array class is good enough for this call
            // An array with specific element types will be created if needed
            *klass = il2cpp_defaults.array_class;
        }
        else
        {
            *klass = il2cpp::vm::Class::FromIl2CppTypeEnum(type);
        }

        return type;
    }
} /* utils */
} /* il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\BlobReader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\Debugger.cpp---------------
.
.
#include "il2cpp-config.h"

#if IL2CPP_MONO_DEBUGGER

#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "il2cpp-metadata.h"
#include "Debugger.h"
#include "os/Thread.h"
#include "os/c-api/Allocator.h"
#include "os/SocketBridge.h"

#include "vm/Assembly.h"
#include "vm/Image.h"
#include "vm/MetadataCache.h"
#include "vm/Method.h"
#include "vm/StackTrace.h"
#include "vm/Thread.h"
#include "utils/Environment.h"
#include "utils/dynamic_array.h"
#include "utils/StringUtils.h"
#include "utils/StringViewUtils.h"
#include "utils/Il2CppHashMap.h"
#include "utils/HashUtils.h"
#include "VmStringUtils.h"

#include <deque>
#include <string>
#include <algorithm>

il2cpp::os::ThreadLocalValue s_ExecutionContexts; // Il2CppThreadUnwindState*

struct MonoDebuggerRuntimeCallbacks
{
    void(*il2cpp_debugger_save_thread_context)(Il2CppThreadUnwindState* context, int frameCountAdjust);
    void(*il2cpp_debugger_free_thread_context)(Il2CppThreadUnwindState* context);
};

struct DebuggerTransport
{
    const char *name;
    void(*connect) (const char *address);
    int (*wait_for_attach) (void);
    void(*close1) (void);
    void(*close2) (void);
    int (*send) (void *buf, int len);
    int(*recv) (void *buf, int len);
};

struct MonoContext;
extern "C"
{
    void mono_debugger_agent_parse_options(const char *options);
    void mono_debugger_agent_init_minimal();
    void mono_debugger_agent_init();
    void mono_debugger_run_debugger_thread_func(void* arg);
    void debugger_agent_single_step_from_context(MonoContext *ctx, Il2CppSequencePoint* sequencePoint);
    void mono_debugger_il2cpp_init();
    void unity_debugger_agent_breakpoint(Il2CppSequencePoint* sequencePoint);
    void unity_debugger_agent_pausepoint();
    void mono_debugger_install_runtime_callbacks(MonoDebuggerRuntimeCallbacks* cbs);
    int32_t unity_debugger_agent_is_global_breakpoint_active(void* singleStepRequest);
    int32_t unity_debugger_agent_is_single_stepping();
    void unity_debugger_agent_handle_exception(Il2CppException *exc);
    int32_t il2cpp_mono_methods_match(const MethodInfo* left, const MethodInfo* right);
    void debugger_agent_user_break();
    int32_t debugger_agent_debug_log_is_enabled();
    void debugger_agent_debug_log(int level, Il2CppString *category, Il2CppString *message);
    int32_t unity_pause_point_active();
    void il2cpp_save_current_thread_context_func_exit();
    void mono_debugger_agent_register_transport(DebuggerTransport *trans);
    void unity_debugger_agent_thread_startup(uintptr_t tid);
    void unity_debugger_agent_thread_end(uintptr_t tid);
    void unity_debugger_agent_runtime_shutdown();

    static void* il2cpp_malloc(size_t size)
    {
        return IL2CPP_MALLOC(size);
    }

    static void il2cpp_mfree(void* memory)
    {
        IL2CPP_FREE(memory);
    }
}

static const Il2CppDebuggerMetadataRegistration *g_metadata;

namespace il2cpp
{
namespace utils
{
    typedef dynamic_array<Il2CppSequencePoint*> SequencePointList;
    typedef Il2CppHashMap<const MethodInfo*, SequencePointList*, il2cpp::utils::PointerHash<MethodInfo> > MethodToSequencePointsMap;
    typedef dynamic_array<Il2CppCatchPoint*> CatchPointList;
    typedef Il2CppHashMap<const MethodInfo*, CatchPointList*, il2cpp::utils::PointerHash<MethodInfo> > MethodToCatchPointsMap;
    typedef Il2CppHashMap<const MethodInfo*, const MethodInfo*, il2cpp::utils::PointerHash<MethodInfo> > MethodToMethodMap;
    typedef dynamic_array<const char*> FileNameList;
    typedef Il2CppHashMap<const Il2CppClass*, FileNameList, il2cpp::utils::PointerHash<Il2CppClass> > TypeSourceFileMap;

    struct DebuggerContext
    {
        DebuggerContext() : m_IsDebuggerAttached(false), m_IsDebuggerInitialized(false), m_Il2CppMonoLoaderLock(false), m_Il2CppMonoLoaderLockThreadId(0)
        {
        }

        os::Thread* m_DebuggerThread;
        bool m_IsDebuggerAttached;
        bool m_IsDebuggerInitialized;

        os::Mutex m_Il2CppMonoLoaderLock;
        uint64_t m_Il2CppMonoLoaderLockThreadId;

        Il2CppMonoInterpCallbacks m_InterpCallbacks;

        MethodToSequencePointsMap m_methodToSequencePoints;

        MethodToCatchPointsMap m_methodToCatchPoints;

        MethodToMethodMap m_uninflatedMethodToInflated;
        SequencePointList m_sequencePoints;

        TypeSourceFileMap *m_typeSourceFiles;
    };

    static std::string s_AgentOptions; // Intentionally left out from the DebuggerContext because it is accessed before we have a chance to call void Debugger::AllocateStaticData()
    static DebuggerContext* s_DebuggerContext = nullptr;

    void Debugger::AllocateStaticData()
    {
        if (s_DebuggerContext == nullptr)
            s_DebuggerContext = new DebuggerContext();
    }

    void Debugger::FreeStaticData()
    {
        delete s_DebuggerContext;
        s_DebuggerContext = nullptr;
    }

    static MethodToSequencePointsMap::const_iterator GetMethodSequencePointIterator(const MethodInfo *method);

    static void* FrameGetArg(Il2CppSequencePointExecutionContext* frame, int pos)
    {
        return frame->params[pos];
    }

    static void* FrameGetLocal(Il2CppSequencePointExecutionContext* frame, int pos)
    {
        return frame->locals[pos];
    }

    static void* FrameGetThis(Il2CppSequencePointExecutionContext* frame)
    {
        return *frame->thisArg;
    }

    static void InitializeInterpCallbacks()
    {
        s_DebuggerContext->m_InterpCallbacks.frame_get_arg = FrameGetArg;
        s_DebuggerContext->m_InterpCallbacks.frame_get_local = FrameGetLocal;
        s_DebuggerContext->m_InterpCallbacks.frame_get_this = FrameGetThis;
    }

    void Debugger::RegisterMetadata(const Il2CppDebuggerMetadataRegistration *data)
    {
        g_metadata = data;
    }

#if defined(RUNTIME_IL2CPP)
    void breakpoint_callback(Il2CppSequencePoint* sequencePoint)
    {
        unity_debugger_agent_breakpoint(sequencePoint);
    }

    void pausepoint_callback()
    {
        unity_debugger_agent_pausepoint();
    }

#endif

    static void InitializeMonoSoftDebugger(const char* options)
    {
#if defined(RUNTIME_IL2CPP)
        InitializeInterpCallbacks();

        os::SocketBridge::WaitForInitialization();

        mono_debugger_il2cpp_init();
        mono_debugger_agent_parse_options(options);
        mono_debugger_agent_init();

        s_DebuggerContext->m_typeSourceFiles = new TypeSourceFileMap();

        MonoDebuggerRuntimeCallbacks cbs;
        cbs.il2cpp_debugger_save_thread_context = Debugger::SaveThreadContext;
        cbs.il2cpp_debugger_free_thread_context = Debugger::FreeThreadContext;
        mono_debugger_install_runtime_callbacks(&cbs);

        il2cpp::utils::Debugger::RegisterCallbacks(breakpoint_callback, pausepoint_callback);

        register_allocator(il2cpp_malloc, il2cpp_mfree);

        s_DebuggerContext->m_IsDebuggerInitialized = true;
#else
        IL2CPP_ASSERT(0 && "The managed debugger is only supported for the libil2cpp runtime backend.");
#endif
    }

    void Debugger::SetAgentOptions(const char* options)
    {
        s_AgentOptions = options;
    }

    void Debugger::RegisterTransport(const Il2CppDebuggerTransport* transport)
    {
#if defined(RUNTIME_IL2CPP)
        DebuggerTransport mono_transport;
        mono_transport.name = transport->name;
        mono_transport.connect = transport->connect;
        mono_transport.wait_for_attach = transport->wait_for_attach;
        mono_transport.close1 = transport->close1;
        mono_transport.close2 = transport->close2;
        mono_transport.send = transport->send;
        mono_transport.recv = transport->recv;
        mono_debugger_agent_register_transport(&mono_transport);
#endif
    }

    void Debugger::InitializeTypeSourceFileMap()
    {
        Il2CppClass* lastKlass = NULL;
        Il2CppClass *klass = NULL;
        FileNameList files;

        vm::AssemblyVector* assemblies = vm::Assembly::GetAllAssemblies();
        for (vm::AssemblyVector::const_iterator  iter = assemblies->begin(); iter != assemblies->end(); ++iter)
        {
            const Il2CppImage* image = vm::Assembly::GetImage(*iter);
            const Il2CppDebuggerMetadataRegistration* debuggerMetadata = image->codeGenModule->debuggerMetadata;
            if (debuggerMetadata == NULL)
                continue;
            for (int i = 0; i < debuggerMetadata->numTypeSourceFileEntries; ++i)
            {
                Il2CppTypeSourceFilePair& pair = debuggerMetadata->typeSourceFiles[i];
                const char *file = debuggerMetadata->sequencePointSourceFiles[pair.sourceFileIndex].file;

                klass = il2cpp::vm::MetadataCache::GetTypeInfoFromTypeSourcePair(image, &pair);
                if (klass != lastKlass && lastKlass != NULL)
                {
                    s_DebuggerContext->m_typeSourceFiles->add(lastKlass, files);
                    files.clear();
                }
                lastKlass = klass;
                files.push_back(file);
            }
        }

        if (files.size() > 0)
            s_DebuggerContext->m_typeSourceFiles->add(klass, files);
    }

    void Debugger::Start()
    {
        if (s_DebuggerContext->m_IsDebuggerInitialized)
        {
            vm::MetadataCache::InitializeAllMethodMetadata();
            InitializeTypeSourceFileMap();
            InitializeMethodToSequencePointMap();
            InitializeMethodToCatchPointMap();
            Debugger::StartDebuggerThread();
        }
    }

    static bool TryInitializeDebugger(const std::string& options)
    {
        if (StringUtils::StartsWith(STRING_TO_STRINGVIEW(options), "--debugger-agent"))
        {
            InitializeMonoSoftDebugger(options.c_str() + options.find("=") + 1);
            return true;
        }

        return false;
    }

    void Debugger::Init()
    {
        AllocateStaticData();

        bool debuggerIsInitialized = false;
        if (!s_AgentOptions.empty())
        {
            debuggerIsInitialized = TryInitializeDebugger(s_AgentOptions);
        }
        else
        {
            const std::vector<UTF16String>& args = Environment::GetMainArgs();
            for (std::vector<UTF16String>::const_iterator arg = args.begin(); arg != args.end(); ++arg)
            {
                std::string argument = StringUtils::Utf16ToUtf8(*arg);
                debuggerIsInitialized = TryInitializeDebugger(argument);
                if (debuggerIsInitialized)
                    break;
            }
        }

        if (!debuggerIsInitialized)
            mono_debugger_agent_init_minimal();
    }

    static Debugger::OnBreakPointHitCallback s_BreakCallback;
    static Debugger::OnPausePointHitCallback s_PauseCallback;
    void Debugger::RegisterCallbacks(OnBreakPointHitCallback breakCallback, OnPausePointHitCallback pauseCallback)
    {
        s_BreakCallback = breakCallback;
        s_PauseCallback = pauseCallback;
    }

    void Debugger::StartDebuggerThread()
    {
#if defined(RUNTIME_IL2CPP)
        // This thread is allocated here once and never deallocated.
        s_DebuggerContext->m_DebuggerThread = new os::Thread();
        s_DebuggerContext->m_DebuggerThread->Run(mono_debugger_run_debugger_thread_func, NULL);
#else
        IL2CPP_ASSERT(0 && "The managed debugger is only supported for the libil2cpp runtime backend.");
#endif
    }

    Il2CppThreadUnwindState* Debugger::GetThreadStatePointer()
    {
        if (!s_DebuggerContext->m_IsDebuggerInitialized)
            return NULL;

        Il2CppThreadUnwindState* unwindState;
        s_ExecutionContexts.GetValue(reinterpret_cast<void**>(&unwindState));

        return unwindState;
    }

    void Debugger::SaveThreadContext(Il2CppThreadUnwindState* context, int frameCountAdjust)
    {
        if (!s_DebuggerContext->m_IsDebuggerInitialized)
            return;

        IL2CPP_ASSERT(!IsDebuggerThread(os::Thread::GetCurrentThread()));
    }

    void Debugger::FreeThreadContext(Il2CppThreadUnwindState* context)
    {
        if (!s_DebuggerContext->m_IsDebuggerInitialized)
            return;

        IL2CPP_ASSERT(!IsDebuggerThread(os::Thread::GetCurrentThread()));
    }

    void Debugger::OnBreakPointHit(Il2CppSequencePoint *sequencePoint)
    {
#if defined(RUNTIME_IL2CPP)
        if (IsGlobalBreakpointActive() || unity_debugger_agent_is_single_stepping())
        {
            debugger_agent_single_step_from_context(NULL, sequencePoint);
        }
        else if (s_BreakCallback)
        {
            s_BreakCallback(sequencePoint);
        }
        else
            IL2CPP_DEBUG_BREAK();
#else
        IL2CPP_ASSERT(0 && "The managed debugger is only supported for the libil2cpp runtime backend.");
#endif
    }

    void Debugger::OnPausePointHit()
    {
#if defined(RUNTIME_IL2CPP)
        if (s_PauseCallback)
            s_PauseCallback();
#else
        IL2CPP_ASSERT(0 && "The managed debugger is only supported for the libil2cpp runtime backend.");
#endif
    }

    bool Debugger::IsGlobalBreakpointActive()
    {
        if (!Debugger::GetIsDebuggerAttached())
            return false;
#if defined(RUNTIME_IL2CPP)
        return unity_debugger_agent_is_global_breakpoint_active(NULL);
#else
        IL2CPP_ASSERT(0 && "The managed debugger is only supported for the libil2cpp runtime backend.");
        return false;
#endif
    }

    bool Debugger::GetIsDebuggerAttached()
    {
        return s_DebuggerContext->m_IsDebuggerAttached;
    }

    void Debugger::SetIsDebuggerAttached(bool attached)
    {
        s_DebuggerContext->m_IsDebuggerAttached = attached;
    }

    bool Debugger::IsDebuggerThread(os::Thread* thread)
    {
        return thread == s_DebuggerContext->m_DebuggerThread;
    }

    static void InitializeUnwindState(Il2CppThreadUnwindState* unwindState, uint32_t frameCapacity)
    {
        unwindState->frameCount = 0;
        unwindState->frameCapacity = frameCapacity;
        unwindState->executionContexts = (Il2CppSequencePointExecutionContext**)calloc(frameCapacity, sizeof(Il2CppSequencePointExecutionContext*));
    }

    void Debugger::AllocateThreadLocalData()
    {
        Il2CppThreadUnwindState* unwindState;
        s_ExecutionContexts.GetValue(reinterpret_cast<void**>(&unwindState));
        if (unwindState == NULL)
        {
            unwindState = (Il2CppThreadUnwindState*)calloc(1, sizeof(Il2CppThreadUnwindState));
            InitializeUnwindState(unwindState, 512);
            s_ExecutionContexts.SetValue(unwindState);
        }
    }

    void Debugger::GrowFrameCapacity(Il2CppThreadUnwindState* unwindState)
    {
        // Create a new unwind state object to hold the large array of execution context pointers
        Il2CppThreadUnwindState newUnwindState;
        InitializeUnwindState(&newUnwindState, unwindState->frameCapacity * 2);

        // Copy the existing execution context pointers into the new one
        memcpy(newUnwindState.executionContexts, unwindState->executionContexts, unwindState->frameCapacity * sizeof(Il2CppSequencePointExecutionContext*));

        // Free the existing one
        free(unwindState->executionContexts);

        // Set the new data into the existing one, so the client can keep its object reference
        unwindState->frameCapacity = newUnwindState.frameCapacity;
        unwindState->executionContexts = newUnwindState.executionContexts;
    }

    void Debugger::FreeThreadLocalData()
    {
        if (s_DebuggerContext->m_IsDebuggerInitialized)
        {
            Il2CppThreadUnwindState* unwindState;
            s_ExecutionContexts.GetValue(reinterpret_cast<void**>(&unwindState));
            s_ExecutionContexts.SetValue(NULL);
            if (unwindState != NULL)
            {
                free(unwindState->executionContexts);
                free(unwindState);
            }
        }
    }

    Il2CppSequencePoint* Debugger::GetSequencePoint(const Il2CppImage* image, size_t id)
    {
        if (image->codeGenModule->debuggerMetadata->numSequencePoints == 0)
            return NULL;

        return &image->codeGenModule->debuggerMetadata->sequencePoints[id];
    }

    struct SeqPointIter
    {
        SequencePointList::iterator iter, end;
    };

    // Returns first sequence point for a method
    Il2CppSequencePoint* Debugger::GetSequenceFirstSequencePoint(const MethodInfo* method)
    {
        // m_methodToSequencePoints contains only generic methods
        if (method->is_inflated)
            method = method->genericMethod->methodDefinition;

        MethodToSequencePointsMap::const_iterator entry = s_DebuggerContext->m_methodToSequencePoints.find(method);
        if (entry == s_DebuggerContext->m_methodToSequencePoints.end())
        {
            return nullptr;
        }

        SequencePointList::iterator iter = entry->second->begin();
        SequencePointList::iterator end = entry->second->end();
        while (iter != end)
        {
            // Return the first sequence point that has a line number
            if ((*iter)->lineStart != 0)
                return *iter;
            ++iter;
        }

        return nullptr;
    }

    Il2CppSequencePoint* Debugger::GetSequencePoints(const MethodInfo* method, void** iter)
    {
        if (!iter)
            return NULL;

        SeqPointIter *pIter = NULL;

        if (!*iter)
        {
            MethodToSequencePointsMap::const_iterator entry = GetMethodSequencePointIterator(method);
            if (entry == s_DebuggerContext->m_methodToSequencePoints.end())
                return NULL;

            pIter = new SeqPointIter();
            *iter = pIter;
            pIter->iter = entry->second->begin();
            pIter->end = entry->second->end();
            return *(pIter->iter);
        }

        pIter = (SeqPointIter*)*iter;
        pIter->iter++;
        if (pIter->iter != pIter->end)
        {
            return *(pIter->iter);
        }
        else
        {
            delete pIter;
            *iter = NULL;
        }

        return NULL;
    }

    Il2CppSequencePoint* Debugger::GetAllSequencePoints(void* *iter)
    {
        size_t index = (size_t)(intptr_t)*iter;

        if (index >= s_DebuggerContext->m_sequencePoints.size())
            return NULL;

        Il2CppSequencePoint* retVal = s_DebuggerContext->m_sequencePoints[index];
        *iter = (void*)(intptr_t)(index + 1);
        return retVal;
    }

    MethodToSequencePointsMap::const_iterator GetMethodSequencePointIterator(const MethodInfo *method)
    {
        if (method->is_inflated)
            method = method->genericMethod->methodDefinition;

        MethodToSequencePointsMap::const_iterator entry = s_DebuggerContext->m_methodToSequencePoints.find(method);
        if (entry == s_DebuggerContext->m_methodToSequencePoints.end())
        {
            //the sequence point map doesn't have uninflated methods, need to map the incoming method to
            //an inflated method.  il2cpp_mono_methods_match has a case for this.
            MethodToMethodMap::const_iterator inflated = s_DebuggerContext->m_uninflatedMethodToInflated.find(method);
            if (inflated != s_DebuggerContext->m_uninflatedMethodToInflated.end())
            {
                method = inflated->second;
            }
            else
            {
                for (MethodToSequencePointsMap::iterator mapIter = s_DebuggerContext->m_methodToSequencePoints.begin(); mapIter != s_DebuggerContext->m_methodToSequencePoints.end(); ++mapIter)
                {
                    if (il2cpp_mono_methods_match(method, mapIter->first))
                    {
                        s_DebuggerContext->m_uninflatedMethodToInflated.add(method, mapIter->first);
                        method = mapIter->first;
                        break;
                    }
                }
            }

            return s_DebuggerContext->m_methodToSequencePoints.find(method);
        }

        return entry;
    }

    Il2CppSequencePoint* Debugger::GetSequencePoint(const Il2CppImage* image, Il2CppCatchPoint* cp)
    {
        const MethodInfo *method = GetCatchPointMethod(image, cp);

        MethodToSequencePointsMap::const_iterator entry = GetMethodSequencePointIterator(method);
        if (entry == s_DebuggerContext->m_methodToSequencePoints.end())
            return NULL;

        SequencePointList::iterator iter = entry->second->begin();
        while (iter != entry->second->end())
        {
            if ((*iter)->ilOffset >= cp->ilOffset)
                return *iter;

            ++iter;
        }

        return NULL;
    }

    struct CatchPointIter
    {
        CatchPointList::iterator iter, end;
    };

    Il2CppCatchPoint* Debugger::GetCatchPoints(const MethodInfo* method, void** iter)
    {
        if (!iter)
            return NULL;

        CatchPointIter *pIter = NULL;

        if (!*iter)
        {
            MethodToCatchPointsMap::const_iterator entry = s_DebuggerContext->m_methodToCatchPoints.find(method);
            if (entry == s_DebuggerContext->m_methodToCatchPoints.end())
                return NULL;

            pIter = new CatchPointIter();
            *iter = pIter;
            pIter->iter = entry->second->begin();
            pIter->end = entry->second->end();
            return *(pIter->iter);
        }

        pIter = (CatchPointIter*)*iter;
        pIter->iter++;
        if (pIter->iter != pIter->end)
        {
            return *(pIter->iter);
        }
        else
        {
            delete pIter;
            *iter = NULL;
        }

        return NULL;
    }

    void Debugger::HandleException(Il2CppException *exc)
    {
        if (s_DebuggerContext->m_IsDebuggerInitialized)
            unity_debugger_agent_handle_exception(exc);
    }

    bool SequencePointOffsetLess(const Il2CppSequencePoint *s1, const Il2CppSequencePoint *s2)
    {
        return s1->ilOffset < s2->ilOffset;
    }

    bool CatchPointOffsetLess(const Il2CppCatchPoint *c1, const Il2CppCatchPoint *c2)
    {
        return c1->ilOffset < c2->ilOffset;
    }

    void Debugger::InitializeMethodToSequencePointMap()
    {
        size_t count = 0;
        vm::AssemblyVector* assemblies = vm::Assembly::GetAllAssemblies();
        for (vm::AssemblyVector::const_iterator iter = assemblies->begin(); iter != assemblies->end(); ++iter)
        {
            const Il2CppImage* image = vm::Assembly::GetImage(*iter);
            const Il2CppDebuggerMetadataRegistration* debuggerMetadata = image->codeGenModule->debuggerMetadata;
            if (debuggerMetadata == NULL)
                continue;
            for (int i = 0; i < debuggerMetadata->numSequencePoints; ++i)
            {
                Il2CppSequencePoint& seqPoint = debuggerMetadata->sequencePoints[i];
                const MethodInfo *method = GetSequencePointMethod(image, &seqPoint);

                if (method != NULL)
                {
                    IL2CPP_ASSERT(!method->is_inflated && "Only open generic methods should have sequence points");

                    SequencePointList* list;
                    MethodToSequencePointsMap::iterator existingList = s_DebuggerContext->m_methodToSequencePoints.find(method);
                    if (existingList == s_DebuggerContext->m_methodToSequencePoints.end())
                    {
                        list = new SequencePointList();
                        s_DebuggerContext->m_methodToSequencePoints.add(method, list);
                    }
                    else
                    {
                        list = existingList->second;
                    }
                    list->push_back(&seqPoint);
                    count++;
                }
            }
        }

        s_DebuggerContext->m_sequencePoints.reserve(count);

        for (MethodToSequencePointsMap::iterator methods = s_DebuggerContext->m_methodToSequencePoints.begin(); methods != s_DebuggerContext->m_methodToSequencePoints.end(); ++methods)
        {
            SequencePointList *seqPoints = methods->second;
            std::sort(seqPoints->begin(), seqPoints->end(), SequencePointOffsetLess);
            s_DebuggerContext->m_sequencePoints.insert(s_DebuggerContext->m_sequencePoints.end(), seqPoints->begin(), seqPoints->end());
        }
    }

    void Debugger::InitializeMethodToCatchPointMap()
    {
        vm::AssemblyVector* assemblies = vm::Assembly::GetAllAssemblies();
        for (vm::AssemblyVector::const_iterator iter = assemblies->begin(); iter != assemblies->end(); ++iter)
        {
            const Il2CppImage* image = vm::Assembly::GetImage(*iter);
            const Il2CppDebuggerMetadataRegistration* debuggerMetadata = image->codeGenModule->debuggerMetadata;
            if (debuggerMetadata == NULL)
                continue;
            for (int i = 0; i < debuggerMetadata->numCatchPoints; ++i)
            {
                Il2CppCatchPoint& catchPoint = debuggerMetadata->catchPoints[i];
                const MethodInfo *method = GetCatchPointMethod(image, &catchPoint);

                if (method != NULL)
                {
                    CatchPointList* list;
                    MethodToCatchPointsMap::iterator existingList = s_DebuggerContext->m_methodToCatchPoints.find(method);
                    if (existingList == s_DebuggerContext->m_methodToCatchPoints.end())
                    {
                        list = new CatchPointList();
                        s_DebuggerContext->m_methodToCatchPoints.add(method, list);
                    }
                    else
                    {
                        list = existingList->second;
                    }
                    list->push_back(&catchPoint);
                }
            }
        }

        for (MethodToCatchPointsMap::iterator methods = s_DebuggerContext->m_methodToCatchPoints.begin(); methods != s_DebuggerContext->m_methodToCatchPoints.end(); ++methods)
        {
            CatchPointList *catchPoints = methods->second;
            std::sort(catchPoints->begin(), catchPoints->end(), CatchPointOffsetLess);
        }
    }

    const char** Debugger::GetTypeSourceFiles(const Il2CppClass *klass, int& count)
    {
        TypeSourceFileMap::iterator it = s_DebuggerContext->m_typeSourceFiles->find(klass);
        if (it == s_DebuggerContext->m_typeSourceFiles->end())
        {
            count = 0;
            return NULL;
        }

        count = (int)it->second.size();
        return it->second.data();
    }

    void Debugger::UserBreak()
    {
        if (s_DebuggerContext->m_IsDebuggerAttached)
            debugger_agent_user_break();
    }

    bool Debugger::IsLoggingEnabled()
    {
        return debugger_agent_debug_log_is_enabled();
    }

    void Debugger::Log(int level, Il2CppString *category, Il2CppString *message)
    {
        if (s_DebuggerContext->m_IsDebuggerAttached)
            debugger_agent_debug_log(level, category, message);
    }

    bool Debugger::IsPausePointActive()
    {
        return unity_pause_point_active();
    }

    void Debugger::CheckPausePoint()
    {
        if (il2cpp::utils::Debugger::IsPausePointActive())
            il2cpp::utils::Debugger::OnPausePointHit();
    }

    const MethodInfo* Debugger::GetSequencePointMethod(const Il2CppImage* image, Il2CppSequencePoint *seqPoint)
    {
        if (seqPoint == NULL)
            return NULL;

        return il2cpp::vm::MetadataCache::GetMethodInfoFromSequencePoint(image, seqPoint);
    }

    const MethodInfo* Debugger::GetCatchPointMethod(const Il2CppImage* image, Il2CppCatchPoint *catchPoint)
    {
        if (catchPoint == NULL)
            return NULL;

        return il2cpp::vm::MetadataCache::GetMethodInfoFromCatchPoint(image, catchPoint);
    }

    const char* Debugger::GetLocalName(const MethodInfo* method, int32_t index)
    {
        const Il2CppDebuggerMetadataRegistration* debuggerMetadata = method->klass->image->codeGenModule->debuggerMetadata;
        return debuggerMetadata->methodExecutionContextInfoStrings[index];
    }

    const Il2CppMethodScope* Debugger::GetLocalScope(const MethodInfo* method, int32_t index)
    {
        const Il2CppDebuggerMetadataRegistration* debuggerMetadata = method->klass->image->codeGenModule->debuggerMetadata;
        return &debuggerMetadata->methodScopes[index];
    }

    void Debugger::GetMethodExecutionContextInfo(const MethodInfo* method, uint32_t* executionContextInfoCount, const Il2CppMethodExecutionContextInfo **executionContextInfo, const Il2CppMethodHeaderInfo **headerInfo, const Il2CppMethodScope **scopes)
    {
        if (il2cpp::vm::Method::IsInflated(method))
            method = il2cpp::vm::MetadataCache::GetGenericMethodDefinition(method);
        const Il2CppDebuggerMetadataRegistration* debuggerMetadata = method->klass->image->codeGenModule->debuggerMetadata;

        Il2CppMethodExecutionContextInfoIndex *index = &debuggerMetadata->methodExecutionContextInfoIndexes[GetTokenRowId(method->token) - 1];
        if (index->count != -1)
        {
            *executionContextInfoCount = index->count;
            *executionContextInfo = &debuggerMetadata->methodExecutionContextInfos[index->startIndex];
        }
        else
        {
            *executionContextInfoCount = 0;
            *executionContextInfo = NULL;
        }
        *headerInfo = &debuggerMetadata->methodHeaderInfos[GetTokenRowId(method->token) - 1];
        *scopes = &debuggerMetadata->methodScopes[(*headerInfo)->startScope];
    }

    void Debugger::GetStackFrames(void* context)
    {
        il2cpp::vm::StackFrames* stackFrames = static_cast<il2cpp::vm::StackFrames*>(context);

        Il2CppThreadUnwindState* unwindState = GetThreadStatePointer();
        if (unwindState == NULL)
            return; // There might not be any managed code executing yet.

        for (uint32_t i = 0; i < unwindState->frameCount; ++i)
        {
            const MethodInfo* method = unwindState->executionContexts[i]->method;
            if (method != NULL)
            {
                Il2CppStackFrameInfo frameInfo = { 0 };
                frameInfo.method = method;
                if (unwindState->executionContexts[i]->currentSequencePoint != NULL)
                {
                    const Il2CppDebuggerMetadataRegistration* debuggerMetadata = method->klass->image->codeGenModule->debuggerMetadata;
                    if (debuggerMetadata != NULL)
                    {
                        int32_t sourceFileIndex = unwindState->executionContexts[i]->currentSequencePoint->sourceFileIndex;
                        frameInfo.filePath = debuggerMetadata->sequencePointSourceFiles[sourceFileIndex].file;
                        frameInfo.sourceCodeLineNumber = unwindState->executionContexts[i]->currentSequencePoint->lineStart;
                        frameInfo.ilOffset = unwindState->executionContexts[i]->currentSequencePoint->ilOffset;
                    }
                }
                stackFrames->push_back(frameInfo);
            }
        }
    }

    void Debugger::AcquireLoaderLock()
    {
        s_DebuggerContext->m_Il2CppMonoLoaderLock.Lock();
        s_DebuggerContext->m_Il2CppMonoLoaderLockThreadId = os::Thread::CurrentThreadId();
    }

    void Debugger::ReleaseLoaderLock()
    {
        s_DebuggerContext->m_Il2CppMonoLoaderLockThreadId = 0;
        s_DebuggerContext->m_Il2CppMonoLoaderLock.Unlock();
    }

    bool Debugger::LoaderLockIsOwnedByThisThread()
    {
        return s_DebuggerContext->m_Il2CppMonoLoaderLockThreadId == os::Thread::CurrentThreadId();
    }

    Il2CppMonoInterpCallbacks* Debugger::GetInterpCallbacks()
    {
        return &s_DebuggerContext->m_InterpCallbacks;
    }

    void Debugger::RuntimeShutdownEnd()
    {
        unity_debugger_agent_runtime_shutdown();
    }

    void Debugger::ThreadStarted(uintptr_t tid)
    {
        unity_debugger_agent_thread_startup(tid);
    }

    void Debugger::ThreadStopped(uintptr_t tid)
    {
        unity_debugger_agent_thread_end(tid);
    }
}
}

#else

#include "Debugger.h"
#include "os/Debug.h"

namespace il2cpp
{
namespace utils
{
    bool Debugger::GetIsDebuggerAttached()
    {
        return os::Debug::IsDebuggerPresent();
    }
}
}

#endif // IL2CPP_MONO_DEBUGGER
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\Debugger.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\DebugSymbolReader.cpp---------------
.
.
#include "il2cpp-config.h"

#include "os/File.h"
#include "os/Image.h"
#include "os/Path.h"
#include "utils/Logging.h"
#include "utils/Memory.h"
#include "utils/MemoryMappedFile.h"
#include "utils/PathUtils.h"
#include "utils/StringView.h"
#include "utils/Runtime.h"
#include "vm-utils/DebugSymbolReader.h"
#include "vm/GlobalMetadata.h"
#include "vm/Method.h"
#include "vm/Reflection.h"
#include <string>

#if IL2CPP_TARGET_ARM64E
#include <ptrauth.h>
#endif

namespace il2cpp
{
namespace utils
{
    struct usymliteHeader
    {
        uint32_t magic;
        uint32_t version;
        uint32_t lineCount;
        uint32_t id; // executable's id, offset in string table
        uint32_t os;
        uint32_t arch;
    };

    struct usymliteLine
    {
        uint64_t address;
        uint32_t methodIndex;
        uint32_t fileName; // Reference to the managed source file name in the string table
        uint32_t line; // Managed line number
        uint32_t parent;
    };

    struct Reader
    {
        void* debugSymbolData;
        const usymliteLine* lines;
        const char* strings;
        usymliteHeader header;
        std::string uuid;
        std::string os;
        std::string arch;
        uint64_t firstLineAddress;
        uint64_t lastLineAddress;
        uint32_t maxStringIndex;
    };

    static Reader s_usym = { 0 };

    const int headerSize = 24;
    const int lineSize = 24;
    const uint32_t magicUsymlite = 0x2D6D7973; // "sym-"
    const uint32_t noLine = 0xFFFFFFFF;

    static std::string GetArchFolder()
    {
#if IL2CPP_TARGET_ARM64
        return PathUtils::Combine(utils::Runtime::GetDataDir(), std::string("arm64"));
#elif IL2CPP_TARGET_X64
        return PathUtils::Combine(utils::Runtime::GetDataDir(), std::string("x64"));
#else
        return std::string("<NotImplemented>");
#endif
    }

    // Do a binary search to find the line with the given address
    // This is looking for the line with the closest address without going over (price is right style)
    static usymliteLine FindLine(uint64_t address)
    {
        uint32_t head = 0;
        uint32_t tail = s_usym.header.lineCount - 1;

        while (head < tail)
        {
            uint32_t mid = (head + tail + 1) / 2;
            uint64_t midAddr = s_usym.lines[mid].address;

            if (address < midAddr)
            {
                tail = mid - 1;
            }
            else
            {
                head = mid;
            }
        }

        uint64_t foundAddr = s_usym.lines[head].address;

        // Find the last entry with this address
        while (head + 1 < s_usym.header.lineCount && s_usym.lines[head + 1].address == foundAddr)
        {
            head += 1;
        }

        return s_usym.lines[head];
    }

    static const char* GetString(uint32_t index)
    {
        IL2CPP_ASSERT(index < s_usym.maxStringIndex);
        return s_usym.strings + index;
    }

#define IL2CPP_DEBUG_DUMP_USYM_DATA 0

#if IL2CPP_DEBUG_DUMP_USYM_DATA
    static void DumpUsymData()
    {
        // You may want to change this to be a full path so it is easy to locate.
        FILE* dumpFile = fopen("usymData.txt", "w");
        uint64_t imageBase = (uint64_t)os::Image::GetImageBase();
        for (uint32_t i = 0; i < s_usym.header.lineCount; i++)
        {
            if (s_usym.lines[i].methodIndex != noLine)
            {
                uint64_t address = s_usym.lines[i].address;
                void* actualAddress = (void*)(s_usym.lines[i].address + imageBase);
                const MethodInfo* methodInfo = vm::GlobalMetadata::GetMethodInfoFromMethodDefinitionIndex(s_usym.lines[i].methodIndex);
                uint32_t methodIndex = s_usym.lines[i].methodIndex;
                const char* filePath = GetString(s_usym.lines[i].fileName);
                uint32_t sourceCodeLineNumber = s_usym.lines[i].line;
                uint32_t parent = s_usym.lines[i].parent;

                if (methodInfo != NULL)
                    fprintf(dumpFile, "%d [%p, %llu] Method Index: %d %s %s(%d) parent: %d\n", i, actualAddress, address, methodIndex, vm::Method::GetFullName(methodInfo).c_str(), filePath, sourceCodeLineNumber, parent);
            }
        }
        fclose(dumpFile);
    }

#endif

    bool DebugSymbolReader::LoadDebugSymbols()
    {
        int error = 0;
        std::string symbolsPath;
        const StringView<char> symbolFileName = "il2cpp.usym";

        // First, look for the symbol file next to the executable.
        std::string applicationFolder = os::Path::GetApplicationFolder();
        if (!applicationFolder.empty())
            symbolsPath = PathUtils::Combine(applicationFolder, symbolFileName);

        os::FileHandle* symbolsFileHandle = NULL;
        if (!symbolsPath.empty())
            symbolsFileHandle = os::File::Open(symbolsPath.c_str(), kFileModeOpen, kFileAccessRead, kFileShareRead, kFileOptionsNone, &error);

        // (MacOS only) - Handle cases where the il2cpp.usym file's been dropped under an architecture specific (x64 or arm64) directory
        if (symbolsPath.empty() || error != 0)
        {
            std::string archFolder = GetArchFolder();
            if (!archFolder.empty())
                symbolsPath = PathUtils::Combine(archFolder, symbolFileName);

            if (!symbolsPath.empty())
                symbolsFileHandle = os::File::Open(symbolsPath.c_str(), kFileModeOpen, kFileAccessRead, kFileShareRead, kFileOptionsNone, &error);
        }

        // If we don't have a symbol path yet or there was some error opening the file next to the executable, try to
        // look in the data directory. For some platforms, the packaging won't allow the file to live next to the
        // executable.
        if (symbolsPath.empty() || error != 0)
        {
            symbolsPath = PathUtils::Combine(utils::Runtime::GetDataDir(), symbolFileName);
            symbolsFileHandle = os::File::Open(symbolsPath.c_str(), kFileModeOpen, kFileAccessRead, kFileShareRead, kFileOptionsNone, &error);
            if (error != 0)
                return false;
        }

        s_usym.debugSymbolData = utils::MemoryMappedFile::Map(symbolsFileHandle);
        int64_t length = os::File::GetLength(symbolsFileHandle, &error);

        os::File::Close(symbolsFileHandle, &error);
        if (error != 0)
        {
            utils::MemoryMappedFile::Unmap(s_usym.debugSymbolData);
            s_usym.debugSymbolData = NULL;
            return false;
        }

        s_usym.header = *(usymliteHeader *)((char *)s_usym.debugSymbolData);

        if (s_usym.header.magic != magicUsymlite || s_usym.header.lineCount == 0)
        {
            utils::MemoryMappedFile::Unmap(s_usym.debugSymbolData);
            s_usym.debugSymbolData = NULL;
            return false;
        }

        int64_t lineOffset = headerSize;
        int64_t stringOffset = lineOffset + (s_usym.header.lineCount * lineSize);

        s_usym.maxStringIndex = (uint32_t)(length - stringOffset);
        s_usym.lines = (const usymliteLine*)((const char *)s_usym.debugSymbolData + lineOffset);
        s_usym.strings = ((const char *)s_usym.debugSymbolData + stringOffset);

#if IL2CPP_ENABLE_NATIVE_INSTRUCTION_POINTER_EMISSION
        char* our_uuid = os::Image::GetImageUUID();
        s_usym.uuid = std::string(GetString(s_usym.header.id));

        if (our_uuid == NULL || s_usym.uuid != our_uuid)
        {
            // UUID mismatch means this usymfile is not for this program
            il2cpp::utils::Logging::Write("Ignoring symbol file due to UUID mismatch. File contains %s but expected %s.", s_usym.uuid.c_str(), our_uuid);
            utils::MemoryMappedFile::Unmap(s_usym.debugSymbolData);
            s_usym.debugSymbolData = NULL;
            s_usym.lines = NULL;
            s_usym.strings = NULL;
            return false;
        }

        IL2CPP_FREE(our_uuid);
#endif

        s_usym.os = std::string(GetString(s_usym.header.os));
        s_usym.arch = std::string(GetString(s_usym.header.arch));

        s_usym.firstLineAddress = s_usym.lines[0].address;
        s_usym.lastLineAddress = s_usym.lines[s_usym.header.lineCount - 1].address;

#if IL2CPP_DEBUG_DUMP_USYM_DATA
        DumpUsymData();
#endif
        return true;
    }

    static void InsertStackFrame(usymliteLine line, std::vector<Il2CppStackFrameInfo>* stackFrames)
    {
        if (line.parent != noLine)
        {
            InsertStackFrame(s_usym.lines[line.parent], stackFrames);
        }

        const MethodInfo* methodInfo = vm::GlobalMetadata::GetMethodInfoFromMethodDefinitionIndex(line.methodIndex);

        Il2CppStackFrameInfo frameInfo = { 0 };
        frameInfo.method = methodInfo;
        frameInfo.raw_ip = (uintptr_t)line.address;
        frameInfo.filePath = GetString(line.fileName);
        frameInfo.sourceCodeLineNumber = line.line;
        stackFrames->push_back(frameInfo);
    }

    // Gets the line information for the given address
    static bool GetUsymLine(void* address, usymliteLine& line)
    {
        if (s_usym.debugSymbolData == NULL || address == NULL)
        {
            return false;
        }

        // The instruction pointer points to the next address, so to get the address we came from, we subtract 1.
        // findLine matches the address to the closest address <= the one we give, so it finds the one we need
        uint64_t adjustedAddress = ((uint64_t)address) - ((uint64_t)os::Image::GetImageBase()) - 1;

#if IL2CPP_TARGET_ANDROID
        // We don't seem to need to subtract by one for Android
        // https://github.com/Unity-Technologies/unity-services-crash/commit/50611fcf29a1d876689942ed1f1cdca23e32c522
        adjustedAddress += 1;
#endif

#if IL2CPP_TARGET_ARM64E
        adjustedAddress = (uint64_t)ptrauth_strip((void*)adjustedAddress, ptrauth_key_return_address);
#endif

        // Quick check to remove anything outside the range
        if (adjustedAddress < s_usym.firstLineAddress || s_usym.lastLineAddress < adjustedAddress)
        {
            return false;
        }

        line = FindLine(adjustedAddress);

        // End of symbol entries are placed to indicate that we're past the end of a C# function.
        // These EOS entries have their Line and FileName set to 0xFFFFFFFF
        if (line.line == noLine)
        {
            return false;
        }

        return true;
    }

    bool DebugSymbolReader::GetSourceLocation(void* nativeInstructionPointer, SourceLocation& sourceLocation)
    {
        usymliteLine line;
        if (!GetUsymLine(nativeInstructionPointer, line))
        {
            return false;
        }

        sourceLocation.filePath = GetString(line.fileName);
        sourceLocation.lineNumber = line.line;

        return true;
    }

    bool DebugSymbolReader::AddStackFrames(void* nativeInstructionPointer, std::vector<Il2CppStackFrameInfo>* stackFrames)
    {
        usymliteLine line;
        if (!GetUsymLine(nativeInstructionPointer, line))
        {
            return false;
        }

        InsertStackFrame(line, stackFrames);

        return true;
    }

    bool DebugSymbolReader::DebugSymbolsAvailable()
    {
        #if IL2CPP_MONO_DEBUGGER
        return true;
        #else
        return s_usym.debugSymbolData != NULL;
        #endif
    }
} /* namespace utils */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\DebugSymbolReader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\Finally.cpp---------------
.
.
#include "il2cpp-config.h"
#include "Finally.h"
#include "vm/Exception.h"

NORETURN void il2cpp::utils::RethrowException(Il2CppException* exception)
{
    vm::Exception::Rethrow(exception);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\Finally.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\NativeSymbol.cpp---------------
.
.
#include "il2cpp-config.h"

#include "il2cpp-class-internals.h"
#include "os/Environment.h"
#include "os/File.h"
#include "os/Image.h"
#include "os/Initialize.h"
#include "os/LibraryLoader.h"
#include "os/Locale.h"
#include "os/Path.h"
#include "utils/Collections.h"
#include "utils/PathUtils.h"
#include "utils/MemoryMappedFile.h"
#include "utils/Runtime.h"
#include "vm/Method.h"
#include "vm-utils/Debugger.h"
#include "vm-utils/DebugSymbolReader.h"
#include "vm-utils/MethodDefinitionKey.h"
#include "vm-utils/NativeSymbol.h"
#include <string>
#include <cstdlib>

namespace il2cpp
{
namespace utils
{
#if IL2CPP_ENABLE_NATIVE_STACKTRACES

    static Il2CppMethodPointer MaskSpareBits(const Il2CppMethodPointer method)
    {
        return (Il2CppMethodPointer)((size_t)method & ~IL2CPP_POINTER_SPARE_BITS);
    }

    struct MethodInfoToMethodPointerConverter
    {
        Il2CppMethodPointer operator()(const MethodDefinitionKey& methodInfo) const
        {
            return MaskSpareBits(methodInfo.method);
        }
    };

    typedef il2cpp::utils::collections::ArrayValueMap<Il2CppMethodPointer, MethodDefinitionKey, MethodInfoToMethodPointerConverter> NativeMethodMap;
    static NativeMethodMap s_NativeMethods;

    struct NativeSymbolMutator
    {
        void operator()(MethodDefinitionKey* method)
        {
            // So, when a function is marked as noreturn, some compilers emit a call to that function and then
            // put the next function immediately after call instruction which means the return address on the stack
            // will appear to point to the wrong function. This messes up our stack walking as we now are confused
            // which method is actually on the stack. To work around this, we add "1" to each of the function addresses,
            // so each function appears to start 1 byte later which means the address on the stack will appear as if
            // it is pointing to function that called the no return function. This is okay because no function will
            // ever return to the first byte of another function.
            method->method = reinterpret_cast<Il2CppMethodPointer>(reinterpret_cast<intptr_t>(method->method) + 1);
        }
    };

    void NativeSymbol::RegisterMethods(const std::vector<MethodDefinitionKey>& managedMethods)
    {
        s_NativeMethods.assign(managedMethods);

#if IL2CPP_MUTATE_METHOD_POINTERS
        NativeSymbolMutator mutator;
        s_NativeMethods.mutate(mutator);
#endif
    }

    static const int k_ProbableMaximumManagedMethodSizeInBytes = 5000;

    static bool IsInstructionPointerProbablyInManagedMethod(Il2CppMethodPointer managedMethodStart, Il2CppMethodPointer instructionPointer)
    {
        if (std::abs((intptr_t)managedMethodStart - (intptr_t)instructionPointer) < k_ProbableMaximumManagedMethodSizeInBytes)
            return true;

        return false;
    }

    const VmMethod* NativeSymbol::GetMethodFromNativeSymbol(Il2CppMethodPointer nativeMethod)
    {
        // Address has to be above our base address
        if ((void*)nativeMethod < il2cpp::os::Image::GetImageBase())
            return NULL;

        // And within the addresses we have our methods in.
        if (il2cpp::os::Image::ManagedSectionExists())
        {
            if (!il2cpp::os::Image::IsInManagedSection((void*)nativeMethod))
                return NULL;
        }

        // Get the first symbol greater than the one we want, because our instruction pointer
        // probably won't be at the start of the method.
        NativeMethodMap::iterator methodAfterNativeMethod = s_NativeMethods.upper_bound(nativeMethod);

        // If method are all of the managed methods are in the same custom section of the binary, then assume we
        // will find the proper method, so the end iterator means we found the last method in this list. If we
        // don't have custom sections, then we may have actually not found the method. In that case, let's not
        // return a method we are unsure of.
        if (!il2cpp::os::Image::ManagedSectionExists())
        {
            if (methodAfterNativeMethod == s_NativeMethods.end())
                return NULL;

            if (!IsInstructionPointerProbablyInManagedMethod(methodAfterNativeMethod->method, nativeMethod))
                return NULL;
        }

        // Go back one to get the method we actually want.
        if (methodAfterNativeMethod != s_NativeMethods.begin())
            methodAfterNativeMethod--;

        return il2cpp::vm::MetadataCache::GetMethodInfoFromMethodHandle(methodAfterNativeMethod->methodHandle);
    }

    static void GetMethodDebugInfoWithSymbols(const MethodInfo* method, intptr_t methodPointer, int32_t size, Il2CppMethodDebugInfo& methodDebugInfo)
    {
        methodDebugInfo.methodPointer = (Il2CppMethodPointer)methodPointer;
        methodDebugInfo.code_size = size;

        // Get the source file name for the method in case usym file is available.
#if !IL2CPP_MONO_DEBUGGER
        // Use usym file if debugging is not available
        il2cpp::utils::SourceLocation sourceLocation;
        if (il2cpp::utils::DebugSymbolReader::GetSourceLocation((void*)methodPointer, sourceLocation))
        {
            methodDebugInfo.file = sourceLocation.filePath;
            methodDebugInfo.line = sourceLocation.lineNumber;
        }
#else
        const Il2CppSequencePoint* sequencePoint = il2cpp::utils::Debugger::GetSequenceFirstSequencePoint(method);
        if (sequencePoint != nullptr)
        {
            const Il2CppSequencePointSourceFile* sequencePointSourceFile = method->klass->image->codeGenModule->debuggerMetadata->sequencePointSourceFiles + sequencePoint->sourceFileIndex;
            methodDebugInfo.file = sequencePointSourceFile->file;
            methodDebugInfo.line = sequencePoint->lineStart;
        }
#endif
        else
        {
            methodDebugInfo.file = NULL;
            methodDebugInfo.line = 0;
        }
    }

#define IL2CPP_DEBUG_DUMP_NATIVE_SYMBOL_DATA 0

#if IL2CPP_DEBUG_DUMP_NATIVE_SYMBOL_DATA
    static void DumpNativeSymbolData()
    {
        // You may want to change this to be a full path so it is easy to locate.
        FILE* dumpFile = fopen("nativeMethodsData.txt", "w");
        for (uint32_t i = 0; i < s_NativeMethods.size(); ++i)
        {
            const MethodDefinitionKey& methodKey = s_NativeMethods[i];

            void* address = methodKey.method;
            const MethodInfo* methodInfo = il2cpp::vm::MetadataCache::GetMethodInfoFromMethodHandle(methodKey.methodHandle);
            if (methodInfo != nullptr)
                fprintf(dumpFile, "%d\t[%p]:\t%s\n", i, address, vm::Method::GetFullName(methodInfo).c_str());
        }
        fclose(dumpFile);
    }

#endif

    void NativeSymbol::GetAllManagedMethodsWithDebugInfo(void(*func)(const MethodInfo* method, Il2CppMethodDebugInfo* methodDebugInfo, void* userData), void* userData)
    {
#if IL2CPP_DEBUG_DUMP_NATIVE_SYMBOL_DATA
        DumpNativeSymbolData();
#endif

        // If we have no data, return as the logic below requires at least one method in the array.
        if (s_NativeMethods.size() == 0)
            return;

        // Store the last image so we can detect boundaries between methods from different images.
        const MethodInfo* prevMethod = nullptr;
        intptr_t prevMethodAddress = 0;
        size_t i = 0;

        // Iterate over all native methods which are registered from imaged and generic instances
        do
        {
            const MethodDefinitionKey& methodInfo = s_NativeMethods[i];

            intptr_t methodAddress = (intptr_t)methodInfo.method;
            // Skip unresolved methods
            if (methodAddress != 0)
            {
                // Get the method info for the method handle.
                // Note this will allocate memory for classes and methods.
                const MethodInfo* method = il2cpp::vm::MetadataCache::GetMethodInfoFromMethodHandle(methodInfo.methodHandle);

                // Report previous method with complete information
                if (prevMethodAddress != 0 && prevMethod != nullptr)
                {
                    int32_t codeSize = (int32_t)(methodAddress - prevMethodAddress);
                    // If the previous method is too far from the current one - we can have other native methods inbetween.
                    // Use heuristic to estimate the size of the method - we expect managed method to be less than
                    // k_ProbableMaximumManagedMethodSizeInBytes, but it still may happen that we have a native method
                    // in the range even between methods in the same image.
                    codeSize = std::min(k_ProbableMaximumManagedMethodSizeInBytes, codeSize);

                    Il2CppMethodDebugInfo methodDebugInfo;
                    GetMethodDebugInfoWithSymbols(prevMethod, prevMethodAddress, codeSize, methodDebugInfo);
                    func(prevMethod, &methodDebugInfo, userData);
                }

                prevMethod = method;
                prevMethodAddress = methodAddress;
            }

            ++i;
        }
        while (i < s_NativeMethods.size());

        if (prevMethodAddress != 0 && prevMethod != nullptr)
        {
            // Report the last method using last method address.
            int32_t codeSize;
            // If there is a managed section we can use it to estimate the method size,
            // otherwise we use a heuristic.
            if (il2cpp::os::Image::ManagedSectionExists())
            {
                void *managedSectionStart, *managedSectionEnd;
                il2cpp::os::Image::GetManagedSectionStartAndEnd(managedSectionStart, managedSectionEnd);
                codeSize = std::min<int32_t>(k_ProbableMaximumManagedMethodSizeInBytes, (int32_t)((intptr_t)managedSectionEnd - prevMethodAddress));
            }
            else
            {
                codeSize = k_ProbableMaximumManagedMethodSizeInBytes;
            }

            Il2CppMethodDebugInfo methodDebugInfo;
            GetMethodDebugInfoWithSymbols(prevMethod, prevMethodAddress, codeSize, methodDebugInfo);
            func(prevMethod, &methodDebugInfo, userData);
        }
    }

    bool NativeSymbol::GetMethodDebugInfo(const MethodInfo* method, Il2CppMethodDebugInfo* methodDebugInfo)
    {
        Il2CppMethodPointer nativeMethod = method->virtualMethodPointer;

        if (il2cpp::os::Image::ManagedSectionExists())
        {
            if (!il2cpp::os::Image::IsInManagedSection((void*)nativeMethod))
                return false;
        }

        if (methodDebugInfo != NULL)
        {
            methodDebugInfo->methodPointer = method->virtualMethodPointer;
            methodDebugInfo->code_size = 0;
            methodDebugInfo->file = NULL;
        }

        return true;
    }

#endif
} /* namespace utils */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\NativeSymbol.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\VmStringUtils.cpp---------------
.
.
#include "il2cpp-config.h"

#include "VmStringUtils.h"
#include "il2cpp-object-internals.h"
#include "../char-conversions.h"
#include "utils/Functional.h"
#include "utils/StringUtils.h"
#include "External/utfcpp/source/utf8.h"

namespace il2cpp
{
namespace utils
{
    Il2CppChar VmStringUtils::Utf16ToLower(Il2CppChar c)
    {
        const Il2CppChar kDataLowThreshold = 9423;
        const Il2CppChar kDataHighThreshold = 65313;

        if (c <= kDataLowThreshold)
        {
            c = ToLowerDataLow[c];
        }
        else if (c >= kDataHighThreshold)
        {
            c = ToLowerDataHigh[c - kDataHighThreshold];
        }

        return c;
    }

    bool VmStringUtils::CaseSensitiveComparer::operator()(const std::string& left, const std::string& right) const
    {
        return left == right;
    }

    bool VmStringUtils::CaseSensitiveComparer::operator()(const std::string& left, const char* right) const
    {
        return left.compare(right) == 0;
    }

    bool VmStringUtils::CaseSensitiveComparer::operator()(const char* left, const std::string& right) const
    {
        return right.compare(left) == 0;
    }

    bool VmStringUtils::CaseSensitiveComparer::operator()(const char* left, const char* right) const
    {
        return strcmp(left, right) == 0;
    }

    static inline void Utf32CharToSurrogatePair(uint32_t c, Il2CppChar(&surrogatePair)[2])
    {
        const Il2CppChar kLeadOffset = 55232;
        const Il2CppChar kTrailSurrogateMin = 56320;

        if (c > 0xffff)
        {
            surrogatePair[0] = static_cast<Il2CppChar>((c >> 10) + kLeadOffset);
            surrogatePair[1] = static_cast<Il2CppChar>((c & 0x3ff) + kTrailSurrogateMin);
        }
        else
        {
            surrogatePair[0] = static_cast<Il2CppChar>(c);
            surrogatePair[1] = 0;
        }
    }

    static inline bool Utf16CharEqualsIgnoreCase(Il2CppChar left, Il2CppChar right)
    {
        return VmStringUtils::Utf16ToLower(left) == VmStringUtils::Utf16ToLower(right);
    }

    bool VmStringUtils::CaseInsensitiveComparer::operator()(const std::string& left, const std::string& right) const
    {
        return operator()(left.c_str(), right.c_str());
    }

    bool VmStringUtils::CaseInsensitiveComparer::operator()(const std::string& left, const char* right) const
    {
        return operator()(left.c_str(), right);
    }

    bool VmStringUtils::CaseInsensitiveComparer::operator()(const char* left, const std::string& right) const
    {
        return operator()(left, right.c_str());
    }

    bool VmStringUtils::CaseInsensitiveComparer::operator()(const char* left, const char* right) const
    {
#if IL2CPP_DEBUG    // Invalid UTF8 strings shouldn't be passed here, so let's assert in debug mode
        IL2CPP_ASSERT(utf8::is_valid(left, left + strlen(left)));
        IL2CPP_ASSERT(utf8::is_valid(right, right + strlen(right)));
#endif

        Il2CppChar utf16Left[2];
        Il2CppChar utf16Right[2];

        while (*left && *right)
        {
            Utf32CharToSurrogatePair(utf8::unchecked::next(left), utf16Left);
            Utf32CharToSurrogatePair(utf8::unchecked::next(right), utf16Right);

            if (!Utf16CharEqualsIgnoreCase(utf16Left[0], utf16Right[0]) ||
                !Utf16CharEqualsIgnoreCase(utf16Left[1], utf16Right[1]))
            {
                return false;
            }
        }

        return *left == '\0' && *right == '\0';
    }

    bool VmStringUtils::CaseSensitiveEquals(Il2CppString* left, const char* right)
    {
        std::string leftString = StringUtils::Utf16ToUtf8(left->chars);
        functional::Filter<const char*, CaseSensitiveComparer> equalsLeft(leftString.c_str());
        return equalsLeft(right);
    }

    bool VmStringUtils::CaseSensitiveEquals(const char* left, const char* right)
    {
        functional::Filter<const char*, CaseSensitiveComparer> equalsLeft(left);
        return equalsLeft(right);
    }

    bool VmStringUtils::CaseInsensitiveEquals(Il2CppString* left, const char* right)
    {
        std::string leftString = StringUtils::Utf16ToUtf8(left->chars);
        functional::Filter<const char*, CaseInsensitiveComparer> equalsLeft(leftString.c_str());
        return equalsLeft(right);
    }

    bool VmStringUtils::CaseInsensitiveEquals(const char* left, const char* right)
    {
        functional::Filter<const char *, CaseInsensitiveComparer> equalsLeft(left);
        return equalsLeft(right);
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\VmStringUtils.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\VmThreadUtils.cpp---------------
.
.
#include "VmThreadUtils.h"
#include "os/Thread.h"

namespace il2cpp
{
namespace utils
{
    Il2CppStackPointerResult VmThreadUtils::PointerIsOnCurrentThreadStack(void* ptr)
    {
        void* low;
        void* high;
        if (il2cpp::os::Thread::GetCurrentThreadStackBounds(&low, &high))
        {
            if ((uintptr_t)ptr >= (uintptr_t)low && (uintptr_t)ptr <= (uintptr_t)high)
                return Il2CppStackPointerIsOnStack;
            return Il2CppStackPointerIsNotOnStack;
        }

        return Il2CppStackPointerNotSupported;
    }
}
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\VmThreadUtils.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\icalls\mscorlib\System\Math.cpp---------------
.
.
#include "il2cpp-config.h"
#include <cmath>
#include <limits>
#include <float.h>
#include "Math.h"
#include "vm/Exception.h"


namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    double Math::Abs(double value)
    {
        return fabs(value);
    }

    double Math::Acos(double d)
    {
        return acos(d);
    }

    double Math::Acosh(double d)
    {
        return acosh(d);
    }

    double Math::Asin(double d)
    {
        return asin(d);
    }

    double Math::Asinh(double d)
    {
        return asinh(d);
    }

    double Math::Atan(double d)
    {
        return atan(d);
    }

    double Math::Atan2(double y, double x)
    {
        return atan2(y, x);
    }

    double Math::Atanh(double d)
    {
        return atanh(d);
    }

    double Math::Cbrt(double d)
    {
        return cbrt(d);
    }

    double Math::Ceiling(double a)
    {
        return ceil(a);
    }

    double Math::Cos(double d)
    {
        return cos(d);
    }

    double Math::Cosh(double value)
    {
        return cosh(value);
    }

    double Math::Exp(double d)
    {
        return exp(d);
    }

    double Math::Floor(double d)
    {
        return floor(d);
    }

    double Math::FMod(double x, double y)
    {
        return fmod(x, y);
    }

    double Math::Log(double d)
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL_NO_ASSERT(Math::Log, "Determin what value of NAN to use");

        if (d == 0)
            return -HUGE_VAL;
        else if (d < 0)
            return std::numeric_limits<double>::signaling_NaN();
        //return NAN;

        return log(d);
    }

    double Math::Log10(double d)
    {
        return log10(d);
    }

    double Math::ModF(double x, double* d)
    {
        return modf(x, d);
    }

    static bool IsInteger(double value)
    {
        double unused;
        return std::modf(value, &unused) == 0.0;
    }

    // Use this function to test for odd integers instead of converting a
    // double to int64_t then ANDing with 1 (or modulo). In C++, double to integer
    // conversions are truncated but the behavior is undefined if the truncated
    // value cannot be represented in the destination type. This means that huge
    // doubles may not be handled correctly.
    static bool IsOddInteger(double value)
    {
        return std::fmod(value, 2.0) == std::copysign(1.0, value);
    }

    double Math::Pow(double val, double exp)
    {
        if (std::isnan(val))
            return val;
        if (std::isnan(exp))
            return exp;

        if (val > -1 && val < 1 && exp == -std::numeric_limits<double>::infinity())
            return std::numeric_limits<double>::infinity();

        if (val > -1 && val < 1 && exp == std::numeric_limits<double>::infinity())
            return 0.0;

        if ((val < -1 || val > 1) && exp == -std::numeric_limits<double>::infinity())
            return 0.0;

        if ((val < -1 || val > 1) && exp == std::numeric_limits<double>::infinity())
            return std::numeric_limits<double>::infinity();

        if (val == -std::numeric_limits<double>::infinity())
        {
            if (exp < 0)
                return 0.0;

            if (exp > 0)
            {
                return IsOddInteger(exp) ? -std::numeric_limits<double>::infinity() : std::numeric_limits<double>::infinity();
            }

            return 1.0;
        }

        if (val < 0)
        {
            if (!IsInteger(exp) || exp == std::numeric_limits<double>::infinity() || exp == -std::numeric_limits<double>::infinity())
                return std::numeric_limits<double>::quiet_NaN();
        }

        double res = pow(val, exp);
        if (std::isnan(res))
            return 1.0;

        if (res == -0.0)
            return 0.0;

        return res;
    }

    double Math::Round(double x)
    {
        double int_part, dec_part;
        int_part = floor(x);
        dec_part = x - int_part;
        if (((dec_part == 0.5) &&
             ((2.0 * ((int_part / 2.0) - floor(int_part / 2.0))) != 0.0)) ||
            (dec_part > 0.5))
        {
            int_part++;
        }
        return int_part;
    }

    double Math::Sin(double a)
    {
        return sin(a);
    }

    double Math::Sinh(double value)
    {
        return sinh(value);
    }

    double Math::Sqrt(double d)
    {
        return sqrt(d);
    }

    double Math::Tan(double a)
    {
        return tan(a);
    }

    double Math::Tanh(double value)
    {
        return tanh(value);
    }

    float Math::Abs(float value)
    {
        return fabsf(value);
    }

    double Math::RoundDigits(double value, int32_t digits)
    {
        return RoundMidpoint(value, digits, false);
    }

    double Math::RoundMidpoint(double value, int32_t digits, bool away_from_zero)
    {
        double p;
        if (value == HUGE_VAL)
            return HUGE_VAL;
        if (value == -HUGE_VAL)
            return -HUGE_VAL;
        if (digits == 0 && !away_from_zero)
            return Round(value);

        p = pow(10.0, digits);

        if (away_from_zero)
            return std::round(value * p) / p;
        else
            return std::rint(value * p) / p;
    }
} /*namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace il2cpp */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\icalls\mscorlib\System\Math.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\icalls\mscorlib\System\MathF.cpp---------------
.
.
#include "il2cpp-config.h"
#include "MathF.h"

#include <cmath>
#include <limits>

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
    static bool IsInteger(float value)
    {
        double unused;
        return std::modf(value, &unused) == 0.0;
    }

    // Use this function to test for odd integers instead of converting a
    // double to int64_t then ANDing with 1 (or modulo). In C++, double to integer
    // conversions are truncated but the behavior is undefined if the truncated
    // value cannot be represented in the destination type. This means that huge
    // doubles may not be handled correctly.
    static bool IsOddInteger(float value)
    {
        return std::fmod(value, 2.0) == std::copysign(1.0, value);
    }

    float MathF::Pow(float val, float exp)
    {
        if (std::isnan(val))
            return val;
        if (std::isnan(exp))
            return exp;

        if (val > -1 && val < 1 && exp == -std::numeric_limits<float>::infinity())
            return std::numeric_limits<float>::infinity();

        if (val > -1 && val < 1 && exp == std::numeric_limits<float>::infinity())
            return 0.0;

        if ((val < -1 || val > 1) && exp == -std::numeric_limits<float>::infinity())
            return 0.0;

        if ((val < -1 || val > 1) && exp == std::numeric_limits<float>::infinity())
            return std::numeric_limits<float>::infinity();

        if (val == -std::numeric_limits<float>::infinity())
        {
            if (exp < 0)
                return 0.0;

            if (exp > 0)
            {
                return IsOddInteger(exp) ? -std::numeric_limits<float>::infinity() : std::numeric_limits<float>::infinity();
            }

            return 1.0;
        }

        if (val < 0)
        {
            if (!IsInteger(exp) || exp == std::numeric_limits<float>::infinity() || exp == -std::numeric_limits<float>::infinity())
                return std::numeric_limits<float>::quiet_NaN();
        }

        float res = pow(val, exp);
        if (std::isnan(res))
            return 1.0;

        if (res == -0.0)
            return 0.0;

        return res;
    }
} // namespace System
} // namespace mscorlib
} // namespace icalls
} // namespace il2cpp
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\icalls\mscorlib\System\MathF.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\icalls\mscorlib\System.Threading\Interlocked.cpp---------------
.
.
#include "il2cpp-config.h"
#include "gc/GarbageCollector.h"
#include "Interlocked.h"
#include <ctype.h>
#include "os/Atomic.h"
#include "os/Mutex.h"
#include "vm/Exception.h"

#if !IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
#include "Baselib.h"
#include "Cpp/ReentrantLock.h"
#endif

union LongDoubleUnion
{
    int64_t l_val;
    double d_val;
};

union IntFloatUnion
{
    int32_t i_val;
    float f_val;
};

namespace il2cpp
{
namespace icalls
{
namespace mscorlib
{
namespace System
{
namespace Threading
{
#if !IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
    static baselib::ReentrantLock m_Atomic64Mutex;
#endif

    void* Interlocked::CompareExchange_T(void** location, void* value, void* comparand)
    {
        void* retval = il2cpp::os::Atomic::CompareExchangePointer(location, value, comparand);
        il2cpp::gc::GarbageCollector::SetWriteBarrier(location);
        return retval;
    }

    void Interlocked::CompareExchangeObject(void** location, void** value, void** comparand, void** res)
    {
        *res = il2cpp::os::Atomic::CompareExchangePointer(location, *value, *comparand);
        il2cpp::gc::GarbageCollector::SetWriteBarrier(location);
    }

    intptr_t Interlocked::CompareExchangeIntPtr(intptr_t* location, intptr_t value, intptr_t comparand)
    {
        return reinterpret_cast<intptr_t>(il2cpp::os::Atomic::CompareExchangePointer(reinterpret_cast<void**>(location), reinterpret_cast<void*>(value), reinterpret_cast<void*>(comparand)));
    }

    int32_t Interlocked::CompareExchange(int32_t* location, int32_t value, int32_t comparand)
    {
        return il2cpp::os::Atomic::CompareExchange(location, value, comparand);
    }

    int64_t Interlocked::CompareExchange64(int64_t* location, int64_t value, int64_t comparand)
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        return il2cpp::os::Atomic::CompareExchange64(location, value, comparand);
#else
        il2cpp::os::FastAutoLock lock(&m_Atomic64Mutex);
        int64_t orig = *location;
        if (*location == comparand)
            *location = value;

        return orig;
#endif
    }

    int32_t Interlocked::Add(int32_t* location1, int32_t value)
    {
        return il2cpp::os::Atomic::Add(location1, value);
    }

    int64_t Interlocked::Add64(int64_t* location1, int64_t value)
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        return il2cpp::os::Atomic::Add64(location1, value);
#else
        il2cpp::os::FastAutoLock lock(&m_Atomic64Mutex);
        return *location1 += value;
#endif
    }

    double Interlocked::CompareExchangeDouble(double* location1, double value, double comparand)
    {
        LongDoubleUnion val, ret, cmp;

        cmp.d_val = comparand;
        val.d_val = value;
        ret.l_val = (int64_t)il2cpp::os::Atomic::CompareExchange64((int64_t*)location1, val.l_val, cmp.l_val);

        return ret.d_val;
    }

    float Interlocked::CompareExchangeSingle(float* location1, float value, float comparand)
    {
        IntFloatUnion val, ret, cmp;

        cmp.f_val = comparand;
        val.f_val = value;
        ret.i_val = (int32_t)il2cpp::os::Atomic::CompareExchange((int32_t*)location1, val.i_val, cmp.i_val);

        return ret.f_val;
    }

    int32_t Interlocked::Increment(int32_t* value)
    {
        return il2cpp::os::Atomic::Increment(value);
    }

    int64_t Interlocked::Increment64(int64_t* location)
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        return il2cpp::os::Atomic::Increment64(location);
#else
        il2cpp::os::FastAutoLock lock(&m_Atomic64Mutex);
        return ++(*location);
#endif
    }

    int32_t Interlocked::Decrement(int32_t* location)
    {
        return il2cpp::os::Atomic::Decrement(location);
    }

    int64_t Interlocked::Decrement64(int64_t* location)
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        return il2cpp::os::Atomic::Decrement64(location);
#else
        il2cpp::os::FastAutoLock lock(&m_Atomic64Mutex);
        return --(*location);
#endif
    }

    double Interlocked::ExchangeDouble(double* location1, double value)
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        LongDoubleUnion val, ret;

        val.d_val = value;
        ret.l_val = (int64_t)il2cpp::os::Atomic::Exchange64((int64_t*)location1, val.l_val);

        return ret.d_val;
#else
        il2cpp::os::FastAutoLock lock(&m_Atomic64Mutex);
        double orig = *location1;
        *location1 = value;
        return orig;
#endif
    }

    intptr_t Interlocked::ExchangeIntPtr(intptr_t* location, intptr_t value)
    {
        return reinterpret_cast<intptr_t>(il2cpp::os::Atomic::ExchangePointer(reinterpret_cast<void**>(location), reinterpret_cast<void*>(value)));
    }

    int32_t Interlocked::Exchange(int32_t* location1, int32_t value)
    {
        return il2cpp::os::Atomic::Exchange(location1, value);
    }

    int64_t Interlocked::Exchange64(int64_t* location1, int64_t value)
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        return il2cpp::os::Atomic::Exchange64(location1, value);
#else
        il2cpp::os::FastAutoLock lock(&m_Atomic64Mutex);
        int64_t orig = *location1;
        *location1 = value;
        return orig;
#endif
    }

    void* Interlocked::ExchangePointer(void** location1, void* value)
    {
        void* retval = il2cpp::os::Atomic::ExchangePointer(location1, value);
        il2cpp::gc::GarbageCollector::SetWriteBarrier(location1);
        return retval;
    }

    void Interlocked::ExchangeObject(void** location1, void** value, void** res)
    {
        *res = il2cpp::os::Atomic::ExchangePointer(location1, *value);
        il2cpp::gc::GarbageCollector::SetWriteBarrier(location1);
    }

    float Interlocked::ExchangeSingle(float* location1, float value)
    {
        IntFloatUnion val, ret;

        val.f_val = value;
        ret.i_val = (int32_t)il2cpp::os::Atomic::Exchange((int32_t*)location1, val.i_val);

        return ret.f_val;
    }

    int64_t Interlocked::Read(int64_t* location)
    {
#if IL2CPP_ENABLE_INTERLOCKED_64_REQUIRED_ALIGNMENT
        return il2cpp::os::Atomic::Read64(location);
#else
        il2cpp::os::FastAutoLock lock(&m_Atomic64Mutex);
        return *location;
#endif
    }

    int32_t Interlocked::CompareExchange(int32_t* location1, int32_t value, int32_t comparand, bool* succeeded)
    {
        int32_t result = CompareExchange(location1, value, comparand);
        *succeeded = result == comparand;
        return result;
    }

    void Interlocked::MemoryBarrierProcessWide()
    {
        IL2CPP_NOT_IMPLEMENTED_ICALL(Interlocked::MemoryBarrierProcessWide);
        IL2CPP_UNREACHABLE;
    }
} /* namespace Threading */
} /* namespace System */
} /* namespace mscorlib */
} /* namespace icalls */
} /* namespace tiny */
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\il2cpp\libil2cpp\vm-utils\icalls\mscorlib\System.Threading\Interlocked.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\PlaybackEngines\windowsstandalonesupport\Source\WindowsPlayer\UnityPlayerStub\Exports.cpp---------------
.
.
#include <wtypes.h>
#include "Exports.h"

int UnityMain(HINSTANCE /*hInstance*/, HINSTANCE /*hPrevInstance*/, LPWSTR /*lpCmdLine*/, int /*nShowCmd*/)
{
    return 0;
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\PlaybackEngines\windowsstandalonesupport\Source\WindowsPlayer\UnityPlayerStub\Exports.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\PlaybackEngines\windowsstandalonesupport\Source\WindowsPlayer\WindowsPlayer\Main.cpp---------------
.
.
#include "PrecompiledHeader.h"
#include "..\UnityPlayerStub\Exports.h"

// Hint that the discrete gpu should be enabled on optimus/enduro systems
// NVIDIA docs: http://developer.download.nvidia.com/devzone/devcenter/gamegraphics/files/OptimusRenderingPolicies.pdf
// AMD forum post: http://devgurus.amd.com/thread/169965
extern "C"
{
    __declspec(dllexport) DWORD NvOptimusEnablement = 0x00000001;
    __declspec(dllexport) int AmdPowerXpressRequestHighPerformance = 1;
    __declspec(dllexport) extern const UINT D3D12SDKVersion = 611;
    __declspec(dllexport) extern const char* D3D12SDKPath = u8".\\D3D12\\";
}

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
{
    return UnityMain(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
}
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\PlaybackEngines\windowsstandalonesupport\Source\WindowsPlayer\WindowsPlayer\Main.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\PlaybackEngines\windowsstandalonesupport\Source\WindowsPlayer\WindowsPlayer\PrecompiledHeader.cpp---------------
.
.
#include "PrecompiledHeader.h"
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\PlaybackEngines\windowsstandalonesupport\Source\WindowsPlayer\WindowsPlayer\PrecompiledHeader.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\RLSL\Shaders\OpenRLCPPSharedIncludesTests.cpp---------------
.
.
#include "UnityPrefix.h"

#if ENABLE_UNIT_TESTS

#include "Runtime/Testing/Testing.h"

#include "External/Wintermute/RLSL/OpenRLCPPSharedIncludes.rlsl"

UNIT_TEST_SUITE(OpenRLCPPSharedIncludes)
{
    TEST(OpenRLCPPSharedIncludes_GetRegionIdxInsideGridReturnsValidIndex)
    {
        {
            // Check a lookup inside the grid
            const Wintermute::Vec3i region = Wintermute::Vec3i(2, 4, 11);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(6, 8, 22);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(554, regionIdx);
        }
        {
            // Check a lookup inside the grid, but at a corner
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(0, regionIdx);
        }
        {
            // Check a lookup inside the grid, when there is a single cell
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 1, 1);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(0, regionIdx);
        }
    }
    TEST(OpenRLCPPSharedIncludes_GetRegionIdxOutsideGridReturnsMinusOne)
    {
        {
            // Check a lookup outside the grid on X
            const Wintermute::Vec3i region = Wintermute::Vec3i(1, 1, 2);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid on Y
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 2, 2);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid on Z
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 1, 3);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the grid dims are zero on one dimension
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(0, 1, 1);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the grid dims are negative on one dimension
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(-1, 1, 1);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the grid is empty (all axes)
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(0, 0, 0);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the region is negative on one axis
            const Wintermute::Vec3i region = Wintermute::Vec3i(1, 1, -1);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(4, 4, 4);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
    }
}


#endif // ENABLE_UNIT_TESTS
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Resources\RLSL\Shaders\OpenRLCPPSharedIncludesTests.cpp---------------
.
.
#---------------BEGIN FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Tools\Data\Resources\RLSL\Shaders\OpenRLCPPSharedIncludesTests.cpp---------------
.
.
#include "UnityPrefix.h"

#if ENABLE_UNIT_TESTS

#include "Runtime/Testing/Testing.h"

#include "External/Wintermute/RLSL/OpenRLCPPSharedIncludes.rlsl"

UNIT_TEST_SUITE(OpenRLCPPSharedIncludes)
{
    TEST(OpenRLCPPSharedIncludes_GetRegionIdxInsideGridReturnsValidIndex)
    {
        {
            // Check a lookup inside the grid
            const Wintermute::Vec3i region = Wintermute::Vec3i(2, 4, 11);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(6, 8, 22);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(554, regionIdx);
        }
        {
            // Check a lookup inside the grid, but at a corner
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(0, regionIdx);
        }
        {
            // Check a lookup inside the grid, when there is a single cell
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 1, 1);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(0, regionIdx);
        }
    }
    TEST(OpenRLCPPSharedIncludes_GetRegionIdxOutsideGridReturnsMinusOne)
    {
        {
            // Check a lookup outside the grid on X
            const Wintermute::Vec3i region = Wintermute::Vec3i(1, 1, 2);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid on Y
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 2, 2);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid on Z
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 1, 3);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(1, 2, 3);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the grid dims are zero on one dimension
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(0, 1, 1);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the grid dims are negative on one dimension
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(-1, 1, 1);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the grid is empty (all axes)
            const Wintermute::Vec3i region = Wintermute::Vec3i(0, 0, 0);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(0, 0, 0);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
        {
            // Check a lookup outside the grid when the region is negative on one axis
            const Wintermute::Vec3i region = Wintermute::Vec3i(1, 1, -1);
            const Wintermute::Vec3i gridDims = Wintermute::Vec3i(4, 4, 4);

            const int regionIdx = OpenRLCPPShared_GetRegionIdx(region, gridDims);

            CHECK_EQUAL(-1, regionIdx);
        }
    }
}


#endif // ENABLE_UNIT_TESTS
.
.
#---------------END FILE: C:\Users\Zack\Unity Versions\6000.0.48f1\6000.0.48f1\Editor\Data\Tools\Data\Resources\RLSL\Shaders\OpenRLCPPSharedIncludesTests.cpp---------------
.
.
